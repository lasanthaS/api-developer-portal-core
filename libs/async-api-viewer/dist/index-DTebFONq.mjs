var T5 = Object.defineProperty;
var M5 = (s, e, t) => e in s ? T5(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : s[e] = t;
var Zt = (s, e, t) => M5(s, typeof e != "symbol" ? e + "" : e, t);
import * as fd from "react";
import { useRef as Sr, useMemo as p2, useEffect as Nn } from "react";
function as(s, e = 0) {
  return s[s.length - (1 + e)];
}
function R5(s) {
  if (s.length === 0)
    throw new Error("Invalid tail call");
  return [s.slice(0, s.length - 1), s[s.length - 1]];
}
function oi(s, e, t = (i, n) => i === n) {
  if (s === e)
    return !0;
  if (!s || !e || s.length !== e.length)
    return !1;
  for (let i = 0, n = s.length; i < n; i++)
    if (!t(s[i], e[i]))
      return !1;
  return !0;
}
function A5(s, e) {
  const t = s.length - 1;
  e < t && (s[e] = s[t]), s.pop();
}
function P5(s, e, t) {
  return O5(s.length, (i) => t(s[i], e));
}
function O5(s, e) {
  let t = 0, i = s - 1;
  for (; t <= i; ) {
    const n = (t + i) / 2 | 0, o = e(n);
    if (o < 0)
      t = n + 1;
    else if (o > 0)
      i = n - 1;
    else
      return n;
  }
  return -(t + 1);
}
function* uL(s, e) {
  let t, i;
  for (const n of s)
    i !== void 0 && e(i, n) ? t.push(n) : (t && (yield t), t = [n]), i = n;
  t && (yield t);
}
function _2(s, e) {
  for (let t = 0; t <= s.length; t++)
    e(t === 0 ? void 0 : s[t - 1], t === s.length ? void 0 : s[t]);
}
function F5(s, e) {
  for (let t = 0; t < s.length; t++)
    e(t === 0 ? void 0 : s[t - 1], s[t], t + 1 === s.length ? void 0 : s[t + 1]);
}
function fL(s) {
  return s.filter((e) => !!e);
}
function Yx(s) {
  let e = 0;
  for (let t = 0; t < s.length; t++)
    s[t] && (s[e] = s[t], e += 1);
  s.length = e;
}
function B5(s) {
  return !Array.isArray(s) || s.length === 0;
}
function Q1(s) {
  return Array.isArray(s) && s.length > 0;
}
function uc(s, e = (t) => t) {
  const t = /* @__PURE__ */ new Set();
  return s.filter((i) => {
    const n = e(i);
    return t.has(n) ? !1 : (t.add(n), !0);
  });
}
function gL(s, e) {
  return s.length > 0 ? s[0] : e;
}
function fn(s, e) {
  let t = typeof e == "number" ? s : 0;
  typeof e == "number" ? t = s : (t = 0, e = s);
  const i = [];
  if (t <= e)
    for (let n = t; n < e; n++)
      i.push(n);
  else
    for (let n = t; n > e; n--)
      i.push(n);
  return i;
}
function X1(s, e, t) {
  const i = s.slice(0, e), n = s.slice(e);
  return i.concat(t, n);
}
function s0(s, e) {
  const t = s.indexOf(e);
  t > -1 && (s.splice(t, 1), s.unshift(e));
}
function Yg(s, e) {
  const t = s.indexOf(e);
  t > -1 && (s.splice(t, 1), s.push(e));
}
function EC(s, e) {
  for (const t of e)
    s.push(t);
}
function W5(s, e, t) {
  const i = b2(s, e), n = s.length, o = t.length;
  s.length = n + o;
  for (let r = n - 1; r >= i; r--)
    s[r + o] = s[r];
  for (let r = 0; r < o; r++)
    s[r + i] = t[r];
}
function Qx(s, e, t, i) {
  const n = b2(s, e);
  let o = s.splice(n, t);
  return o === void 0 && (o = []), W5(s, n, i), o;
}
function b2(s, e) {
  return e < 0 ? Math.max(e + s.length, 0) : Math.min(e, s.length);
}
var If;
(function(s) {
  function e(o) {
    return o < 0;
  }
  s.isLessThan = e;
  function t(o) {
    return o <= 0;
  }
  s.isLessThanOrEqual = t;
  function i(o) {
    return o > 0;
  }
  s.isGreaterThan = i;
  function n(o) {
    return o === 0;
  }
  s.isNeitherLessOrGreaterThan = n, s.greaterThan = 1, s.lessThan = -1, s.neitherLessOrGreaterThan = 0;
})(If || (If = {}));
function Ts(s, e) {
  return (t, i) => e(s(t), s(i));
}
function V5(...s) {
  return (e, t) => {
    for (const i of s) {
      const n = i(e, t);
      if (!If.isNeitherLessOrGreaterThan(n))
        return n;
    }
    return If.neitherLessOrGreaterThan;
  };
}
const Aa = (s, e) => s - e, H5 = (s, e) => Aa(s ? 1 : 0, e ? 1 : 0);
function z5(s) {
  return (e, t) => -s(e, t);
}
class Gr {
  /**
   * Constructs a queue that is backed by the given array. Runtime is O(1).
  */
  constructor(e) {
    this.items = e, this.firstIdx = 0, this.lastIdx = this.items.length - 1;
  }
  get length() {
    return this.lastIdx - this.firstIdx + 1;
  }
  /**
   * Consumes elements from the beginning of the queue as long as the predicate returns true.
   * If no elements were consumed, `null` is returned. Has a runtime of O(result.length).
  */
  takeWhile(e) {
    let t = this.firstIdx;
    for (; t < this.items.length && e(this.items[t]); )
      t++;
    const i = t === this.firstIdx ? null : this.items.slice(this.firstIdx, t);
    return this.firstIdx = t, i;
  }
  /**
   * Consumes elements from the end of the queue as long as the predicate returns true.
   * If no elements were consumed, `null` is returned.
   * The result has the same order as the underlying array!
  */
  takeFromEndWhile(e) {
    let t = this.lastIdx;
    for (; t >= 0 && e(this.items[t]); )
      t--;
    const i = t === this.lastIdx ? null : this.items.slice(t + 1, this.lastIdx + 1);
    return this.lastIdx = t, i;
  }
  peek() {
    if (this.length !== 0)
      return this.items[this.firstIdx];
  }
  dequeue() {
    const e = this.items[this.firstIdx];
    return this.firstIdx++, e;
  }
  takeCount(e) {
    const t = this.items.slice(this.firstIdx, this.firstIdx + e);
    return this.firstIdx += e, t;
  }
}
const Ih = class Ih {
  constructor(e) {
    this.iterate = e;
  }
  toArray() {
    const e = [];
    return this.iterate((t) => (e.push(t), !0)), e;
  }
  filter(e) {
    return new Ih((t) => this.iterate((i) => e(i) ? t(i) : !0));
  }
  map(e) {
    return new Ih((t) => this.iterate((i) => t(e(i))));
  }
  findLast(e) {
    let t;
    return this.iterate((i) => (e(i) && (t = i), !0)), t;
  }
  findLastMaxBy(e) {
    let t, i = !0;
    return this.iterate((n) => ((i || If.isGreaterThan(e(n, t))) && (i = !1, t = n), !0)), t;
  }
};
Ih.empty = new Ih((e) => {
});
let Gl = Ih;
function Jn(s) {
  return typeof s == "string";
}
function _n(s) {
  return typeof s == "object" && s !== null && !Array.isArray(s) && !(s instanceof RegExp) && !(s instanceof Date);
}
function U5(s) {
  const e = Object.getPrototypeOf(Uint8Array);
  return typeof s == "object" && s instanceof e;
}
function Od(s) {
  return typeof s == "number" && !isNaN(s);
}
function Xx(s) {
  return !!s && typeof s[Symbol.iterator] == "function";
}
function C2(s) {
  return s === !0 || s === !1;
}
function fs(s) {
  return typeof s > "u";
}
function gd(s) {
  return !Zn(s);
}
function Zn(s) {
  return fs(s) || s === null;
}
function Pa(s, e) {
  if (!s)
    throw new Error("Unexpected type");
}
function w2(s) {
  if (Zn(s))
    throw new Error("Assertion Failed: argument is undefined or null");
  return s;
}
function pp(s) {
  return typeof s == "function";
}
function $5(s, e) {
  const t = Math.min(s.length, e.length);
  for (let i = 0; i < t; i++)
    K5(s[i], e[i]);
}
function K5(s, e) {
  if (Jn(e)) {
    if (typeof s !== e)
      throw new Error(`argument does not match constraint: typeof ${e}`);
  } else if (pp(e)) {
    try {
      if (s instanceof e)
        return;
    } catch {
    }
    if (!Zn(s) && s.constructor === e || e.length === 1 && e.call(void 0, s) === !0)
      return;
    throw new Error("argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true");
  }
}
function fa(s) {
  if (!s || typeof s != "object" || s instanceof RegExp)
    return s;
  const e = Array.isArray(s) ? [] : {};
  return Object.entries(s).forEach(([t, i]) => {
    e[t] = i && typeof i == "object" ? fa(i) : i;
  }), e;
}
function q5(s) {
  if (!s || typeof s != "object")
    return s;
  const e = [s];
  for (; e.length > 0; ) {
    const t = e.shift();
    Object.freeze(t);
    for (const i in t)
      if (v2.call(t, i)) {
        const n = t[i];
        typeof n == "object" && !Object.isFrozen(n) && !U5(n) && e.push(n);
      }
  }
  return s;
}
const v2 = Object.prototype.hasOwnProperty;
function y2(s, e) {
  return IC(s, e, /* @__PURE__ */ new Set());
}
function IC(s, e, t) {
  if (Zn(s))
    return s;
  const i = e(s);
  if (typeof i < "u")
    return i;
  if (Array.isArray(s)) {
    const n = [];
    for (const o of s)
      n.push(IC(o, e, t));
    return n;
  }
  if (_n(s)) {
    if (t.has(s))
      throw new Error("Cannot clone recursive data-structure");
    t.add(s);
    const n = {};
    for (const o in s)
      v2.call(s, o) && (n[o] = IC(s[o], e, t));
    return t.delete(s), n;
  }
  return s;
}
function Pn(s, e) {
  if (s === e)
    return !0;
  if (s == null || e === null || e === void 0 || typeof s != typeof e || typeof s != "object" || Array.isArray(s) !== Array.isArray(e))
    return !1;
  let t, i;
  if (Array.isArray(s)) {
    if (s.length !== e.length)
      return !1;
    for (t = 0; t < s.length; t++)
      if (!Pn(s[t], e[t]))
        return !1;
  } else {
    const n = [];
    for (i in s)
      n.push(i);
    n.sort();
    const o = [];
    for (i in e)
      o.push(i);
    if (o.sort(), !Pn(n, o))
      return !1;
    for (t = 0; t < n.length; t++)
      if (!Pn(s[n[t]], e[n[t]]))
        return !1;
  }
  return !0;
}
function j5(s) {
  let e = [];
  for (; Object.prototype !== s; )
    e = e.concat(Object.getOwnPropertyNames(s)), s = Object.getPrototypeOf(s);
  return e;
}
function NC(s) {
  const e = [];
  for (const t of j5(s))
    typeof s[t] == "function" && e.push(t);
  return e;
}
function G5(s, e) {
  const t = (n) => function() {
    const o = Array.prototype.slice.call(arguments, 0);
    return e(n, o);
  }, i = {};
  for (const n of s)
    i[n] = t(n);
  return i;
}
function S2() {
  return globalThis._VSCODE_NLS_MESSAGES;
}
function mL() {
  return globalThis._VSCODE_NLS_LANGUAGE;
}
const Z5 = mL() === "pseudo" || typeof document < "u" && document.location && document.location.hash.indexOf("pseudo=true") >= 0;
function Jx(s, e) {
  let t;
  return e.length === 0 ? t = s : t = s.replace(/\{(\d+)\}/g, (i, n) => {
    const o = n[0], r = e[o];
    let a = i;
    return typeof r == "string" ? a = r : (typeof r == "number" || typeof r == "boolean" || r === void 0 || r === null) && (a = String(r)), a;
  }), Z5 && (t = "［" + t.replace(/[aouei]/g, "$&$&") + "］"), t;
}
function p(s, e, ...t) {
  return Jx(typeof s == "number" ? Y5(s, e) : e, t);
}
function Y5(s, e) {
  var i;
  const t = (i = S2()) == null ? void 0 : i[s];
  if (typeof t != "string") {
    if (typeof e == "string")
      return e;
    throw new Error(`!!! NLS MISSING: ${s} !!!`);
  }
  return t;
}
var tu = {};
const lh = "en";
let _p = !1, bp = !1, zm = !1, L2 = !1, pL = !1, _L = !1, k2 = !1, Qg, o0 = lh, eD = lh, Q5, $s;
const Vr = globalThis;
let Ji;
var u2;
typeof Vr.vscode < "u" && typeof Vr.vscode.process < "u" ? Ji = Vr.vscode.process : typeof tu < "u" && typeof ((u2 = tu == null ? void 0 : tu.versions) == null ? void 0 : u2.node) == "string" && (Ji = tu);
var f2;
const X5 = typeof ((f2 = Ji == null ? void 0 : Ji.versions) == null ? void 0 : f2.electron) == "string", J5 = X5 && (Ji == null ? void 0 : Ji.type) === "renderer";
var g2;
if (typeof Ji == "object") {
  _p = Ji.platform === "win32", bp = Ji.platform === "darwin", zm = Ji.platform === "linux", zm && Ji.env.SNAP && Ji.env.SNAP_REVISION, Ji.env.CI || Ji.env.BUILD_ARTIFACTSTAGINGDIRECTORY, Qg = lh, o0 = lh;
  const s = Ji.env.VSCODE_NLS_CONFIG;
  if (s)
    try {
      const e = JSON.parse(s);
      Qg = e.userLocale, eD = e.osLocale, o0 = e.resolvedLanguage || lh, Q5 = (g2 = e.languagePack) == null ? void 0 : g2.translationsConfigFile;
    } catch {
    }
  L2 = !0;
} else typeof navigator == "object" && !J5 ? ($s = navigator.userAgent, _p = $s.indexOf("Windows") >= 0, bp = $s.indexOf("Macintosh") >= 0, _L = ($s.indexOf("Macintosh") >= 0 || $s.indexOf("iPad") >= 0 || $s.indexOf("iPhone") >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0, zm = $s.indexOf("Linux") >= 0, k2 = ($s == null ? void 0 : $s.indexOf("Mobi")) >= 0, pL = !0, o0 = mL() || lh, Qg = navigator.language.toLowerCase(), eD = Qg) : console.error("Unable to resolve platform.");
const Fn = _p, He = bp, wn = zm, Cp = L2, Fd = pL, eP = pL && typeof Vr.importScripts == "function", tP = eP ? Vr.origin : void 0, fc = _L, x2 = k2, zo = $s, iP = typeof Vr.postMessage == "function" && !Vr.importScripts, D2 = (() => {
  if (iP) {
    const s = [];
    Vr.addEventListener("message", (t) => {
      if (t.data && t.data.vscodeScheduleAsyncWork)
        for (let i = 0, n = s.length; i < n; i++) {
          const o = s[i];
          if (o.id === t.data.vscodeScheduleAsyncWork) {
            s.splice(i, 1), o.callback();
            return;
          }
        }
    });
    let e = 0;
    return (t) => {
      const i = ++e;
      s.push({
        id: i,
        callback: t
      }), Vr.postMessage({ vscodeScheduleAsyncWork: i }, "*");
    };
  }
  return (s) => setTimeout(s);
})(), Es = bp || _L ? 2 : _p ? 1 : 3;
let tD = !0, iD = !1;
function nP() {
  if (!iD) {
    iD = !0;
    const s = new Uint8Array(2);
    s[0] = 1, s[1] = 2, tD = new Uint16Array(s.buffer)[0] === 513;
  }
  return tD;
}
const E2 = !!(zo && zo.indexOf("Chrome") >= 0), sP = !!(zo && zo.indexOf("Firefox") >= 0), oP = !!(!E2 && zo && zo.indexOf("Safari") >= 0), rP = !!(zo && zo.indexOf("Edg/") >= 0), aP = !!(zo && zo.indexOf("Android") >= 0), Oi = {
  tabSize: 4,
  indentSize: 4,
  insertSpaces: !0,
  detectIndentation: !0,
  trimAutoWhitespace: !0,
  largeFileOptimizations: !0,
  bracketPairColorizationOptions: {
    enabled: !0,
    independentColorPoolPerBracketType: !1
  }
};
var Ye;
(function(s) {
  function e(w) {
    return w && typeof w == "object" && typeof w[Symbol.iterator] == "function";
  }
  s.is = e;
  const t = Object.freeze([]);
  function i() {
    return t;
  }
  s.empty = i;
  function* n(w) {
    yield w;
  }
  s.single = n;
  function o(w) {
    return e(w) ? w : n(w);
  }
  s.wrap = o;
  function r(w) {
    return w || t;
  }
  s.from = r;
  function* a(w) {
    for (let S = w.length - 1; S >= 0; S--)
      yield w[S];
  }
  s.reverse = a;
  function l(w) {
    return !w || w[Symbol.iterator]().next().done === !0;
  }
  s.isEmpty = l;
  function c(w) {
    return w[Symbol.iterator]().next().value;
  }
  s.first = c;
  function h(w, S) {
    let L = 0;
    for (const k of w)
      if (S(k, L++))
        return !0;
    return !1;
  }
  s.some = h;
  function d(w, S) {
    for (const L of w)
      if (S(L))
        return L;
  }
  s.find = d;
  function* u(w, S) {
    for (const L of w)
      S(L) && (yield L);
  }
  s.filter = u;
  function* f(w, S) {
    let L = 0;
    for (const k of w)
      yield S(k, L++);
  }
  s.map = f;
  function* g(w, S) {
    let L = 0;
    for (const k of w)
      yield* S(k, L++);
  }
  s.flatMap = g;
  function* m(...w) {
    for (const S of w)
      yield* S;
  }
  s.concat = m;
  function _(w, S, L) {
    let k = L;
    for (const D of w)
      k = S(k, D);
    return k;
  }
  s.reduce = _;
  function* b(w, S, L = w.length) {
    for (S < 0 && (S += w.length), L < 0 ? L += w.length : L > w.length && (L = w.length); S < L; S++)
      yield w[S];
  }
  s.slice = b;
  function C(w, S = Number.POSITIVE_INFINITY) {
    const L = [];
    if (S === 0)
      return [L, w];
    const k = w[Symbol.iterator]();
    for (let D = 0; D < S; D++) {
      const E = k.next();
      if (E.done)
        return [L, s.empty()];
      L.push(E.value);
    }
    return [L, { [Symbol.iterator]() {
      return k;
    } }];
  }
  s.consume = C;
  async function v(w) {
    const S = [];
    for await (const L of w)
      S.push(L);
    return Promise.resolve(S);
  }
  s.asyncToArray = v;
})(Ye || (Ye = {}));
var Fr;
let ei = (Fr = class {
  constructor(e) {
    this.element = e, this.next = Fr.Undefined, this.prev = Fr.Undefined;
  }
}, Fr.Undefined = new Fr(void 0), Fr);
class An {
  constructor() {
    this._first = ei.Undefined, this._last = ei.Undefined, this._size = 0;
  }
  get size() {
    return this._size;
  }
  isEmpty() {
    return this._first === ei.Undefined;
  }
  clear() {
    let e = this._first;
    for (; e !== ei.Undefined; ) {
      const t = e.next;
      e.prev = ei.Undefined, e.next = ei.Undefined, e = t;
    }
    this._first = ei.Undefined, this._last = ei.Undefined, this._size = 0;
  }
  unshift(e) {
    return this._insert(e, !1);
  }
  push(e) {
    return this._insert(e, !0);
  }
  _insert(e, t) {
    const i = new ei(e);
    if (this._first === ei.Undefined)
      this._first = i, this._last = i;
    else if (t) {
      const o = this._last;
      this._last = i, i.prev = o, o.next = i;
    } else {
      const o = this._first;
      this._first = i, i.next = o, o.prev = i;
    }
    this._size += 1;
    let n = !1;
    return () => {
      n || (n = !0, this._remove(i));
    };
  }
  shift() {
    if (this._first !== ei.Undefined) {
      const e = this._first.element;
      return this._remove(this._first), e;
    }
  }
  pop() {
    if (this._last !== ei.Undefined) {
      const e = this._last.element;
      return this._remove(this._last), e;
    }
  }
  _remove(e) {
    if (e.prev !== ei.Undefined && e.next !== ei.Undefined) {
      const t = e.prev;
      t.next = e.next, e.next.prev = t;
    } else e.prev === ei.Undefined && e.next === ei.Undefined ? (this._first = ei.Undefined, this._last = ei.Undefined) : e.next === ei.Undefined ? (this._last = this._last.prev, this._last.next = ei.Undefined) : e.prev === ei.Undefined && (this._first = this._first.next, this._first.prev = ei.Undefined);
    this._size -= 1;
  }
  *[Symbol.iterator]() {
    let e = this._first;
    for (; e !== ei.Undefined; )
      yield e.element, e = e.next;
  }
}
const I2 = "`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?";
function lP(s = "") {
  let e = "(-?\\d*\\.\\d\\w*)|([^";
  for (const t of I2)
    s.indexOf(t) >= 0 || (e += "\\" + t);
  return e += "\\s]+)", new RegExp(e, "g");
}
const bL = lP();
function CL(s) {
  let e = bL;
  if (s && s instanceof RegExp)
    if (s.global)
      e = s;
    else {
      let t = "g";
      s.ignoreCase && (t += "i"), s.multiline && (t += "m"), s.unicode && (t += "u"), e = new RegExp(s.source, t);
    }
  return e.lastIndex = 0, e;
}
const N2 = new An();
N2.unshift({
  maxLen: 1e3,
  windowSize: 15,
  timeBudget: 150
});
function Nf(s, e, t, i, n) {
  if (e = CL(e), n || (n = Ye.first(N2)), t.length > n.maxLen) {
    let c = s - n.maxLen / 2;
    return c < 0 ? c = 0 : i += c, t = t.substring(c, s + n.maxLen / 2), Nf(s, e, t, i, n);
  }
  const o = Date.now(), r = s - 1 - i;
  let a = -1, l = null;
  for (let c = 1; !(Date.now() - o >= n.timeBudget); c++) {
    const h = r - n.windowSize * c;
    e.lastIndex = Math.max(0, h);
    const d = cP(e, t, r, a);
    if (!d && l || (l = d, h <= 0))
      break;
    a = h;
  }
  if (l) {
    const c = {
      word: l[0],
      startColumn: i + 1 + l.index,
      endColumn: i + 1 + l.index + l[0].length
    };
    return e.lastIndex = 0, c;
  }
  return null;
}
function cP(s, e, t, i) {
  let n;
  for (; n = s.exec(e); ) {
    const o = n.index || 0;
    if (o <= t && s.lastIndex >= t)
      return n;
    if (i > 0 && o > i)
      return null;
  }
  return null;
}
const So = 8;
class T2 {
  /**
   * @internal
   */
  constructor(e) {
    this._values = e;
  }
  hasChanged(e) {
    return this._values[e];
  }
}
class M2 {
  constructor() {
    this.stableMinimapLayoutInput = null, this.stableFitMaxMinimapScale = 0, this.stableFitRemainingWidth = 0;
  }
}
class kt {
  constructor(e, t, i, n) {
    this.id = e, this.name = t, this.defaultValue = i, this.schema = n;
  }
  applyUpdate(e, t) {
    return J1(e, t);
  }
  compute(e, t, i) {
    return i;
  }
}
class Ou {
  constructor(e, t) {
    this.newValue = e, this.didChange = t;
  }
}
function J1(s, e) {
  if (typeof s != "object" || typeof e != "object" || !s || !e)
    return new Ou(e, s !== e);
  if (Array.isArray(s) || Array.isArray(e)) {
    const i = Array.isArray(s) && Array.isArray(e) && oi(s, e);
    return new Ou(e, !i);
  }
  let t = !1;
  for (const i in e)
    if (e.hasOwnProperty(i)) {
      const n = J1(s[i], e[i]);
      n.didChange && (s[i] = n.newValue, t = !0);
    }
  return new Ou(s, t);
}
class Cg {
  constructor(e) {
    this.schema = void 0, this.id = e, this.name = "_never_", this.defaultValue = void 0;
  }
  applyUpdate(e, t) {
    return J1(e, t);
  }
  validate(e) {
    return this.defaultValue;
  }
}
class Bd {
  constructor(e, t, i, n) {
    this.id = e, this.name = t, this.defaultValue = i, this.schema = n;
  }
  applyUpdate(e, t) {
    return J1(e, t);
  }
  validate(e) {
    return typeof e > "u" ? this.defaultValue : e;
  }
  compute(e, t, i) {
    return i;
  }
}
function oe(s, e) {
  return typeof s > "u" ? e : s === "false" ? !1 : !!s;
}
class Fe extends Bd {
  constructor(e, t, i, n = void 0) {
    typeof n < "u" && (n.type = "boolean", n.default = i), super(e, t, i, n);
  }
  validate(e) {
    return oe(e, this.defaultValue);
  }
}
function gl(s, e, t, i) {
  if (typeof s > "u")
    return e;
  let n = parseInt(s, 10);
  return isNaN(n) ? e : (n = Math.max(t, n), n = Math.min(i, n), n | 0);
}
class lt extends Bd {
  static clampedInt(e, t, i, n) {
    return gl(e, t, i, n);
  }
  constructor(e, t, i, n, o, r = void 0) {
    typeof r < "u" && (r.type = "integer", r.default = i, r.minimum = n, r.maximum = o), super(e, t, i, r), this.minimum = n, this.maximum = o;
  }
  validate(e) {
    return lt.clampedInt(e, this.defaultValue, this.minimum, this.maximum);
  }
}
function hP(s, e, t, i) {
  if (typeof s > "u")
    return e;
  const n = Qn.float(s, e);
  return Qn.clamp(n, t, i);
}
class Qn extends Bd {
  static clamp(e, t, i) {
    return e < t ? t : e > i ? i : e;
  }
  static float(e, t) {
    if (typeof e == "number")
      return e;
    if (typeof e > "u")
      return t;
    const i = parseFloat(e);
    return isNaN(i) ? t : i;
  }
  constructor(e, t, i, n, o) {
    typeof o < "u" && (o.type = "number", o.default = i), super(e, t, i, o), this.validationFn = n;
  }
  validate(e) {
    return this.validationFn(Qn.float(e, this.defaultValue));
  }
}
class qi extends Bd {
  static string(e, t) {
    return typeof e != "string" ? t : e;
  }
  constructor(e, t, i, n = void 0) {
    typeof n < "u" && (n.type = "string", n.default = i), super(e, t, i, n);
  }
  validate(e) {
    return qi.string(e, this.defaultValue);
  }
}
function Mt(s, e, t, i) {
  return typeof s != "string" ? e : i && s in i ? i[s] : t.indexOf(s) === -1 ? e : s;
}
class Tt extends Bd {
  constructor(e, t, i, n, o = void 0) {
    typeof o < "u" && (o.type = "string", o.enum = n, o.default = i), super(e, t, i, o), this._allowedValues = n;
  }
  validate(e) {
    return Mt(e, this.defaultValue, this._allowedValues);
  }
}
class Xg extends kt {
  constructor(e, t, i, n, o, r, a = void 0) {
    typeof a < "u" && (a.type = "string", a.enum = o, a.default = n), super(e, t, i, a), this._allowedValues = o, this._convert = r;
  }
  validate(e) {
    return typeof e != "string" ? this.defaultValue : this._allowedValues.indexOf(e) === -1 ? this.defaultValue : this._convert(e);
  }
}
function dP(s) {
  switch (s) {
    case "none":
      return 0;
    case "keep":
      return 1;
    case "brackets":
      return 2;
    case "advanced":
      return 3;
    case "full":
      return 4;
  }
}
class uP extends kt {
  constructor() {
    super(2, "accessibilitySupport", 0, {
      type: "string",
      enum: ["auto", "on", "off"],
      enumDescriptions: [
        p("accessibilitySupport.auto", "Use platform APIs to detect when a Screen Reader is attached."),
        p("accessibilitySupport.on", "Optimize for usage with a Screen Reader."),
        p("accessibilitySupport.off", "Assume a screen reader is not attached.")
      ],
      default: "auto",
      tags: ["accessibility"],
      description: p("accessibilitySupport", "Controls if the UI should run in a mode where it is optimized for screen readers.")
    });
  }
  validate(e) {
    switch (e) {
      case "auto":
        return 0;
      case "off":
        return 1;
      case "on":
        return 2;
    }
    return this.defaultValue;
  }
  compute(e, t, i) {
    return i === 0 ? e.accessibilitySupport : i;
  }
}
class fP extends kt {
  constructor() {
    const e = {
      insertSpace: !0,
      ignoreEmptyLines: !0
    };
    super(23, "comments", e, {
      "editor.comments.insertSpace": {
        type: "boolean",
        default: e.insertSpace,
        description: p("comments.insertSpace", "Controls whether a space character is inserted when commenting.")
      },
      "editor.comments.ignoreEmptyLines": {
        type: "boolean",
        default: e.ignoreEmptyLines,
        description: p("comments.ignoreEmptyLines", "Controls if empty lines should be ignored with toggle, add or remove actions for line comments.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      insertSpace: oe(t.insertSpace, this.defaultValue.insertSpace),
      ignoreEmptyLines: oe(t.ignoreEmptyLines, this.defaultValue.ignoreEmptyLines)
    };
  }
}
function gP(s) {
  switch (s) {
    case "blink":
      return 1;
    case "smooth":
      return 2;
    case "phase":
      return 3;
    case "expand":
      return 4;
    case "solid":
      return 5;
  }
}
var wi;
(function(s) {
  s[s.Line = 1] = "Line", s[s.Block = 2] = "Block", s[s.Underline = 3] = "Underline", s[s.LineThin = 4] = "LineThin", s[s.BlockOutline = 5] = "BlockOutline", s[s.UnderlineThin = 6] = "UnderlineThin";
})(wi || (wi = {}));
function mP(s) {
  switch (s) {
    case "line":
      return wi.Line;
    case "block":
      return wi.Block;
    case "underline":
      return wi.Underline;
    case "line-thin":
      return wi.LineThin;
    case "block-outline":
      return wi.BlockOutline;
    case "underline-thin":
      return wi.UnderlineThin;
  }
}
class pP extends Cg {
  constructor() {
    super(
      143
      /* EditorOption.editorClassName */
    );
  }
  compute(e, t, i) {
    const n = ["monaco-editor"];
    return t.get(
      39
      /* EditorOption.extraEditorClassName */
    ) && n.push(t.get(
      39
      /* EditorOption.extraEditorClassName */
    )), e.extraEditorClassName && n.push(e.extraEditorClassName), t.get(
      74
      /* EditorOption.mouseStyle */
    ) === "default" ? n.push("mouse-default") : t.get(
      74
      /* EditorOption.mouseStyle */
    ) === "copy" && n.push("mouse-copy"), t.get(
      112
      /* EditorOption.showUnused */
    ) && n.push("showUnused"), t.get(
      141
      /* EditorOption.showDeprecated */
    ) && n.push("showDeprecated"), n.join(" ");
  }
}
class _P extends Fe {
  constructor() {
    super(37, "emptySelectionClipboard", !0, { description: p("emptySelectionClipboard", "Controls whether copying without a selection copies the current line.") });
  }
  compute(e, t, i) {
    return i && e.emptySelectionClipboard;
  }
}
class bP extends kt {
  constructor() {
    const e = {
      cursorMoveOnType: !0,
      seedSearchStringFromSelection: "always",
      autoFindInSelection: "never",
      globalFindClipboard: !1,
      addExtraSpaceOnTop: !0,
      loop: !0
    };
    super(41, "find", e, {
      "editor.find.cursorMoveOnType": {
        type: "boolean",
        default: e.cursorMoveOnType,
        description: p("find.cursorMoveOnType", "Controls whether the cursor should jump to find matches while typing.")
      },
      "editor.find.seedSearchStringFromSelection": {
        type: "string",
        enum: ["never", "always", "selection"],
        default: e.seedSearchStringFromSelection,
        enumDescriptions: [
          p("editor.find.seedSearchStringFromSelection.never", "Never seed search string from the editor selection."),
          p("editor.find.seedSearchStringFromSelection.always", "Always seed search string from the editor selection, including word at cursor position."),
          p("editor.find.seedSearchStringFromSelection.selection", "Only seed search string from the editor selection.")
        ],
        description: p("find.seedSearchStringFromSelection", "Controls whether the search string in the Find Widget is seeded from the editor selection.")
      },
      "editor.find.autoFindInSelection": {
        type: "string",
        enum: ["never", "always", "multiline"],
        default: e.autoFindInSelection,
        enumDescriptions: [
          p("editor.find.autoFindInSelection.never", "Never turn on Find in Selection automatically (default)."),
          p("editor.find.autoFindInSelection.always", "Always turn on Find in Selection automatically."),
          p("editor.find.autoFindInSelection.multiline", "Turn on Find in Selection automatically when multiple lines of content are selected.")
        ],
        description: p("find.autoFindInSelection", "Controls the condition for turning on Find in Selection automatically.")
      },
      "editor.find.globalFindClipboard": {
        type: "boolean",
        default: e.globalFindClipboard,
        description: p("find.globalFindClipboard", "Controls whether the Find Widget should read or modify the shared find clipboard on macOS."),
        included: He
      },
      "editor.find.addExtraSpaceOnTop": {
        type: "boolean",
        default: e.addExtraSpaceOnTop,
        description: p("find.addExtraSpaceOnTop", "Controls whether the Find Widget should add extra lines on top of the editor. When true, you can scroll beyond the first line when the Find Widget is visible.")
      },
      "editor.find.loop": {
        type: "boolean",
        default: e.loop,
        description: p("find.loop", "Controls whether the search automatically restarts from the beginning (or the end) when no further matches can be found.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      cursorMoveOnType: oe(t.cursorMoveOnType, this.defaultValue.cursorMoveOnType),
      seedSearchStringFromSelection: typeof e.seedSearchStringFromSelection == "boolean" ? e.seedSearchStringFromSelection ? "always" : "never" : Mt(t.seedSearchStringFromSelection, this.defaultValue.seedSearchStringFromSelection, ["never", "always", "selection"]),
      autoFindInSelection: typeof e.autoFindInSelection == "boolean" ? e.autoFindInSelection ? "always" : "never" : Mt(t.autoFindInSelection, this.defaultValue.autoFindInSelection, ["never", "always", "multiline"]),
      globalFindClipboard: oe(t.globalFindClipboard, this.defaultValue.globalFindClipboard),
      addExtraSpaceOnTop: oe(t.addExtraSpaceOnTop, this.defaultValue.addExtraSpaceOnTop),
      loop: oe(t.loop, this.defaultValue.loop)
    };
  }
}
const mr = class mr extends kt {
  constructor() {
    super(51, "fontLigatures", mr.OFF, {
      anyOf: [
        {
          type: "boolean",
          description: p("fontLigatures", "Enables/Disables font ligatures ('calt' and 'liga' font features). Change this to a string for fine-grained control of the 'font-feature-settings' CSS property.")
        },
        {
          type: "string",
          description: p("fontFeatureSettings", "Explicit 'font-feature-settings' CSS property. A boolean can be passed instead if one only needs to turn on/off ligatures.")
        }
      ],
      description: p("fontLigaturesGeneral", "Configures font ligatures or font features. Can be either a boolean to enable/disable ligatures or a string for the value of the CSS 'font-feature-settings' property."),
      default: !1
    });
  }
  validate(e) {
    return typeof e > "u" ? this.defaultValue : typeof e == "string" ? e === "false" || e.length === 0 ? mr.OFF : e === "true" ? mr.ON : e : e ? mr.ON : mr.OFF;
  }
};
mr.OFF = '"liga" off, "calt" off', mr.ON = '"liga" on, "calt" on';
let gc = mr;
const pr = class pr extends kt {
  constructor() {
    super(54, "fontVariations", pr.OFF, {
      anyOf: [
        {
          type: "boolean",
          description: p("fontVariations", "Enables/Disables the translation from font-weight to font-variation-settings. Change this to a string for fine-grained control of the 'font-variation-settings' CSS property.")
        },
        {
          type: "string",
          description: p("fontVariationSettings", "Explicit 'font-variation-settings' CSS property. A boolean can be passed instead if one only needs to translate font-weight to font-variation-settings.")
        }
      ],
      description: p("fontVariationsGeneral", "Configures font variations. Can be either a boolean to enable/disable the translation from font-weight to font-variation-settings or a string for the value of the CSS 'font-variation-settings' property."),
      default: !1
    });
  }
  validate(e) {
    return typeof e > "u" ? this.defaultValue : typeof e == "string" ? e === "false" ? pr.OFF : e === "true" ? pr.TRANSLATE : e : e ? pr.TRANSLATE : pr.OFF;
  }
  compute(e, t, i) {
    return e.fontInfo.fontVariationSettings;
  }
};
pr.OFF = "normal", pr.TRANSLATE = "translate";
let Tf = pr;
class CP extends Cg {
  constructor() {
    super(
      50
      /* EditorOption.fontInfo */
    );
  }
  compute(e, t, i) {
    return e.fontInfo;
  }
}
class wP extends Bd {
  constructor() {
    super(52, "fontSize", es.fontSize, {
      type: "number",
      minimum: 6,
      maximum: 100,
      default: es.fontSize,
      description: p("fontSize", "Controls the font size in pixels.")
    });
  }
  validate(e) {
    const t = Qn.float(e, this.defaultValue);
    return t === 0 ? es.fontSize : Qn.clamp(t, 6, 100);
  }
  compute(e, t, i) {
    return e.fontInfo.fontSize;
  }
}
const Do = class Do extends kt {
  constructor() {
    super(53, "fontWeight", es.fontWeight, {
      anyOf: [
        {
          type: "number",
          minimum: Do.MINIMUM_VALUE,
          maximum: Do.MAXIMUM_VALUE,
          errorMessage: p("fontWeightErrorMessage", 'Only "normal" and "bold" keywords or numbers between 1 and 1000 are allowed.')
        },
        {
          type: "string",
          pattern: "^(normal|bold|1000|[1-9][0-9]{0,2})$"
        },
        {
          enum: Do.SUGGESTION_VALUES
        }
      ],
      default: es.fontWeight,
      description: p("fontWeight", 'Controls the font weight. Accepts "normal" and "bold" keywords or numbers between 1 and 1000.')
    });
  }
  validate(e) {
    return e === "normal" || e === "bold" ? e : String(lt.clampedInt(e, es.fontWeight, Do.MINIMUM_VALUE, Do.MAXIMUM_VALUE));
  }
};
Do.SUGGESTION_VALUES = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"], Do.MINIMUM_VALUE = 1, Do.MAXIMUM_VALUE = 1e3;
let TC = Do;
class vP extends kt {
  constructor() {
    const e = {
      multiple: "peek",
      multipleDefinitions: "peek",
      multipleTypeDefinitions: "peek",
      multipleDeclarations: "peek",
      multipleImplementations: "peek",
      multipleReferences: "peek",
      multipleTests: "peek",
      alternativeDefinitionCommand: "editor.action.goToReferences",
      alternativeTypeDefinitionCommand: "editor.action.goToReferences",
      alternativeDeclarationCommand: "editor.action.goToReferences",
      alternativeImplementationCommand: "",
      alternativeReferenceCommand: "",
      alternativeTestsCommand: ""
    }, t = {
      type: "string",
      enum: ["peek", "gotoAndPeek", "goto"],
      default: e.multiple,
      enumDescriptions: [
        p("editor.gotoLocation.multiple.peek", "Show Peek view of the results (default)"),
        p("editor.gotoLocation.multiple.gotoAndPeek", "Go to the primary result and show a Peek view"),
        p("editor.gotoLocation.multiple.goto", "Go to the primary result and enable Peek-less navigation to others")
      ]
    }, i = ["", "editor.action.referenceSearch.trigger", "editor.action.goToReferences", "editor.action.peekImplementation", "editor.action.goToImplementation", "editor.action.peekTypeDefinition", "editor.action.goToTypeDefinition", "editor.action.peekDeclaration", "editor.action.revealDeclaration", "editor.action.peekDefinition", "editor.action.revealDefinitionAside", "editor.action.revealDefinition"];
    super(58, "gotoLocation", e, {
      "editor.gotoLocation.multiple": {
        deprecationMessage: p("editor.gotoLocation.multiple.deprecated", "This setting is deprecated, please use separate settings like 'editor.editor.gotoLocation.multipleDefinitions' or 'editor.editor.gotoLocation.multipleImplementations' instead.")
      },
      "editor.gotoLocation.multipleDefinitions": {
        description: p("editor.editor.gotoLocation.multipleDefinitions", "Controls the behavior the 'Go to Definition'-command when multiple target locations exist."),
        ...t
      },
      "editor.gotoLocation.multipleTypeDefinitions": {
        description: p("editor.editor.gotoLocation.multipleTypeDefinitions", "Controls the behavior the 'Go to Type Definition'-command when multiple target locations exist."),
        ...t
      },
      "editor.gotoLocation.multipleDeclarations": {
        description: p("editor.editor.gotoLocation.multipleDeclarations", "Controls the behavior the 'Go to Declaration'-command when multiple target locations exist."),
        ...t
      },
      "editor.gotoLocation.multipleImplementations": {
        description: p("editor.editor.gotoLocation.multipleImplemenattions", "Controls the behavior the 'Go to Implementations'-command when multiple target locations exist."),
        ...t
      },
      "editor.gotoLocation.multipleReferences": {
        description: p("editor.editor.gotoLocation.multipleReferences", "Controls the behavior the 'Go to References'-command when multiple target locations exist."),
        ...t
      },
      "editor.gotoLocation.alternativeDefinitionCommand": {
        type: "string",
        default: e.alternativeDefinitionCommand,
        enum: i,
        description: p("alternativeDefinitionCommand", "Alternative command id that is being executed when the result of 'Go to Definition' is the current location.")
      },
      "editor.gotoLocation.alternativeTypeDefinitionCommand": {
        type: "string",
        default: e.alternativeTypeDefinitionCommand,
        enum: i,
        description: p("alternativeTypeDefinitionCommand", "Alternative command id that is being executed when the result of 'Go to Type Definition' is the current location.")
      },
      "editor.gotoLocation.alternativeDeclarationCommand": {
        type: "string",
        default: e.alternativeDeclarationCommand,
        enum: i,
        description: p("alternativeDeclarationCommand", "Alternative command id that is being executed when the result of 'Go to Declaration' is the current location.")
      },
      "editor.gotoLocation.alternativeImplementationCommand": {
        type: "string",
        default: e.alternativeImplementationCommand,
        enum: i,
        description: p("alternativeImplementationCommand", "Alternative command id that is being executed when the result of 'Go to Implementation' is the current location.")
      },
      "editor.gotoLocation.alternativeReferenceCommand": {
        type: "string",
        default: e.alternativeReferenceCommand,
        enum: i,
        description: p("alternativeReferenceCommand", "Alternative command id that is being executed when the result of 'Go to Reference' is the current location.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      multiple: Mt(t.multiple, this.defaultValue.multiple, ["peek", "gotoAndPeek", "goto"]),
      multipleDefinitions: t.multipleDefinitions ?? Mt(t.multipleDefinitions, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleTypeDefinitions: t.multipleTypeDefinitions ?? Mt(t.multipleTypeDefinitions, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleDeclarations: t.multipleDeclarations ?? Mt(t.multipleDeclarations, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleImplementations: t.multipleImplementations ?? Mt(t.multipleImplementations, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleReferences: t.multipleReferences ?? Mt(t.multipleReferences, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleTests: t.multipleTests ?? Mt(t.multipleTests, "peek", ["peek", "gotoAndPeek", "goto"]),
      alternativeDefinitionCommand: qi.string(t.alternativeDefinitionCommand, this.defaultValue.alternativeDefinitionCommand),
      alternativeTypeDefinitionCommand: qi.string(t.alternativeTypeDefinitionCommand, this.defaultValue.alternativeTypeDefinitionCommand),
      alternativeDeclarationCommand: qi.string(t.alternativeDeclarationCommand, this.defaultValue.alternativeDeclarationCommand),
      alternativeImplementationCommand: qi.string(t.alternativeImplementationCommand, this.defaultValue.alternativeImplementationCommand),
      alternativeReferenceCommand: qi.string(t.alternativeReferenceCommand, this.defaultValue.alternativeReferenceCommand),
      alternativeTestsCommand: qi.string(t.alternativeTestsCommand, this.defaultValue.alternativeTestsCommand)
    };
  }
}
class yP extends kt {
  constructor() {
    const e = {
      enabled: !0,
      delay: 300,
      hidingDelay: 300,
      sticky: !0,
      above: !0
    };
    super(60, "hover", e, {
      "editor.hover.enabled": {
        type: "boolean",
        default: e.enabled,
        description: p("hover.enabled", "Controls whether the hover is shown.")
      },
      "editor.hover.delay": {
        type: "number",
        default: e.delay,
        minimum: 0,
        maximum: 1e4,
        description: p("hover.delay", "Controls the delay in milliseconds after which the hover is shown.")
      },
      "editor.hover.sticky": {
        type: "boolean",
        default: e.sticky,
        description: p("hover.sticky", "Controls whether the hover should remain visible when mouse is moved over it.")
      },
      "editor.hover.hidingDelay": {
        type: "integer",
        minimum: 0,
        default: e.hidingDelay,
        description: p("hover.hidingDelay", "Controls the delay in milliseconds after which the hover is hidden. Requires `editor.hover.sticky` to be enabled.")
      },
      "editor.hover.above": {
        type: "boolean",
        default: e.above,
        description: p("hover.above", "Prefer showing hovers above the line, if there's space.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: oe(t.enabled, this.defaultValue.enabled),
      delay: lt.clampedInt(t.delay, this.defaultValue.delay, 0, 1e4),
      sticky: oe(t.sticky, this.defaultValue.sticky),
      hidingDelay: lt.clampedInt(t.hidingDelay, this.defaultValue.hidingDelay, 0, 6e5),
      above: oe(t.above, this.defaultValue.above)
    };
  }
}
class Hh extends Cg {
  constructor() {
    super(
      146
      /* EditorOption.layoutInfo */
    );
  }
  compute(e, t, i) {
    return Hh.computeLayout(t, {
      memory: e.memory,
      outerWidth: e.outerWidth,
      outerHeight: e.outerHeight,
      isDominatedByLongLines: e.isDominatedByLongLines,
      lineHeight: e.fontInfo.lineHeight,
      viewLineCount: e.viewLineCount,
      lineNumbersDigitCount: e.lineNumbersDigitCount,
      typicalHalfwidthCharacterWidth: e.fontInfo.typicalHalfwidthCharacterWidth,
      maxDigitWidth: e.fontInfo.maxDigitWidth,
      pixelRatio: e.pixelRatio,
      glyphMarginDecorationLaneCount: e.glyphMarginDecorationLaneCount
    });
  }
  static computeContainedMinimapLineCount(e) {
    const t = e.height / e.lineHeight, i = Math.floor(e.paddingTop / e.lineHeight);
    let n = Math.floor(e.paddingBottom / e.lineHeight);
    e.scrollBeyondLastLine && (n = Math.max(n, t - 1));
    const o = (i + e.viewLineCount + n) / (e.pixelRatio * e.height), r = Math.floor(e.viewLineCount / o);
    return { typicalViewportLineCount: t, extraLinesBeforeFirstLine: i, extraLinesBeyondLastLine: n, desiredRatio: o, minimapLineCount: r };
  }
  static _computeMinimapLayout(e, t) {
    const i = e.outerWidth, n = e.outerHeight, o = e.pixelRatio;
    if (!e.minimap.enabled)
      return {
        renderMinimap: 0,
        minimapLeft: 0,
        minimapWidth: 0,
        minimapHeightIsEditorHeight: !1,
        minimapIsSampling: !1,
        minimapScale: 1,
        minimapLineHeight: 1,
        minimapCanvasInnerWidth: 0,
        minimapCanvasInnerHeight: Math.floor(o * n),
        minimapCanvasOuterWidth: 0,
        minimapCanvasOuterHeight: n
      };
    const r = t.stableMinimapLayoutInput, a = r && e.outerHeight === r.outerHeight && e.lineHeight === r.lineHeight && e.typicalHalfwidthCharacterWidth === r.typicalHalfwidthCharacterWidth && e.pixelRatio === r.pixelRatio && e.scrollBeyondLastLine === r.scrollBeyondLastLine && e.paddingTop === r.paddingTop && e.paddingBottom === r.paddingBottom && e.minimap.enabled === r.minimap.enabled && e.minimap.side === r.minimap.side && e.minimap.size === r.minimap.size && e.minimap.showSlider === r.minimap.showSlider && e.minimap.renderCharacters === r.minimap.renderCharacters && e.minimap.maxColumn === r.minimap.maxColumn && e.minimap.scale === r.minimap.scale && e.verticalScrollbarWidth === r.verticalScrollbarWidth && e.isViewportWrapping === r.isViewportWrapping, l = e.lineHeight, c = e.typicalHalfwidthCharacterWidth, h = e.scrollBeyondLastLine, d = e.minimap.renderCharacters;
    let u = o >= 2 ? Math.round(e.minimap.scale * 2) : e.minimap.scale;
    const f = e.minimap.maxColumn, g = e.minimap.size, m = e.minimap.side, _ = e.verticalScrollbarWidth, b = e.viewLineCount, C = e.remainingWidth, v = e.isViewportWrapping, w = d ? 2 : 3;
    let S = Math.floor(o * n);
    const L = S / o;
    let k = !1, D = !1, E = w * u, U = u / o, P = 1;
    if (g === "fill" || g === "fit") {
      const { typicalViewportLineCount: ne, extraLinesBeforeFirstLine: ie, extraLinesBeyondLastLine: me, desiredRatio: _e, minimapLineCount: vt } = Hh.computeContainedMinimapLineCount({
        viewLineCount: b,
        scrollBeyondLastLine: h,
        paddingTop: e.paddingTop,
        paddingBottom: e.paddingBottom,
        height: n,
        lineHeight: l,
        pixelRatio: o
      });
      if (b / vt > 1)
        k = !0, D = !0, u = 1, E = 1, U = u / o;
      else {
        let Ze = !1, De = u + 1;
        if (g === "fit") {
          const mt = Math.ceil((ie + b + me) * E);
          v && a && C <= t.stableFitRemainingWidth ? (Ze = !0, De = t.stableFitMaxMinimapScale) : Ze = mt > S;
        }
        if (g === "fill" || Ze) {
          k = !0;
          const mt = u;
          E = Math.min(l * o, Math.max(1, Math.floor(1 / _e))), v && a && C <= t.stableFitRemainingWidth && (De = t.stableFitMaxMinimapScale), u = Math.min(De, Math.max(1, Math.floor(E / w))), u > mt && (P = Math.min(2, u / mt)), U = u / o / P, S = Math.ceil(Math.max(ne, ie + b + me) * E), v ? (t.stableMinimapLayoutInput = e, t.stableFitRemainingWidth = C, t.stableFitMaxMinimapScale = u) : (t.stableMinimapLayoutInput = null, t.stableFitRemainingWidth = 0);
        }
      }
    }
    const B = Math.floor(f * U), W = Math.min(B, Math.max(0, Math.floor((C - _ - 2) * U / (c + U))) + So);
    let A = Math.floor(o * W);
    const K = A / o;
    A = Math.floor(A * P);
    const Y = d ? 1 : 2, Q = m === "left" ? 0 : i - W - _;
    return {
      renderMinimap: Y,
      minimapLeft: Q,
      minimapWidth: W,
      minimapHeightIsEditorHeight: k,
      minimapIsSampling: D,
      minimapScale: u,
      minimapLineHeight: E,
      minimapCanvasInnerWidth: A,
      minimapCanvasInnerHeight: S,
      minimapCanvasOuterWidth: K,
      minimapCanvasOuterHeight: L
    };
  }
  static computeLayout(e, t) {
    const i = t.outerWidth | 0, n = t.outerHeight | 0, o = t.lineHeight | 0, r = t.lineNumbersDigitCount | 0, a = t.typicalHalfwidthCharacterWidth, l = t.maxDigitWidth, c = t.pixelRatio, h = t.viewLineCount, d = e.get(
      138
      /* EditorOption.wordWrapOverride2 */
    ), u = d === "inherit" ? e.get(
      137
      /* EditorOption.wordWrapOverride1 */
    ) : d, f = u === "inherit" ? e.get(
      133
      /* EditorOption.wordWrap */
    ) : u, g = e.get(
      136
      /* EditorOption.wordWrapColumn */
    ), m = t.isDominatedByLongLines, _ = e.get(
      57
      /* EditorOption.glyphMargin */
    ), b = e.get(
      68
      /* EditorOption.lineNumbers */
    ).renderType !== 0, C = e.get(
      69
      /* EditorOption.lineNumbersMinChars */
    ), v = e.get(
      106
      /* EditorOption.scrollBeyondLastLine */
    ), w = e.get(
      84
      /* EditorOption.padding */
    ), S = e.get(
      73
      /* EditorOption.minimap */
    ), L = e.get(
      104
      /* EditorOption.scrollbar */
    ), k = L.verticalScrollbarSize, D = L.verticalHasArrows, E = L.arrowSize, U = L.horizontalScrollbarSize, P = e.get(
      43
      /* EditorOption.folding */
    ), B = e.get(
      111
      /* EditorOption.showFoldingControls */
    ) !== "never";
    let W = e.get(
      66
      /* EditorOption.lineDecorationsWidth */
    );
    P && B && (W += 16);
    let A = 0;
    if (b) {
      const xt = Math.max(r, C);
      A = Math.round(xt * l);
    }
    let K = 0;
    _ && (K = o * t.glyphMarginDecorationLaneCount);
    let Y = 0, Q = Y + K, ne = Q + A, ie = ne + W;
    const me = i - K - A - W;
    let _e = !1, vt = !1, be = -1;
    u === "inherit" && m ? (_e = !0, vt = !0) : f === "on" || f === "bounded" ? vt = !0 : f === "wordWrapColumn" && (be = g);
    const Ze = Hh._computeMinimapLayout({
      outerWidth: i,
      outerHeight: n,
      lineHeight: o,
      typicalHalfwidthCharacterWidth: a,
      pixelRatio: c,
      scrollBeyondLastLine: v,
      paddingTop: w.top,
      paddingBottom: w.bottom,
      minimap: S,
      verticalScrollbarWidth: k,
      viewLineCount: h,
      remainingWidth: me,
      isViewportWrapping: vt
    }, t.memory || new M2());
    Ze.renderMinimap !== 0 && Ze.minimapLeft === 0 && (Y += Ze.minimapWidth, Q += Ze.minimapWidth, ne += Ze.minimapWidth, ie += Ze.minimapWidth);
    const De = me - Ze.minimapWidth, mt = Math.max(1, Math.floor((De - k - 2) / a)), Je = D ? E : 0;
    return vt && (be = Math.max(1, mt), f === "bounded" && (be = Math.min(be, g))), {
      width: i,
      height: n,
      glyphMarginLeft: Y,
      glyphMarginWidth: K,
      glyphMarginDecorationLaneCount: t.glyphMarginDecorationLaneCount,
      lineNumbersLeft: Q,
      lineNumbersWidth: A,
      decorationsLeft: ne,
      decorationsWidth: W,
      contentLeft: ie,
      contentWidth: De,
      minimap: Ze,
      viewportColumn: mt,
      isWordWrapMinified: _e,
      isViewportWrapping: vt,
      wrappingColumn: be,
      verticalScrollbarWidth: k,
      horizontalScrollbarHeight: U,
      overviewRuler: {
        top: Je,
        width: k,
        height: n - 2 * Je,
        right: 0
      }
    };
  }
}
class SP extends kt {
  constructor() {
    super(140, "wrappingStrategy", "simple", {
      "editor.wrappingStrategy": {
        enumDescriptions: [
          p("wrappingStrategy.simple", "Assumes that all characters are of the same width. This is a fast algorithm that works correctly for monospace fonts and certain scripts (like Latin characters) where glyphs are of equal width."),
          p("wrappingStrategy.advanced", "Delegates wrapping points computation to the browser. This is a slow algorithm, that might cause freezes for large files, but it works correctly in all cases.")
        ],
        type: "string",
        enum: ["simple", "advanced"],
        default: "simple",
        description: p("wrappingStrategy", "Controls the algorithm that computes wrapping points. Note that when in accessibility mode, advanced will be used for the best experience.")
      }
    });
  }
  validate(e) {
    return Mt(e, "simple", ["simple", "advanced"]);
  }
  compute(e, t, i) {
    return t.get(
      2
      /* EditorOption.accessibilitySupport */
    ) === 2 ? "advanced" : i;
  }
}
var hr;
(function(s) {
  s.Off = "off", s.OnCode = "onCode", s.On = "on";
})(hr || (hr = {}));
class LP extends kt {
  constructor() {
    const e = { enabled: hr.OnCode };
    super(65, "lightbulb", e, {
      "editor.lightbulb.enabled": {
        type: "string",
        tags: ["experimental"],
        enum: [hr.Off, hr.OnCode, hr.On],
        default: e.enabled,
        enumDescriptions: [
          p("editor.lightbulb.enabled.off", "Disable the code action menu."),
          p("editor.lightbulb.enabled.onCode", "Show the code action menu when the cursor is on lines with code."),
          p("editor.lightbulb.enabled.on", "Show the code action menu when the cursor is on lines with code or on empty lines.")
        ],
        description: p("enabled", "Enables the Code Action lightbulb in the editor.")
      }
    });
  }
  validate(e) {
    return !e || typeof e != "object" ? this.defaultValue : {
      enabled: Mt(e.enabled, this.defaultValue.enabled, [hr.Off, hr.OnCode, hr.On])
    };
  }
}
class kP extends kt {
  constructor() {
    const e = { enabled: !0, maxLineCount: 5, defaultModel: "outlineModel", scrollWithEditor: !0 };
    super(116, "stickyScroll", e, {
      "editor.stickyScroll.enabled": {
        type: "boolean",
        default: e.enabled,
        description: p("editor.stickyScroll.enabled", "Shows the nested current scopes during the scroll at the top of the editor."),
        tags: ["experimental"]
      },
      "editor.stickyScroll.maxLineCount": {
        type: "number",
        default: e.maxLineCount,
        minimum: 1,
        maximum: 20,
        description: p("editor.stickyScroll.maxLineCount", "Defines the maximum number of sticky lines to show.")
      },
      "editor.stickyScroll.defaultModel": {
        type: "string",
        enum: ["outlineModel", "foldingProviderModel", "indentationModel"],
        default: e.defaultModel,
        description: p("editor.stickyScroll.defaultModel", "Defines the model to use for determining which lines to stick. If the outline model does not exist, it will fall back on the folding provider model which falls back on the indentation model. This order is respected in all three cases.")
      },
      "editor.stickyScroll.scrollWithEditor": {
        type: "boolean",
        default: e.scrollWithEditor,
        description: p("editor.stickyScroll.scrollWithEditor", "Enable scrolling of Sticky Scroll with the editor's horizontal scrollbar.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: oe(t.enabled, this.defaultValue.enabled),
      maxLineCount: lt.clampedInt(t.maxLineCount, this.defaultValue.maxLineCount, 1, 20),
      defaultModel: Mt(t.defaultModel, this.defaultValue.defaultModel, ["outlineModel", "foldingProviderModel", "indentationModel"]),
      scrollWithEditor: oe(t.scrollWithEditor, this.defaultValue.scrollWithEditor)
    };
  }
}
class xP extends kt {
  constructor() {
    const e = { enabled: "on", fontSize: 0, fontFamily: "", padding: !1 };
    super(142, "inlayHints", e, {
      "editor.inlayHints.enabled": {
        type: "string",
        default: e.enabled,
        description: p("inlayHints.enable", "Enables the inlay hints in the editor."),
        enum: ["on", "onUnlessPressed", "offUnlessPressed", "off"],
        markdownEnumDescriptions: [
          p("editor.inlayHints.on", "Inlay hints are enabled"),
          p("editor.inlayHints.onUnlessPressed", "Inlay hints are showing by default and hide when holding {0}", He ? "Ctrl+Option" : "Ctrl+Alt"),
          p("editor.inlayHints.offUnlessPressed", "Inlay hints are hidden by default and show when holding {0}", He ? "Ctrl+Option" : "Ctrl+Alt"),
          p("editor.inlayHints.off", "Inlay hints are disabled")
        ]
      },
      "editor.inlayHints.fontSize": {
        type: "number",
        default: e.fontSize,
        markdownDescription: p("inlayHints.fontSize", "Controls font size of inlay hints in the editor. As default the {0} is used when the configured value is less than {1} or greater than the editor font size.", "`#editor.fontSize#`", "`5`")
      },
      "editor.inlayHints.fontFamily": {
        type: "string",
        default: e.fontFamily,
        markdownDescription: p("inlayHints.fontFamily", "Controls font family of inlay hints in the editor. When set to empty, the {0} is used.", "`#editor.fontFamily#`")
      },
      "editor.inlayHints.padding": {
        type: "boolean",
        default: e.padding,
        description: p("inlayHints.padding", "Enables the padding around the inlay hints in the editor.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return typeof t.enabled == "boolean" && (t.enabled = t.enabled ? "on" : "off"), {
      enabled: Mt(t.enabled, this.defaultValue.enabled, ["on", "off", "offUnlessPressed", "onUnlessPressed"]),
      fontSize: lt.clampedInt(t.fontSize, this.defaultValue.fontSize, 0, 100),
      fontFamily: qi.string(t.fontFamily, this.defaultValue.fontFamily),
      padding: oe(t.padding, this.defaultValue.padding)
    };
  }
}
class DP extends kt {
  constructor() {
    super(66, "lineDecorationsWidth", 10);
  }
  validate(e) {
    return typeof e == "string" && /^\d+(\.\d+)?ch$/.test(e) ? -parseFloat(e.substring(0, e.length - 2)) : lt.clampedInt(e, this.defaultValue, 0, 1e3);
  }
  compute(e, t, i) {
    return i < 0 ? lt.clampedInt(-i * e.fontInfo.typicalHalfwidthCharacterWidth, this.defaultValue, 0, 1e3) : i;
  }
}
class EP extends Qn {
  constructor() {
    super(67, "lineHeight", es.lineHeight, (e) => Qn.clamp(e, 0, 150), { markdownDescription: p("lineHeight", `Controls the line height. 
 - Use 0 to automatically compute the line height from the font size.
 - Values between 0 and 8 will be used as a multiplier with the font size.
 - Values greater than or equal to 8 will be used as effective values.`) });
  }
  compute(e, t, i) {
    return e.fontInfo.lineHeight;
  }
}
class IP extends kt {
  constructor() {
    const e = {
      enabled: !0,
      size: "proportional",
      side: "right",
      showSlider: "mouseover",
      autohide: !1,
      renderCharacters: !0,
      maxColumn: 120,
      scale: 1,
      showRegionSectionHeaders: !0,
      showMarkSectionHeaders: !0,
      sectionHeaderFontSize: 9,
      sectionHeaderLetterSpacing: 1
    };
    super(73, "minimap", e, {
      "editor.minimap.enabled": {
        type: "boolean",
        default: e.enabled,
        description: p("minimap.enabled", "Controls whether the minimap is shown.")
      },
      "editor.minimap.autohide": {
        type: "boolean",
        default: e.autohide,
        description: p("minimap.autohide", "Controls whether the minimap is hidden automatically.")
      },
      "editor.minimap.size": {
        type: "string",
        enum: ["proportional", "fill", "fit"],
        enumDescriptions: [
          p("minimap.size.proportional", "The minimap has the same size as the editor contents (and might scroll)."),
          p("minimap.size.fill", "The minimap will stretch or shrink as necessary to fill the height of the editor (no scrolling)."),
          p("minimap.size.fit", "The minimap will shrink as necessary to never be larger than the editor (no scrolling).")
        ],
        default: e.size,
        description: p("minimap.size", "Controls the size of the minimap.")
      },
      "editor.minimap.side": {
        type: "string",
        enum: ["left", "right"],
        default: e.side,
        description: p("minimap.side", "Controls the side where to render the minimap.")
      },
      "editor.minimap.showSlider": {
        type: "string",
        enum: ["always", "mouseover"],
        default: e.showSlider,
        description: p("minimap.showSlider", "Controls when the minimap slider is shown.")
      },
      "editor.minimap.scale": {
        type: "number",
        default: e.scale,
        minimum: 1,
        maximum: 3,
        enum: [1, 2, 3],
        description: p("minimap.scale", "Scale of content drawn in the minimap: 1, 2 or 3.")
      },
      "editor.minimap.renderCharacters": {
        type: "boolean",
        default: e.renderCharacters,
        description: p("minimap.renderCharacters", "Render the actual characters on a line as opposed to color blocks.")
      },
      "editor.minimap.maxColumn": {
        type: "number",
        default: e.maxColumn,
        description: p("minimap.maxColumn", "Limit the width of the minimap to render at most a certain number of columns.")
      },
      "editor.minimap.showRegionSectionHeaders": {
        type: "boolean",
        default: e.showRegionSectionHeaders,
        description: p("minimap.showRegionSectionHeaders", "Controls whether named regions are shown as section headers in the minimap.")
      },
      "editor.minimap.showMarkSectionHeaders": {
        type: "boolean",
        default: e.showMarkSectionHeaders,
        description: p("minimap.showMarkSectionHeaders", "Controls whether MARK: comments are shown as section headers in the minimap.")
      },
      "editor.minimap.sectionHeaderFontSize": {
        type: "number",
        default: e.sectionHeaderFontSize,
        description: p("minimap.sectionHeaderFontSize", "Controls the font size of section headers in the minimap.")
      },
      "editor.minimap.sectionHeaderLetterSpacing": {
        type: "number",
        default: e.sectionHeaderLetterSpacing,
        description: p("minimap.sectionHeaderLetterSpacing", "Controls the amount of space (in pixels) between characters of section header. This helps the readability of the header in small font sizes.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: oe(t.enabled, this.defaultValue.enabled),
      autohide: oe(t.autohide, this.defaultValue.autohide),
      size: Mt(t.size, this.defaultValue.size, ["proportional", "fill", "fit"]),
      side: Mt(t.side, this.defaultValue.side, ["right", "left"]),
      showSlider: Mt(t.showSlider, this.defaultValue.showSlider, ["always", "mouseover"]),
      renderCharacters: oe(t.renderCharacters, this.defaultValue.renderCharacters),
      scale: lt.clampedInt(t.scale, 1, 1, 3),
      maxColumn: lt.clampedInt(t.maxColumn, this.defaultValue.maxColumn, 1, 1e4),
      showRegionSectionHeaders: oe(t.showRegionSectionHeaders, this.defaultValue.showRegionSectionHeaders),
      showMarkSectionHeaders: oe(t.showMarkSectionHeaders, this.defaultValue.showMarkSectionHeaders),
      sectionHeaderFontSize: Qn.clamp(t.sectionHeaderFontSize ?? this.defaultValue.sectionHeaderFontSize, 4, 32),
      sectionHeaderLetterSpacing: Qn.clamp(t.sectionHeaderLetterSpacing ?? this.defaultValue.sectionHeaderLetterSpacing, 0, 5)
    };
  }
}
function NP(s) {
  return s === "ctrlCmd" ? He ? "metaKey" : "ctrlKey" : "altKey";
}
class TP extends kt {
  constructor() {
    super(84, "padding", { top: 0, bottom: 0 }, {
      "editor.padding.top": {
        type: "number",
        default: 0,
        minimum: 0,
        maximum: 1e3,
        description: p("padding.top", "Controls the amount of space between the top edge of the editor and the first line.")
      },
      "editor.padding.bottom": {
        type: "number",
        default: 0,
        minimum: 0,
        maximum: 1e3,
        description: p("padding.bottom", "Controls the amount of space between the bottom edge of the editor and the last line.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      top: lt.clampedInt(t.top, 0, 0, 1e3),
      bottom: lt.clampedInt(t.bottom, 0, 0, 1e3)
    };
  }
}
class MP extends kt {
  constructor() {
    const e = {
      enabled: !0,
      cycle: !0
    };
    super(86, "parameterHints", e, {
      "editor.parameterHints.enabled": {
        type: "boolean",
        default: e.enabled,
        description: p("parameterHints.enabled", "Enables a pop-up that shows parameter documentation and type information as you type.")
      },
      "editor.parameterHints.cycle": {
        type: "boolean",
        default: e.cycle,
        description: p("parameterHints.cycle", "Controls whether the parameter hints menu cycles or closes when reaching the end of the list.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: oe(t.enabled, this.defaultValue.enabled),
      cycle: oe(t.cycle, this.defaultValue.cycle)
    };
  }
}
class RP extends Cg {
  constructor() {
    super(
      144
      /* EditorOption.pixelRatio */
    );
  }
  compute(e, t, i) {
    return e.pixelRatio;
  }
}
class AP extends kt {
  constructor() {
    super(88, "placeholder", void 0);
  }
  validate(e) {
    return typeof e > "u" ? this.defaultValue : typeof e == "string" ? e : this.defaultValue;
  }
}
class PP extends kt {
  constructor() {
    const e = {
      other: "on",
      comments: "off",
      strings: "off"
    }, t = [
      { type: "boolean" },
      {
        type: "string",
        enum: ["on", "inline", "off"],
        enumDescriptions: [p("on", "Quick suggestions show inside the suggest widget"), p("inline", "Quick suggestions show as ghost text"), p("off", "Quick suggestions are disabled")]
      }
    ];
    super(90, "quickSuggestions", e, {
      type: "object",
      additionalProperties: !1,
      properties: {
        strings: {
          anyOf: t,
          default: e.strings,
          description: p("quickSuggestions.strings", "Enable quick suggestions inside strings.")
        },
        comments: {
          anyOf: t,
          default: e.comments,
          description: p("quickSuggestions.comments", "Enable quick suggestions inside comments.")
        },
        other: {
          anyOf: t,
          default: e.other,
          description: p("quickSuggestions.other", "Enable quick suggestions outside of strings and comments.")
        }
      },
      default: e,
      markdownDescription: p("quickSuggestions", "Controls whether suggestions should automatically show up while typing. This can be controlled for typing in comments, strings, and other code. Quick suggestion can be configured to show as ghost text or with the suggest widget. Also be aware of the {0}-setting which controls if suggestions are triggered by special characters.", "`#editor.suggestOnTriggerCharacters#`")
    }), this.defaultValue = e;
  }
  validate(e) {
    if (typeof e == "boolean") {
      const c = e ? "on" : "off";
      return { comments: c, strings: c, other: c };
    }
    if (!e || typeof e != "object")
      return this.defaultValue;
    const { other: t, comments: i, strings: n } = e, o = ["on", "inline", "off"];
    let r, a, l;
    return typeof t == "boolean" ? r = t ? "on" : "off" : r = Mt(t, this.defaultValue.other, o), typeof i == "boolean" ? a = i ? "on" : "off" : a = Mt(i, this.defaultValue.comments, o), typeof n == "boolean" ? l = n ? "on" : "off" : l = Mt(n, this.defaultValue.strings, o), {
      other: r,
      comments: a,
      strings: l
    };
  }
}
class OP extends kt {
  constructor() {
    super(68, "lineNumbers", { renderType: 1, renderFn: null }, {
      type: "string",
      enum: ["off", "on", "relative", "interval"],
      enumDescriptions: [
        p("lineNumbers.off", "Line numbers are not rendered."),
        p("lineNumbers.on", "Line numbers are rendered as absolute number."),
        p("lineNumbers.relative", "Line numbers are rendered as distance in lines to cursor position."),
        p("lineNumbers.interval", "Line numbers are rendered every 10 lines.")
      ],
      default: "on",
      description: p("lineNumbers", "Controls the display of line numbers.")
    });
  }
  validate(e) {
    let t = this.defaultValue.renderType, i = this.defaultValue.renderFn;
    return typeof e < "u" && (typeof e == "function" ? (t = 4, i = e) : e === "interval" ? t = 3 : e === "relative" ? t = 2 : e === "on" ? t = 1 : t = 0), {
      renderType: t,
      renderFn: i
    };
  }
}
function wp(s) {
  const e = s.get(
    99
    /* EditorOption.renderValidationDecorations */
  );
  return e === "editable" ? s.get(
    92
    /* EditorOption.readOnly */
  ) : e !== "on";
}
class FP extends kt {
  constructor() {
    const e = [], t = { type: "number", description: p("rulers.size", "Number of monospace characters at which this editor ruler will render.") };
    super(103, "rulers", e, {
      type: "array",
      items: {
        anyOf: [
          t,
          {
            type: [
              "object"
            ],
            properties: {
              column: t,
              color: {
                type: "string",
                description: p("rulers.color", "Color of this editor ruler."),
                format: "color-hex"
              }
            }
          }
        ]
      },
      default: e,
      description: p("rulers", "Render vertical rulers after a certain number of monospace characters. Use multiple values for multiple rulers. No rulers are drawn if array is empty.")
    });
  }
  validate(e) {
    if (Array.isArray(e)) {
      const t = [];
      for (const i of e)
        if (typeof i == "number")
          t.push({
            column: lt.clampedInt(i, 0, 0, 1e4),
            color: null
          });
        else if (i && typeof i == "object") {
          const n = i;
          t.push({
            column: lt.clampedInt(n.column, 0, 0, 1e4),
            color: n.color
          });
        }
      return t.sort((i, n) => i.column - n.column), t;
    }
    return this.defaultValue;
  }
}
class BP extends kt {
  constructor() {
    super(93, "readOnlyMessage", void 0);
  }
  validate(e) {
    return !e || typeof e != "object" ? this.defaultValue : e;
  }
}
function nD(s, e) {
  if (typeof s != "string")
    return e;
  switch (s) {
    case "hidden":
      return 2;
    case "visible":
      return 3;
    default:
      return 1;
  }
}
let WP = class extends kt {
  constructor() {
    const e = {
      vertical: 1,
      horizontal: 1,
      arrowSize: 11,
      useShadows: !0,
      verticalHasArrows: !1,
      horizontalHasArrows: !1,
      horizontalScrollbarSize: 12,
      horizontalSliderSize: 12,
      verticalScrollbarSize: 14,
      verticalSliderSize: 14,
      handleMouseWheel: !0,
      alwaysConsumeMouseWheel: !0,
      scrollByPage: !1,
      ignoreHorizontalScrollbarInContentHeight: !1
    };
    super(104, "scrollbar", e, {
      "editor.scrollbar.vertical": {
        type: "string",
        enum: ["auto", "visible", "hidden"],
        enumDescriptions: [
          p("scrollbar.vertical.auto", "The vertical scrollbar will be visible only when necessary."),
          p("scrollbar.vertical.visible", "The vertical scrollbar will always be visible."),
          p("scrollbar.vertical.fit", "The vertical scrollbar will always be hidden.")
        ],
        default: "auto",
        description: p("scrollbar.vertical", "Controls the visibility of the vertical scrollbar.")
      },
      "editor.scrollbar.horizontal": {
        type: "string",
        enum: ["auto", "visible", "hidden"],
        enumDescriptions: [
          p("scrollbar.horizontal.auto", "The horizontal scrollbar will be visible only when necessary."),
          p("scrollbar.horizontal.visible", "The horizontal scrollbar will always be visible."),
          p("scrollbar.horizontal.fit", "The horizontal scrollbar will always be hidden.")
        ],
        default: "auto",
        description: p("scrollbar.horizontal", "Controls the visibility of the horizontal scrollbar.")
      },
      "editor.scrollbar.verticalScrollbarSize": {
        type: "number",
        default: e.verticalScrollbarSize,
        description: p("scrollbar.verticalScrollbarSize", "The width of the vertical scrollbar.")
      },
      "editor.scrollbar.horizontalScrollbarSize": {
        type: "number",
        default: e.horizontalScrollbarSize,
        description: p("scrollbar.horizontalScrollbarSize", "The height of the horizontal scrollbar.")
      },
      "editor.scrollbar.scrollByPage": {
        type: "boolean",
        default: e.scrollByPage,
        description: p("scrollbar.scrollByPage", "Controls whether clicks scroll by page or jump to click position.")
      },
      "editor.scrollbar.ignoreHorizontalScrollbarInContentHeight": {
        type: "boolean",
        default: e.ignoreHorizontalScrollbarInContentHeight,
        description: p("scrollbar.ignoreHorizontalScrollbarInContentHeight", "When set, the horizontal scrollbar will not increase the size of the editor's content.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e, i = lt.clampedInt(t.horizontalScrollbarSize, this.defaultValue.horizontalScrollbarSize, 0, 1e3), n = lt.clampedInt(t.verticalScrollbarSize, this.defaultValue.verticalScrollbarSize, 0, 1e3);
    return {
      arrowSize: lt.clampedInt(t.arrowSize, this.defaultValue.arrowSize, 0, 1e3),
      vertical: nD(t.vertical, this.defaultValue.vertical),
      horizontal: nD(t.horizontal, this.defaultValue.horizontal),
      useShadows: oe(t.useShadows, this.defaultValue.useShadows),
      verticalHasArrows: oe(t.verticalHasArrows, this.defaultValue.verticalHasArrows),
      horizontalHasArrows: oe(t.horizontalHasArrows, this.defaultValue.horizontalHasArrows),
      handleMouseWheel: oe(t.handleMouseWheel, this.defaultValue.handleMouseWheel),
      alwaysConsumeMouseWheel: oe(t.alwaysConsumeMouseWheel, this.defaultValue.alwaysConsumeMouseWheel),
      horizontalScrollbarSize: i,
      horizontalSliderSize: lt.clampedInt(t.horizontalSliderSize, i, 0, 1e3),
      verticalScrollbarSize: n,
      verticalSliderSize: lt.clampedInt(t.verticalSliderSize, n, 0, 1e3),
      scrollByPage: oe(t.scrollByPage, this.defaultValue.scrollByPage),
      ignoreHorizontalScrollbarInContentHeight: oe(t.ignoreHorizontalScrollbarInContentHeight, this.defaultValue.ignoreHorizontalScrollbarInContentHeight)
    };
  }
};
const zs = "inUntrustedWorkspace", rl = {
  allowedCharacters: "editor.unicodeHighlight.allowedCharacters",
  invisibleCharacters: "editor.unicodeHighlight.invisibleCharacters",
  nonBasicASCII: "editor.unicodeHighlight.nonBasicASCII",
  ambiguousCharacters: "editor.unicodeHighlight.ambiguousCharacters",
  includeComments: "editor.unicodeHighlight.includeComments",
  includeStrings: "editor.unicodeHighlight.includeStrings",
  allowedLocales: "editor.unicodeHighlight.allowedLocales"
};
class VP extends kt {
  constructor() {
    const e = {
      nonBasicASCII: zs,
      invisibleCharacters: !0,
      ambiguousCharacters: !0,
      includeComments: zs,
      includeStrings: !0,
      allowedCharacters: {},
      allowedLocales: { _os: !0, _vscode: !0 }
    };
    super(126, "unicodeHighlight", e, {
      [rl.nonBasicASCII]: {
        restricted: !0,
        type: ["boolean", "string"],
        enum: [!0, !1, zs],
        default: e.nonBasicASCII,
        description: p("unicodeHighlight.nonBasicASCII", "Controls whether all non-basic ASCII characters are highlighted. Only characters between U+0020 and U+007E, tab, line-feed and carriage-return are considered basic ASCII.")
      },
      [rl.invisibleCharacters]: {
        restricted: !0,
        type: "boolean",
        default: e.invisibleCharacters,
        description: p("unicodeHighlight.invisibleCharacters", "Controls whether characters that just reserve space or have no width at all are highlighted.")
      },
      [rl.ambiguousCharacters]: {
        restricted: !0,
        type: "boolean",
        default: e.ambiguousCharacters,
        description: p("unicodeHighlight.ambiguousCharacters", "Controls whether characters are highlighted that can be confused with basic ASCII characters, except those that are common in the current user locale.")
      },
      [rl.includeComments]: {
        restricted: !0,
        type: ["boolean", "string"],
        enum: [!0, !1, zs],
        default: e.includeComments,
        description: p("unicodeHighlight.includeComments", "Controls whether characters in comments should also be subject to Unicode highlighting.")
      },
      [rl.includeStrings]: {
        restricted: !0,
        type: ["boolean", "string"],
        enum: [!0, !1, zs],
        default: e.includeStrings,
        description: p("unicodeHighlight.includeStrings", "Controls whether characters in strings should also be subject to Unicode highlighting.")
      },
      [rl.allowedCharacters]: {
        restricted: !0,
        type: "object",
        default: e.allowedCharacters,
        description: p("unicodeHighlight.allowedCharacters", "Defines allowed characters that are not being highlighted."),
        additionalProperties: {
          type: "boolean"
        }
      },
      [rl.allowedLocales]: {
        restricted: !0,
        type: "object",
        additionalProperties: {
          type: "boolean"
        },
        default: e.allowedLocales,
        description: p("unicodeHighlight.allowedLocales", "Unicode characters that are common in allowed locales are not being highlighted.")
      }
    });
  }
  applyUpdate(e, t) {
    let i = !1;
    t.allowedCharacters && e && (Pn(e.allowedCharacters, t.allowedCharacters) || (e = { ...e, allowedCharacters: t.allowedCharacters }, i = !0)), t.allowedLocales && e && (Pn(e.allowedLocales, t.allowedLocales) || (e = { ...e, allowedLocales: t.allowedLocales }, i = !0));
    const n = super.applyUpdate(e, t);
    return i ? new Ou(n.newValue, !0) : n;
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      nonBasicASCII: zh(t.nonBasicASCII, zs, [!0, !1, zs]),
      invisibleCharacters: oe(t.invisibleCharacters, this.defaultValue.invisibleCharacters),
      ambiguousCharacters: oe(t.ambiguousCharacters, this.defaultValue.ambiguousCharacters),
      includeComments: zh(t.includeComments, zs, [!0, !1, zs]),
      includeStrings: zh(t.includeStrings, zs, [!0, !1, zs]),
      allowedCharacters: this.validateBooleanMap(e.allowedCharacters, this.defaultValue.allowedCharacters),
      allowedLocales: this.validateBooleanMap(e.allowedLocales, this.defaultValue.allowedLocales)
    };
  }
  validateBooleanMap(e, t) {
    if (typeof e != "object" || !e)
      return t;
    const i = {};
    for (const [n, o] of Object.entries(e))
      o === !0 && (i[n] = !0);
    return i;
  }
}
class HP extends kt {
  constructor() {
    const e = {
      enabled: !0,
      mode: "subwordSmart",
      showToolbar: "onHover",
      suppressSuggestions: !1,
      keepOnBlur: !1,
      fontFamily: "default"
    };
    super(62, "inlineSuggest", e, {
      "editor.inlineSuggest.enabled": {
        type: "boolean",
        default: e.enabled,
        description: p("inlineSuggest.enabled", "Controls whether to automatically show inline suggestions in the editor.")
      },
      "editor.inlineSuggest.showToolbar": {
        type: "string",
        default: e.showToolbar,
        enum: ["always", "onHover", "never"],
        enumDescriptions: [
          p("inlineSuggest.showToolbar.always", "Show the inline suggestion toolbar whenever an inline suggestion is shown."),
          p("inlineSuggest.showToolbar.onHover", "Show the inline suggestion toolbar when hovering over an inline suggestion."),
          p("inlineSuggest.showToolbar.never", "Never show the inline suggestion toolbar.")
        ],
        description: p("inlineSuggest.showToolbar", "Controls when to show the inline suggestion toolbar.")
      },
      "editor.inlineSuggest.suppressSuggestions": {
        type: "boolean",
        default: e.suppressSuggestions,
        description: p("inlineSuggest.suppressSuggestions", "Controls how inline suggestions interact with the suggest widget. If enabled, the suggest widget is not shown automatically when inline suggestions are available.")
      },
      "editor.inlineSuggest.fontFamily": {
        type: "string",
        default: e.fontFamily,
        description: p("inlineSuggest.fontFamily", "Controls the font family of the inline suggestions.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: oe(t.enabled, this.defaultValue.enabled),
      mode: Mt(t.mode, this.defaultValue.mode, ["prefix", "subword", "subwordSmart"]),
      showToolbar: Mt(t.showToolbar, this.defaultValue.showToolbar, ["always", "onHover", "never"]),
      suppressSuggestions: oe(t.suppressSuggestions, this.defaultValue.suppressSuggestions),
      keepOnBlur: oe(t.keepOnBlur, this.defaultValue.keepOnBlur),
      fontFamily: qi.string(t.fontFamily, this.defaultValue.fontFamily)
    };
  }
}
class zP extends kt {
  constructor() {
    const e = {
      enabled: !1,
      showToolbar: "onHover",
      fontFamily: "default",
      keepOnBlur: !1
    };
    super(63, "experimentalInlineEdit", e, {
      "editor.experimentalInlineEdit.enabled": {
        type: "boolean",
        default: e.enabled,
        description: p("inlineEdit.enabled", "Controls whether to show inline edits in the editor.")
      },
      "editor.experimentalInlineEdit.showToolbar": {
        type: "string",
        default: e.showToolbar,
        enum: ["always", "onHover", "never"],
        enumDescriptions: [
          p("inlineEdit.showToolbar.always", "Show the inline edit toolbar whenever an inline suggestion is shown."),
          p("inlineEdit.showToolbar.onHover", "Show the inline edit toolbar when hovering over an inline suggestion."),
          p("inlineEdit.showToolbar.never", "Never show the inline edit toolbar.")
        ],
        description: p("inlineEdit.showToolbar", "Controls when to show the inline edit toolbar.")
      },
      "editor.experimentalInlineEdit.fontFamily": {
        type: "string",
        default: e.fontFamily,
        description: p("inlineEdit.fontFamily", "Controls the font family of the inline edit.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: oe(t.enabled, this.defaultValue.enabled),
      showToolbar: Mt(t.showToolbar, this.defaultValue.showToolbar, ["always", "onHover", "never"]),
      fontFamily: qi.string(t.fontFamily, this.defaultValue.fontFamily),
      keepOnBlur: oe(t.keepOnBlur, this.defaultValue.keepOnBlur)
    };
  }
}
class UP extends kt {
  constructor() {
    const e = {
      enabled: Oi.bracketPairColorizationOptions.enabled,
      independentColorPoolPerBracketType: Oi.bracketPairColorizationOptions.independentColorPoolPerBracketType
    };
    super(15, "bracketPairColorization", e, {
      "editor.bracketPairColorization.enabled": {
        type: "boolean",
        default: e.enabled,
        markdownDescription: p("bracketPairColorization.enabled", "Controls whether bracket pair colorization is enabled or not. Use {0} to override the bracket highlight colors.", "`#workbench.colorCustomizations#`")
      },
      "editor.bracketPairColorization.independentColorPoolPerBracketType": {
        type: "boolean",
        default: e.independentColorPoolPerBracketType,
        description: p("bracketPairColorization.independentColorPoolPerBracketType", "Controls whether each bracket type has its own independent color pool.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: oe(t.enabled, this.defaultValue.enabled),
      independentColorPoolPerBracketType: oe(t.independentColorPoolPerBracketType, this.defaultValue.independentColorPoolPerBracketType)
    };
  }
}
class $P extends kt {
  constructor() {
    const e = {
      bracketPairs: !1,
      bracketPairsHorizontal: "active",
      highlightActiveBracketPair: !0,
      indentation: !0,
      highlightActiveIndentation: !0
    };
    super(16, "guides", e, {
      "editor.guides.bracketPairs": {
        type: ["boolean", "string"],
        enum: [!0, "active", !1],
        enumDescriptions: [
          p("editor.guides.bracketPairs.true", "Enables bracket pair guides."),
          p("editor.guides.bracketPairs.active", "Enables bracket pair guides only for the active bracket pair."),
          p("editor.guides.bracketPairs.false", "Disables bracket pair guides.")
        ],
        default: e.bracketPairs,
        description: p("editor.guides.bracketPairs", "Controls whether bracket pair guides are enabled or not.")
      },
      "editor.guides.bracketPairsHorizontal": {
        type: ["boolean", "string"],
        enum: [!0, "active", !1],
        enumDescriptions: [
          p("editor.guides.bracketPairsHorizontal.true", "Enables horizontal guides as addition to vertical bracket pair guides."),
          p("editor.guides.bracketPairsHorizontal.active", "Enables horizontal guides only for the active bracket pair."),
          p("editor.guides.bracketPairsHorizontal.false", "Disables horizontal bracket pair guides.")
        ],
        default: e.bracketPairsHorizontal,
        description: p("editor.guides.bracketPairsHorizontal", "Controls whether horizontal bracket pair guides are enabled or not.")
      },
      "editor.guides.highlightActiveBracketPair": {
        type: "boolean",
        default: e.highlightActiveBracketPair,
        description: p("editor.guides.highlightActiveBracketPair", "Controls whether the editor should highlight the active bracket pair.")
      },
      "editor.guides.indentation": {
        type: "boolean",
        default: e.indentation,
        description: p("editor.guides.indentation", "Controls whether the editor should render indent guides.")
      },
      "editor.guides.highlightActiveIndentation": {
        type: ["boolean", "string"],
        enum: [!0, "always", !1],
        enumDescriptions: [
          p("editor.guides.highlightActiveIndentation.true", "Highlights the active indent guide."),
          p("editor.guides.highlightActiveIndentation.always", "Highlights the active indent guide even if bracket guides are highlighted."),
          p("editor.guides.highlightActiveIndentation.false", "Do not highlight the active indent guide.")
        ],
        default: e.highlightActiveIndentation,
        description: p("editor.guides.highlightActiveIndentation", "Controls whether the editor should highlight the active indent guide.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      bracketPairs: zh(t.bracketPairs, this.defaultValue.bracketPairs, [!0, !1, "active"]),
      bracketPairsHorizontal: zh(t.bracketPairsHorizontal, this.defaultValue.bracketPairsHorizontal, [!0, !1, "active"]),
      highlightActiveBracketPair: oe(t.highlightActiveBracketPair, this.defaultValue.highlightActiveBracketPair),
      indentation: oe(t.indentation, this.defaultValue.indentation),
      highlightActiveIndentation: zh(t.highlightActiveIndentation, this.defaultValue.highlightActiveIndentation, [!0, !1, "always"])
    };
  }
}
function zh(s, e, t) {
  const i = t.indexOf(s);
  return i === -1 ? e : t[i];
}
class KP extends kt {
  constructor() {
    const e = {
      insertMode: "insert",
      filterGraceful: !0,
      snippetsPreventQuickSuggestions: !1,
      localityBonus: !1,
      shareSuggestSelections: !1,
      selectionMode: "always",
      showIcons: !0,
      showStatusBar: !1,
      preview: !1,
      previewMode: "subwordSmart",
      showInlineDetails: !0,
      showMethods: !0,
      showFunctions: !0,
      showConstructors: !0,
      showDeprecated: !0,
      matchOnWordStartOnly: !0,
      showFields: !0,
      showVariables: !0,
      showClasses: !0,
      showStructs: !0,
      showInterfaces: !0,
      showModules: !0,
      showProperties: !0,
      showEvents: !0,
      showOperators: !0,
      showUnits: !0,
      showValues: !0,
      showConstants: !0,
      showEnums: !0,
      showEnumMembers: !0,
      showKeywords: !0,
      showWords: !0,
      showColors: !0,
      showFiles: !0,
      showReferences: !0,
      showFolders: !0,
      showTypeParameters: !0,
      showSnippets: !0,
      showUsers: !0,
      showIssues: !0
    };
    super(119, "suggest", e, {
      "editor.suggest.insertMode": {
        type: "string",
        enum: ["insert", "replace"],
        enumDescriptions: [
          p("suggest.insertMode.insert", "Insert suggestion without overwriting text right of the cursor."),
          p("suggest.insertMode.replace", "Insert suggestion and overwrite text right of the cursor.")
        ],
        default: e.insertMode,
        description: p("suggest.insertMode", "Controls whether words are overwritten when accepting completions. Note that this depends on extensions opting into this feature.")
      },
      "editor.suggest.filterGraceful": {
        type: "boolean",
        default: e.filterGraceful,
        description: p("suggest.filterGraceful", "Controls whether filtering and sorting suggestions accounts for small typos.")
      },
      "editor.suggest.localityBonus": {
        type: "boolean",
        default: e.localityBonus,
        description: p("suggest.localityBonus", "Controls whether sorting favors words that appear close to the cursor.")
      },
      "editor.suggest.shareSuggestSelections": {
        type: "boolean",
        default: e.shareSuggestSelections,
        markdownDescription: p("suggest.shareSuggestSelections", "Controls whether remembered suggestion selections are shared between multiple workspaces and windows (needs `#editor.suggestSelection#`).")
      },
      "editor.suggest.selectionMode": {
        type: "string",
        enum: ["always", "never", "whenTriggerCharacter", "whenQuickSuggestion"],
        enumDescriptions: [
          p("suggest.insertMode.always", "Always select a suggestion when automatically triggering IntelliSense."),
          p("suggest.insertMode.never", "Never select a suggestion when automatically triggering IntelliSense."),
          p("suggest.insertMode.whenTriggerCharacter", "Select a suggestion only when triggering IntelliSense from a trigger character."),
          p("suggest.insertMode.whenQuickSuggestion", "Select a suggestion only when triggering IntelliSense as you type.")
        ],
        default: e.selectionMode,
        markdownDescription: p("suggest.selectionMode", "Controls whether a suggestion is selected when the widget shows. Note that this only applies to automatically triggered suggestions ({0} and {1}) and that a suggestion is always selected when explicitly invoked, e.g via `Ctrl+Space`.", "`#editor.quickSuggestions#`", "`#editor.suggestOnTriggerCharacters#`")
      },
      "editor.suggest.snippetsPreventQuickSuggestions": {
        type: "boolean",
        default: e.snippetsPreventQuickSuggestions,
        description: p("suggest.snippetsPreventQuickSuggestions", "Controls whether an active snippet prevents quick suggestions.")
      },
      "editor.suggest.showIcons": {
        type: "boolean",
        default: e.showIcons,
        description: p("suggest.showIcons", "Controls whether to show or hide icons in suggestions.")
      },
      "editor.suggest.showStatusBar": {
        type: "boolean",
        default: e.showStatusBar,
        description: p("suggest.showStatusBar", "Controls the visibility of the status bar at the bottom of the suggest widget.")
      },
      "editor.suggest.preview": {
        type: "boolean",
        default: e.preview,
        description: p("suggest.preview", "Controls whether to preview the suggestion outcome in the editor.")
      },
      "editor.suggest.showInlineDetails": {
        type: "boolean",
        default: e.showInlineDetails,
        description: p("suggest.showInlineDetails", "Controls whether suggest details show inline with the label or only in the details widget.")
      },
      "editor.suggest.maxVisibleSuggestions": {
        type: "number",
        deprecationMessage: p("suggest.maxVisibleSuggestions.dep", "This setting is deprecated. The suggest widget can now be resized.")
      },
      "editor.suggest.filteredTypes": {
        type: "object",
        deprecationMessage: p("deprecated", "This setting is deprecated, please use separate settings like 'editor.suggest.showKeywords' or 'editor.suggest.showSnippets' instead.")
      },
      "editor.suggest.showMethods": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showMethods", "When enabled IntelliSense shows `method`-suggestions.")
      },
      "editor.suggest.showFunctions": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showFunctions", "When enabled IntelliSense shows `function`-suggestions.")
      },
      "editor.suggest.showConstructors": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showConstructors", "When enabled IntelliSense shows `constructor`-suggestions.")
      },
      "editor.suggest.showDeprecated": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showDeprecated", "When enabled IntelliSense shows `deprecated`-suggestions.")
      },
      "editor.suggest.matchOnWordStartOnly": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.matchOnWordStartOnly", "When enabled IntelliSense filtering requires that the first character matches on a word start. For example, `c` on `Console` or `WebContext` but _not_ on `description`. When disabled IntelliSense will show more results but still sorts them by match quality.")
      },
      "editor.suggest.showFields": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showFields", "When enabled IntelliSense shows `field`-suggestions.")
      },
      "editor.suggest.showVariables": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showVariables", "When enabled IntelliSense shows `variable`-suggestions.")
      },
      "editor.suggest.showClasses": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showClasss", "When enabled IntelliSense shows `class`-suggestions.")
      },
      "editor.suggest.showStructs": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showStructs", "When enabled IntelliSense shows `struct`-suggestions.")
      },
      "editor.suggest.showInterfaces": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showInterfaces", "When enabled IntelliSense shows `interface`-suggestions.")
      },
      "editor.suggest.showModules": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showModules", "When enabled IntelliSense shows `module`-suggestions.")
      },
      "editor.suggest.showProperties": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showPropertys", "When enabled IntelliSense shows `property`-suggestions.")
      },
      "editor.suggest.showEvents": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showEvents", "When enabled IntelliSense shows `event`-suggestions.")
      },
      "editor.suggest.showOperators": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showOperators", "When enabled IntelliSense shows `operator`-suggestions.")
      },
      "editor.suggest.showUnits": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showUnits", "When enabled IntelliSense shows `unit`-suggestions.")
      },
      "editor.suggest.showValues": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showValues", "When enabled IntelliSense shows `value`-suggestions.")
      },
      "editor.suggest.showConstants": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showConstants", "When enabled IntelliSense shows `constant`-suggestions.")
      },
      "editor.suggest.showEnums": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showEnums", "When enabled IntelliSense shows `enum`-suggestions.")
      },
      "editor.suggest.showEnumMembers": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showEnumMembers", "When enabled IntelliSense shows `enumMember`-suggestions.")
      },
      "editor.suggest.showKeywords": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showKeywords", "When enabled IntelliSense shows `keyword`-suggestions.")
      },
      "editor.suggest.showWords": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showTexts", "When enabled IntelliSense shows `text`-suggestions.")
      },
      "editor.suggest.showColors": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showColors", "When enabled IntelliSense shows `color`-suggestions.")
      },
      "editor.suggest.showFiles": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showFiles", "When enabled IntelliSense shows `file`-suggestions.")
      },
      "editor.suggest.showReferences": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showReferences", "When enabled IntelliSense shows `reference`-suggestions.")
      },
      "editor.suggest.showCustomcolors": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showCustomcolors", "When enabled IntelliSense shows `customcolor`-suggestions.")
      },
      "editor.suggest.showFolders": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showFolders", "When enabled IntelliSense shows `folder`-suggestions.")
      },
      "editor.suggest.showTypeParameters": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showTypeParameters", "When enabled IntelliSense shows `typeParameter`-suggestions.")
      },
      "editor.suggest.showSnippets": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showSnippets", "When enabled IntelliSense shows `snippet`-suggestions.")
      },
      "editor.suggest.showUsers": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showUsers", "When enabled IntelliSense shows `user`-suggestions.")
      },
      "editor.suggest.showIssues": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showIssues", "When enabled IntelliSense shows `issues`-suggestions.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      insertMode: Mt(t.insertMode, this.defaultValue.insertMode, ["insert", "replace"]),
      filterGraceful: oe(t.filterGraceful, this.defaultValue.filterGraceful),
      snippetsPreventQuickSuggestions: oe(t.snippetsPreventQuickSuggestions, this.defaultValue.filterGraceful),
      localityBonus: oe(t.localityBonus, this.defaultValue.localityBonus),
      shareSuggestSelections: oe(t.shareSuggestSelections, this.defaultValue.shareSuggestSelections),
      selectionMode: Mt(t.selectionMode, this.defaultValue.selectionMode, ["always", "never", "whenQuickSuggestion", "whenTriggerCharacter"]),
      showIcons: oe(t.showIcons, this.defaultValue.showIcons),
      showStatusBar: oe(t.showStatusBar, this.defaultValue.showStatusBar),
      preview: oe(t.preview, this.defaultValue.preview),
      previewMode: Mt(t.previewMode, this.defaultValue.previewMode, ["prefix", "subword", "subwordSmart"]),
      showInlineDetails: oe(t.showInlineDetails, this.defaultValue.showInlineDetails),
      showMethods: oe(t.showMethods, this.defaultValue.showMethods),
      showFunctions: oe(t.showFunctions, this.defaultValue.showFunctions),
      showConstructors: oe(t.showConstructors, this.defaultValue.showConstructors),
      showDeprecated: oe(t.showDeprecated, this.defaultValue.showDeprecated),
      matchOnWordStartOnly: oe(t.matchOnWordStartOnly, this.defaultValue.matchOnWordStartOnly),
      showFields: oe(t.showFields, this.defaultValue.showFields),
      showVariables: oe(t.showVariables, this.defaultValue.showVariables),
      showClasses: oe(t.showClasses, this.defaultValue.showClasses),
      showStructs: oe(t.showStructs, this.defaultValue.showStructs),
      showInterfaces: oe(t.showInterfaces, this.defaultValue.showInterfaces),
      showModules: oe(t.showModules, this.defaultValue.showModules),
      showProperties: oe(t.showProperties, this.defaultValue.showProperties),
      showEvents: oe(t.showEvents, this.defaultValue.showEvents),
      showOperators: oe(t.showOperators, this.defaultValue.showOperators),
      showUnits: oe(t.showUnits, this.defaultValue.showUnits),
      showValues: oe(t.showValues, this.defaultValue.showValues),
      showConstants: oe(t.showConstants, this.defaultValue.showConstants),
      showEnums: oe(t.showEnums, this.defaultValue.showEnums),
      showEnumMembers: oe(t.showEnumMembers, this.defaultValue.showEnumMembers),
      showKeywords: oe(t.showKeywords, this.defaultValue.showKeywords),
      showWords: oe(t.showWords, this.defaultValue.showWords),
      showColors: oe(t.showColors, this.defaultValue.showColors),
      showFiles: oe(t.showFiles, this.defaultValue.showFiles),
      showReferences: oe(t.showReferences, this.defaultValue.showReferences),
      showFolders: oe(t.showFolders, this.defaultValue.showFolders),
      showTypeParameters: oe(t.showTypeParameters, this.defaultValue.showTypeParameters),
      showSnippets: oe(t.showSnippets, this.defaultValue.showSnippets),
      showUsers: oe(t.showUsers, this.defaultValue.showUsers),
      showIssues: oe(t.showIssues, this.defaultValue.showIssues)
    };
  }
}
class qP extends kt {
  constructor() {
    super(114, "smartSelect", {
      selectLeadingAndTrailingWhitespace: !0,
      selectSubwords: !0
    }, {
      "editor.smartSelect.selectLeadingAndTrailingWhitespace": {
        description: p("selectLeadingAndTrailingWhitespace", "Whether leading and trailing whitespace should always be selected."),
        default: !0,
        type: "boolean"
      },
      "editor.smartSelect.selectSubwords": {
        description: p("selectSubwords", "Whether subwords (like 'foo' in 'fooBar' or 'foo_bar') should be selected."),
        default: !0,
        type: "boolean"
      }
    });
  }
  validate(e) {
    return !e || typeof e != "object" ? this.defaultValue : {
      selectLeadingAndTrailingWhitespace: oe(e.selectLeadingAndTrailingWhitespace, this.defaultValue.selectLeadingAndTrailingWhitespace),
      selectSubwords: oe(e.selectSubwords, this.defaultValue.selectSubwords)
    };
  }
}
class jP extends kt {
  constructor() {
    const e = [];
    super(131, "wordSegmenterLocales", e, {
      anyOf: [
        {
          description: p("wordSegmenterLocales", "Locales to be used for word segmentation when doing word related navigations or operations. Specify the BCP 47 language tag of the word you wish to recognize (e.g., ja, zh-CN, zh-Hant-TW, etc.)."),
          type: "string"
        },
        {
          description: p("wordSegmenterLocales", "Locales to be used for word segmentation when doing word related navigations or operations. Specify the BCP 47 language tag of the word you wish to recognize (e.g., ja, zh-CN, zh-Hant-TW, etc.)."),
          type: "array",
          items: {
            type: "string"
          }
        }
      ]
    });
  }
  validate(e) {
    if (typeof e == "string" && (e = [e]), Array.isArray(e)) {
      const t = [];
      for (const i of e)
        if (typeof i == "string")
          try {
            Intl.Segmenter.supportedLocalesOf(i).length > 0 && t.push(i);
          } catch {
          }
      return t;
    }
    return this.defaultValue;
  }
}
class GP extends kt {
  constructor() {
    super(139, "wrappingIndent", 1, {
      "editor.wrappingIndent": {
        type: "string",
        enum: ["none", "same", "indent", "deepIndent"],
        enumDescriptions: [
          p("wrappingIndent.none", "No indentation. Wrapped lines begin at column 1."),
          p("wrappingIndent.same", "Wrapped lines get the same indentation as the parent."),
          p("wrappingIndent.indent", "Wrapped lines get +1 indentation toward the parent."),
          p("wrappingIndent.deepIndent", "Wrapped lines get +2 indentation toward the parent.")
        ],
        description: p("wrappingIndent", "Controls the indentation of wrapped lines."),
        default: "same"
      }
    });
  }
  validate(e) {
    switch (e) {
      case "none":
        return 0;
      case "same":
        return 1;
      case "indent":
        return 2;
      case "deepIndent":
        return 3;
    }
    return 1;
  }
  compute(e, t, i) {
    return t.get(
      2
      /* EditorOption.accessibilitySupport */
    ) === 2 ? 0 : i;
  }
}
class ZP extends Cg {
  constructor() {
    super(
      147
      /* EditorOption.wrappingInfo */
    );
  }
  compute(e, t, i) {
    const n = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    return {
      isDominatedByLongLines: e.isDominatedByLongLines,
      isWordWrapMinified: n.isWordWrapMinified,
      isViewportWrapping: n.isViewportWrapping,
      wrappingColumn: n.wrappingColumn
    };
  }
}
class YP extends kt {
  constructor() {
    const e = { enabled: !0, showDropSelector: "afterDrop" };
    super(36, "dropIntoEditor", e, {
      "editor.dropIntoEditor.enabled": {
        type: "boolean",
        default: e.enabled,
        markdownDescription: p("dropIntoEditor.enabled", "Controls whether you can drag and drop a file into a text editor by holding down the `Shift` key (instead of opening the file in an editor).")
      },
      "editor.dropIntoEditor.showDropSelector": {
        type: "string",
        markdownDescription: p("dropIntoEditor.showDropSelector", "Controls if a widget is shown when dropping files into the editor. This widget lets you control how the file is dropped."),
        enum: [
          "afterDrop",
          "never"
        ],
        enumDescriptions: [
          p("dropIntoEditor.showDropSelector.afterDrop", "Show the drop selector widget after a file is dropped into the editor."),
          p("dropIntoEditor.showDropSelector.never", "Never show the drop selector widget. Instead the default drop provider is always used.")
        ],
        default: "afterDrop"
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: oe(t.enabled, this.defaultValue.enabled),
      showDropSelector: Mt(t.showDropSelector, this.defaultValue.showDropSelector, ["afterDrop", "never"])
    };
  }
}
class QP extends kt {
  constructor() {
    const e = { enabled: !0, showPasteSelector: "afterPaste" };
    super(85, "pasteAs", e, {
      "editor.pasteAs.enabled": {
        type: "boolean",
        default: e.enabled,
        markdownDescription: p("pasteAs.enabled", "Controls whether you can paste content in different ways.")
      },
      "editor.pasteAs.showPasteSelector": {
        type: "string",
        markdownDescription: p("pasteAs.showPasteSelector", "Controls if a widget is shown when pasting content in to the editor. This widget lets you control how the file is pasted."),
        enum: [
          "afterPaste",
          "never"
        ],
        enumDescriptions: [
          p("pasteAs.showPasteSelector.afterPaste", "Show the paste selector widget after content is pasted into the editor."),
          p("pasteAs.showPasteSelector.never", "Never show the paste selector widget. Instead the default pasting behavior is always used.")
        ],
        default: "afterPaste"
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: oe(t.enabled, this.defaultValue.enabled),
      showPasteSelector: Mt(t.showPasteSelector, this.defaultValue.showPasteSelector, ["afterPaste", "never"])
    };
  }
}
const XP = "Consolas, 'Courier New', monospace", JP = "Menlo, Monaco, 'Courier New', monospace", eO = "'Droid Sans Mono', 'monospace', monospace", es = {
  fontFamily: He ? JP : wn ? eO : XP,
  fontWeight: "normal",
  fontSize: He ? 12 : 14,
  lineHeight: 0,
  letterSpacing: 0
}, ch = [];
function G(s) {
  return ch[s.id] = s, s;
}
const xc = {
  acceptSuggestionOnCommitCharacter: G(new Fe(0, "acceptSuggestionOnCommitCharacter", !0, { markdownDescription: p("acceptSuggestionOnCommitCharacter", "Controls whether suggestions should be accepted on commit characters. For example, in JavaScript, the semi-colon (`;`) can be a commit character that accepts a suggestion and types that character.") })),
  acceptSuggestionOnEnter: G(new Tt(1, "acceptSuggestionOnEnter", "on", ["on", "smart", "off"], {
    markdownEnumDescriptions: [
      "",
      p("acceptSuggestionOnEnterSmart", "Only accept a suggestion with `Enter` when it makes a textual change."),
      ""
    ],
    markdownDescription: p("acceptSuggestionOnEnter", "Controls whether suggestions should be accepted on `Enter`, in addition to `Tab`. Helps to avoid ambiguity between inserting new lines or accepting suggestions.")
  })),
  accessibilitySupport: G(new uP()),
  accessibilityPageSize: G(new lt(3, "accessibilityPageSize", 10, 1, 1073741824, {
    description: p("accessibilityPageSize", "Controls the number of lines in the editor that can be read out by a screen reader at once. When we detect a screen reader we automatically set the default to be 500. Warning: this has a performance implication for numbers larger than the default."),
    tags: ["accessibility"]
  })),
  ariaLabel: G(new qi(4, "ariaLabel", p("editorViewAccessibleLabel", "Editor content"))),
  ariaRequired: G(new Fe(5, "ariaRequired", !1, void 0)),
  screenReaderAnnounceInlineSuggestion: G(new Fe(8, "screenReaderAnnounceInlineSuggestion", !0, {
    description: p("screenReaderAnnounceInlineSuggestion", "Control whether inline suggestions are announced by a screen reader."),
    tags: ["accessibility"]
  })),
  autoClosingBrackets: G(new Tt(6, "autoClosingBrackets", "languageDefined", ["always", "languageDefined", "beforeWhitespace", "never"], {
    enumDescriptions: [
      "",
      p("editor.autoClosingBrackets.languageDefined", "Use language configurations to determine when to autoclose brackets."),
      p("editor.autoClosingBrackets.beforeWhitespace", "Autoclose brackets only when the cursor is to the left of whitespace."),
      ""
    ],
    description: p("autoClosingBrackets", "Controls whether the editor should automatically close brackets after the user adds an opening bracket.")
  })),
  autoClosingComments: G(new Tt(7, "autoClosingComments", "languageDefined", ["always", "languageDefined", "beforeWhitespace", "never"], {
    enumDescriptions: [
      "",
      p("editor.autoClosingComments.languageDefined", "Use language configurations to determine when to autoclose comments."),
      p("editor.autoClosingComments.beforeWhitespace", "Autoclose comments only when the cursor is to the left of whitespace."),
      ""
    ],
    description: p("autoClosingComments", "Controls whether the editor should automatically close comments after the user adds an opening comment.")
  })),
  autoClosingDelete: G(new Tt(9, "autoClosingDelete", "auto", ["always", "auto", "never"], {
    enumDescriptions: [
      "",
      p("editor.autoClosingDelete.auto", "Remove adjacent closing quotes or brackets only if they were automatically inserted."),
      ""
    ],
    description: p("autoClosingDelete", "Controls whether the editor should remove adjacent closing quotes or brackets when deleting.")
  })),
  autoClosingOvertype: G(new Tt(10, "autoClosingOvertype", "auto", ["always", "auto", "never"], {
    enumDescriptions: [
      "",
      p("editor.autoClosingOvertype.auto", "Type over closing quotes or brackets only if they were automatically inserted."),
      ""
    ],
    description: p("autoClosingOvertype", "Controls whether the editor should type over closing quotes or brackets.")
  })),
  autoClosingQuotes: G(new Tt(11, "autoClosingQuotes", "languageDefined", ["always", "languageDefined", "beforeWhitespace", "never"], {
    enumDescriptions: [
      "",
      p("editor.autoClosingQuotes.languageDefined", "Use language configurations to determine when to autoclose quotes."),
      p("editor.autoClosingQuotes.beforeWhitespace", "Autoclose quotes only when the cursor is to the left of whitespace."),
      ""
    ],
    description: p("autoClosingQuotes", "Controls whether the editor should automatically close quotes after the user adds an opening quote.")
  })),
  autoIndent: G(new Xg(12, "autoIndent", 4, "full", ["none", "keep", "brackets", "advanced", "full"], dP, {
    enumDescriptions: [
      p("editor.autoIndent.none", "The editor will not insert indentation automatically."),
      p("editor.autoIndent.keep", "The editor will keep the current line's indentation."),
      p("editor.autoIndent.brackets", "The editor will keep the current line's indentation and honor language defined brackets."),
      p("editor.autoIndent.advanced", "The editor will keep the current line's indentation, honor language defined brackets and invoke special onEnterRules defined by languages."),
      p("editor.autoIndent.full", "The editor will keep the current line's indentation, honor language defined brackets, invoke special onEnterRules defined by languages, and honor indentationRules defined by languages.")
    ],
    description: p("autoIndent", "Controls whether the editor should automatically adjust the indentation when users type, paste, move or indent lines.")
  })),
  automaticLayout: G(new Fe(13, "automaticLayout", !1)),
  autoSurround: G(new Tt(14, "autoSurround", "languageDefined", ["languageDefined", "quotes", "brackets", "never"], {
    enumDescriptions: [
      p("editor.autoSurround.languageDefined", "Use language configurations to determine when to automatically surround selections."),
      p("editor.autoSurround.quotes", "Surround with quotes but not brackets."),
      p("editor.autoSurround.brackets", "Surround with brackets but not quotes."),
      ""
    ],
    description: p("autoSurround", "Controls whether the editor should automatically surround selections when typing quotes or brackets.")
  })),
  bracketPairColorization: G(new UP()),
  bracketPairGuides: G(new $P()),
  stickyTabStops: G(new Fe(117, "stickyTabStops", !1, { description: p("stickyTabStops", "Emulate selection behavior of tab characters when using spaces for indentation. Selection will stick to tab stops.") })),
  codeLens: G(new Fe(17, "codeLens", !0, { description: p("codeLens", "Controls whether the editor shows CodeLens.") })),
  codeLensFontFamily: G(new qi(18, "codeLensFontFamily", "", { description: p("codeLensFontFamily", "Controls the font family for CodeLens.") })),
  codeLensFontSize: G(new lt(19, "codeLensFontSize", 0, 0, 100, {
    type: "number",
    default: 0,
    minimum: 0,
    maximum: 100,
    markdownDescription: p("codeLensFontSize", "Controls the font size in pixels for CodeLens. When set to 0, 90% of `#editor.fontSize#` is used.")
  })),
  colorDecorators: G(new Fe(20, "colorDecorators", !0, { description: p("colorDecorators", "Controls whether the editor should render the inline color decorators and color picker.") })),
  colorDecoratorActivatedOn: G(new Tt(149, "colorDecoratorsActivatedOn", "clickAndHover", ["clickAndHover", "hover", "click"], {
    enumDescriptions: [
      p("editor.colorDecoratorActivatedOn.clickAndHover", "Make the color picker appear both on click and hover of the color decorator"),
      p("editor.colorDecoratorActivatedOn.hover", "Make the color picker appear on hover of the color decorator"),
      p("editor.colorDecoratorActivatedOn.click", "Make the color picker appear on click of the color decorator")
    ],
    description: p("colorDecoratorActivatedOn", "Controls the condition to make a color picker appear from a color decorator")
  })),
  colorDecoratorsLimit: G(new lt(21, "colorDecoratorsLimit", 500, 1, 1e6, {
    markdownDescription: p("colorDecoratorsLimit", "Controls the max number of color decorators that can be rendered in an editor at once.")
  })),
  columnSelection: G(new Fe(22, "columnSelection", !1, { description: p("columnSelection", "Enable that the selection with the mouse and keys is doing column selection.") })),
  comments: G(new fP()),
  contextmenu: G(new Fe(24, "contextmenu", !0)),
  copyWithSyntaxHighlighting: G(new Fe(25, "copyWithSyntaxHighlighting", !0, { description: p("copyWithSyntaxHighlighting", "Controls whether syntax highlighting should be copied into the clipboard.") })),
  cursorBlinking: G(new Xg(26, "cursorBlinking", 1, "blink", ["blink", "smooth", "phase", "expand", "solid"], gP, { description: p("cursorBlinking", "Control the cursor animation style.") })),
  cursorSmoothCaretAnimation: G(new Tt(27, "cursorSmoothCaretAnimation", "off", ["off", "explicit", "on"], {
    enumDescriptions: [
      p("cursorSmoothCaretAnimation.off", "Smooth caret animation is disabled."),
      p("cursorSmoothCaretAnimation.explicit", "Smooth caret animation is enabled only when the user moves the cursor with an explicit gesture."),
      p("cursorSmoothCaretAnimation.on", "Smooth caret animation is always enabled.")
    ],
    description: p("cursorSmoothCaretAnimation", "Controls whether the smooth caret animation should be enabled.")
  })),
  cursorStyle: G(new Xg(28, "cursorStyle", wi.Line, "line", ["line", "block", "underline", "line-thin", "block-outline", "underline-thin"], mP, { description: p("cursorStyle", "Controls the cursor style.") })),
  cursorSurroundingLines: G(new lt(29, "cursorSurroundingLines", 0, 0, 1073741824, { description: p("cursorSurroundingLines", "Controls the minimal number of visible leading lines (minimum 0) and trailing lines (minimum 1) surrounding the cursor. Known as 'scrollOff' or 'scrollOffset' in some other editors.") })),
  cursorSurroundingLinesStyle: G(new Tt(30, "cursorSurroundingLinesStyle", "default", ["default", "all"], {
    enumDescriptions: [
      p("cursorSurroundingLinesStyle.default", "`cursorSurroundingLines` is enforced only when triggered via the keyboard or API."),
      p("cursorSurroundingLinesStyle.all", "`cursorSurroundingLines` is enforced always.")
    ],
    markdownDescription: p("cursorSurroundingLinesStyle", "Controls when `#editor.cursorSurroundingLines#` should be enforced.")
  })),
  cursorWidth: G(new lt(31, "cursorWidth", 0, 0, 1073741824, { markdownDescription: p("cursorWidth", "Controls the width of the cursor when `#editor.cursorStyle#` is set to `line`.") })),
  disableLayerHinting: G(new Fe(32, "disableLayerHinting", !1)),
  disableMonospaceOptimizations: G(new Fe(33, "disableMonospaceOptimizations", !1)),
  domReadOnly: G(new Fe(34, "domReadOnly", !1)),
  dragAndDrop: G(new Fe(35, "dragAndDrop", !0, { description: p("dragAndDrop", "Controls whether the editor should allow moving selections via drag and drop.") })),
  emptySelectionClipboard: G(new _P()),
  dropIntoEditor: G(new YP()),
  stickyScroll: G(new kP()),
  experimentalWhitespaceRendering: G(new Tt(38, "experimentalWhitespaceRendering", "svg", ["svg", "font", "off"], {
    enumDescriptions: [
      p("experimentalWhitespaceRendering.svg", "Use a new rendering method with svgs."),
      p("experimentalWhitespaceRendering.font", "Use a new rendering method with font characters."),
      p("experimentalWhitespaceRendering.off", "Use the stable rendering method.")
    ],
    description: p("experimentalWhitespaceRendering", "Controls whether whitespace is rendered with a new, experimental method.")
  })),
  extraEditorClassName: G(new qi(39, "extraEditorClassName", "")),
  fastScrollSensitivity: G(new Qn(40, "fastScrollSensitivity", 5, (s) => s <= 0 ? 5 : s, { markdownDescription: p("fastScrollSensitivity", "Scrolling speed multiplier when pressing `Alt`.") })),
  find: G(new bP()),
  fixedOverflowWidgets: G(new Fe(42, "fixedOverflowWidgets", !1)),
  folding: G(new Fe(43, "folding", !0, { description: p("folding", "Controls whether the editor has code folding enabled.") })),
  foldingStrategy: G(new Tt(44, "foldingStrategy", "auto", ["auto", "indentation"], {
    enumDescriptions: [
      p("foldingStrategy.auto", "Use a language-specific folding strategy if available, else the indentation-based one."),
      p("foldingStrategy.indentation", "Use the indentation-based folding strategy.")
    ],
    description: p("foldingStrategy", "Controls the strategy for computing folding ranges.")
  })),
  foldingHighlight: G(new Fe(45, "foldingHighlight", !0, { description: p("foldingHighlight", "Controls whether the editor should highlight folded ranges.") })),
  foldingImportsByDefault: G(new Fe(46, "foldingImportsByDefault", !1, { description: p("foldingImportsByDefault", "Controls whether the editor automatically collapses import ranges.") })),
  foldingMaximumRegions: G(new lt(
    47,
    "foldingMaximumRegions",
    5e3,
    10,
    65e3,
    // limit must be less than foldingRanges MAX_FOLDING_REGIONS
    { description: p("foldingMaximumRegions", "The maximum number of foldable regions. Increasing this value may result in the editor becoming less responsive when the current source has a large number of foldable regions.") }
  )),
  unfoldOnClickAfterEndOfLine: G(new Fe(48, "unfoldOnClickAfterEndOfLine", !1, { description: p("unfoldOnClickAfterEndOfLine", "Controls whether clicking on the empty content after a folded line will unfold the line.") })),
  fontFamily: G(new qi(49, "fontFamily", es.fontFamily, { description: p("fontFamily", "Controls the font family.") })),
  fontInfo: G(new CP()),
  fontLigatures2: G(new gc()),
  fontSize: G(new wP()),
  fontWeight: G(new TC()),
  fontVariations: G(new Tf()),
  formatOnPaste: G(new Fe(55, "formatOnPaste", !1, { description: p("formatOnPaste", "Controls whether the editor should automatically format the pasted content. A formatter must be available and the formatter should be able to format a range in a document.") })),
  formatOnType: G(new Fe(56, "formatOnType", !1, { description: p("formatOnType", "Controls whether the editor should automatically format the line after typing.") })),
  glyphMargin: G(new Fe(57, "glyphMargin", !0, { description: p("glyphMargin", "Controls whether the editor should render the vertical glyph margin. Glyph margin is mostly used for debugging.") })),
  gotoLocation: G(new vP()),
  hideCursorInOverviewRuler: G(new Fe(59, "hideCursorInOverviewRuler", !1, { description: p("hideCursorInOverviewRuler", "Controls whether the cursor should be hidden in the overview ruler.") })),
  hover: G(new yP()),
  inDiffEditor: G(new Fe(61, "inDiffEditor", !1)),
  letterSpacing: G(new Qn(64, "letterSpacing", es.letterSpacing, (s) => Qn.clamp(s, -5, 20), { description: p("letterSpacing", "Controls the letter spacing in pixels.") })),
  lightbulb: G(new LP()),
  lineDecorationsWidth: G(new DP()),
  lineHeight: G(new EP()),
  lineNumbers: G(new OP()),
  lineNumbersMinChars: G(new lt(69, "lineNumbersMinChars", 5, 1, 300)),
  linkedEditing: G(new Fe(70, "linkedEditing", !1, { description: p("linkedEditing", "Controls whether the editor has linked editing enabled. Depending on the language, related symbols such as HTML tags, are updated while editing.") })),
  links: G(new Fe(71, "links", !0, { description: p("links", "Controls whether the editor should detect links and make them clickable.") })),
  matchBrackets: G(new Tt(72, "matchBrackets", "always", ["always", "near", "never"], { description: p("matchBrackets", "Highlight matching brackets.") })),
  minimap: G(new IP()),
  mouseStyle: G(new Tt(74, "mouseStyle", "text", ["text", "default", "copy"])),
  mouseWheelScrollSensitivity: G(new Qn(75, "mouseWheelScrollSensitivity", 1, (s) => s === 0 ? 1 : s, { markdownDescription: p("mouseWheelScrollSensitivity", "A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.") })),
  mouseWheelZoom: G(new Fe(76, "mouseWheelZoom", !1, {
    markdownDescription: He ? p("mouseWheelZoom.mac", "Zoom the font of the editor when using mouse wheel and holding `Cmd`.") : p("mouseWheelZoom", "Zoom the font of the editor when using mouse wheel and holding `Ctrl`.")
  })),
  multiCursorMergeOverlapping: G(new Fe(77, "multiCursorMergeOverlapping", !0, { description: p("multiCursorMergeOverlapping", "Merge multiple cursors when they are overlapping.") })),
  multiCursorModifier: G(new Xg(78, "multiCursorModifier", "altKey", "alt", ["ctrlCmd", "alt"], NP, {
    markdownEnumDescriptions: [
      p("multiCursorModifier.ctrlCmd", "Maps to `Control` on Windows and Linux and to `Command` on macOS."),
      p("multiCursorModifier.alt", "Maps to `Alt` on Windows and Linux and to `Option` on macOS.")
    ],
    markdownDescription: p({
      key: "multiCursorModifier",
      comment: [
        "- `ctrlCmd` refers to a value the setting can take and should not be localized.",
        "- `Control` and `Command` refer to the modifier keys Ctrl or Cmd on the keyboard and can be localized."
      ]
    }, "The modifier to be used to add multiple cursors with the mouse. The Go to Definition and Open Link mouse gestures will adapt such that they do not conflict with the [multicursor modifier](https://code.visualstudio.com/docs/editor/codebasics#_multicursor-modifier).")
  })),
  multiCursorPaste: G(new Tt(79, "multiCursorPaste", "spread", ["spread", "full"], {
    markdownEnumDescriptions: [
      p("multiCursorPaste.spread", "Each cursor pastes a single line of the text."),
      p("multiCursorPaste.full", "Each cursor pastes the full text.")
    ],
    markdownDescription: p("multiCursorPaste", "Controls pasting when the line count of the pasted text matches the cursor count.")
  })),
  multiCursorLimit: G(new lt(80, "multiCursorLimit", 1e4, 1, 1e5, {
    markdownDescription: p("multiCursorLimit", "Controls the max number of cursors that can be in an active editor at once.")
  })),
  occurrencesHighlight: G(new Tt(81, "occurrencesHighlight", "singleFile", ["off", "singleFile", "multiFile"], {
    markdownEnumDescriptions: [
      p("occurrencesHighlight.off", "Does not highlight occurrences."),
      p("occurrencesHighlight.singleFile", "Highlights occurrences only in the current file."),
      p("occurrencesHighlight.multiFile", "Experimental: Highlights occurrences across all valid open files.")
    ],
    markdownDescription: p("occurrencesHighlight", "Controls whether occurrences should be highlighted across open files.")
  })),
  overviewRulerBorder: G(new Fe(82, "overviewRulerBorder", !0, { description: p("overviewRulerBorder", "Controls whether a border should be drawn around the overview ruler.") })),
  overviewRulerLanes: G(new lt(83, "overviewRulerLanes", 3, 0, 3)),
  padding: G(new TP()),
  pasteAs: G(new QP()),
  parameterHints: G(new MP()),
  peekWidgetDefaultFocus: G(new Tt(87, "peekWidgetDefaultFocus", "tree", ["tree", "editor"], {
    enumDescriptions: [
      p("peekWidgetDefaultFocus.tree", "Focus the tree when opening peek"),
      p("peekWidgetDefaultFocus.editor", "Focus the editor when opening peek")
    ],
    description: p("peekWidgetDefaultFocus", "Controls whether to focus the inline editor or the tree in the peek widget.")
  })),
  placeholder: G(new AP()),
  definitionLinkOpensInPeek: G(new Fe(89, "definitionLinkOpensInPeek", !1, { description: p("definitionLinkOpensInPeek", "Controls whether the Go to Definition mouse gesture always opens the peek widget.") })),
  quickSuggestions: G(new PP()),
  quickSuggestionsDelay: G(new lt(91, "quickSuggestionsDelay", 10, 0, 1073741824, { description: p("quickSuggestionsDelay", "Controls the delay in milliseconds after which quick suggestions will show up.") })),
  readOnly: G(new Fe(92, "readOnly", !1)),
  readOnlyMessage: G(new BP()),
  renameOnType: G(new Fe(94, "renameOnType", !1, { description: p("renameOnType", "Controls whether the editor auto renames on type."), markdownDeprecationMessage: p("renameOnTypeDeprecate", "Deprecated, use `editor.linkedEditing` instead.") })),
  renderControlCharacters: G(new Fe(95, "renderControlCharacters", !0, { description: p("renderControlCharacters", "Controls whether the editor should render control characters."), restricted: !0 })),
  renderFinalNewline: G(new Tt(96, "renderFinalNewline", wn ? "dimmed" : "on", ["off", "on", "dimmed"], { description: p("renderFinalNewline", "Render last line number when the file ends with a newline.") })),
  renderLineHighlight: G(new Tt(97, "renderLineHighlight", "line", ["none", "gutter", "line", "all"], {
    enumDescriptions: [
      "",
      "",
      "",
      p("renderLineHighlight.all", "Highlights both the gutter and the current line.")
    ],
    description: p("renderLineHighlight", "Controls how the editor should render the current line highlight.")
  })),
  renderLineHighlightOnlyWhenFocus: G(new Fe(98, "renderLineHighlightOnlyWhenFocus", !1, { description: p("renderLineHighlightOnlyWhenFocus", "Controls if the editor should render the current line highlight only when the editor is focused.") })),
  renderValidationDecorations: G(new Tt(99, "renderValidationDecorations", "editable", ["editable", "on", "off"])),
  renderWhitespace: G(new Tt(100, "renderWhitespace", "selection", ["none", "boundary", "selection", "trailing", "all"], {
    enumDescriptions: [
      "",
      p("renderWhitespace.boundary", "Render whitespace characters except for single spaces between words."),
      p("renderWhitespace.selection", "Render whitespace characters only on selected text."),
      p("renderWhitespace.trailing", "Render only trailing whitespace characters."),
      ""
    ],
    description: p("renderWhitespace", "Controls how the editor should render whitespace characters.")
  })),
  revealHorizontalRightPadding: G(new lt(101, "revealHorizontalRightPadding", 15, 0, 1e3)),
  roundedSelection: G(new Fe(102, "roundedSelection", !0, { description: p("roundedSelection", "Controls whether selections should have rounded corners.") })),
  rulers: G(new FP()),
  scrollbar: G(new WP()),
  scrollBeyondLastColumn: G(new lt(105, "scrollBeyondLastColumn", 4, 0, 1073741824, { description: p("scrollBeyondLastColumn", "Controls the number of extra characters beyond which the editor will scroll horizontally.") })),
  scrollBeyondLastLine: G(new Fe(106, "scrollBeyondLastLine", !0, { description: p("scrollBeyondLastLine", "Controls whether the editor will scroll beyond the last line.") })),
  scrollPredominantAxis: G(new Fe(107, "scrollPredominantAxis", !0, { description: p("scrollPredominantAxis", "Scroll only along the predominant axis when scrolling both vertically and horizontally at the same time. Prevents horizontal drift when scrolling vertically on a trackpad.") })),
  selectionClipboard: G(new Fe(108, "selectionClipboard", !0, {
    description: p("selectionClipboard", "Controls whether the Linux primary clipboard should be supported."),
    included: wn
  })),
  selectionHighlight: G(new Fe(109, "selectionHighlight", !0, { description: p("selectionHighlight", "Controls whether the editor should highlight matches similar to the selection.") })),
  selectOnLineNumbers: G(new Fe(110, "selectOnLineNumbers", !0)),
  showFoldingControls: G(new Tt(111, "showFoldingControls", "mouseover", ["always", "never", "mouseover"], {
    enumDescriptions: [
      p("showFoldingControls.always", "Always show the folding controls."),
      p("showFoldingControls.never", "Never show the folding controls and reduce the gutter size."),
      p("showFoldingControls.mouseover", "Only show the folding controls when the mouse is over the gutter.")
    ],
    description: p("showFoldingControls", "Controls when the folding controls on the gutter are shown.")
  })),
  showUnused: G(new Fe(112, "showUnused", !0, { description: p("showUnused", "Controls fading out of unused code.") })),
  showDeprecated: G(new Fe(141, "showDeprecated", !0, { description: p("showDeprecated", "Controls strikethrough deprecated variables.") })),
  inlayHints: G(new xP()),
  snippetSuggestions: G(new Tt(113, "snippetSuggestions", "inline", ["top", "bottom", "inline", "none"], {
    enumDescriptions: [
      p("snippetSuggestions.top", "Show snippet suggestions on top of other suggestions."),
      p("snippetSuggestions.bottom", "Show snippet suggestions below other suggestions."),
      p("snippetSuggestions.inline", "Show snippets suggestions with other suggestions."),
      p("snippetSuggestions.none", "Do not show snippet suggestions.")
    ],
    description: p("snippetSuggestions", "Controls whether snippets are shown with other suggestions and how they are sorted.")
  })),
  smartSelect: G(new qP()),
  smoothScrolling: G(new Fe(115, "smoothScrolling", !1, { description: p("smoothScrolling", "Controls whether the editor will scroll using an animation.") })),
  stopRenderingLineAfter: G(new lt(
    118,
    "stopRenderingLineAfter",
    1e4,
    -1,
    1073741824
    /* Constants.MAX_SAFE_SMALL_INTEGER */
  )),
  suggest: G(new KP()),
  inlineSuggest: G(new HP()),
  inlineEdit: G(new zP()),
  inlineCompletionsAccessibilityVerbose: G(new Fe(150, "inlineCompletionsAccessibilityVerbose", !1, { description: p("inlineCompletionsAccessibilityVerbose", "Controls whether the accessibility hint should be provided to screen reader users when an inline completion is shown.") })),
  suggestFontSize: G(new lt(120, "suggestFontSize", 0, 0, 1e3, { markdownDescription: p("suggestFontSize", "Font size for the suggest widget. When set to {0}, the value of {1} is used.", "`0`", "`#editor.fontSize#`") })),
  suggestLineHeight: G(new lt(121, "suggestLineHeight", 0, 0, 1e3, { markdownDescription: p("suggestLineHeight", "Line height for the suggest widget. When set to {0}, the value of {1} is used. The minimum value is 8.", "`0`", "`#editor.lineHeight#`") })),
  suggestOnTriggerCharacters: G(new Fe(122, "suggestOnTriggerCharacters", !0, { description: p("suggestOnTriggerCharacters", "Controls whether suggestions should automatically show up when typing trigger characters.") })),
  suggestSelection: G(new Tt(123, "suggestSelection", "first", ["first", "recentlyUsed", "recentlyUsedByPrefix"], {
    markdownEnumDescriptions: [
      p("suggestSelection.first", "Always select the first suggestion."),
      p("suggestSelection.recentlyUsed", "Select recent suggestions unless further typing selects one, e.g. `console.| -> console.log` because `log` has been completed recently."),
      p("suggestSelection.recentlyUsedByPrefix", "Select suggestions based on previous prefixes that have completed those suggestions, e.g. `co -> console` and `con -> const`.")
    ],
    description: p("suggestSelection", "Controls how suggestions are pre-selected when showing the suggest list.")
  })),
  tabCompletion: G(new Tt(124, "tabCompletion", "off", ["on", "off", "onlySnippets"], {
    enumDescriptions: [
      p("tabCompletion.on", "Tab complete will insert the best matching suggestion when pressing tab."),
      p("tabCompletion.off", "Disable tab completions."),
      p("tabCompletion.onlySnippets", "Tab complete snippets when their prefix match. Works best when 'quickSuggestions' aren't enabled.")
    ],
    description: p("tabCompletion", "Enables tab completions.")
  })),
  tabIndex: G(new lt(
    125,
    "tabIndex",
    0,
    -1,
    1073741824
    /* Constants.MAX_SAFE_SMALL_INTEGER */
  )),
  unicodeHighlight: G(new VP()),
  unusualLineTerminators: G(new Tt(127, "unusualLineTerminators", "prompt", ["auto", "off", "prompt"], {
    enumDescriptions: [
      p("unusualLineTerminators.auto", "Unusual line terminators are automatically removed."),
      p("unusualLineTerminators.off", "Unusual line terminators are ignored."),
      p("unusualLineTerminators.prompt", "Unusual line terminators prompt to be removed.")
    ],
    description: p("unusualLineTerminators", "Remove unusual line terminators that might cause problems.")
  })),
  useShadowDOM: G(new Fe(128, "useShadowDOM", !0)),
  useTabStops: G(new Fe(129, "useTabStops", !0, { description: p("useTabStops", "Spaces and tabs are inserted and deleted in alignment with tab stops.") })),
  wordBreak: G(new Tt(130, "wordBreak", "normal", ["normal", "keepAll"], {
    markdownEnumDescriptions: [
      p("wordBreak.normal", "Use the default line break rule."),
      p("wordBreak.keepAll", "Word breaks should not be used for Chinese/Japanese/Korean (CJK) text. Non-CJK text behavior is the same as for normal.")
    ],
    description: p("wordBreak", "Controls the word break rules used for Chinese/Japanese/Korean (CJK) text.")
  })),
  wordSegmenterLocales: G(new jP()),
  wordSeparators: G(new qi(132, "wordSeparators", I2, { description: p("wordSeparators", "Characters that will be used as word separators when doing word related navigations or operations.") })),
  wordWrap: G(new Tt(133, "wordWrap", "off", ["off", "on", "wordWrapColumn", "bounded"], {
    markdownEnumDescriptions: [
      p("wordWrap.off", "Lines will never wrap."),
      p("wordWrap.on", "Lines will wrap at the viewport width."),
      p({
        key: "wordWrap.wordWrapColumn",
        comment: [
          "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
        ]
      }, "Lines will wrap at `#editor.wordWrapColumn#`."),
      p({
        key: "wordWrap.bounded",
        comment: [
          "- viewport means the edge of the visible window size.",
          "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
        ]
      }, "Lines will wrap at the minimum of viewport and `#editor.wordWrapColumn#`.")
    ],
    description: p({
      key: "wordWrap",
      comment: [
        "- 'off', 'on', 'wordWrapColumn' and 'bounded' refer to values the setting can take and should not be localized.",
        "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
      ]
    }, "Controls how lines should wrap.")
  })),
  wordWrapBreakAfterCharacters: G(new qi(
    134,
    "wordWrapBreakAfterCharacters",
    // allow-any-unicode-next-line
    " 	})]?|/&.,;¢°′″‰℃、。｡､￠，．：；？！％・･ゝゞヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻ｧｨｩｪｫｬｭｮｯｰ”〉》」』】〕）］｝｣"
  )),
  wordWrapBreakBeforeCharacters: G(new qi(
    135,
    "wordWrapBreakBeforeCharacters",
    // allow-any-unicode-next-line
    "([{‘“〈《「『【〔（［｛｢£¥＄￡￥+＋"
  )),
  wordWrapColumn: G(new lt(136, "wordWrapColumn", 80, 1, 1073741824, {
    markdownDescription: p({
      key: "wordWrapColumn",
      comment: [
        "- `editor.wordWrap` refers to a different setting and should not be localized.",
        "- 'wordWrapColumn' and 'bounded' refer to values the different setting can take and should not be localized."
      ]
    }, "Controls the wrapping column of the editor when `#editor.wordWrap#` is `wordWrapColumn` or `bounded`.")
  })),
  wordWrapOverride1: G(new Tt(137, "wordWrapOverride1", "inherit", ["off", "on", "inherit"])),
  wordWrapOverride2: G(new Tt(138, "wordWrapOverride2", "inherit", ["off", "on", "inherit"])),
  // Leave these at the end (because they have dependencies!)
  editorClassName: G(new pP()),
  defaultColorDecorators: G(new Fe(148, "defaultColorDecorators", !1, { markdownDescription: p("defaultColorDecorators", "Controls whether inline color decorations should be shown using the default document color provider") })),
  pixelRatio: G(new RP()),
  tabFocusMode: G(new Fe(145, "tabFocusMode", !1, { markdownDescription: p("tabFocusMode", "Controls whether the editor receives tabs or defers them to the workbench for navigation.") })),
  layoutInfo: G(new Hh()),
  wrappingInfo: G(new ZP()),
  wrappingIndent: G(new GP()),
  wrappingStrategy: G(new SP())
};
class tO {
  constructor() {
    this.listeners = [], this.unexpectedErrorHandler = function(e) {
      setTimeout(() => {
        throw e.stack ? md.isErrorNoTelemetry(e) ? new md(e.message + `

` + e.stack) : new Error(e.message + `

` + e.stack) : e;
      }, 0);
    };
  }
  emit(e) {
    this.listeners.forEach((t) => {
      t(e);
    });
  }
  onUnexpectedError(e) {
    this.unexpectedErrorHandler(e), this.emit(e);
  }
  // For external errors, we don't want the listeners to be called
  onUnexpectedExternalError(e) {
    this.unexpectedErrorHandler(e);
  }
}
const R2 = new tO();
function ht(s) {
  wg(s) || R2.onUnexpectedError(s);
}
function wL(s) {
  wg(s) || R2.onUnexpectedExternalError(s);
}
function sD(s) {
  if (s instanceof Error) {
    const { name: e, message: t } = s, i = s.stacktrace || s.stack;
    return {
      $isError: !0,
      name: e,
      message: t,
      stack: i,
      noTelemetry: md.isErrorNoTelemetry(s)
    };
  }
  return s;
}
const vp = "Canceled";
function wg(s) {
  return s instanceof vg ? !0 : s instanceof Error && s.name === vp && s.message === vp;
}
class vg extends Error {
  constructor() {
    super(vp), this.name = this.message;
  }
}
function iO() {
  const s = new Error(vp);
  return s.name = s.message, s;
}
function eb(s) {
  return s ? new Error(`Illegal argument: ${s}`) : new Error("Illegal argument");
}
function vL(s) {
  return s ? new Error(`Illegal state: ${s}`) : new Error("Illegal state");
}
class nO extends Error {
  constructor(e) {
    super("NotSupported"), e && (this.message = e);
  }
}
class md extends Error {
  constructor(e) {
    super(e), this.name = "CodeExpectedError";
  }
  static fromError(e) {
    if (e instanceof md)
      return e;
    const t = new md();
    return t.message = e.message, t.stack = e.stack, t;
  }
  static isErrorNoTelemetry(e) {
    return e.name === "CodeExpectedError";
  }
}
class it extends Error {
  constructor(e) {
    super(e || "An unexpected bug occurred."), Object.setPrototypeOf(this, it.prototype);
  }
}
function pd(s, e) {
  const t = this;
  let i = !1, n;
  return function() {
    return i || (i = !0, n = s.apply(t, arguments)), n;
  };
}
function A2(s) {
  return typeof s == "object" && s !== null && typeof s.dispose == "function" && s.dispose.length === 0;
}
function Ri(s) {
  if (Ye.is(s)) {
    const e = [];
    for (const t of s)
      if (t)
        try {
          t.dispose();
        } catch (i) {
          e.push(i);
        }
    if (e.length === 1)
      throw e[0];
    if (e.length > 1)
      throw new AggregateError(e, "Encountered errors while disposing of store");
    return Array.isArray(s) ? [] : s;
  } else if (s)
    return s.dispose(), s;
}
function Wo(...s) {
  return ke(() => Ri(s));
}
function ke(s) {
  return {
    dispose: pd(() => {
      s();
    })
  };
}
const o1 = class o1 {
  constructor() {
    this._toDispose = /* @__PURE__ */ new Set(), this._isDisposed = !1;
  }
  /**
   * Dispose of all registered disposables and mark this object as disposed.
   *
   * Any future disposables added to this object will be disposed of on `add`.
   */
  dispose() {
    this._isDisposed || (this._isDisposed = !0, this.clear());
  }
  /**
   * @return `true` if this object has been disposed of.
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * Dispose of all registered disposables but do not mark this object as disposed.
   */
  clear() {
    if (this._toDispose.size !== 0)
      try {
        Ri(this._toDispose);
      } finally {
        this._toDispose.clear();
      }
  }
  /**
   * Add a new {@link IDisposable disposable} to the collection.
   */
  add(e) {
    if (!e)
      return e;
    if (e === this)
      throw new Error("Cannot register a disposable on itself!");
    return this._isDisposed ? o1.DISABLE_DISPOSED_WARNING || console.warn(new Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!").stack) : this._toDispose.add(e), e;
  }
  /**
   * Deletes the value from the store, but does not dispose it.
   */
  deleteAndLeak(e) {
    e && this._toDispose.has(e) && this._toDispose.delete(e);
  }
};
o1.DISABLE_DISPOSED_WARNING = !1;
let he = o1;
const Kx = class Kx {
  constructor() {
    this._store = new he(), this._store;
  }
  dispose() {
    this._store.dispose();
  }
  /**
   * Adds `o` to the collection of disposables managed by this object.
   */
  _register(e) {
    if (e === this)
      throw new Error("Cannot register a disposable on itself!");
    return this._store.add(e);
  }
};
Kx.None = Object.freeze({ dispose() {
} });
let q = Kx;
class Zr {
  constructor() {
    this._isDisposed = !1;
  }
  get value() {
    return this._isDisposed ? void 0 : this._value;
  }
  set value(e) {
    var t;
    this._isDisposed || e === this._value || ((t = this._value) == null || t.dispose(), this._value = e);
  }
  /**
   * Resets the stored value and disposed of the previously stored value.
   */
  clear() {
    this.value = void 0;
  }
  dispose() {
    var e;
    this._isDisposed = !0, (e = this._value) == null || e.dispose(), this._value = void 0;
  }
}
class sO {
  constructor(e) {
    this.object = e;
  }
  dispose() {
  }
}
class yL {
  constructor() {
    this._store = /* @__PURE__ */ new Map(), this._isDisposed = !1;
  }
  /**
   * Disposes of all stored values and mark this object as disposed.
   *
   * Trying to use this object after it has been disposed of is an error.
   */
  dispose() {
    this._isDisposed = !0, this.clearAndDisposeAll();
  }
  /**
   * Disposes of all stored values and clear the map, but DO NOT mark this object as disposed.
   */
  clearAndDisposeAll() {
    if (this._store.size)
      try {
        Ri(this._store.values());
      } finally {
        this._store.clear();
      }
  }
  get(e) {
    return this._store.get(e);
  }
  set(e, t, i = !1) {
    var n;
    this._isDisposed && console.warn(new Error("Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!").stack), i || (n = this._store.get(e)) == null || n.dispose(), this._store.set(e, t);
  }
  /**
   * Delete the value stored for `key` from this map and also dispose of it.
   */
  deleteAndDispose(e) {
    var t;
    (t = this._store.get(e)) == null || t.dispose(), this._store.delete(e);
  }
  [Symbol.iterator]() {
    return this._store[Symbol.iterator]();
  }
}
const oO = globalThis.performance && typeof globalThis.performance.now == "function";
class Dc {
  static create(e) {
    return new Dc(e);
  }
  constructor(e) {
    this._now = oO && e === !1 ? Date.now : globalThis.performance.now.bind(globalThis.performance), this._startTime = this._now(), this._stopTime = -1;
  }
  stop() {
    this._stopTime = this._now();
  }
  reset() {
    this._startTime = this._now(), this._stopTime = -1;
  }
  elapsed() {
    return this._stopTime !== -1 ? this._stopTime - this._startTime : this._now() - this._startTime;
  }
}
var J;
(function(s) {
  s.None = () => q.None;
  function e(W, A) {
    return u(W, () => {
    }, 0, void 0, !0, void 0, A);
  }
  s.defer = e;
  function t(W) {
    return (A, K = null, Y) => {
      let Q = !1, ne;
      return ne = W((ie) => {
        if (!Q)
          return ne ? ne.dispose() : Q = !0, A.call(K, ie);
      }, null, Y), Q && ne.dispose(), ne;
    };
  }
  s.once = t;
  function i(W, A) {
    return s.once(s.filter(W, A));
  }
  s.onceIf = i;
  function n(W, A, K) {
    return h((Y, Q = null, ne) => W((ie) => Y.call(Q, A(ie)), null, ne), K);
  }
  s.map = n;
  function o(W, A, K) {
    return h((Y, Q = null, ne) => W((ie) => {
      A(ie), Y.call(Q, ie);
    }, null, ne), K);
  }
  s.forEach = o;
  function r(W, A, K) {
    return h((Y, Q = null, ne) => W((ie) => A(ie) && Y.call(Q, ie), null, ne), K);
  }
  s.filter = r;
  function a(W) {
    return W;
  }
  s.signal = a;
  function l(...W) {
    return (A, K = null, Y) => {
      const Q = Wo(...W.map((ne) => ne((ie) => A.call(K, ie))));
      return d(Q, Y);
    };
  }
  s.any = l;
  function c(W, A, K, Y) {
    let Q = K;
    return n(W, (ne) => (Q = A(Q, ne), Q), Y);
  }
  s.reduce = c;
  function h(W, A) {
    let K;
    const Y = {
      onWillAddFirstListener() {
        K = W(Q.fire, Q);
      },
      onDidRemoveLastListener() {
        K == null || K.dispose();
      }
    }, Q = new O(Y);
    return A == null || A.add(Q), Q.event;
  }
  function d(W, A) {
    return A instanceof Array ? A.push(W) : A && A.add(W), W;
  }
  function u(W, A, K = 100, Y = !1, Q = !1, ne, ie) {
    let me, _e, vt, be = 0, Ze;
    const De = {
      leakWarningThreshold: ne,
      onWillAddFirstListener() {
        me = W((Je) => {
          be++, _e = A(_e, Je), Y && !vt && (mt.fire(_e), _e = void 0), Ze = () => {
            const xt = _e;
            _e = void 0, vt = void 0, (!Y || be > 1) && mt.fire(xt), be = 0;
          }, typeof K == "number" ? (clearTimeout(vt), vt = setTimeout(Ze, K)) : vt === void 0 && (vt = 0, queueMicrotask(Ze));
        });
      },
      onWillRemoveListener() {
        Q && be > 0 && (Ze == null || Ze());
      },
      onDidRemoveLastListener() {
        Ze = void 0, me.dispose();
      }
    }, mt = new O(De);
    return ie == null || ie.add(mt), mt.event;
  }
  s.debounce = u;
  function f(W, A = 0, K) {
    return s.debounce(W, (Y, Q) => Y ? (Y.push(Q), Y) : [Q], A, void 0, !0, void 0, K);
  }
  s.accumulate = f;
  function g(W, A = (Y, Q) => Y === Q, K) {
    let Y = !0, Q;
    return r(W, (ne) => {
      const ie = Y || !A(ne, Q);
      return Y = !1, Q = ne, ie;
    }, K);
  }
  s.latch = g;
  function m(W, A, K) {
    return [
      s.filter(W, A, K),
      s.filter(W, (Y) => !A(Y), K)
    ];
  }
  s.split = m;
  function _(W, A = !1, K = [], Y) {
    let Q = K.slice(), ne = W((_e) => {
      Q ? Q.push(_e) : me.fire(_e);
    });
    Y && Y.add(ne);
    const ie = () => {
      Q == null || Q.forEach((_e) => me.fire(_e)), Q = null;
    }, me = new O({
      onWillAddFirstListener() {
        ne || (ne = W((_e) => me.fire(_e)), Y && Y.add(ne));
      },
      onDidAddFirstListener() {
        Q && (A ? setTimeout(ie) : ie());
      },
      onDidRemoveLastListener() {
        ne && ne.dispose(), ne = null;
      }
    });
    return Y && Y.add(me), me.event;
  }
  s.buffer = _;
  function b(W, A) {
    return (Y, Q, ne) => {
      const ie = A(new v());
      return W(function(me) {
        const _e = ie.evaluate(me);
        _e !== C && Y.call(Q, _e);
      }, void 0, ne);
    };
  }
  s.chain = b;
  const C = Symbol("HaltChainable");
  class v {
    constructor() {
      this.steps = [];
    }
    map(A) {
      return this.steps.push(A), this;
    }
    forEach(A) {
      return this.steps.push((K) => (A(K), K)), this;
    }
    filter(A) {
      return this.steps.push((K) => A(K) ? K : C), this;
    }
    reduce(A, K) {
      let Y = K;
      return this.steps.push((Q) => (Y = A(Y, Q), Y)), this;
    }
    latch(A = (K, Y) => K === Y) {
      let K = !0, Y;
      return this.steps.push((Q) => {
        const ne = K || !A(Q, Y);
        return K = !1, Y = Q, ne ? Q : C;
      }), this;
    }
    evaluate(A) {
      for (const K of this.steps)
        if (A = K(A), A === C)
          break;
      return A;
    }
  }
  function w(W, A, K = (Y) => Y) {
    const Y = (...me) => ie.fire(K(...me)), Q = () => W.on(A, Y), ne = () => W.removeListener(A, Y), ie = new O({ onWillAddFirstListener: Q, onDidRemoveLastListener: ne });
    return ie.event;
  }
  s.fromNodeEventEmitter = w;
  function S(W, A, K = (Y) => Y) {
    const Y = (...me) => ie.fire(K(...me)), Q = () => W.addEventListener(A, Y), ne = () => W.removeEventListener(A, Y), ie = new O({ onWillAddFirstListener: Q, onDidRemoveLastListener: ne });
    return ie.event;
  }
  s.fromDOMEventEmitter = S;
  function L(W) {
    return new Promise((A) => t(W)(A));
  }
  s.toPromise = L;
  function k(W) {
    const A = new O();
    return W.then((K) => {
      A.fire(K);
    }, () => {
      A.fire(void 0);
    }).finally(() => {
      A.dispose();
    }), A.event;
  }
  s.fromPromise = k;
  function D(W, A) {
    return W((K) => A.fire(K));
  }
  s.forward = D;
  function E(W, A, K) {
    return A(K), W((Y) => A(Y));
  }
  s.runAndSubscribe = E;
  class U {
    constructor(A, K) {
      this._observable = A, this._counter = 0, this._hasChanged = !1;
      const Y = {
        onWillAddFirstListener: () => {
          A.addObserver(this), this._observable.reportChanges();
        },
        onDidRemoveLastListener: () => {
          A.removeObserver(this);
        }
      };
      this.emitter = new O(Y), K && K.add(this.emitter);
    }
    beginUpdate(A) {
      this._counter++;
    }
    handlePossibleChange(A) {
    }
    handleChange(A, K) {
      this._hasChanged = !0;
    }
    endUpdate(A) {
      this._counter--, this._counter === 0 && (this._observable.reportChanges(), this._hasChanged && (this._hasChanged = !1, this.emitter.fire(this._observable.get())));
    }
  }
  function P(W, A) {
    return new U(W, A).emitter.event;
  }
  s.fromObservable = P;
  function B(W) {
    return (A, K, Y) => {
      let Q = 0, ne = !1;
      const ie = {
        beginUpdate() {
          Q++;
        },
        endUpdate() {
          Q--, Q === 0 && (W.reportChanges(), ne && (ne = !1, A.call(K)));
        },
        handlePossibleChange() {
        },
        handleChange() {
          ne = !0;
        }
      };
      W.addObserver(ie), W.reportChanges();
      const me = {
        dispose() {
          W.removeObserver(ie);
        }
      };
      return Y instanceof he ? Y.add(me) : Array.isArray(Y) && Y.push(me), me;
    };
  }
  s.fromObservableLight = B;
})(J || (J = {}));
const Nh = class Nh {
  constructor(e) {
    this.listenerCount = 0, this.invocationCount = 0, this.elapsedOverall = 0, this.durations = [], this.name = `${e}_${Nh._idPool++}`, Nh.all.add(this);
  }
  start(e) {
    this._stopWatch = new Dc(), this.listenerCount = e;
  }
  stop() {
    if (this._stopWatch) {
      const e = this._stopWatch.elapsed();
      this.durations.push(e), this.elapsedOverall += e, this.invocationCount += 1, this._stopWatch = void 0;
    }
  }
};
Nh.all = /* @__PURE__ */ new Set(), Nh._idPool = 0;
let MC = Nh, rO = -1;
const r1 = class r1 {
  constructor(e, t, i = (r1._idPool++).toString(16).padStart(3, "0")) {
    this._errorHandler = e, this.threshold = t, this.name = i, this._warnCountdown = 0;
  }
  dispose() {
    var e;
    (e = this._stacks) == null || e.clear();
  }
  check(e, t) {
    const i = this.threshold;
    if (i <= 0 || t < i)
      return;
    this._stacks || (this._stacks = /* @__PURE__ */ new Map());
    const n = this._stacks.get(e.value) || 0;
    if (this._stacks.set(e.value, n + 1), this._warnCountdown -= 1, this._warnCountdown <= 0) {
      this._warnCountdown = i * 0.5;
      const [o, r] = this.getMostFrequentStack(), a = `[${this.name}] potential listener LEAK detected, having ${t} listeners already. MOST frequent listener (${r}):`;
      console.warn(a), console.warn(o);
      const l = new aO(a, o);
      this._errorHandler(l);
    }
    return () => {
      const o = this._stacks.get(e.value) || 0;
      this._stacks.set(e.value, o - 1);
    };
  }
  getMostFrequentStack() {
    if (!this._stacks)
      return;
    let e, t = 0;
    for (const [i, n] of this._stacks)
      (!e || t < n) && (e = [i, n], t = n);
    return e;
  }
};
r1._idPool = 1;
let RC = r1;
class SL {
  static create() {
    const e = new Error();
    return new SL(e.stack ?? "");
  }
  constructor(e) {
    this.value = e;
  }
  print() {
    console.warn(this.value.split(`
`).slice(2).join(`
`));
  }
}
class aO extends Error {
  constructor(e, t) {
    super(e), this.name = "ListenerLeakError", this.stack = t;
  }
}
class lO extends Error {
  constructor(e, t) {
    super(e), this.name = "ListenerRefusalError", this.stack = t;
  }
}
class r0 {
  constructor(e) {
    this.value = e;
  }
}
const cO = 2;
let O = class {
  constructor(e) {
    var t, i, n, o;
    this._size = 0, this._options = e, this._leakageMon = (t = this._options) != null && t.leakWarningThreshold ? new RC((e == null ? void 0 : e.onListenerError) ?? ht, ((i = this._options) == null ? void 0 : i.leakWarningThreshold) ?? rO) : void 0, this._perfMon = (n = this._options) != null && n._profName ? new MC(this._options._profName) : void 0, this._deliveryQueue = (o = this._options) == null ? void 0 : o.deliveryQueue;
  }
  dispose() {
    var e, t, i, n;
    this._disposed || (this._disposed = !0, ((e = this._deliveryQueue) == null ? void 0 : e.current) === this && this._deliveryQueue.reset(), this._listeners && (this._listeners = void 0, this._size = 0), (i = (t = this._options) == null ? void 0 : t.onDidRemoveLastListener) == null || i.call(t), (n = this._leakageMon) == null || n.dispose());
  }
  /**
   * For the public to allow to subscribe
   * to events from this Emitter
   */
  get event() {
    return this._event ?? (this._event = (e, t, i) => {
      var a, l, c, h, d;
      if (this._leakageMon && this._size > this._leakageMon.threshold ** 2) {
        const u = `[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far (${this._size} vs ${this._leakageMon.threshold})`;
        console.warn(u);
        const f = this._leakageMon.getMostFrequentStack() ?? ["UNKNOWN stack", -1], g = new lO(`${u}. HINT: Stack shows most frequent listener (${f[1]}-times)`, f[0]);
        return (((a = this._options) == null ? void 0 : a.onListenerError) || ht)(g), q.None;
      }
      if (this._disposed)
        return q.None;
      t && (e = e.bind(t));
      const n = new r0(e);
      let o;
      this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2) && (n.stack = SL.create(), o = this._leakageMon.check(n.stack, this._size + 1)), this._listeners ? this._listeners instanceof r0 ? (this._deliveryQueue ?? (this._deliveryQueue = new P2()), this._listeners = [this._listeners, n]) : this._listeners.push(n) : ((c = (l = this._options) == null ? void 0 : l.onWillAddFirstListener) == null || c.call(l, this), this._listeners = n, (d = (h = this._options) == null ? void 0 : h.onDidAddFirstListener) == null || d.call(h, this)), this._size++;
      const r = ke(() => {
        o == null || o(), this._removeListener(n);
      });
      return i instanceof he ? i.add(r) : Array.isArray(i) && i.push(r), r;
    }), this._event;
  }
  _removeListener(e) {
    var o, r, a, l;
    if ((r = (o = this._options) == null ? void 0 : o.onWillRemoveListener) == null || r.call(o, this), !this._listeners)
      return;
    if (this._size === 1) {
      this._listeners = void 0, (l = (a = this._options) == null ? void 0 : a.onDidRemoveLastListener) == null || l.call(a, this), this._size = 0;
      return;
    }
    const t = this._listeners, i = t.indexOf(e);
    if (i === -1)
      throw console.log("disposed?", this._disposed), console.log("size?", this._size), console.log("arr?", JSON.stringify(this._listeners)), new Error("Attempted to dispose unknown listener");
    this._size--, t[i] = void 0;
    const n = this._deliveryQueue.current === this;
    if (this._size * cO <= t.length) {
      let c = 0;
      for (let h = 0; h < t.length; h++)
        t[h] ? t[c++] = t[h] : n && (this._deliveryQueue.end--, c < this._deliveryQueue.i && this._deliveryQueue.i--);
      t.length = c;
    }
  }
  _deliver(e, t) {
    var n;
    if (!e)
      return;
    const i = ((n = this._options) == null ? void 0 : n.onListenerError) || ht;
    if (!i) {
      e.value(t);
      return;
    }
    try {
      e.value(t);
    } catch (o) {
      i(o);
    }
  }
  /** Delivers items in the queue. Assumes the queue is ready to go. */
  _deliverQueue(e) {
    const t = e.current._listeners;
    for (; e.i < e.end; )
      this._deliver(t[e.i++], e.value);
    e.reset();
  }
  /**
   * To be kept private to fire an event to
   * subscribers
   */
  fire(e) {
    var t, i, n, o;
    if ((t = this._deliveryQueue) != null && t.current && (this._deliverQueue(this._deliveryQueue), (i = this._perfMon) == null || i.stop()), (n = this._perfMon) == null || n.start(this._size), this._listeners) if (this._listeners instanceof r0)
      this._deliver(this._listeners, e);
    else {
      const r = this._deliveryQueue;
      r.enqueue(this, e, this._listeners.length), this._deliverQueue(r);
    }
    (o = this._perfMon) == null || o.stop();
  }
  hasListeners() {
    return this._size > 0;
  }
};
const hO = () => new P2();
class P2 {
  constructor() {
    this.i = -1, this.end = 0;
  }
  enqueue(e, t, i) {
    this.i = 0, this.end = i, this.current = e, this.value = t;
  }
  reset() {
    this.i = this.end, this.current = void 0, this.value = void 0;
  }
}
class Mf extends O {
  constructor(e) {
    super(e), this._isPaused = 0, this._eventQueue = new An(), this._mergeFn = e == null ? void 0 : e.merge;
  }
  pause() {
    this._isPaused++;
  }
  resume() {
    if (this._isPaused !== 0 && --this._isPaused === 0)
      if (this._mergeFn) {
        if (this._eventQueue.size > 0) {
          const e = Array.from(this._eventQueue);
          this._eventQueue.clear(), super.fire(this._mergeFn(e));
        }
      } else
        for (; !this._isPaused && this._eventQueue.size !== 0; )
          super.fire(this._eventQueue.shift());
  }
  fire(e) {
    this._size && (this._isPaused !== 0 ? this._eventQueue.push(e) : super.fire(e));
  }
}
class O2 extends Mf {
  constructor(e) {
    super(e), this._delay = e.delay ?? 100;
  }
  fire(e) {
    this._handle || (this.pause(), this._handle = setTimeout(() => {
      this._handle = void 0, this.resume();
    }, this._delay)), super.fire(e);
  }
}
class dO extends O {
  constructor(e) {
    super(e), this._queuedEvents = [], this._mergeFn = e == null ? void 0 : e.merge;
  }
  fire(e) {
    this.hasListeners() && (this._queuedEvents.push(e), this._queuedEvents.length === 1 && queueMicrotask(() => {
      this._mergeFn ? super.fire(this._mergeFn(this._queuedEvents)) : this._queuedEvents.forEach((t) => super.fire(t)), this._queuedEvents = [];
    }));
  }
}
class uO {
  constructor() {
    this.hasListeners = !1, this.events = [], this.emitter = new O({
      onWillAddFirstListener: () => this.onFirstListenerAdd(),
      onDidRemoveLastListener: () => this.onLastListenerRemove()
    });
  }
  get event() {
    return this.emitter.event;
  }
  add(e) {
    const t = { event: e, listener: null };
    return this.events.push(t), this.hasListeners && this.hook(t), ke(pd(() => {
      this.hasListeners && this.unhook(t);
      const n = this.events.indexOf(t);
      this.events.splice(n, 1);
    }));
  }
  onFirstListenerAdd() {
    this.hasListeners = !0, this.events.forEach((e) => this.hook(e));
  }
  onLastListenerRemove() {
    this.hasListeners = !1, this.events.forEach((e) => this.unhook(e));
  }
  hook(e) {
    e.listener = e.event((t) => this.emitter.fire(t));
  }
  unhook(e) {
    var t;
    (t = e.listener) == null || t.dispose(), e.listener = null;
  }
  dispose() {
    var e;
    this.emitter.dispose();
    for (const t of this.events)
      (e = t.listener) == null || e.dispose();
    this.events = [];
  }
}
class yg {
  constructor() {
    this.data = [];
  }
  wrapEvent(e, t, i) {
    return (n, o, r) => e((a) => {
      const l = this.data[this.data.length - 1];
      if (!t) {
        l ? l.buffers.push(() => n.call(o, a)) : n.call(o, a);
        return;
      }
      const c = l;
      if (!c) {
        n.call(o, t(i, a));
        return;
      }
      c.items ?? (c.items = []), c.items.push(a), c.buffers.length === 0 && l.buffers.push(() => {
        c.reducedResult ?? (c.reducedResult = i ? c.items.reduce(t, i) : c.items.reduce(t)), n.call(o, c.reducedResult);
      });
    }, void 0, r);
  }
  bufferEvents(e) {
    const t = { buffers: new Array() };
    this.data.push(t);
    const i = e();
    return this.data.pop(), t.buffers.forEach((n) => n()), i;
  }
}
class oD {
  constructor() {
    this.listening = !1, this.inputEvent = J.None, this.inputEventListener = q.None, this.emitter = new O({
      onDidAddFirstListener: () => {
        this.listening = !0, this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);
      },
      onDidRemoveLastListener: () => {
        this.listening = !1, this.inputEventListener.dispose();
      }
    }), this.event = this.emitter.event;
  }
  set input(e) {
    this.inputEvent = e, this.listening && (this.inputEventListener.dispose(), this.inputEventListener = e(this.emitter.fire, this.emitter));
  }
  dispose() {
    this.inputEventListener.dispose(), this.emitter.dispose();
  }
}
const F2 = Object.freeze(function(s, e) {
  const t = setTimeout(s.bind(e), 0);
  return { dispose() {
    clearTimeout(t);
  } };
});
var Rs;
(function(s) {
  function e(t) {
    return t === s.None || t === s.Cancelled || t instanceof Um ? !0 : !t || typeof t != "object" ? !1 : typeof t.isCancellationRequested == "boolean" && typeof t.onCancellationRequested == "function";
  }
  s.isCancellationToken = e, s.None = Object.freeze({
    isCancellationRequested: !1,
    onCancellationRequested: J.None
  }), s.Cancelled = Object.freeze({
    isCancellationRequested: !0,
    onCancellationRequested: F2
  });
})(Rs || (Rs = {}));
class Um {
  constructor() {
    this._isCancelled = !1, this._emitter = null;
  }
  cancel() {
    this._isCancelled || (this._isCancelled = !0, this._emitter && (this._emitter.fire(void 0), this.dispose()));
  }
  get isCancellationRequested() {
    return this._isCancelled;
  }
  get onCancellationRequested() {
    return this._isCancelled ? F2 : (this._emitter || (this._emitter = new O()), this._emitter.event);
  }
  dispose() {
    this._emitter && (this._emitter.dispose(), this._emitter = null);
  }
}
let Wd = class {
  constructor(e) {
    this._token = void 0, this._parentListener = void 0, this._parentListener = e && e.onCancellationRequested(this.cancel, this);
  }
  get token() {
    return this._token || (this._token = new Um()), this._token;
  }
  cancel() {
    this._token ? this._token instanceof Um && this._token.cancel() : this._token = Rs.Cancelled;
  }
  dispose(e = !1) {
    var t;
    e && this.cancel(), (t = this._parentListener) == null || t.dispose(), this._token ? this._token instanceof Um && this._token.dispose() : this._token = Rs.None;
  }
};
class LL {
  constructor() {
    this._keyCodeToStr = [], this._strToKeyCode = /* @__PURE__ */ Object.create(null);
  }
  define(e, t) {
    this._keyCodeToStr[e] = t, this._strToKeyCode[t.toLowerCase()] = e;
  }
  keyCodeToStr(e) {
    return this._keyCodeToStr[e];
  }
  strToKeyCode(e) {
    return this._strToKeyCode[e.toLowerCase()] || 0;
  }
}
const $m = new LL(), AC = new LL(), PC = new LL(), B2 = new Array(230), fO = /* @__PURE__ */ Object.create(null), gO = /* @__PURE__ */ Object.create(null), kL = [];
for (let s = 0; s <= 193; s++)
  kL[s] = -1;
(function() {
  const e = [
    // immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel
    [1, 0, "None", 0, "unknown", 0, "VK_UNKNOWN", "", ""],
    [1, 1, "Hyper", 0, "", 0, "", "", ""],
    [1, 2, "Super", 0, "", 0, "", "", ""],
    [1, 3, "Fn", 0, "", 0, "", "", ""],
    [1, 4, "FnLock", 0, "", 0, "", "", ""],
    [1, 5, "Suspend", 0, "", 0, "", "", ""],
    [1, 6, "Resume", 0, "", 0, "", "", ""],
    [1, 7, "Turbo", 0, "", 0, "", "", ""],
    [1, 8, "Sleep", 0, "", 0, "VK_SLEEP", "", ""],
    [1, 9, "WakeUp", 0, "", 0, "", "", ""],
    [0, 10, "KeyA", 31, "A", 65, "VK_A", "", ""],
    [0, 11, "KeyB", 32, "B", 66, "VK_B", "", ""],
    [0, 12, "KeyC", 33, "C", 67, "VK_C", "", ""],
    [0, 13, "KeyD", 34, "D", 68, "VK_D", "", ""],
    [0, 14, "KeyE", 35, "E", 69, "VK_E", "", ""],
    [0, 15, "KeyF", 36, "F", 70, "VK_F", "", ""],
    [0, 16, "KeyG", 37, "G", 71, "VK_G", "", ""],
    [0, 17, "KeyH", 38, "H", 72, "VK_H", "", ""],
    [0, 18, "KeyI", 39, "I", 73, "VK_I", "", ""],
    [0, 19, "KeyJ", 40, "J", 74, "VK_J", "", ""],
    [0, 20, "KeyK", 41, "K", 75, "VK_K", "", ""],
    [0, 21, "KeyL", 42, "L", 76, "VK_L", "", ""],
    [0, 22, "KeyM", 43, "M", 77, "VK_M", "", ""],
    [0, 23, "KeyN", 44, "N", 78, "VK_N", "", ""],
    [0, 24, "KeyO", 45, "O", 79, "VK_O", "", ""],
    [0, 25, "KeyP", 46, "P", 80, "VK_P", "", ""],
    [0, 26, "KeyQ", 47, "Q", 81, "VK_Q", "", ""],
    [0, 27, "KeyR", 48, "R", 82, "VK_R", "", ""],
    [0, 28, "KeyS", 49, "S", 83, "VK_S", "", ""],
    [0, 29, "KeyT", 50, "T", 84, "VK_T", "", ""],
    [0, 30, "KeyU", 51, "U", 85, "VK_U", "", ""],
    [0, 31, "KeyV", 52, "V", 86, "VK_V", "", ""],
    [0, 32, "KeyW", 53, "W", 87, "VK_W", "", ""],
    [0, 33, "KeyX", 54, "X", 88, "VK_X", "", ""],
    [0, 34, "KeyY", 55, "Y", 89, "VK_Y", "", ""],
    [0, 35, "KeyZ", 56, "Z", 90, "VK_Z", "", ""],
    [0, 36, "Digit1", 22, "1", 49, "VK_1", "", ""],
    [0, 37, "Digit2", 23, "2", 50, "VK_2", "", ""],
    [0, 38, "Digit3", 24, "3", 51, "VK_3", "", ""],
    [0, 39, "Digit4", 25, "4", 52, "VK_4", "", ""],
    [0, 40, "Digit5", 26, "5", 53, "VK_5", "", ""],
    [0, 41, "Digit6", 27, "6", 54, "VK_6", "", ""],
    [0, 42, "Digit7", 28, "7", 55, "VK_7", "", ""],
    [0, 43, "Digit8", 29, "8", 56, "VK_8", "", ""],
    [0, 44, "Digit9", 30, "9", 57, "VK_9", "", ""],
    [0, 45, "Digit0", 21, "0", 48, "VK_0", "", ""],
    [1, 46, "Enter", 3, "Enter", 13, "VK_RETURN", "", ""],
    [1, 47, "Escape", 9, "Escape", 27, "VK_ESCAPE", "", ""],
    [1, 48, "Backspace", 1, "Backspace", 8, "VK_BACK", "", ""],
    [1, 49, "Tab", 2, "Tab", 9, "VK_TAB", "", ""],
    [1, 50, "Space", 10, "Space", 32, "VK_SPACE", "", ""],
    [0, 51, "Minus", 88, "-", 189, "VK_OEM_MINUS", "-", "OEM_MINUS"],
    [0, 52, "Equal", 86, "=", 187, "VK_OEM_PLUS", "=", "OEM_PLUS"],
    [0, 53, "BracketLeft", 92, "[", 219, "VK_OEM_4", "[", "OEM_4"],
    [0, 54, "BracketRight", 94, "]", 221, "VK_OEM_6", "]", "OEM_6"],
    [0, 55, "Backslash", 93, "\\", 220, "VK_OEM_5", "\\", "OEM_5"],
    [0, 56, "IntlHash", 0, "", 0, "", "", ""],
    // has been dropped from the w3c spec
    [0, 57, "Semicolon", 85, ";", 186, "VK_OEM_1", ";", "OEM_1"],
    [0, 58, "Quote", 95, "'", 222, "VK_OEM_7", "'", "OEM_7"],
    [0, 59, "Backquote", 91, "`", 192, "VK_OEM_3", "`", "OEM_3"],
    [0, 60, "Comma", 87, ",", 188, "VK_OEM_COMMA", ",", "OEM_COMMA"],
    [0, 61, "Period", 89, ".", 190, "VK_OEM_PERIOD", ".", "OEM_PERIOD"],
    [0, 62, "Slash", 90, "/", 191, "VK_OEM_2", "/", "OEM_2"],
    [1, 63, "CapsLock", 8, "CapsLock", 20, "VK_CAPITAL", "", ""],
    [1, 64, "F1", 59, "F1", 112, "VK_F1", "", ""],
    [1, 65, "F2", 60, "F2", 113, "VK_F2", "", ""],
    [1, 66, "F3", 61, "F3", 114, "VK_F3", "", ""],
    [1, 67, "F4", 62, "F4", 115, "VK_F4", "", ""],
    [1, 68, "F5", 63, "F5", 116, "VK_F5", "", ""],
    [1, 69, "F6", 64, "F6", 117, "VK_F6", "", ""],
    [1, 70, "F7", 65, "F7", 118, "VK_F7", "", ""],
    [1, 71, "F8", 66, "F8", 119, "VK_F8", "", ""],
    [1, 72, "F9", 67, "F9", 120, "VK_F9", "", ""],
    [1, 73, "F10", 68, "F10", 121, "VK_F10", "", ""],
    [1, 74, "F11", 69, "F11", 122, "VK_F11", "", ""],
    [1, 75, "F12", 70, "F12", 123, "VK_F12", "", ""],
    [1, 76, "PrintScreen", 0, "", 0, "", "", ""],
    [1, 77, "ScrollLock", 84, "ScrollLock", 145, "VK_SCROLL", "", ""],
    [1, 78, "Pause", 7, "PauseBreak", 19, "VK_PAUSE", "", ""],
    [1, 79, "Insert", 19, "Insert", 45, "VK_INSERT", "", ""],
    [1, 80, "Home", 14, "Home", 36, "VK_HOME", "", ""],
    [1, 81, "PageUp", 11, "PageUp", 33, "VK_PRIOR", "", ""],
    [1, 82, "Delete", 20, "Delete", 46, "VK_DELETE", "", ""],
    [1, 83, "End", 13, "End", 35, "VK_END", "", ""],
    [1, 84, "PageDown", 12, "PageDown", 34, "VK_NEXT", "", ""],
    [1, 85, "ArrowRight", 17, "RightArrow", 39, "VK_RIGHT", "Right", ""],
    [1, 86, "ArrowLeft", 15, "LeftArrow", 37, "VK_LEFT", "Left", ""],
    [1, 87, "ArrowDown", 18, "DownArrow", 40, "VK_DOWN", "Down", ""],
    [1, 88, "ArrowUp", 16, "UpArrow", 38, "VK_UP", "Up", ""],
    [1, 89, "NumLock", 83, "NumLock", 144, "VK_NUMLOCK", "", ""],
    [1, 90, "NumpadDivide", 113, "NumPad_Divide", 111, "VK_DIVIDE", "", ""],
    [1, 91, "NumpadMultiply", 108, "NumPad_Multiply", 106, "VK_MULTIPLY", "", ""],
    [1, 92, "NumpadSubtract", 111, "NumPad_Subtract", 109, "VK_SUBTRACT", "", ""],
    [1, 93, "NumpadAdd", 109, "NumPad_Add", 107, "VK_ADD", "", ""],
    [1, 94, "NumpadEnter", 3, "", 0, "", "", ""],
    [1, 95, "Numpad1", 99, "NumPad1", 97, "VK_NUMPAD1", "", ""],
    [1, 96, "Numpad2", 100, "NumPad2", 98, "VK_NUMPAD2", "", ""],
    [1, 97, "Numpad3", 101, "NumPad3", 99, "VK_NUMPAD3", "", ""],
    [1, 98, "Numpad4", 102, "NumPad4", 100, "VK_NUMPAD4", "", ""],
    [1, 99, "Numpad5", 103, "NumPad5", 101, "VK_NUMPAD5", "", ""],
    [1, 100, "Numpad6", 104, "NumPad6", 102, "VK_NUMPAD6", "", ""],
    [1, 101, "Numpad7", 105, "NumPad7", 103, "VK_NUMPAD7", "", ""],
    [1, 102, "Numpad8", 106, "NumPad8", 104, "VK_NUMPAD8", "", ""],
    [1, 103, "Numpad9", 107, "NumPad9", 105, "VK_NUMPAD9", "", ""],
    [1, 104, "Numpad0", 98, "NumPad0", 96, "VK_NUMPAD0", "", ""],
    [1, 105, "NumpadDecimal", 112, "NumPad_Decimal", 110, "VK_DECIMAL", "", ""],
    [0, 106, "IntlBackslash", 97, "OEM_102", 226, "VK_OEM_102", "", ""],
    [1, 107, "ContextMenu", 58, "ContextMenu", 93, "", "", ""],
    [1, 108, "Power", 0, "", 0, "", "", ""],
    [1, 109, "NumpadEqual", 0, "", 0, "", "", ""],
    [1, 110, "F13", 71, "F13", 124, "VK_F13", "", ""],
    [1, 111, "F14", 72, "F14", 125, "VK_F14", "", ""],
    [1, 112, "F15", 73, "F15", 126, "VK_F15", "", ""],
    [1, 113, "F16", 74, "F16", 127, "VK_F16", "", ""],
    [1, 114, "F17", 75, "F17", 128, "VK_F17", "", ""],
    [1, 115, "F18", 76, "F18", 129, "VK_F18", "", ""],
    [1, 116, "F19", 77, "F19", 130, "VK_F19", "", ""],
    [1, 117, "F20", 78, "F20", 131, "VK_F20", "", ""],
    [1, 118, "F21", 79, "F21", 132, "VK_F21", "", ""],
    [1, 119, "F22", 80, "F22", 133, "VK_F22", "", ""],
    [1, 120, "F23", 81, "F23", 134, "VK_F23", "", ""],
    [1, 121, "F24", 82, "F24", 135, "VK_F24", "", ""],
    [1, 122, "Open", 0, "", 0, "", "", ""],
    [1, 123, "Help", 0, "", 0, "", "", ""],
    [1, 124, "Select", 0, "", 0, "", "", ""],
    [1, 125, "Again", 0, "", 0, "", "", ""],
    [1, 126, "Undo", 0, "", 0, "", "", ""],
    [1, 127, "Cut", 0, "", 0, "", "", ""],
    [1, 128, "Copy", 0, "", 0, "", "", ""],
    [1, 129, "Paste", 0, "", 0, "", "", ""],
    [1, 130, "Find", 0, "", 0, "", "", ""],
    [1, 131, "AudioVolumeMute", 117, "AudioVolumeMute", 173, "VK_VOLUME_MUTE", "", ""],
    [1, 132, "AudioVolumeUp", 118, "AudioVolumeUp", 175, "VK_VOLUME_UP", "", ""],
    [1, 133, "AudioVolumeDown", 119, "AudioVolumeDown", 174, "VK_VOLUME_DOWN", "", ""],
    [1, 134, "NumpadComma", 110, "NumPad_Separator", 108, "VK_SEPARATOR", "", ""],
    [0, 135, "IntlRo", 115, "ABNT_C1", 193, "VK_ABNT_C1", "", ""],
    [1, 136, "KanaMode", 0, "", 0, "", "", ""],
    [0, 137, "IntlYen", 0, "", 0, "", "", ""],
    [1, 138, "Convert", 0, "", 0, "", "", ""],
    [1, 139, "NonConvert", 0, "", 0, "", "", ""],
    [1, 140, "Lang1", 0, "", 0, "", "", ""],
    [1, 141, "Lang2", 0, "", 0, "", "", ""],
    [1, 142, "Lang3", 0, "", 0, "", "", ""],
    [1, 143, "Lang4", 0, "", 0, "", "", ""],
    [1, 144, "Lang5", 0, "", 0, "", "", ""],
    [1, 145, "Abort", 0, "", 0, "", "", ""],
    [1, 146, "Props", 0, "", 0, "", "", ""],
    [1, 147, "NumpadParenLeft", 0, "", 0, "", "", ""],
    [1, 148, "NumpadParenRight", 0, "", 0, "", "", ""],
    [1, 149, "NumpadBackspace", 0, "", 0, "", "", ""],
    [1, 150, "NumpadMemoryStore", 0, "", 0, "", "", ""],
    [1, 151, "NumpadMemoryRecall", 0, "", 0, "", "", ""],
    [1, 152, "NumpadMemoryClear", 0, "", 0, "", "", ""],
    [1, 153, "NumpadMemoryAdd", 0, "", 0, "", "", ""],
    [1, 154, "NumpadMemorySubtract", 0, "", 0, "", "", ""],
    [1, 155, "NumpadClear", 131, "Clear", 12, "VK_CLEAR", "", ""],
    [1, 156, "NumpadClearEntry", 0, "", 0, "", "", ""],
    [1, 0, "", 5, "Ctrl", 17, "VK_CONTROL", "", ""],
    [1, 0, "", 4, "Shift", 16, "VK_SHIFT", "", ""],
    [1, 0, "", 6, "Alt", 18, "VK_MENU", "", ""],
    [1, 0, "", 57, "Meta", 91, "VK_COMMAND", "", ""],
    [1, 157, "ControlLeft", 5, "", 0, "VK_LCONTROL", "", ""],
    [1, 158, "ShiftLeft", 4, "", 0, "VK_LSHIFT", "", ""],
    [1, 159, "AltLeft", 6, "", 0, "VK_LMENU", "", ""],
    [1, 160, "MetaLeft", 57, "", 0, "VK_LWIN", "", ""],
    [1, 161, "ControlRight", 5, "", 0, "VK_RCONTROL", "", ""],
    [1, 162, "ShiftRight", 4, "", 0, "VK_RSHIFT", "", ""],
    [1, 163, "AltRight", 6, "", 0, "VK_RMENU", "", ""],
    [1, 164, "MetaRight", 57, "", 0, "VK_RWIN", "", ""],
    [1, 165, "BrightnessUp", 0, "", 0, "", "", ""],
    [1, 166, "BrightnessDown", 0, "", 0, "", "", ""],
    [1, 167, "MediaPlay", 0, "", 0, "", "", ""],
    [1, 168, "MediaRecord", 0, "", 0, "", "", ""],
    [1, 169, "MediaFastForward", 0, "", 0, "", "", ""],
    [1, 170, "MediaRewind", 0, "", 0, "", "", ""],
    [1, 171, "MediaTrackNext", 124, "MediaTrackNext", 176, "VK_MEDIA_NEXT_TRACK", "", ""],
    [1, 172, "MediaTrackPrevious", 125, "MediaTrackPrevious", 177, "VK_MEDIA_PREV_TRACK", "", ""],
    [1, 173, "MediaStop", 126, "MediaStop", 178, "VK_MEDIA_STOP", "", ""],
    [1, 174, "Eject", 0, "", 0, "", "", ""],
    [1, 175, "MediaPlayPause", 127, "MediaPlayPause", 179, "VK_MEDIA_PLAY_PAUSE", "", ""],
    [1, 176, "MediaSelect", 128, "LaunchMediaPlayer", 181, "VK_MEDIA_LAUNCH_MEDIA_SELECT", "", ""],
    [1, 177, "LaunchMail", 129, "LaunchMail", 180, "VK_MEDIA_LAUNCH_MAIL", "", ""],
    [1, 178, "LaunchApp2", 130, "LaunchApp2", 183, "VK_MEDIA_LAUNCH_APP2", "", ""],
    [1, 179, "LaunchApp1", 0, "", 0, "VK_MEDIA_LAUNCH_APP1", "", ""],
    [1, 180, "SelectTask", 0, "", 0, "", "", ""],
    [1, 181, "LaunchScreenSaver", 0, "", 0, "", "", ""],
    [1, 182, "BrowserSearch", 120, "BrowserSearch", 170, "VK_BROWSER_SEARCH", "", ""],
    [1, 183, "BrowserHome", 121, "BrowserHome", 172, "VK_BROWSER_HOME", "", ""],
    [1, 184, "BrowserBack", 122, "BrowserBack", 166, "VK_BROWSER_BACK", "", ""],
    [1, 185, "BrowserForward", 123, "BrowserForward", 167, "VK_BROWSER_FORWARD", "", ""],
    [1, 186, "BrowserStop", 0, "", 0, "VK_BROWSER_STOP", "", ""],
    [1, 187, "BrowserRefresh", 0, "", 0, "VK_BROWSER_REFRESH", "", ""],
    [1, 188, "BrowserFavorites", 0, "", 0, "VK_BROWSER_FAVORITES", "", ""],
    [1, 189, "ZoomToggle", 0, "", 0, "", "", ""],
    [1, 190, "MailReply", 0, "", 0, "", "", ""],
    [1, 191, "MailForward", 0, "", 0, "", "", ""],
    [1, 192, "MailSend", 0, "", 0, "", "", ""],
    // See https://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html
    // If an Input Method Editor is processing key input and the event is keydown, return 229.
    [1, 0, "", 114, "KeyInComposition", 229, "", "", ""],
    [1, 0, "", 116, "ABNT_C2", 194, "VK_ABNT_C2", "", ""],
    [1, 0, "", 96, "OEM_8", 223, "VK_OEM_8", "", ""],
    [1, 0, "", 0, "", 0, "VK_KANA", "", ""],
    [1, 0, "", 0, "", 0, "VK_HANGUL", "", ""],
    [1, 0, "", 0, "", 0, "VK_JUNJA", "", ""],
    [1, 0, "", 0, "", 0, "VK_FINAL", "", ""],
    [1, 0, "", 0, "", 0, "VK_HANJA", "", ""],
    [1, 0, "", 0, "", 0, "VK_KANJI", "", ""],
    [1, 0, "", 0, "", 0, "VK_CONVERT", "", ""],
    [1, 0, "", 0, "", 0, "VK_NONCONVERT", "", ""],
    [1, 0, "", 0, "", 0, "VK_ACCEPT", "", ""],
    [1, 0, "", 0, "", 0, "VK_MODECHANGE", "", ""],
    [1, 0, "", 0, "", 0, "VK_SELECT", "", ""],
    [1, 0, "", 0, "", 0, "VK_PRINT", "", ""],
    [1, 0, "", 0, "", 0, "VK_EXECUTE", "", ""],
    [1, 0, "", 0, "", 0, "VK_SNAPSHOT", "", ""],
    [1, 0, "", 0, "", 0, "VK_HELP", "", ""],
    [1, 0, "", 0, "", 0, "VK_APPS", "", ""],
    [1, 0, "", 0, "", 0, "VK_PROCESSKEY", "", ""],
    [1, 0, "", 0, "", 0, "VK_PACKET", "", ""],
    [1, 0, "", 0, "", 0, "VK_DBE_SBCSCHAR", "", ""],
    [1, 0, "", 0, "", 0, "VK_DBE_DBCSCHAR", "", ""],
    [1, 0, "", 0, "", 0, "VK_ATTN", "", ""],
    [1, 0, "", 0, "", 0, "VK_CRSEL", "", ""],
    [1, 0, "", 0, "", 0, "VK_EXSEL", "", ""],
    [1, 0, "", 0, "", 0, "VK_EREOF", "", ""],
    [1, 0, "", 0, "", 0, "VK_PLAY", "", ""],
    [1, 0, "", 0, "", 0, "VK_ZOOM", "", ""],
    [1, 0, "", 0, "", 0, "VK_NONAME", "", ""],
    [1, 0, "", 0, "", 0, "VK_PA1", "", ""],
    [1, 0, "", 0, "", 0, "VK_OEM_CLEAR", "", ""]
  ], t = [], i = [];
  for (const n of e) {
    const [o, r, a, l, c, h, d, u, f] = n;
    if (i[r] || (i[r] = !0, fO[a] = r, gO[a.toLowerCase()] = r, o && (kL[r] = l)), !t[l]) {
      if (t[l] = !0, !c)
        throw new Error(`String representation missing for key code ${l} around scan code ${a}`);
      $m.define(l, c), AC.define(l, u || c), PC.define(l, f || u || c);
    }
    h && (B2[h] = l);
  }
})();
var Lr;
(function(s) {
  function e(a) {
    return $m.keyCodeToStr(a);
  }
  s.toString = e;
  function t(a) {
    return $m.strToKeyCode(a);
  }
  s.fromString = t;
  function i(a) {
    return AC.keyCodeToStr(a);
  }
  s.toUserSettingsUS = i;
  function n(a) {
    return PC.keyCodeToStr(a);
  }
  s.toUserSettingsGeneral = n;
  function o(a) {
    return AC.strToKeyCode(a) || PC.strToKeyCode(a);
  }
  s.fromUserSettings = o;
  function r(a) {
    if (a >= 98 && a <= 113)
      return null;
    switch (a) {
      case 16:
        return "Up";
      case 18:
        return "Down";
      case 15:
        return "Left";
      case 17:
        return "Right";
    }
    return $m.keyCodeToStr(a);
  }
  s.toElectronAccelerator = r;
})(Lr || (Lr = {}));
function mO(s, e) {
  const t = (e & 65535) << 16 >>> 0;
  return (s | t) >>> 0;
}
var ir = {};
let Uh;
const a0 = globalThis.vscode;
var m2;
if (typeof a0 < "u" && typeof a0.process < "u") {
  const s = a0.process;
  Uh = {
    get platform() {
      return s.platform;
    },
    get arch() {
      return s.arch;
    },
    get env() {
      return s.env;
    },
    cwd() {
      return s.cwd();
    }
  };
} else typeof ir < "u" && typeof ((m2 = ir == null ? void 0 : ir.versions) == null ? void 0 : m2.node) == "string" ? Uh = {
  get platform() {
    return ir.platform;
  },
  get arch() {
    return ir.arch;
  },
  get env() {
    return ir.env;
  },
  cwd() {
    return ir.env.VSCODE_CWD || ir.cwd();
  }
} : Uh = {
  // Supported
  get platform() {
    return Fn ? "win32" : He ? "darwin" : "linux";
  },
  get arch() {
  },
  // Unsupported
  get env() {
    return {};
  },
  cwd() {
    return "/";
  }
};
const yp = Uh.cwd, OC = Uh.env, pO = Uh.platform, _O = 65, bO = 97, CO = 90, wO = 122, Oa = 46, zi = 47, $n = 92, aa = 58, vO = 63;
class W2 extends Error {
  constructor(e, t, i) {
    let n;
    typeof t == "string" && t.indexOf("not ") === 0 ? (n = "must not be", t = t.replace(/^not /, "")) : n = "must be";
    const o = e.indexOf(".") !== -1 ? "property" : "argument";
    let r = `The "${e}" ${o} ${n} of type ${t}`;
    r += `. Received type ${typeof i}`, super(r), this.code = "ERR_INVALID_ARG_TYPE";
  }
}
function yO(s, e) {
  if (s === null || typeof s != "object")
    throw new W2(e, "Object", s);
}
function ci(s, e) {
  if (typeof s != "string")
    throw new W2(e, "string", s);
}
const Xr = pO === "win32";
function tt(s) {
  return s === zi || s === $n;
}
function FC(s) {
  return s === zi;
}
function la(s) {
  return s >= _O && s <= CO || s >= bO && s <= wO;
}
function Sp(s, e, t, i) {
  let n = "", o = 0, r = -1, a = 0, l = 0;
  for (let c = 0; c <= s.length; ++c) {
    if (c < s.length)
      l = s.charCodeAt(c);
    else {
      if (i(l))
        break;
      l = zi;
    }
    if (i(l)) {
      if (!(r === c - 1 || a === 1)) if (a === 2) {
        if (n.length < 2 || o !== 2 || n.charCodeAt(n.length - 1) !== Oa || n.charCodeAt(n.length - 2) !== Oa) {
          if (n.length > 2) {
            const h = n.lastIndexOf(t);
            h === -1 ? (n = "", o = 0) : (n = n.slice(0, h), o = n.length - 1 - n.lastIndexOf(t)), r = c, a = 0;
            continue;
          } else if (n.length !== 0) {
            n = "", o = 0, r = c, a = 0;
            continue;
          }
        }
        e && (n += n.length > 0 ? `${t}..` : "..", o = 2);
      } else
        n.length > 0 ? n += `${t}${s.slice(r + 1, c)}` : n = s.slice(r + 1, c), o = c - r - 1;
      r = c, a = 0;
    } else l === Oa && a !== -1 ? ++a : a = -1;
  }
  return n;
}
function SO(s) {
  return s ? `${s[0] === "." ? "" : "."}${s}` : "";
}
function V2(s, e) {
  yO(e, "pathObject");
  const t = e.dir || e.root, i = e.base || `${e.name || ""}${SO(e.ext)}`;
  return t ? t === e.root ? `${t}${i}` : `${t}${s}${i}` : i;
}
const bn = {
  // path.resolve([from ...], to)
  resolve(...s) {
    let e = "", t = "", i = !1;
    for (let n = s.length - 1; n >= -1; n--) {
      let o;
      if (n >= 0) {
        if (o = s[n], ci(o, `paths[${n}]`), o.length === 0)
          continue;
      } else e.length === 0 ? o = yp() : (o = OC[`=${e}`] || yp(), (o === void 0 || o.slice(0, 2).toLowerCase() !== e.toLowerCase() && o.charCodeAt(2) === $n) && (o = `${e}\\`));
      const r = o.length;
      let a = 0, l = "", c = !1;
      const h = o.charCodeAt(0);
      if (r === 1)
        tt(h) && (a = 1, c = !0);
      else if (tt(h))
        if (c = !0, tt(o.charCodeAt(1))) {
          let d = 2, u = d;
          for (; d < r && !tt(o.charCodeAt(d)); )
            d++;
          if (d < r && d !== u) {
            const f = o.slice(u, d);
            for (u = d; d < r && tt(o.charCodeAt(d)); )
              d++;
            if (d < r && d !== u) {
              for (u = d; d < r && !tt(o.charCodeAt(d)); )
                d++;
              (d === r || d !== u) && (l = `\\\\${f}\\${o.slice(u, d)}`, a = d);
            }
          }
        } else
          a = 1;
      else la(h) && o.charCodeAt(1) === aa && (l = o.slice(0, 2), a = 2, r > 2 && tt(o.charCodeAt(2)) && (c = !0, a = 3));
      if (l.length > 0)
        if (e.length > 0) {
          if (l.toLowerCase() !== e.toLowerCase())
            continue;
        } else
          e = l;
      if (i) {
        if (e.length > 0)
          break;
      } else if (t = `${o.slice(a)}\\${t}`, i = c, c && e.length > 0)
        break;
    }
    return t = Sp(t, !i, "\\", tt), i ? `${e}\\${t}` : `${e}${t}` || ".";
  },
  normalize(s) {
    ci(s, "path");
    const e = s.length;
    if (e === 0)
      return ".";
    let t = 0, i, n = !1;
    const o = s.charCodeAt(0);
    if (e === 1)
      return FC(o) ? "\\" : s;
    if (tt(o))
      if (n = !0, tt(s.charCodeAt(1))) {
        let a = 2, l = a;
        for (; a < e && !tt(s.charCodeAt(a)); )
          a++;
        if (a < e && a !== l) {
          const c = s.slice(l, a);
          for (l = a; a < e && tt(s.charCodeAt(a)); )
            a++;
          if (a < e && a !== l) {
            for (l = a; a < e && !tt(s.charCodeAt(a)); )
              a++;
            if (a === e)
              return `\\\\${c}\\${s.slice(l)}\\`;
            a !== l && (i = `\\\\${c}\\${s.slice(l, a)}`, t = a);
          }
        }
      } else
        t = 1;
    else la(o) && s.charCodeAt(1) === aa && (i = s.slice(0, 2), t = 2, e > 2 && tt(s.charCodeAt(2)) && (n = !0, t = 3));
    let r = t < e ? Sp(s.slice(t), !n, "\\", tt) : "";
    return r.length === 0 && !n && (r = "."), r.length > 0 && tt(s.charCodeAt(e - 1)) && (r += "\\"), i === void 0 ? n ? `\\${r}` : r : n ? `${i}\\${r}` : `${i}${r}`;
  },
  isAbsolute(s) {
    ci(s, "path");
    const e = s.length;
    if (e === 0)
      return !1;
    const t = s.charCodeAt(0);
    return tt(t) || // Possible device root
    e > 2 && la(t) && s.charCodeAt(1) === aa && tt(s.charCodeAt(2));
  },
  join(...s) {
    if (s.length === 0)
      return ".";
    let e, t;
    for (let o = 0; o < s.length; ++o) {
      const r = s[o];
      ci(r, "path"), r.length > 0 && (e === void 0 ? e = t = r : e += `\\${r}`);
    }
    if (e === void 0)
      return ".";
    let i = !0, n = 0;
    if (typeof t == "string" && tt(t.charCodeAt(0))) {
      ++n;
      const o = t.length;
      o > 1 && tt(t.charCodeAt(1)) && (++n, o > 2 && (tt(t.charCodeAt(2)) ? ++n : i = !1));
    }
    if (i) {
      for (; n < e.length && tt(e.charCodeAt(n)); )
        n++;
      n >= 2 && (e = `\\${e.slice(n)}`);
    }
    return bn.normalize(e);
  },
  // It will solve the relative path from `from` to `to`, for instance:
  //  from = 'C:\\orandea\\test\\aaa'
  //  to = 'C:\\orandea\\impl\\bbb'
  // The output of the function should be: '..\\..\\impl\\bbb'
  relative(s, e) {
    if (ci(s, "from"), ci(e, "to"), s === e)
      return "";
    const t = bn.resolve(s), i = bn.resolve(e);
    if (t === i || (s = t.toLowerCase(), e = i.toLowerCase(), s === e))
      return "";
    let n = 0;
    for (; n < s.length && s.charCodeAt(n) === $n; )
      n++;
    let o = s.length;
    for (; o - 1 > n && s.charCodeAt(o - 1) === $n; )
      o--;
    const r = o - n;
    let a = 0;
    for (; a < e.length && e.charCodeAt(a) === $n; )
      a++;
    let l = e.length;
    for (; l - 1 > a && e.charCodeAt(l - 1) === $n; )
      l--;
    const c = l - a, h = r < c ? r : c;
    let d = -1, u = 0;
    for (; u < h; u++) {
      const g = s.charCodeAt(n + u);
      if (g !== e.charCodeAt(a + u))
        break;
      g === $n && (d = u);
    }
    if (u !== h) {
      if (d === -1)
        return i;
    } else {
      if (c > h) {
        if (e.charCodeAt(a + u) === $n)
          return i.slice(a + u + 1);
        if (u === 2)
          return i.slice(a + u);
      }
      r > h && (s.charCodeAt(n + u) === $n ? d = u : u === 2 && (d = 3)), d === -1 && (d = 0);
    }
    let f = "";
    for (u = n + d + 1; u <= o; ++u)
      (u === o || s.charCodeAt(u) === $n) && (f += f.length === 0 ? ".." : "\\..");
    return a += d, f.length > 0 ? `${f}${i.slice(a, l)}` : (i.charCodeAt(a) === $n && ++a, i.slice(a, l));
  },
  toNamespacedPath(s) {
    if (typeof s != "string" || s.length === 0)
      return s;
    const e = bn.resolve(s);
    if (e.length <= 2)
      return s;
    if (e.charCodeAt(0) === $n) {
      if (e.charCodeAt(1) === $n) {
        const t = e.charCodeAt(2);
        if (t !== vO && t !== Oa)
          return `\\\\?\\UNC\\${e.slice(2)}`;
      }
    } else if (la(e.charCodeAt(0)) && e.charCodeAt(1) === aa && e.charCodeAt(2) === $n)
      return `\\\\?\\${e}`;
    return s;
  },
  dirname(s) {
    ci(s, "path");
    const e = s.length;
    if (e === 0)
      return ".";
    let t = -1, i = 0;
    const n = s.charCodeAt(0);
    if (e === 1)
      return tt(n) ? s : ".";
    if (tt(n)) {
      if (t = i = 1, tt(s.charCodeAt(1))) {
        let a = 2, l = a;
        for (; a < e && !tt(s.charCodeAt(a)); )
          a++;
        if (a < e && a !== l) {
          for (l = a; a < e && tt(s.charCodeAt(a)); )
            a++;
          if (a < e && a !== l) {
            for (l = a; a < e && !tt(s.charCodeAt(a)); )
              a++;
            if (a === e)
              return s;
            a !== l && (t = i = a + 1);
          }
        }
      }
    } else la(n) && s.charCodeAt(1) === aa && (t = e > 2 && tt(s.charCodeAt(2)) ? 3 : 2, i = t);
    let o = -1, r = !0;
    for (let a = e - 1; a >= i; --a)
      if (tt(s.charCodeAt(a))) {
        if (!r) {
          o = a;
          break;
        }
      } else
        r = !1;
    if (o === -1) {
      if (t === -1)
        return ".";
      o = t;
    }
    return s.slice(0, o);
  },
  basename(s, e) {
    e !== void 0 && ci(e, "suffix"), ci(s, "path");
    let t = 0, i = -1, n = !0, o;
    if (s.length >= 2 && la(s.charCodeAt(0)) && s.charCodeAt(1) === aa && (t = 2), e !== void 0 && e.length > 0 && e.length <= s.length) {
      if (e === s)
        return "";
      let r = e.length - 1, a = -1;
      for (o = s.length - 1; o >= t; --o) {
        const l = s.charCodeAt(o);
        if (tt(l)) {
          if (!n) {
            t = o + 1;
            break;
          }
        } else
          a === -1 && (n = !1, a = o + 1), r >= 0 && (l === e.charCodeAt(r) ? --r === -1 && (i = o) : (r = -1, i = a));
      }
      return t === i ? i = a : i === -1 && (i = s.length), s.slice(t, i);
    }
    for (o = s.length - 1; o >= t; --o)
      if (tt(s.charCodeAt(o))) {
        if (!n) {
          t = o + 1;
          break;
        }
      } else i === -1 && (n = !1, i = o + 1);
    return i === -1 ? "" : s.slice(t, i);
  },
  extname(s) {
    ci(s, "path");
    let e = 0, t = -1, i = 0, n = -1, o = !0, r = 0;
    s.length >= 2 && s.charCodeAt(1) === aa && la(s.charCodeAt(0)) && (e = i = 2);
    for (let a = s.length - 1; a >= e; --a) {
      const l = s.charCodeAt(a);
      if (tt(l)) {
        if (!o) {
          i = a + 1;
          break;
        }
        continue;
      }
      n === -1 && (o = !1, n = a + 1), l === Oa ? t === -1 ? t = a : r !== 1 && (r = 1) : t !== -1 && (r = -1);
    }
    return t === -1 || n === -1 || // We saw a non-dot character immediately before the dot
    r === 0 || // The (right-most) trimmed path component is exactly '..'
    r === 1 && t === n - 1 && t === i + 1 ? "" : s.slice(t, n);
  },
  format: V2.bind(null, "\\"),
  parse(s) {
    ci(s, "path");
    const e = { root: "", dir: "", base: "", ext: "", name: "" };
    if (s.length === 0)
      return e;
    const t = s.length;
    let i = 0, n = s.charCodeAt(0);
    if (t === 1)
      return tt(n) ? (e.root = e.dir = s, e) : (e.base = e.name = s, e);
    if (tt(n)) {
      if (i = 1, tt(s.charCodeAt(1))) {
        let d = 2, u = d;
        for (; d < t && !tt(s.charCodeAt(d)); )
          d++;
        if (d < t && d !== u) {
          for (u = d; d < t && tt(s.charCodeAt(d)); )
            d++;
          if (d < t && d !== u) {
            for (u = d; d < t && !tt(s.charCodeAt(d)); )
              d++;
            d === t ? i = d : d !== u && (i = d + 1);
          }
        }
      }
    } else if (la(n) && s.charCodeAt(1) === aa) {
      if (t <= 2)
        return e.root = e.dir = s, e;
      if (i = 2, tt(s.charCodeAt(2))) {
        if (t === 3)
          return e.root = e.dir = s, e;
        i = 3;
      }
    }
    i > 0 && (e.root = s.slice(0, i));
    let o = -1, r = i, a = -1, l = !0, c = s.length - 1, h = 0;
    for (; c >= i; --c) {
      if (n = s.charCodeAt(c), tt(n)) {
        if (!l) {
          r = c + 1;
          break;
        }
        continue;
      }
      a === -1 && (l = !1, a = c + 1), n === Oa ? o === -1 ? o = c : h !== 1 && (h = 1) : o !== -1 && (h = -1);
    }
    return a !== -1 && (o === -1 || // We saw a non-dot character immediately before the dot
    h === 0 || // The (right-most) trimmed path component is exactly '..'
    h === 1 && o === a - 1 && o === r + 1 ? e.base = e.name = s.slice(r, a) : (e.name = s.slice(r, o), e.base = s.slice(r, a), e.ext = s.slice(o, a))), r > 0 && r !== i ? e.dir = s.slice(0, r - 1) : e.dir = e.root, e;
  },
  sep: "\\",
  delimiter: ";",
  win32: null,
  posix: null
}, LO = (() => {
  if (Xr) {
    const s = /\\/g;
    return () => {
      const e = yp().replace(s, "/");
      return e.slice(e.indexOf("/"));
    };
  }
  return () => yp();
})(), Kt = {
  // path.resolve([from ...], to)
  resolve(...s) {
    let e = "", t = !1;
    for (let i = s.length - 1; i >= -1 && !t; i--) {
      const n = i >= 0 ? s[i] : LO();
      ci(n, `paths[${i}]`), n.length !== 0 && (e = `${n}/${e}`, t = n.charCodeAt(0) === zi);
    }
    return e = Sp(e, !t, "/", FC), t ? `/${e}` : e.length > 0 ? e : ".";
  },
  normalize(s) {
    if (ci(s, "path"), s.length === 0)
      return ".";
    const e = s.charCodeAt(0) === zi, t = s.charCodeAt(s.length - 1) === zi;
    return s = Sp(s, !e, "/", FC), s.length === 0 ? e ? "/" : t ? "./" : "." : (t && (s += "/"), e ? `/${s}` : s);
  },
  isAbsolute(s) {
    return ci(s, "path"), s.length > 0 && s.charCodeAt(0) === zi;
  },
  join(...s) {
    if (s.length === 0)
      return ".";
    let e;
    for (let t = 0; t < s.length; ++t) {
      const i = s[t];
      ci(i, "path"), i.length > 0 && (e === void 0 ? e = i : e += `/${i}`);
    }
    return e === void 0 ? "." : Kt.normalize(e);
  },
  relative(s, e) {
    if (ci(s, "from"), ci(e, "to"), s === e || (s = Kt.resolve(s), e = Kt.resolve(e), s === e))
      return "";
    const t = 1, i = s.length, n = i - t, o = 1, r = e.length - o, a = n < r ? n : r;
    let l = -1, c = 0;
    for (; c < a; c++) {
      const d = s.charCodeAt(t + c);
      if (d !== e.charCodeAt(o + c))
        break;
      d === zi && (l = c);
    }
    if (c === a)
      if (r > a) {
        if (e.charCodeAt(o + c) === zi)
          return e.slice(o + c + 1);
        if (c === 0)
          return e.slice(o + c);
      } else n > a && (s.charCodeAt(t + c) === zi ? l = c : c === 0 && (l = 0));
    let h = "";
    for (c = t + l + 1; c <= i; ++c)
      (c === i || s.charCodeAt(c) === zi) && (h += h.length === 0 ? ".." : "/..");
    return `${h}${e.slice(o + l)}`;
  },
  toNamespacedPath(s) {
    return s;
  },
  dirname(s) {
    if (ci(s, "path"), s.length === 0)
      return ".";
    const e = s.charCodeAt(0) === zi;
    let t = -1, i = !0;
    for (let n = s.length - 1; n >= 1; --n)
      if (s.charCodeAt(n) === zi) {
        if (!i) {
          t = n;
          break;
        }
      } else
        i = !1;
    return t === -1 ? e ? "/" : "." : e && t === 1 ? "//" : s.slice(0, t);
  },
  basename(s, e) {
    e !== void 0 && ci(e, "ext"), ci(s, "path");
    let t = 0, i = -1, n = !0, o;
    if (e !== void 0 && e.length > 0 && e.length <= s.length) {
      if (e === s)
        return "";
      let r = e.length - 1, a = -1;
      for (o = s.length - 1; o >= 0; --o) {
        const l = s.charCodeAt(o);
        if (l === zi) {
          if (!n) {
            t = o + 1;
            break;
          }
        } else
          a === -1 && (n = !1, a = o + 1), r >= 0 && (l === e.charCodeAt(r) ? --r === -1 && (i = o) : (r = -1, i = a));
      }
      return t === i ? i = a : i === -1 && (i = s.length), s.slice(t, i);
    }
    for (o = s.length - 1; o >= 0; --o)
      if (s.charCodeAt(o) === zi) {
        if (!n) {
          t = o + 1;
          break;
        }
      } else i === -1 && (n = !1, i = o + 1);
    return i === -1 ? "" : s.slice(t, i);
  },
  extname(s) {
    ci(s, "path");
    let e = -1, t = 0, i = -1, n = !0, o = 0;
    for (let r = s.length - 1; r >= 0; --r) {
      const a = s.charCodeAt(r);
      if (a === zi) {
        if (!n) {
          t = r + 1;
          break;
        }
        continue;
      }
      i === -1 && (n = !1, i = r + 1), a === Oa ? e === -1 ? e = r : o !== 1 && (o = 1) : e !== -1 && (o = -1);
    }
    return e === -1 || i === -1 || // We saw a non-dot character immediately before the dot
    o === 0 || // The (right-most) trimmed path component is exactly '..'
    o === 1 && e === i - 1 && e === t + 1 ? "" : s.slice(e, i);
  },
  format: V2.bind(null, "/"),
  parse(s) {
    ci(s, "path");
    const e = { root: "", dir: "", base: "", ext: "", name: "" };
    if (s.length === 0)
      return e;
    const t = s.charCodeAt(0) === zi;
    let i;
    t ? (e.root = "/", i = 1) : i = 0;
    let n = -1, o = 0, r = -1, a = !0, l = s.length - 1, c = 0;
    for (; l >= i; --l) {
      const h = s.charCodeAt(l);
      if (h === zi) {
        if (!a) {
          o = l + 1;
          break;
        }
        continue;
      }
      r === -1 && (a = !1, r = l + 1), h === Oa ? n === -1 ? n = l : c !== 1 && (c = 1) : n !== -1 && (c = -1);
    }
    if (r !== -1) {
      const h = o === 0 && t ? 1 : o;
      n === -1 || // We saw a non-dot character immediately before the dot
      c === 0 || // The (right-most) trimmed path component is exactly '..'
      c === 1 && n === r - 1 && n === o + 1 ? e.base = e.name = s.slice(h, r) : (e.name = s.slice(h, n), e.base = s.slice(h, r), e.ext = s.slice(n, r));
    }
    return o > 0 ? e.dir = s.slice(0, o - 1) : t && (e.dir = "/"), e;
  },
  sep: "/",
  delimiter: ":",
  win32: null,
  posix: null
};
Kt.win32 = bn.win32 = bn;
Kt.posix = bn.posix = Kt;
const H2 = Xr ? bn.normalize : Kt.normalize, kO = Xr ? bn.join : Kt.join, xO = Xr ? bn.resolve : Kt.resolve, DO = Xr ? bn.relative : Kt.relative, EO = Xr ? bn.dirname : Kt.dirname, z2 = Xr ? bn.basename : Kt.basename, IO = Xr ? bn.extname : Kt.extname, Fa = Xr ? bn.sep : Kt.sep, NO = /^\w[\w\d+.-]*$/, TO = /^\//, MO = /^\/\//;
function RO(s, e) {
  if (!s.scheme && e)
    throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${s.authority}", path: "${s.path}", query: "${s.query}", fragment: "${s.fragment}"}`);
  if (s.scheme && !NO.test(s.scheme))
    throw new Error("[UriError]: Scheme contains illegal characters.");
  if (s.path) {
    if (s.authority) {
      if (!TO.test(s.path))
        throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
    } else if (MO.test(s.path))
      throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
  }
}
function AO(s, e) {
  return !s && !e ? "file" : s;
}
function PO(s, e) {
  switch (s) {
    case "https":
    case "http":
    case "file":
      e ? e[0] !== Qs && (e = Qs + e) : e = Qs;
      break;
  }
  return e;
}
const zt = "", Qs = "/", OO = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
class Te {
  static isUri(e) {
    return e instanceof Te ? !0 : e ? typeof e.authority == "string" && typeof e.fragment == "string" && typeof e.path == "string" && typeof e.query == "string" && typeof e.scheme == "string" && typeof e.fsPath == "string" && typeof e.with == "function" && typeof e.toString == "function" : !1;
  }
  /**
   * @internal
   */
  constructor(e, t, i, n, o, r = !1) {
    typeof e == "object" ? (this.scheme = e.scheme || zt, this.authority = e.authority || zt, this.path = e.path || zt, this.query = e.query || zt, this.fragment = e.fragment || zt) : (this.scheme = AO(e, r), this.authority = t || zt, this.path = PO(this.scheme, i || zt), this.query = n || zt, this.fragment = o || zt, RO(this, r));
  }
  // ---- filesystem path -----------------------
  /**
   * Returns a string representing the corresponding file system path of this URI.
   * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
   * platform specific path separator.
   *
   * * Will *not* validate the path for invalid characters and semantics.
   * * Will *not* look at the scheme of this URI.
   * * The result shall *not* be used for display purposes but for accessing a file on disk.
   *
   *
   * The *difference* to `URI#path` is the use of the platform specific separator and the handling
   * of UNC paths. See the below sample of a file-uri with an authority (UNC path).
   *
   * ```ts
      const u = URI.parse('file://server/c$/folder/file.txt')
      u.authority === 'server'
      u.path === '/shares/c$/file.txt'
      u.fsPath === '\\server\c$\folder\file.txt'
  ```
   *
   * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,
   * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working
   * with URIs that represent files on disk (`file` scheme).
   */
  get fsPath() {
    return Lp(this, !1);
  }
  // ---- modify to new -------------------------
  with(e) {
    if (!e)
      return this;
    let { scheme: t, authority: i, path: n, query: o, fragment: r } = e;
    return t === void 0 ? t = this.scheme : t === null && (t = zt), i === void 0 ? i = this.authority : i === null && (i = zt), n === void 0 ? n = this.path : n === null && (n = zt), o === void 0 ? o = this.query : o === null && (o = zt), r === void 0 ? r = this.fragment : r === null && (r = zt), t === this.scheme && i === this.authority && n === this.path && o === this.query && r === this.fragment ? this : new Gc(t, i, n, o, r);
  }
  // ---- parse & validate ------------------------
  /**
   * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,
   * `file:///usr/home`, or `scheme:with/path`.
   *
   * @param value A string which represents an URI (see `URI#toString`).
   */
  static parse(e, t = !1) {
    const i = OO.exec(e);
    return i ? new Gc(i[2] || zt, Jg(i[4] || zt), Jg(i[5] || zt), Jg(i[7] || zt), Jg(i[9] || zt), t) : new Gc(zt, zt, zt, zt, zt);
  }
  /**
   * Creates a new URI from a file system path, e.g. `c:\my\files`,
   * `/usr/home`, or `\\server\share\some\path`.
   *
   * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument
   * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**
   * `URI.parse('file://' + path)` because the path might contain characters that are
   * interpreted (# and ?). See the following sample:
   * ```ts
  const good = URI.file('/coding/c#/project1');
  good.scheme === 'file';
  good.path === '/coding/c#/project1';
  good.fragment === '';
  const bad = URI.parse('file://' + '/coding/c#/project1');
  bad.scheme === 'file';
  bad.path === '/coding/c'; // path is now broken
  bad.fragment === '/project1';
  ```
   *
   * @param path A file system path (see `URI#fsPath`)
   */
  static file(e) {
    let t = zt;
    if (Fn && (e = e.replace(/\\/g, Qs)), e[0] === Qs && e[1] === Qs) {
      const i = e.indexOf(Qs, 2);
      i === -1 ? (t = e.substring(2), e = Qs) : (t = e.substring(2, i), e = e.substring(i) || Qs);
    }
    return new Gc("file", t, e, zt, zt);
  }
  /**
   * Creates new URI from uri components.
   *
   * Unless `strict` is `true` the scheme is defaults to be `file`. This function performs
   * validation and should be used for untrusted uri components retrieved from storage,
   * user input, command arguments etc
   */
  static from(e, t) {
    return new Gc(e.scheme, e.authority, e.path, e.query, e.fragment, t);
  }
  /**
   * Join a URI path with path fragments and normalizes the resulting path.
   *
   * @param uri The input URI.
   * @param pathFragment The path fragment to add to the URI path.
   * @returns The resulting URI.
   */
  static joinPath(e, ...t) {
    if (!e.path)
      throw new Error("[UriError]: cannot call joinPath on URI without path");
    let i;
    return Fn && e.scheme === "file" ? i = Te.file(bn.join(Lp(e, !0), ...t)).path : i = Kt.join(e.path, ...t), e.with({ path: i });
  }
  // ---- printing/externalize ---------------------------
  /**
   * Creates a string representation for this URI. It's guaranteed that calling
   * `URI.parse` with the result of this function creates an URI which is equal
   * to this URI.
   *
   * * The result shall *not* be used for display purposes but for externalization or transport.
   * * The result will be encoded using the percentage encoding and encoding happens mostly
   * ignore the scheme-specific encoding rules.
   *
   * @param skipEncoding Do not encode the result, default is `false`
   */
  toString(e = !1) {
    return BC(this, e);
  }
  toJSON() {
    return this;
  }
  static revive(e) {
    if (e) {
      if (e instanceof Te)
        return e;
      {
        const t = new Gc(e);
        return t._formatted = e.external ?? null, t._fsPath = e._sep === U2 ? e.fsPath ?? null : null, t;
      }
    } else return e;
  }
}
const U2 = Fn ? 1 : void 0;
let Gc = class extends Te {
  constructor() {
    super(...arguments), this._formatted = null, this._fsPath = null;
  }
  get fsPath() {
    return this._fsPath || (this._fsPath = Lp(this, !1)), this._fsPath;
  }
  toString(e = !1) {
    return e ? BC(this, !0) : (this._formatted || (this._formatted = BC(this, !1)), this._formatted);
  }
  toJSON() {
    const e = {
      $mid: 1
      /* MarshalledId.Uri */
    };
    return this._fsPath && (e.fsPath = this._fsPath, e._sep = U2), this._formatted && (e.external = this._formatted), this.path && (e.path = this.path), this.scheme && (e.scheme = this.scheme), this.authority && (e.authority = this.authority), this.query && (e.query = this.query), this.fragment && (e.fragment = this.fragment), e;
  }
};
const $2 = {
  58: "%3A",
  // gen-delims
  47: "%2F",
  63: "%3F",
  35: "%23",
  91: "%5B",
  93: "%5D",
  64: "%40",
  33: "%21",
  // sub-delims
  36: "%24",
  38: "%26",
  39: "%27",
  40: "%28",
  41: "%29",
  42: "%2A",
  43: "%2B",
  44: "%2C",
  59: "%3B",
  61: "%3D",
  32: "%20"
};
function rD(s, e, t) {
  let i, n = -1;
  for (let o = 0; o < s.length; o++) {
    const r = s.charCodeAt(o);
    if (r >= 97 && r <= 122 || r >= 65 && r <= 90 || r >= 48 && r <= 57 || r === 45 || r === 46 || r === 95 || r === 126 || e && r === 47 || t && r === 91 || t && r === 93 || t && r === 58)
      n !== -1 && (i += encodeURIComponent(s.substring(n, o)), n = -1), i !== void 0 && (i += s.charAt(o));
    else {
      i === void 0 && (i = s.substr(0, o));
      const a = $2[r];
      a !== void 0 ? (n !== -1 && (i += encodeURIComponent(s.substring(n, o)), n = -1), i += a) : n === -1 && (n = o);
    }
  }
  return n !== -1 && (i += encodeURIComponent(s.substring(n))), i !== void 0 ? i : s;
}
function FO(s) {
  let e;
  for (let t = 0; t < s.length; t++) {
    const i = s.charCodeAt(t);
    i === 35 || i === 63 ? (e === void 0 && (e = s.substr(0, t)), e += $2[i]) : e !== void 0 && (e += s[t]);
  }
  return e !== void 0 ? e : s;
}
function Lp(s, e) {
  let t;
  return s.authority && s.path.length > 1 && s.scheme === "file" ? t = `//${s.authority}${s.path}` : s.path.charCodeAt(0) === 47 && (s.path.charCodeAt(1) >= 65 && s.path.charCodeAt(1) <= 90 || s.path.charCodeAt(1) >= 97 && s.path.charCodeAt(1) <= 122) && s.path.charCodeAt(2) === 58 ? e ? t = s.path.substr(1) : t = s.path[1].toLowerCase() + s.path.substr(2) : t = s.path, Fn && (t = t.replace(/\//g, "\\")), t;
}
function BC(s, e) {
  const t = e ? FO : rD;
  let i = "", { scheme: n, authority: o, path: r, query: a, fragment: l } = s;
  if (n && (i += n, i += ":"), (o || n === "file") && (i += Qs, i += Qs), o) {
    let c = o.indexOf("@");
    if (c !== -1) {
      const h = o.substr(0, c);
      o = o.substr(c + 1), c = h.lastIndexOf(":"), c === -1 ? i += t(h, !1, !1) : (i += t(h.substr(0, c), !1, !1), i += ":", i += t(h.substr(c + 1), !1, !0)), i += "@";
    }
    o = o.toLowerCase(), c = o.lastIndexOf(":"), c === -1 ? i += t(o, !1, !0) : (i += t(o.substr(0, c), !1, !0), i += o.substr(c));
  }
  if (r) {
    if (r.length >= 3 && r.charCodeAt(0) === 47 && r.charCodeAt(2) === 58) {
      const c = r.charCodeAt(1);
      c >= 65 && c <= 90 && (r = `/${String.fromCharCode(c + 32)}:${r.substr(3)}`);
    } else if (r.length >= 2 && r.charCodeAt(1) === 58) {
      const c = r.charCodeAt(0);
      c >= 65 && c <= 90 && (r = `${String.fromCharCode(c + 32)}:${r.substr(2)}`);
    }
    i += t(r, !0, !1);
  }
  return a && (i += "?", i += t(a, !1, !1)), l && (i += "#", i += e ? l : rD(l, !1, !1)), i;
}
function K2(s) {
  try {
    return decodeURIComponent(s);
  } catch {
    return s.length > 3 ? s.substr(0, 3) + K2(s.substr(3)) : s;
  }
}
const aD = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
function Jg(s) {
  return s.match(aD) ? s.replace(aD, (e) => K2(e)) : s;
}
let V = class ml {
  constructor(e, t) {
    this.lineNumber = e, this.column = t;
  }
  /**
   * Create a new position from this position.
   *
   * @param newLineNumber new line number
   * @param newColumn new column
   */
  with(e = this.lineNumber, t = this.column) {
    return e === this.lineNumber && t === this.column ? this : new ml(e, t);
  }
  /**
   * Derive a new position from this position.
   *
   * @param deltaLineNumber line number delta
   * @param deltaColumn column delta
   */
  delta(e = 0, t = 0) {
    return this.with(this.lineNumber + e, this.column + t);
  }
  /**
   * Test if this position equals other position
   */
  equals(e) {
    return ml.equals(this, e);
  }
  /**
   * Test if position `a` equals position `b`
   */
  static equals(e, t) {
    return !e && !t ? !0 : !!e && !!t && e.lineNumber === t.lineNumber && e.column === t.column;
  }
  /**
   * Test if this position is before other position.
   * If the two positions are equal, the result will be false.
   */
  isBefore(e) {
    return ml.isBefore(this, e);
  }
  /**
   * Test if position `a` is before position `b`.
   * If the two positions are equal, the result will be false.
   */
  static isBefore(e, t) {
    return e.lineNumber < t.lineNumber ? !0 : t.lineNumber < e.lineNumber ? !1 : e.column < t.column;
  }
  /**
   * Test if this position is before other position.
   * If the two positions are equal, the result will be true.
   */
  isBeforeOrEqual(e) {
    return ml.isBeforeOrEqual(this, e);
  }
  /**
   * Test if position `a` is before position `b`.
   * If the two positions are equal, the result will be true.
   */
  static isBeforeOrEqual(e, t) {
    return e.lineNumber < t.lineNumber ? !0 : t.lineNumber < e.lineNumber ? !1 : e.column <= t.column;
  }
  /**
   * A function that compares positions, useful for sorting
   */
  static compare(e, t) {
    const i = e.lineNumber | 0, n = t.lineNumber | 0;
    if (i === n) {
      const o = e.column | 0, r = t.column | 0;
      return o - r;
    }
    return i - n;
  }
  /**
   * Clone this position.
   */
  clone() {
    return new ml(this.lineNumber, this.column);
  }
  /**
   * Convert to a human-readable representation.
   */
  toString() {
    return "(" + this.lineNumber + "," + this.column + ")";
  }
  // ---
  /**
   * Create a `Position` from an `IPosition`.
   */
  static lift(e) {
    return new ml(e.lineNumber, e.column);
  }
  /**
   * Test if `obj` is an `IPosition`.
   */
  static isIPosition(e) {
    return e && typeof e.lineNumber == "number" && typeof e.column == "number";
  }
  toJSON() {
    return {
      lineNumber: this.lineNumber,
      column: this.column
    };
  }
}, R = class bi {
  constructor(e, t, i, n) {
    e > i || e === i && t > n ? (this.startLineNumber = i, this.startColumn = n, this.endLineNumber = e, this.endColumn = t) : (this.startLineNumber = e, this.startColumn = t, this.endLineNumber = i, this.endColumn = n);
  }
  /**
   * Test if this range is empty.
   */
  isEmpty() {
    return bi.isEmpty(this);
  }
  /**
   * Test if `range` is empty.
   */
  static isEmpty(e) {
    return e.startLineNumber === e.endLineNumber && e.startColumn === e.endColumn;
  }
  /**
   * Test if position is in this range. If the position is at the edges, will return true.
   */
  containsPosition(e) {
    return bi.containsPosition(this, e);
  }
  /**
   * Test if `position` is in `range`. If the position is at the edges, will return true.
   */
  static containsPosition(e, t) {
    return !(t.lineNumber < e.startLineNumber || t.lineNumber > e.endLineNumber || t.lineNumber === e.startLineNumber && t.column < e.startColumn || t.lineNumber === e.endLineNumber && t.column > e.endColumn);
  }
  /**
   * Test if `position` is in `range`. If the position is at the edges, will return false.
   * @internal
   */
  static strictContainsPosition(e, t) {
    return !(t.lineNumber < e.startLineNumber || t.lineNumber > e.endLineNumber || t.lineNumber === e.startLineNumber && t.column <= e.startColumn || t.lineNumber === e.endLineNumber && t.column >= e.endColumn);
  }
  /**
   * Test if range is in this range. If the range is equal to this range, will return true.
   */
  containsRange(e) {
    return bi.containsRange(this, e);
  }
  /**
   * Test if `otherRange` is in `range`. If the ranges are equal, will return true.
   */
  static containsRange(e, t) {
    return !(t.startLineNumber < e.startLineNumber || t.endLineNumber < e.startLineNumber || t.startLineNumber > e.endLineNumber || t.endLineNumber > e.endLineNumber || t.startLineNumber === e.startLineNumber && t.startColumn < e.startColumn || t.endLineNumber === e.endLineNumber && t.endColumn > e.endColumn);
  }
  /**
   * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.
   */
  strictContainsRange(e) {
    return bi.strictContainsRange(this, e);
  }
  /**
   * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.
   */
  static strictContainsRange(e, t) {
    return !(t.startLineNumber < e.startLineNumber || t.endLineNumber < e.startLineNumber || t.startLineNumber > e.endLineNumber || t.endLineNumber > e.endLineNumber || t.startLineNumber === e.startLineNumber && t.startColumn <= e.startColumn || t.endLineNumber === e.endLineNumber && t.endColumn >= e.endColumn);
  }
  /**
   * A reunion of the two ranges.
   * The smallest position will be used as the start point, and the largest one as the end point.
   */
  plusRange(e) {
    return bi.plusRange(this, e);
  }
  /**
   * A reunion of the two ranges.
   * The smallest position will be used as the start point, and the largest one as the end point.
   */
  static plusRange(e, t) {
    let i, n, o, r;
    return t.startLineNumber < e.startLineNumber ? (i = t.startLineNumber, n = t.startColumn) : t.startLineNumber === e.startLineNumber ? (i = t.startLineNumber, n = Math.min(t.startColumn, e.startColumn)) : (i = e.startLineNumber, n = e.startColumn), t.endLineNumber > e.endLineNumber ? (o = t.endLineNumber, r = t.endColumn) : t.endLineNumber === e.endLineNumber ? (o = t.endLineNumber, r = Math.max(t.endColumn, e.endColumn)) : (o = e.endLineNumber, r = e.endColumn), new bi(i, n, o, r);
  }
  /**
   * A intersection of the two ranges.
   */
  intersectRanges(e) {
    return bi.intersectRanges(this, e);
  }
  /**
   * A intersection of the two ranges.
   */
  static intersectRanges(e, t) {
    let i = e.startLineNumber, n = e.startColumn, o = e.endLineNumber, r = e.endColumn;
    const a = t.startLineNumber, l = t.startColumn, c = t.endLineNumber, h = t.endColumn;
    return i < a ? (i = a, n = l) : i === a && (n = Math.max(n, l)), o > c ? (o = c, r = h) : o === c && (r = Math.min(r, h)), i > o || i === o && n > r ? null : new bi(i, n, o, r);
  }
  /**
   * Test if this range equals other.
   */
  equalsRange(e) {
    return bi.equalsRange(this, e);
  }
  /**
   * Test if range `a` equals `b`.
   */
  static equalsRange(e, t) {
    return !e && !t ? !0 : !!e && !!t && e.startLineNumber === t.startLineNumber && e.startColumn === t.startColumn && e.endLineNumber === t.endLineNumber && e.endColumn === t.endColumn;
  }
  /**
   * Return the end position (which will be after or equal to the start position)
   */
  getEndPosition() {
    return bi.getEndPosition(this);
  }
  /**
   * Return the end position (which will be after or equal to the start position)
   */
  static getEndPosition(e) {
    return new V(e.endLineNumber, e.endColumn);
  }
  /**
   * Return the start position (which will be before or equal to the end position)
   */
  getStartPosition() {
    return bi.getStartPosition(this);
  }
  /**
   * Return the start position (which will be before or equal to the end position)
   */
  static getStartPosition(e) {
    return new V(e.startLineNumber, e.startColumn);
  }
  /**
   * Transform to a user presentable string representation.
   */
  toString() {
    return "[" + this.startLineNumber + "," + this.startColumn + " -> " + this.endLineNumber + "," + this.endColumn + "]";
  }
  /**
   * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.
   */
  setEndPosition(e, t) {
    return new bi(this.startLineNumber, this.startColumn, e, t);
  }
  /**
   * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.
   */
  setStartPosition(e, t) {
    return new bi(e, t, this.endLineNumber, this.endColumn);
  }
  /**
   * Create a new empty range using this range's start position.
   */
  collapseToStart() {
    return bi.collapseToStart(this);
  }
  /**
   * Create a new empty range using this range's start position.
   */
  static collapseToStart(e) {
    return new bi(e.startLineNumber, e.startColumn, e.startLineNumber, e.startColumn);
  }
  /**
   * Create a new empty range using this range's end position.
   */
  collapseToEnd() {
    return bi.collapseToEnd(this);
  }
  /**
   * Create a new empty range using this range's end position.
   */
  static collapseToEnd(e) {
    return new bi(e.endLineNumber, e.endColumn, e.endLineNumber, e.endColumn);
  }
  /**
   * Moves the range by the given amount of lines.
   */
  delta(e) {
    return new bi(this.startLineNumber + e, this.startColumn, this.endLineNumber + e, this.endColumn);
  }
  // ---
  static fromPositions(e, t = e) {
    return new bi(e.lineNumber, e.column, t.lineNumber, t.column);
  }
  static lift(e) {
    return e ? new bi(e.startLineNumber, e.startColumn, e.endLineNumber, e.endColumn) : null;
  }
  /**
   * Test if `obj` is an `IRange`.
   */
  static isIRange(e) {
    return e && typeof e.startLineNumber == "number" && typeof e.startColumn == "number" && typeof e.endLineNumber == "number" && typeof e.endColumn == "number";
  }
  /**
   * Test if the two ranges are touching in any way.
   */
  static areIntersectingOrTouching(e, t) {
    return !(e.endLineNumber < t.startLineNumber || e.endLineNumber === t.startLineNumber && e.endColumn < t.startColumn || t.endLineNumber < e.startLineNumber || t.endLineNumber === e.startLineNumber && t.endColumn < e.startColumn);
  }
  /**
   * Test if the two ranges are intersecting. If the ranges are touching it returns true.
   */
  static areIntersecting(e, t) {
    return !(e.endLineNumber < t.startLineNumber || e.endLineNumber === t.startLineNumber && e.endColumn <= t.startColumn || t.endLineNumber < e.startLineNumber || t.endLineNumber === e.startLineNumber && t.endColumn <= e.startColumn);
  }
  /**
   * A function that compares ranges, useful for sorting ranges
   * It will first compare ranges on the startPosition and then on the endPosition
   */
  static compareRangesUsingStarts(e, t) {
    if (e && t) {
      const o = e.startLineNumber | 0, r = t.startLineNumber | 0;
      if (o === r) {
        const a = e.startColumn | 0, l = t.startColumn | 0;
        if (a === l) {
          const c = e.endLineNumber | 0, h = t.endLineNumber | 0;
          if (c === h) {
            const d = e.endColumn | 0, u = t.endColumn | 0;
            return d - u;
          }
          return c - h;
        }
        return a - l;
      }
      return o - r;
    }
    return (e ? 1 : 0) - (t ? 1 : 0);
  }
  /**
   * A function that compares ranges, useful for sorting ranges
   * It will first compare ranges on the endPosition and then on the startPosition
   */
  static compareRangesUsingEnds(e, t) {
    return e.endLineNumber === t.endLineNumber ? e.endColumn === t.endColumn ? e.startLineNumber === t.startLineNumber ? e.startColumn - t.startColumn : e.startLineNumber - t.startLineNumber : e.endColumn - t.endColumn : e.endLineNumber - t.endLineNumber;
  }
  /**
   * Test if the range spans multiple lines.
   */
  static spansMultipleLines(e) {
    return e.endLineNumber > e.startLineNumber;
  }
  toJSON() {
    return this;
  }
}, ft = class ys extends R {
  constructor(e, t, i, n) {
    super(e, t, i, n), this.selectionStartLineNumber = e, this.selectionStartColumn = t, this.positionLineNumber = i, this.positionColumn = n;
  }
  /**
   * Transform to a human-readable representation.
   */
  toString() {
    return "[" + this.selectionStartLineNumber + "," + this.selectionStartColumn + " -> " + this.positionLineNumber + "," + this.positionColumn + "]";
  }
  /**
   * Test if equals other selection.
   */
  equalsSelection(e) {
    return ys.selectionsEqual(this, e);
  }
  /**
   * Test if the two selections are equal.
   */
  static selectionsEqual(e, t) {
    return e.selectionStartLineNumber === t.selectionStartLineNumber && e.selectionStartColumn === t.selectionStartColumn && e.positionLineNumber === t.positionLineNumber && e.positionColumn === t.positionColumn;
  }
  /**
   * Get directions (LTR or RTL).
   */
  getDirection() {
    return this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn ? 0 : 1;
  }
  /**
   * Create a new selection with a different `positionLineNumber` and `positionColumn`.
   */
  setEndPosition(e, t) {
    return this.getDirection() === 0 ? new ys(this.startLineNumber, this.startColumn, e, t) : new ys(e, t, this.startLineNumber, this.startColumn);
  }
  /**
   * Get the position at `positionLineNumber` and `positionColumn`.
   */
  getPosition() {
    return new V(this.positionLineNumber, this.positionColumn);
  }
  /**
   * Get the position at the start of the selection.
  */
  getSelectionStart() {
    return new V(this.selectionStartLineNumber, this.selectionStartColumn);
  }
  /**
   * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.
   */
  setStartPosition(e, t) {
    return this.getDirection() === 0 ? new ys(e, t, this.endLineNumber, this.endColumn) : new ys(this.endLineNumber, this.endColumn, e, t);
  }
  // ----
  /**
   * Create a `Selection` from one or two positions
   */
  static fromPositions(e, t = e) {
    return new ys(e.lineNumber, e.column, t.lineNumber, t.column);
  }
  /**
   * Creates a `Selection` from a range, given a direction.
   */
  static fromRange(e, t) {
    return t === 0 ? new ys(e.startLineNumber, e.startColumn, e.endLineNumber, e.endColumn) : new ys(e.endLineNumber, e.endColumn, e.startLineNumber, e.startColumn);
  }
  /**
   * Create a `Selection` from an `ISelection`.
   */
  static liftSelection(e) {
    return new ys(e.selectionStartLineNumber, e.selectionStartColumn, e.positionLineNumber, e.positionColumn);
  }
  /**
   * `a` equals `b`.
   */
  static selectionsArrEqual(e, t) {
    if (e && !t || !e && t)
      return !1;
    if (!e && !t)
      return !0;
    if (e.length !== t.length)
      return !1;
    for (let i = 0, n = e.length; i < n; i++)
      if (!this.selectionsEqual(e[i], t[i]))
        return !1;
    return !0;
  }
  /**
   * Test if `obj` is an `ISelection`.
   */
  static isISelection(e) {
    return e && typeof e.selectionStartLineNumber == "number" && typeof e.selectionStartColumn == "number" && typeof e.positionLineNumber == "number" && typeof e.positionColumn == "number";
  }
  /**
   * Create with a direction.
   */
  static createWithDirection(e, t, i, n, o) {
    return o === 0 ? new ys(e, t, i, n) : new ys(i, n, e, t);
  }
};
const WC = /* @__PURE__ */ Object.create(null);
function y(s, e) {
  if (Jn(e)) {
    const t = WC[e];
    if (t === void 0)
      throw new Error(`${s} references an unknown codicon: ${e}`);
    e = t;
  }
  return WC[s] = e, { id: s };
}
function q2() {
  return WC;
}
const BO = {
  add: y("add", 6e4),
  plus: y("plus", 6e4),
  gistNew: y("gist-new", 6e4),
  repoCreate: y("repo-create", 6e4),
  lightbulb: y("lightbulb", 60001),
  lightBulb: y("light-bulb", 60001),
  repo: y("repo", 60002),
  repoDelete: y("repo-delete", 60002),
  gistFork: y("gist-fork", 60003),
  repoForked: y("repo-forked", 60003),
  gitPullRequest: y("git-pull-request", 60004),
  gitPullRequestAbandoned: y("git-pull-request-abandoned", 60004),
  recordKeys: y("record-keys", 60005),
  keyboard: y("keyboard", 60005),
  tag: y("tag", 60006),
  gitPullRequestLabel: y("git-pull-request-label", 60006),
  tagAdd: y("tag-add", 60006),
  tagRemove: y("tag-remove", 60006),
  person: y("person", 60007),
  personFollow: y("person-follow", 60007),
  personOutline: y("person-outline", 60007),
  personFilled: y("person-filled", 60007),
  gitBranch: y("git-branch", 60008),
  gitBranchCreate: y("git-branch-create", 60008),
  gitBranchDelete: y("git-branch-delete", 60008),
  sourceControl: y("source-control", 60008),
  mirror: y("mirror", 60009),
  mirrorPublic: y("mirror-public", 60009),
  star: y("star", 60010),
  starAdd: y("star-add", 60010),
  starDelete: y("star-delete", 60010),
  starEmpty: y("star-empty", 60010),
  comment: y("comment", 60011),
  commentAdd: y("comment-add", 60011),
  alert: y("alert", 60012),
  warning: y("warning", 60012),
  search: y("search", 60013),
  searchSave: y("search-save", 60013),
  logOut: y("log-out", 60014),
  signOut: y("sign-out", 60014),
  logIn: y("log-in", 60015),
  signIn: y("sign-in", 60015),
  eye: y("eye", 60016),
  eyeUnwatch: y("eye-unwatch", 60016),
  eyeWatch: y("eye-watch", 60016),
  circleFilled: y("circle-filled", 60017),
  primitiveDot: y("primitive-dot", 60017),
  closeDirty: y("close-dirty", 60017),
  debugBreakpoint: y("debug-breakpoint", 60017),
  debugBreakpointDisabled: y("debug-breakpoint-disabled", 60017),
  debugHint: y("debug-hint", 60017),
  terminalDecorationSuccess: y("terminal-decoration-success", 60017),
  primitiveSquare: y("primitive-square", 60018),
  edit: y("edit", 60019),
  pencil: y("pencil", 60019),
  info: y("info", 60020),
  issueOpened: y("issue-opened", 60020),
  gistPrivate: y("gist-private", 60021),
  gitForkPrivate: y("git-fork-private", 60021),
  lock: y("lock", 60021),
  mirrorPrivate: y("mirror-private", 60021),
  close: y("close", 60022),
  removeClose: y("remove-close", 60022),
  x: y("x", 60022),
  repoSync: y("repo-sync", 60023),
  sync: y("sync", 60023),
  clone: y("clone", 60024),
  desktopDownload: y("desktop-download", 60024),
  beaker: y("beaker", 60025),
  microscope: y("microscope", 60025),
  vm: y("vm", 60026),
  deviceDesktop: y("device-desktop", 60026),
  file: y("file", 60027),
  fileText: y("file-text", 60027),
  more: y("more", 60028),
  ellipsis: y("ellipsis", 60028),
  kebabHorizontal: y("kebab-horizontal", 60028),
  mailReply: y("mail-reply", 60029),
  reply: y("reply", 60029),
  organization: y("organization", 60030),
  organizationFilled: y("organization-filled", 60030),
  organizationOutline: y("organization-outline", 60030),
  newFile: y("new-file", 60031),
  fileAdd: y("file-add", 60031),
  newFolder: y("new-folder", 60032),
  fileDirectoryCreate: y("file-directory-create", 60032),
  trash: y("trash", 60033),
  trashcan: y("trashcan", 60033),
  history: y("history", 60034),
  clock: y("clock", 60034),
  folder: y("folder", 60035),
  fileDirectory: y("file-directory", 60035),
  symbolFolder: y("symbol-folder", 60035),
  logoGithub: y("logo-github", 60036),
  markGithub: y("mark-github", 60036),
  github: y("github", 60036),
  terminal: y("terminal", 60037),
  console: y("console", 60037),
  repl: y("repl", 60037),
  zap: y("zap", 60038),
  symbolEvent: y("symbol-event", 60038),
  error: y("error", 60039),
  stop: y("stop", 60039),
  variable: y("variable", 60040),
  symbolVariable: y("symbol-variable", 60040),
  array: y("array", 60042),
  symbolArray: y("symbol-array", 60042),
  symbolModule: y("symbol-module", 60043),
  symbolPackage: y("symbol-package", 60043),
  symbolNamespace: y("symbol-namespace", 60043),
  symbolObject: y("symbol-object", 60043),
  symbolMethod: y("symbol-method", 60044),
  symbolFunction: y("symbol-function", 60044),
  symbolConstructor: y("symbol-constructor", 60044),
  symbolBoolean: y("symbol-boolean", 60047),
  symbolNull: y("symbol-null", 60047),
  symbolNumeric: y("symbol-numeric", 60048),
  symbolNumber: y("symbol-number", 60048),
  symbolStructure: y("symbol-structure", 60049),
  symbolStruct: y("symbol-struct", 60049),
  symbolParameter: y("symbol-parameter", 60050),
  symbolTypeParameter: y("symbol-type-parameter", 60050),
  symbolKey: y("symbol-key", 60051),
  symbolText: y("symbol-text", 60051),
  symbolReference: y("symbol-reference", 60052),
  goToFile: y("go-to-file", 60052),
  symbolEnum: y("symbol-enum", 60053),
  symbolValue: y("symbol-value", 60053),
  symbolRuler: y("symbol-ruler", 60054),
  symbolUnit: y("symbol-unit", 60054),
  activateBreakpoints: y("activate-breakpoints", 60055),
  archive: y("archive", 60056),
  arrowBoth: y("arrow-both", 60057),
  arrowDown: y("arrow-down", 60058),
  arrowLeft: y("arrow-left", 60059),
  arrowRight: y("arrow-right", 60060),
  arrowSmallDown: y("arrow-small-down", 60061),
  arrowSmallLeft: y("arrow-small-left", 60062),
  arrowSmallRight: y("arrow-small-right", 60063),
  arrowSmallUp: y("arrow-small-up", 60064),
  arrowUp: y("arrow-up", 60065),
  bell: y("bell", 60066),
  bold: y("bold", 60067),
  book: y("book", 60068),
  bookmark: y("bookmark", 60069),
  debugBreakpointConditionalUnverified: y("debug-breakpoint-conditional-unverified", 60070),
  debugBreakpointConditional: y("debug-breakpoint-conditional", 60071),
  debugBreakpointConditionalDisabled: y("debug-breakpoint-conditional-disabled", 60071),
  debugBreakpointDataUnverified: y("debug-breakpoint-data-unverified", 60072),
  debugBreakpointData: y("debug-breakpoint-data", 60073),
  debugBreakpointDataDisabled: y("debug-breakpoint-data-disabled", 60073),
  debugBreakpointLogUnverified: y("debug-breakpoint-log-unverified", 60074),
  debugBreakpointLog: y("debug-breakpoint-log", 60075),
  debugBreakpointLogDisabled: y("debug-breakpoint-log-disabled", 60075),
  briefcase: y("briefcase", 60076),
  broadcast: y("broadcast", 60077),
  browser: y("browser", 60078),
  bug: y("bug", 60079),
  calendar: y("calendar", 60080),
  caseSensitive: y("case-sensitive", 60081),
  check: y("check", 60082),
  checklist: y("checklist", 60083),
  chevronDown: y("chevron-down", 60084),
  chevronLeft: y("chevron-left", 60085),
  chevronRight: y("chevron-right", 60086),
  chevronUp: y("chevron-up", 60087),
  chromeClose: y("chrome-close", 60088),
  chromeMaximize: y("chrome-maximize", 60089),
  chromeMinimize: y("chrome-minimize", 60090),
  chromeRestore: y("chrome-restore", 60091),
  circleOutline: y("circle-outline", 60092),
  circle: y("circle", 60092),
  debugBreakpointUnverified: y("debug-breakpoint-unverified", 60092),
  terminalDecorationIncomplete: y("terminal-decoration-incomplete", 60092),
  circleSlash: y("circle-slash", 60093),
  circuitBoard: y("circuit-board", 60094),
  clearAll: y("clear-all", 60095),
  clippy: y("clippy", 60096),
  closeAll: y("close-all", 60097),
  cloudDownload: y("cloud-download", 60098),
  cloudUpload: y("cloud-upload", 60099),
  code: y("code", 60100),
  collapseAll: y("collapse-all", 60101),
  colorMode: y("color-mode", 60102),
  commentDiscussion: y("comment-discussion", 60103),
  creditCard: y("credit-card", 60105),
  dash: y("dash", 60108),
  dashboard: y("dashboard", 60109),
  database: y("database", 60110),
  debugContinue: y("debug-continue", 60111),
  debugDisconnect: y("debug-disconnect", 60112),
  debugPause: y("debug-pause", 60113),
  debugRestart: y("debug-restart", 60114),
  debugStart: y("debug-start", 60115),
  debugStepInto: y("debug-step-into", 60116),
  debugStepOut: y("debug-step-out", 60117),
  debugStepOver: y("debug-step-over", 60118),
  debugStop: y("debug-stop", 60119),
  debug: y("debug", 60120),
  deviceCameraVideo: y("device-camera-video", 60121),
  deviceCamera: y("device-camera", 60122),
  deviceMobile: y("device-mobile", 60123),
  diffAdded: y("diff-added", 60124),
  diffIgnored: y("diff-ignored", 60125),
  diffModified: y("diff-modified", 60126),
  diffRemoved: y("diff-removed", 60127),
  diffRenamed: y("diff-renamed", 60128),
  diff: y("diff", 60129),
  diffSidebyside: y("diff-sidebyside", 60129),
  discard: y("discard", 60130),
  editorLayout: y("editor-layout", 60131),
  emptyWindow: y("empty-window", 60132),
  exclude: y("exclude", 60133),
  extensions: y("extensions", 60134),
  eyeClosed: y("eye-closed", 60135),
  fileBinary: y("file-binary", 60136),
  fileCode: y("file-code", 60137),
  fileMedia: y("file-media", 60138),
  filePdf: y("file-pdf", 60139),
  fileSubmodule: y("file-submodule", 60140),
  fileSymlinkDirectory: y("file-symlink-directory", 60141),
  fileSymlinkFile: y("file-symlink-file", 60142),
  fileZip: y("file-zip", 60143),
  files: y("files", 60144),
  filter: y("filter", 60145),
  flame: y("flame", 60146),
  foldDown: y("fold-down", 60147),
  foldUp: y("fold-up", 60148),
  fold: y("fold", 60149),
  folderActive: y("folder-active", 60150),
  folderOpened: y("folder-opened", 60151),
  gear: y("gear", 60152),
  gift: y("gift", 60153),
  gistSecret: y("gist-secret", 60154),
  gist: y("gist", 60155),
  gitCommit: y("git-commit", 60156),
  gitCompare: y("git-compare", 60157),
  compareChanges: y("compare-changes", 60157),
  gitMerge: y("git-merge", 60158),
  githubAction: y("github-action", 60159),
  githubAlt: y("github-alt", 60160),
  globe: y("globe", 60161),
  grabber: y("grabber", 60162),
  graph: y("graph", 60163),
  gripper: y("gripper", 60164),
  heart: y("heart", 60165),
  home: y("home", 60166),
  horizontalRule: y("horizontal-rule", 60167),
  hubot: y("hubot", 60168),
  inbox: y("inbox", 60169),
  issueReopened: y("issue-reopened", 60171),
  issues: y("issues", 60172),
  italic: y("italic", 60173),
  jersey: y("jersey", 60174),
  json: y("json", 60175),
  kebabVertical: y("kebab-vertical", 60176),
  key: y("key", 60177),
  law: y("law", 60178),
  lightbulbAutofix: y("lightbulb-autofix", 60179),
  linkExternal: y("link-external", 60180),
  link: y("link", 60181),
  listOrdered: y("list-ordered", 60182),
  listUnordered: y("list-unordered", 60183),
  liveShare: y("live-share", 60184),
  loading: y("loading", 60185),
  location: y("location", 60186),
  mailRead: y("mail-read", 60187),
  mail: y("mail", 60188),
  markdown: y("markdown", 60189),
  megaphone: y("megaphone", 60190),
  mention: y("mention", 60191),
  milestone: y("milestone", 60192),
  gitPullRequestMilestone: y("git-pull-request-milestone", 60192),
  mortarBoard: y("mortar-board", 60193),
  move: y("move", 60194),
  multipleWindows: y("multiple-windows", 60195),
  mute: y("mute", 60196),
  noNewline: y("no-newline", 60197),
  note: y("note", 60198),
  octoface: y("octoface", 60199),
  openPreview: y("open-preview", 60200),
  package: y("package", 60201),
  paintcan: y("paintcan", 60202),
  pin: y("pin", 60203),
  play: y("play", 60204),
  run: y("run", 60204),
  plug: y("plug", 60205),
  preserveCase: y("preserve-case", 60206),
  preview: y("preview", 60207),
  project: y("project", 60208),
  pulse: y("pulse", 60209),
  question: y("question", 60210),
  quote: y("quote", 60211),
  radioTower: y("radio-tower", 60212),
  reactions: y("reactions", 60213),
  references: y("references", 60214),
  refresh: y("refresh", 60215),
  regex: y("regex", 60216),
  remoteExplorer: y("remote-explorer", 60217),
  remote: y("remote", 60218),
  remove: y("remove", 60219),
  replaceAll: y("replace-all", 60220),
  replace: y("replace", 60221),
  repoClone: y("repo-clone", 60222),
  repoForcePush: y("repo-force-push", 60223),
  repoPull: y("repo-pull", 60224),
  repoPush: y("repo-push", 60225),
  report: y("report", 60226),
  requestChanges: y("request-changes", 60227),
  rocket: y("rocket", 60228),
  rootFolderOpened: y("root-folder-opened", 60229),
  rootFolder: y("root-folder", 60230),
  rss: y("rss", 60231),
  ruby: y("ruby", 60232),
  saveAll: y("save-all", 60233),
  saveAs: y("save-as", 60234),
  save: y("save", 60235),
  screenFull: y("screen-full", 60236),
  screenNormal: y("screen-normal", 60237),
  searchStop: y("search-stop", 60238),
  server: y("server", 60240),
  settingsGear: y("settings-gear", 60241),
  settings: y("settings", 60242),
  shield: y("shield", 60243),
  smiley: y("smiley", 60244),
  sortPrecedence: y("sort-precedence", 60245),
  splitHorizontal: y("split-horizontal", 60246),
  splitVertical: y("split-vertical", 60247),
  squirrel: y("squirrel", 60248),
  starFull: y("star-full", 60249),
  starHalf: y("star-half", 60250),
  symbolClass: y("symbol-class", 60251),
  symbolColor: y("symbol-color", 60252),
  symbolConstant: y("symbol-constant", 60253),
  symbolEnumMember: y("symbol-enum-member", 60254),
  symbolField: y("symbol-field", 60255),
  symbolFile: y("symbol-file", 60256),
  symbolInterface: y("symbol-interface", 60257),
  symbolKeyword: y("symbol-keyword", 60258),
  symbolMisc: y("symbol-misc", 60259),
  symbolOperator: y("symbol-operator", 60260),
  symbolProperty: y("symbol-property", 60261),
  wrench: y("wrench", 60261),
  wrenchSubaction: y("wrench-subaction", 60261),
  symbolSnippet: y("symbol-snippet", 60262),
  tasklist: y("tasklist", 60263),
  telescope: y("telescope", 60264),
  textSize: y("text-size", 60265),
  threeBars: y("three-bars", 60266),
  thumbsdown: y("thumbsdown", 60267),
  thumbsup: y("thumbsup", 60268),
  tools: y("tools", 60269),
  triangleDown: y("triangle-down", 60270),
  triangleLeft: y("triangle-left", 60271),
  triangleRight: y("triangle-right", 60272),
  triangleUp: y("triangle-up", 60273),
  twitter: y("twitter", 60274),
  unfold: y("unfold", 60275),
  unlock: y("unlock", 60276),
  unmute: y("unmute", 60277),
  unverified: y("unverified", 60278),
  verified: y("verified", 60279),
  versions: y("versions", 60280),
  vmActive: y("vm-active", 60281),
  vmOutline: y("vm-outline", 60282),
  vmRunning: y("vm-running", 60283),
  watch: y("watch", 60284),
  whitespace: y("whitespace", 60285),
  wholeWord: y("whole-word", 60286),
  window: y("window", 60287),
  wordWrap: y("word-wrap", 60288),
  zoomIn: y("zoom-in", 60289),
  zoomOut: y("zoom-out", 60290),
  listFilter: y("list-filter", 60291),
  listFlat: y("list-flat", 60292),
  listSelection: y("list-selection", 60293),
  selection: y("selection", 60293),
  listTree: y("list-tree", 60294),
  debugBreakpointFunctionUnverified: y("debug-breakpoint-function-unverified", 60295),
  debugBreakpointFunction: y("debug-breakpoint-function", 60296),
  debugBreakpointFunctionDisabled: y("debug-breakpoint-function-disabled", 60296),
  debugStackframeActive: y("debug-stackframe-active", 60297),
  circleSmallFilled: y("circle-small-filled", 60298),
  debugStackframeDot: y("debug-stackframe-dot", 60298),
  terminalDecorationMark: y("terminal-decoration-mark", 60298),
  debugStackframe: y("debug-stackframe", 60299),
  debugStackframeFocused: y("debug-stackframe-focused", 60299),
  debugBreakpointUnsupported: y("debug-breakpoint-unsupported", 60300),
  symbolString: y("symbol-string", 60301),
  debugReverseContinue: y("debug-reverse-continue", 60302),
  debugStepBack: y("debug-step-back", 60303),
  debugRestartFrame: y("debug-restart-frame", 60304),
  debugAlt: y("debug-alt", 60305),
  callIncoming: y("call-incoming", 60306),
  callOutgoing: y("call-outgoing", 60307),
  menu: y("menu", 60308),
  expandAll: y("expand-all", 60309),
  feedback: y("feedback", 60310),
  gitPullRequestReviewer: y("git-pull-request-reviewer", 60310),
  groupByRefType: y("group-by-ref-type", 60311),
  ungroupByRefType: y("ungroup-by-ref-type", 60312),
  account: y("account", 60313),
  gitPullRequestAssignee: y("git-pull-request-assignee", 60313),
  bellDot: y("bell-dot", 60314),
  debugConsole: y("debug-console", 60315),
  library: y("library", 60316),
  output: y("output", 60317),
  runAll: y("run-all", 60318),
  syncIgnored: y("sync-ignored", 60319),
  pinned: y("pinned", 60320),
  githubInverted: y("github-inverted", 60321),
  serverProcess: y("server-process", 60322),
  serverEnvironment: y("server-environment", 60323),
  pass: y("pass", 60324),
  issueClosed: y("issue-closed", 60324),
  stopCircle: y("stop-circle", 60325),
  playCircle: y("play-circle", 60326),
  record: y("record", 60327),
  debugAltSmall: y("debug-alt-small", 60328),
  vmConnect: y("vm-connect", 60329),
  cloud: y("cloud", 60330),
  merge: y("merge", 60331),
  export: y("export", 60332),
  graphLeft: y("graph-left", 60333),
  magnet: y("magnet", 60334),
  notebook: y("notebook", 60335),
  redo: y("redo", 60336),
  checkAll: y("check-all", 60337),
  pinnedDirty: y("pinned-dirty", 60338),
  passFilled: y("pass-filled", 60339),
  circleLargeFilled: y("circle-large-filled", 60340),
  circleLarge: y("circle-large", 60341),
  circleLargeOutline: y("circle-large-outline", 60341),
  combine: y("combine", 60342),
  gather: y("gather", 60342),
  table: y("table", 60343),
  variableGroup: y("variable-group", 60344),
  typeHierarchy: y("type-hierarchy", 60345),
  typeHierarchySub: y("type-hierarchy-sub", 60346),
  typeHierarchySuper: y("type-hierarchy-super", 60347),
  gitPullRequestCreate: y("git-pull-request-create", 60348),
  runAbove: y("run-above", 60349),
  runBelow: y("run-below", 60350),
  notebookTemplate: y("notebook-template", 60351),
  debugRerun: y("debug-rerun", 60352),
  workspaceTrusted: y("workspace-trusted", 60353),
  workspaceUntrusted: y("workspace-untrusted", 60354),
  workspaceUnknown: y("workspace-unknown", 60355),
  terminalCmd: y("terminal-cmd", 60356),
  terminalDebian: y("terminal-debian", 60357),
  terminalLinux: y("terminal-linux", 60358),
  terminalPowershell: y("terminal-powershell", 60359),
  terminalTmux: y("terminal-tmux", 60360),
  terminalUbuntu: y("terminal-ubuntu", 60361),
  terminalBash: y("terminal-bash", 60362),
  arrowSwap: y("arrow-swap", 60363),
  copy: y("copy", 60364),
  personAdd: y("person-add", 60365),
  filterFilled: y("filter-filled", 60366),
  wand: y("wand", 60367),
  debugLineByLine: y("debug-line-by-line", 60368),
  inspect: y("inspect", 60369),
  layers: y("layers", 60370),
  layersDot: y("layers-dot", 60371),
  layersActive: y("layers-active", 60372),
  compass: y("compass", 60373),
  compassDot: y("compass-dot", 60374),
  compassActive: y("compass-active", 60375),
  azure: y("azure", 60376),
  issueDraft: y("issue-draft", 60377),
  gitPullRequestClosed: y("git-pull-request-closed", 60378),
  gitPullRequestDraft: y("git-pull-request-draft", 60379),
  debugAll: y("debug-all", 60380),
  debugCoverage: y("debug-coverage", 60381),
  runErrors: y("run-errors", 60382),
  folderLibrary: y("folder-library", 60383),
  debugContinueSmall: y("debug-continue-small", 60384),
  beakerStop: y("beaker-stop", 60385),
  graphLine: y("graph-line", 60386),
  graphScatter: y("graph-scatter", 60387),
  pieChart: y("pie-chart", 60388),
  bracket: y("bracket", 60175),
  bracketDot: y("bracket-dot", 60389),
  bracketError: y("bracket-error", 60390),
  lockSmall: y("lock-small", 60391),
  azureDevops: y("azure-devops", 60392),
  verifiedFilled: y("verified-filled", 60393),
  newline: y("newline", 60394),
  layout: y("layout", 60395),
  layoutActivitybarLeft: y("layout-activitybar-left", 60396),
  layoutActivitybarRight: y("layout-activitybar-right", 60397),
  layoutPanelLeft: y("layout-panel-left", 60398),
  layoutPanelCenter: y("layout-panel-center", 60399),
  layoutPanelJustify: y("layout-panel-justify", 60400),
  layoutPanelRight: y("layout-panel-right", 60401),
  layoutPanel: y("layout-panel", 60402),
  layoutSidebarLeft: y("layout-sidebar-left", 60403),
  layoutSidebarRight: y("layout-sidebar-right", 60404),
  layoutStatusbar: y("layout-statusbar", 60405),
  layoutMenubar: y("layout-menubar", 60406),
  layoutCentered: y("layout-centered", 60407),
  target: y("target", 60408),
  indent: y("indent", 60409),
  recordSmall: y("record-small", 60410),
  errorSmall: y("error-small", 60411),
  terminalDecorationError: y("terminal-decoration-error", 60411),
  arrowCircleDown: y("arrow-circle-down", 60412),
  arrowCircleLeft: y("arrow-circle-left", 60413),
  arrowCircleRight: y("arrow-circle-right", 60414),
  arrowCircleUp: y("arrow-circle-up", 60415),
  layoutSidebarRightOff: y("layout-sidebar-right-off", 60416),
  layoutPanelOff: y("layout-panel-off", 60417),
  layoutSidebarLeftOff: y("layout-sidebar-left-off", 60418),
  blank: y("blank", 60419),
  heartFilled: y("heart-filled", 60420),
  map: y("map", 60421),
  mapHorizontal: y("map-horizontal", 60421),
  foldHorizontal: y("fold-horizontal", 60421),
  mapFilled: y("map-filled", 60422),
  mapHorizontalFilled: y("map-horizontal-filled", 60422),
  foldHorizontalFilled: y("fold-horizontal-filled", 60422),
  circleSmall: y("circle-small", 60423),
  bellSlash: y("bell-slash", 60424),
  bellSlashDot: y("bell-slash-dot", 60425),
  commentUnresolved: y("comment-unresolved", 60426),
  gitPullRequestGoToChanges: y("git-pull-request-go-to-changes", 60427),
  gitPullRequestNewChanges: y("git-pull-request-new-changes", 60428),
  searchFuzzy: y("search-fuzzy", 60429),
  commentDraft: y("comment-draft", 60430),
  send: y("send", 60431),
  sparkle: y("sparkle", 60432),
  insert: y("insert", 60433),
  mic: y("mic", 60434),
  thumbsdownFilled: y("thumbsdown-filled", 60435),
  thumbsupFilled: y("thumbsup-filled", 60436),
  coffee: y("coffee", 60437),
  snake: y("snake", 60438),
  game: y("game", 60439),
  vr: y("vr", 60440),
  chip: y("chip", 60441),
  piano: y("piano", 60442),
  music: y("music", 60443),
  micFilled: y("mic-filled", 60444),
  repoFetch: y("repo-fetch", 60445),
  copilot: y("copilot", 60446),
  lightbulbSparkle: y("lightbulb-sparkle", 60447),
  robot: y("robot", 60448),
  sparkleFilled: y("sparkle-filled", 60449),
  diffSingle: y("diff-single", 60450),
  diffMultiple: y("diff-multiple", 60451),
  surroundWith: y("surround-with", 60452),
  share: y("share", 60453),
  gitStash: y("git-stash", 60454),
  gitStashApply: y("git-stash-apply", 60455),
  gitStashPop: y("git-stash-pop", 60456),
  vscode: y("vscode", 60457),
  vscodeInsiders: y("vscode-insiders", 60458),
  codeOss: y("code-oss", 60459),
  runCoverage: y("run-coverage", 60460),
  runAllCoverage: y("run-all-coverage", 60461),
  coverage: y("coverage", 60462),
  githubProject: y("github-project", 60463),
  mapVertical: y("map-vertical", 60464),
  foldVertical: y("fold-vertical", 60464),
  mapVerticalFilled: y("map-vertical-filled", 60465),
  foldVerticalFilled: y("fold-vertical-filled", 60465),
  goToSearch: y("go-to-search", 60466),
  percentage: y("percentage", 60467),
  sortPercentage: y("sort-percentage", 60467),
  attach: y("attach", 60468)
}, WO = {
  dialogError: y("dialog-error", "error"),
  dialogWarning: y("dialog-warning", "warning"),
  dialogInfo: y("dialog-info", "info"),
  dialogClose: y("dialog-close", "close"),
  treeItemExpanded: y("tree-item-expanded", "chevron-down"),
  // collapsed is done with rotation
  treeFilterOnTypeOn: y("tree-filter-on-type-on", "list-filter"),
  treeFilterOnTypeOff: y("tree-filter-on-type-off", "list-selection"),
  treeFilterClear: y("tree-filter-clear", "close"),
  treeItemLoading: y("tree-item-loading", "loading"),
  menuSelection: y("menu-selection", "check"),
  menuSubmenu: y("menu-submenu", "chevron-right"),
  menuBarMore: y("menubar-more", "more"),
  scrollbarButtonLeft: y("scrollbar-button-left", "triangle-left"),
  scrollbarButtonRight: y("scrollbar-button-right", "triangle-right"),
  scrollbarButtonUp: y("scrollbar-button-up", "triangle-up"),
  scrollbarButtonDown: y("scrollbar-button-down", "triangle-down"),
  toolBarMore: y("toolbar-more", "more"),
  quickInputBack: y("quick-input-back", "arrow-left"),
  dropDownButton: y("drop-down-button", 60084),
  symbolCustomColor: y("symbol-customcolor", 60252),
  exportIcon: y("export", 60332),
  workspaceUnspecified: y("workspace-unspecified", 60355),
  newLine: y("newline", 60394),
  thumbsDownFilled: y("thumbsdown-filled", 60435),
  thumbsUpFilled: y("thumbsup-filled", 60436),
  gitFetch: y("git-fetch", 60445),
  lightbulbSparkleAutofix: y("lightbulb-sparkle-autofix", 60447),
  debugBreakpointPending: y("debug-breakpoint-pending", 60377)
}, re = {
  ...BO,
  ...WO
};
let j2 = class {
  constructor() {
    this._tokenizationSupports = /* @__PURE__ */ new Map(), this._factories = /* @__PURE__ */ new Map(), this._onDidChange = new O(), this.onDidChange = this._onDidChange.event, this._colorMap = null;
  }
  handleChange(e) {
    this._onDidChange.fire({
      changedLanguages: e,
      changedColorMap: !1
    });
  }
  register(e, t) {
    return this._tokenizationSupports.set(e, t), this.handleChange([e]), ke(() => {
      this._tokenizationSupports.get(e) === t && (this._tokenizationSupports.delete(e), this.handleChange([e]));
    });
  }
  get(e) {
    return this._tokenizationSupports.get(e) || null;
  }
  registerFactory(e, t) {
    var n;
    (n = this._factories.get(e)) == null || n.dispose();
    const i = new VO(this, e, t);
    return this._factories.set(e, i), ke(() => {
      const o = this._factories.get(e);
      !o || o !== i || (this._factories.delete(e), o.dispose());
    });
  }
  async getOrCreate(e) {
    const t = this.get(e);
    if (t)
      return t;
    const i = this._factories.get(e);
    return !i || i.isResolved ? null : (await i.resolve(), this.get(e));
  }
  isResolved(e) {
    if (this.get(e))
      return !0;
    const i = this._factories.get(e);
    return !!(!i || i.isResolved);
  }
  setColorMap(e) {
    this._colorMap = e, this._onDidChange.fire({
      changedLanguages: Array.from(this._tokenizationSupports.keys()),
      changedColorMap: !0
    });
  }
  getColorMap() {
    return this._colorMap;
  }
  getDefaultBackground() {
    return this._colorMap && this._colorMap.length > 2 ? this._colorMap[
      2
      /* ColorId.DefaultBackground */
    ] : null;
  }
};
class VO extends q {
  get isResolved() {
    return this._isResolved;
  }
  constructor(e, t, i) {
    super(), this._registry = e, this._languageId = t, this._factory = i, this._isDisposed = !1, this._resolvePromise = null, this._isResolved = !1;
  }
  dispose() {
    this._isDisposed = !0, super.dispose();
  }
  async resolve() {
    return this._resolvePromise || (this._resolvePromise = this._create()), this._resolvePromise;
  }
  async _create() {
    const e = await this._factory.tokenizationSupport;
    this._isResolved = !0, e && !this._isDisposed && this._register(this._registry.register(this._languageId, e));
  }
}
let Rf = class {
  constructor(e, t, i) {
    this.offset = e, this.type = t, this.language = i, this._tokenBrand = void 0;
  }
  toString() {
    return "(" + this.offset + ", " + this.type + ")";
  }
};
class xL {
  constructor(e, t) {
    this.tokens = e, this.endState = t, this._tokenizationResultBrand = void 0;
  }
}
class tb {
  constructor(e, t) {
    this.tokens = e, this.endState = t, this._encodedTokenizationResultBrand = void 0;
  }
}
var lD;
(function(s) {
  s[s.Increase = 0] = "Increase", s[s.Decrease = 1] = "Decrease";
})(lD || (lD = {}));
var cD;
(function(s) {
  const e = /* @__PURE__ */ new Map();
  e.set(0, re.symbolMethod), e.set(1, re.symbolFunction), e.set(2, re.symbolConstructor), e.set(3, re.symbolField), e.set(4, re.symbolVariable), e.set(5, re.symbolClass), e.set(6, re.symbolStruct), e.set(7, re.symbolInterface), e.set(8, re.symbolModule), e.set(9, re.symbolProperty), e.set(10, re.symbolEvent), e.set(11, re.symbolOperator), e.set(12, re.symbolUnit), e.set(13, re.symbolValue), e.set(15, re.symbolEnum), e.set(14, re.symbolConstant), e.set(15, re.symbolEnum), e.set(16, re.symbolEnumMember), e.set(17, re.symbolKeyword), e.set(27, re.symbolSnippet), e.set(18, re.symbolText), e.set(19, re.symbolColor), e.set(20, re.symbolFile), e.set(21, re.symbolReference), e.set(22, re.symbolCustomColor), e.set(23, re.symbolFolder), e.set(24, re.symbolTypeParameter), e.set(25, re.account), e.set(26, re.issues);
  function t(o) {
    let r = e.get(o);
    return r || (console.info("No codicon found for CompletionItemKind " + o), r = re.symbolProperty), r;
  }
  s.toIcon = t;
  const i = /* @__PURE__ */ new Map();
  i.set(
    "method",
    0
    /* CompletionItemKind.Method */
  ), i.set(
    "function",
    1
    /* CompletionItemKind.Function */
  ), i.set(
    "constructor",
    2
    /* CompletionItemKind.Constructor */
  ), i.set(
    "field",
    3
    /* CompletionItemKind.Field */
  ), i.set(
    "variable",
    4
    /* CompletionItemKind.Variable */
  ), i.set(
    "class",
    5
    /* CompletionItemKind.Class */
  ), i.set(
    "struct",
    6
    /* CompletionItemKind.Struct */
  ), i.set(
    "interface",
    7
    /* CompletionItemKind.Interface */
  ), i.set(
    "module",
    8
    /* CompletionItemKind.Module */
  ), i.set(
    "property",
    9
    /* CompletionItemKind.Property */
  ), i.set(
    "event",
    10
    /* CompletionItemKind.Event */
  ), i.set(
    "operator",
    11
    /* CompletionItemKind.Operator */
  ), i.set(
    "unit",
    12
    /* CompletionItemKind.Unit */
  ), i.set(
    "value",
    13
    /* CompletionItemKind.Value */
  ), i.set(
    "constant",
    14
    /* CompletionItemKind.Constant */
  ), i.set(
    "enum",
    15
    /* CompletionItemKind.Enum */
  ), i.set(
    "enum-member",
    16
    /* CompletionItemKind.EnumMember */
  ), i.set(
    "enumMember",
    16
    /* CompletionItemKind.EnumMember */
  ), i.set(
    "keyword",
    17
    /* CompletionItemKind.Keyword */
  ), i.set(
    "snippet",
    27
    /* CompletionItemKind.Snippet */
  ), i.set(
    "text",
    18
    /* CompletionItemKind.Text */
  ), i.set(
    "color",
    19
    /* CompletionItemKind.Color */
  ), i.set(
    "file",
    20
    /* CompletionItemKind.File */
  ), i.set(
    "reference",
    21
    /* CompletionItemKind.Reference */
  ), i.set(
    "customcolor",
    22
    /* CompletionItemKind.Customcolor */
  ), i.set(
    "folder",
    23
    /* CompletionItemKind.Folder */
  ), i.set(
    "type-parameter",
    24
    /* CompletionItemKind.TypeParameter */
  ), i.set(
    "typeParameter",
    24
    /* CompletionItemKind.TypeParameter */
  ), i.set(
    "account",
    25
    /* CompletionItemKind.User */
  ), i.set(
    "issue",
    26
    /* CompletionItemKind.Issue */
  );
  function n(o, r) {
    let a = i.get(o);
    return typeof a > "u" && !r && (a = 9), a;
  }
  s.fromString = n;
})(cD || (cD = {}));
var hD;
(function(s) {
  s[s.Automatic = 0] = "Automatic", s[s.Explicit = 1] = "Explicit";
})(hD || (hD = {}));
class HO {
  constructor(e, t, i, n) {
    this.range = e, this.text = t, this.completionKind = i, this.isSnippetText = n;
  }
  equals(e) {
    return R.lift(this.range).equalsRange(e.range) && this.text === e.text && this.completionKind === e.completionKind && this.isSnippetText === e.isSnippetText;
  }
}
var dD;
(function(s) {
  s[s.Automatic = 0] = "Automatic", s[s.PasteAs = 1] = "PasteAs";
})(dD || (dD = {}));
var uD;
(function(s) {
  s[s.Invoke = 1] = "Invoke", s[s.TriggerCharacter = 2] = "TriggerCharacter", s[s.ContentChange = 3] = "ContentChange";
})(uD || (uD = {}));
var fD;
(function(s) {
  s[s.Text = 0] = "Text", s[s.Read = 1] = "Read", s[s.Write = 2] = "Write";
})(fD || (fD = {}));
p("Array", "array"), p("Boolean", "boolean"), p("Class", "class"), p("Constant", "constant"), p("Constructor", "constructor"), p("Enum", "enumeration"), p("EnumMember", "enumeration member"), p("Event", "event"), p("Field", "field"), p("File", "file"), p("Function", "function"), p("Interface", "interface"), p("Key", "key"), p("Method", "method"), p("Module", "module"), p("Namespace", "namespace"), p("Null", "null"), p("Number", "number"), p("Object", "object"), p("Operator", "operator"), p("Package", "package"), p("Property", "property"), p("String", "string"), p("Struct", "struct"), p("TypeParameter", "type parameter"), p("Variable", "variable");
var VC;
(function(s) {
  const e = /* @__PURE__ */ new Map();
  e.set(0, re.symbolFile), e.set(1, re.symbolModule), e.set(2, re.symbolNamespace), e.set(3, re.symbolPackage), e.set(4, re.symbolClass), e.set(5, re.symbolMethod), e.set(6, re.symbolProperty), e.set(7, re.symbolField), e.set(8, re.symbolConstructor), e.set(9, re.symbolEnum), e.set(10, re.symbolInterface), e.set(11, re.symbolFunction), e.set(12, re.symbolVariable), e.set(13, re.symbolConstant), e.set(14, re.symbolString), e.set(15, re.symbolNumber), e.set(16, re.symbolBoolean), e.set(17, re.symbolArray), e.set(18, re.symbolObject), e.set(19, re.symbolKey), e.set(20, re.symbolNull), e.set(21, re.symbolEnumMember), e.set(22, re.symbolStruct), e.set(23, re.symbolEvent), e.set(24, re.symbolOperator), e.set(25, re.symbolTypeParameter);
  function t(i) {
    let n = e.get(i);
    return n || (console.info("No codicon found for SymbolKind " + i), n = re.symbolProperty), n;
  }
  s.toIcon = t;
})(VC || (VC = {}));
const Ls = class Ls {
  /**
   * Returns a {@link FoldingRangeKind} for the given value.
   *
   * @param value of the kind.
   */
  static fromValue(e) {
    switch (e) {
      case "comment":
        return Ls.Comment;
      case "imports":
        return Ls.Imports;
      case "region":
        return Ls.Region;
    }
    return new Ls(e);
  }
  /**
   * Creates a new {@link FoldingRangeKind}.
   *
   * @param value of the kind.
   */
  constructor(e) {
    this.value = e;
  }
};
Ls.Comment = new Ls("comment"), Ls.Imports = new Ls("imports"), Ls.Region = new Ls("region");
let HC = Ls;
var gD;
(function(s) {
  s[s.AIGenerated = 1] = "AIGenerated";
})(gD || (gD = {}));
var mD;
(function(s) {
  s[s.Invoke = 0] = "Invoke", s[s.Automatic = 1] = "Automatic";
})(mD || (mD = {}));
var pD;
(function(s) {
  function e(t) {
    return !t || typeof t != "object" ? !1 : typeof t.id == "string" && typeof t.title == "string";
  }
  s.is = e;
})(pD || (pD = {}));
var _D;
(function(s) {
  s[s.Type = 1] = "Type", s[s.Parameter = 2] = "Parameter";
})(_D || (_D = {}));
class zO {
  constructor(e) {
    this.createSupport = e, this._tokenizationSupport = null;
  }
  dispose() {
    this._tokenizationSupport && this._tokenizationSupport.then((e) => {
      e && e.dispose();
    });
  }
  get tokenizationSupport() {
    return this._tokenizationSupport || (this._tokenizationSupport = this.createSupport()), this._tokenizationSupport;
  }
}
const Yt = new j2(), zC = new j2();
var bD;
(function(s) {
  s[s.Invoke = 0] = "Invoke", s[s.Automatic = 1] = "Automatic";
})(bD || (bD = {}));
var UC;
(function(s) {
  s[s.Unknown = 0] = "Unknown", s[s.Disabled = 1] = "Disabled", s[s.Enabled = 2] = "Enabled";
})(UC || (UC = {}));
var $C;
(function(s) {
  s[s.Invoke = 1] = "Invoke", s[s.Auto = 2] = "Auto";
})($C || ($C = {}));
var KC;
(function(s) {
  s[s.None = 0] = "None", s[s.KeepWhitespace = 1] = "KeepWhitespace", s[s.InsertAsSnippet = 4] = "InsertAsSnippet";
})(KC || (KC = {}));
var qC;
(function(s) {
  s[s.Method = 0] = "Method", s[s.Function = 1] = "Function", s[s.Constructor = 2] = "Constructor", s[s.Field = 3] = "Field", s[s.Variable = 4] = "Variable", s[s.Class = 5] = "Class", s[s.Struct = 6] = "Struct", s[s.Interface = 7] = "Interface", s[s.Module = 8] = "Module", s[s.Property = 9] = "Property", s[s.Event = 10] = "Event", s[s.Operator = 11] = "Operator", s[s.Unit = 12] = "Unit", s[s.Value = 13] = "Value", s[s.Constant = 14] = "Constant", s[s.Enum = 15] = "Enum", s[s.EnumMember = 16] = "EnumMember", s[s.Keyword = 17] = "Keyword", s[s.Text = 18] = "Text", s[s.Color = 19] = "Color", s[s.File = 20] = "File", s[s.Reference = 21] = "Reference", s[s.Customcolor = 22] = "Customcolor", s[s.Folder = 23] = "Folder", s[s.TypeParameter = 24] = "TypeParameter", s[s.User = 25] = "User", s[s.Issue = 26] = "Issue", s[s.Snippet = 27] = "Snippet";
})(qC || (qC = {}));
var jC;
(function(s) {
  s[s.Deprecated = 1] = "Deprecated";
})(jC || (jC = {}));
var GC;
(function(s) {
  s[s.Invoke = 0] = "Invoke", s[s.TriggerCharacter = 1] = "TriggerCharacter", s[s.TriggerForIncompleteCompletions = 2] = "TriggerForIncompleteCompletions";
})(GC || (GC = {}));
var ZC;
(function(s) {
  s[s.EXACT = 0] = "EXACT", s[s.ABOVE = 1] = "ABOVE", s[s.BELOW = 2] = "BELOW";
})(ZC || (ZC = {}));
var YC;
(function(s) {
  s[s.NotSet = 0] = "NotSet", s[s.ContentFlush = 1] = "ContentFlush", s[s.RecoverFromMarkers = 2] = "RecoverFromMarkers", s[s.Explicit = 3] = "Explicit", s[s.Paste = 4] = "Paste", s[s.Undo = 5] = "Undo", s[s.Redo = 6] = "Redo";
})(YC || (YC = {}));
var QC;
(function(s) {
  s[s.LF = 1] = "LF", s[s.CRLF = 2] = "CRLF";
})(QC || (QC = {}));
var XC;
(function(s) {
  s[s.Text = 0] = "Text", s[s.Read = 1] = "Read", s[s.Write = 2] = "Write";
})(XC || (XC = {}));
var JC;
(function(s) {
  s[s.None = 0] = "None", s[s.Keep = 1] = "Keep", s[s.Brackets = 2] = "Brackets", s[s.Advanced = 3] = "Advanced", s[s.Full = 4] = "Full";
})(JC || (JC = {}));
var ew;
(function(s) {
  s[s.acceptSuggestionOnCommitCharacter = 0] = "acceptSuggestionOnCommitCharacter", s[s.acceptSuggestionOnEnter = 1] = "acceptSuggestionOnEnter", s[s.accessibilitySupport = 2] = "accessibilitySupport", s[s.accessibilityPageSize = 3] = "accessibilityPageSize", s[s.ariaLabel = 4] = "ariaLabel", s[s.ariaRequired = 5] = "ariaRequired", s[s.autoClosingBrackets = 6] = "autoClosingBrackets", s[s.autoClosingComments = 7] = "autoClosingComments", s[s.screenReaderAnnounceInlineSuggestion = 8] = "screenReaderAnnounceInlineSuggestion", s[s.autoClosingDelete = 9] = "autoClosingDelete", s[s.autoClosingOvertype = 10] = "autoClosingOvertype", s[s.autoClosingQuotes = 11] = "autoClosingQuotes", s[s.autoIndent = 12] = "autoIndent", s[s.automaticLayout = 13] = "automaticLayout", s[s.autoSurround = 14] = "autoSurround", s[s.bracketPairColorization = 15] = "bracketPairColorization", s[s.guides = 16] = "guides", s[s.codeLens = 17] = "codeLens", s[s.codeLensFontFamily = 18] = "codeLensFontFamily", s[s.codeLensFontSize = 19] = "codeLensFontSize", s[s.colorDecorators = 20] = "colorDecorators", s[s.colorDecoratorsLimit = 21] = "colorDecoratorsLimit", s[s.columnSelection = 22] = "columnSelection", s[s.comments = 23] = "comments", s[s.contextmenu = 24] = "contextmenu", s[s.copyWithSyntaxHighlighting = 25] = "copyWithSyntaxHighlighting", s[s.cursorBlinking = 26] = "cursorBlinking", s[s.cursorSmoothCaretAnimation = 27] = "cursorSmoothCaretAnimation", s[s.cursorStyle = 28] = "cursorStyle", s[s.cursorSurroundingLines = 29] = "cursorSurroundingLines", s[s.cursorSurroundingLinesStyle = 30] = "cursorSurroundingLinesStyle", s[s.cursorWidth = 31] = "cursorWidth", s[s.disableLayerHinting = 32] = "disableLayerHinting", s[s.disableMonospaceOptimizations = 33] = "disableMonospaceOptimizations", s[s.domReadOnly = 34] = "domReadOnly", s[s.dragAndDrop = 35] = "dragAndDrop", s[s.dropIntoEditor = 36] = "dropIntoEditor", s[s.emptySelectionClipboard = 37] = "emptySelectionClipboard", s[s.experimentalWhitespaceRendering = 38] = "experimentalWhitespaceRendering", s[s.extraEditorClassName = 39] = "extraEditorClassName", s[s.fastScrollSensitivity = 40] = "fastScrollSensitivity", s[s.find = 41] = "find", s[s.fixedOverflowWidgets = 42] = "fixedOverflowWidgets", s[s.folding = 43] = "folding", s[s.foldingStrategy = 44] = "foldingStrategy", s[s.foldingHighlight = 45] = "foldingHighlight", s[s.foldingImportsByDefault = 46] = "foldingImportsByDefault", s[s.foldingMaximumRegions = 47] = "foldingMaximumRegions", s[s.unfoldOnClickAfterEndOfLine = 48] = "unfoldOnClickAfterEndOfLine", s[s.fontFamily = 49] = "fontFamily", s[s.fontInfo = 50] = "fontInfo", s[s.fontLigatures = 51] = "fontLigatures", s[s.fontSize = 52] = "fontSize", s[s.fontWeight = 53] = "fontWeight", s[s.fontVariations = 54] = "fontVariations", s[s.formatOnPaste = 55] = "formatOnPaste", s[s.formatOnType = 56] = "formatOnType", s[s.glyphMargin = 57] = "glyphMargin", s[s.gotoLocation = 58] = "gotoLocation", s[s.hideCursorInOverviewRuler = 59] = "hideCursorInOverviewRuler", s[s.hover = 60] = "hover", s[s.inDiffEditor = 61] = "inDiffEditor", s[s.inlineSuggest = 62] = "inlineSuggest", s[s.inlineEdit = 63] = "inlineEdit", s[s.letterSpacing = 64] = "letterSpacing", s[s.lightbulb = 65] = "lightbulb", s[s.lineDecorationsWidth = 66] = "lineDecorationsWidth", s[s.lineHeight = 67] = "lineHeight", s[s.lineNumbers = 68] = "lineNumbers", s[s.lineNumbersMinChars = 69] = "lineNumbersMinChars", s[s.linkedEditing = 70] = "linkedEditing", s[s.links = 71] = "links", s[s.matchBrackets = 72] = "matchBrackets", s[s.minimap = 73] = "minimap", s[s.mouseStyle = 74] = "mouseStyle", s[s.mouseWheelScrollSensitivity = 75] = "mouseWheelScrollSensitivity", s[s.mouseWheelZoom = 76] = "mouseWheelZoom", s[s.multiCursorMergeOverlapping = 77] = "multiCursorMergeOverlapping", s[s.multiCursorModifier = 78] = "multiCursorModifier", s[s.multiCursorPaste = 79] = "multiCursorPaste", s[s.multiCursorLimit = 80] = "multiCursorLimit", s[s.occurrencesHighlight = 81] = "occurrencesHighlight", s[s.overviewRulerBorder = 82] = "overviewRulerBorder", s[s.overviewRulerLanes = 83] = "overviewRulerLanes", s[s.padding = 84] = "padding", s[s.pasteAs = 85] = "pasteAs", s[s.parameterHints = 86] = "parameterHints", s[s.peekWidgetDefaultFocus = 87] = "peekWidgetDefaultFocus", s[s.placeholder = 88] = "placeholder", s[s.definitionLinkOpensInPeek = 89] = "definitionLinkOpensInPeek", s[s.quickSuggestions = 90] = "quickSuggestions", s[s.quickSuggestionsDelay = 91] = "quickSuggestionsDelay", s[s.readOnly = 92] = "readOnly", s[s.readOnlyMessage = 93] = "readOnlyMessage", s[s.renameOnType = 94] = "renameOnType", s[s.renderControlCharacters = 95] = "renderControlCharacters", s[s.renderFinalNewline = 96] = "renderFinalNewline", s[s.renderLineHighlight = 97] = "renderLineHighlight", s[s.renderLineHighlightOnlyWhenFocus = 98] = "renderLineHighlightOnlyWhenFocus", s[s.renderValidationDecorations = 99] = "renderValidationDecorations", s[s.renderWhitespace = 100] = "renderWhitespace", s[s.revealHorizontalRightPadding = 101] = "revealHorizontalRightPadding", s[s.roundedSelection = 102] = "roundedSelection", s[s.rulers = 103] = "rulers", s[s.scrollbar = 104] = "scrollbar", s[s.scrollBeyondLastColumn = 105] = "scrollBeyondLastColumn", s[s.scrollBeyondLastLine = 106] = "scrollBeyondLastLine", s[s.scrollPredominantAxis = 107] = "scrollPredominantAxis", s[s.selectionClipboard = 108] = "selectionClipboard", s[s.selectionHighlight = 109] = "selectionHighlight", s[s.selectOnLineNumbers = 110] = "selectOnLineNumbers", s[s.showFoldingControls = 111] = "showFoldingControls", s[s.showUnused = 112] = "showUnused", s[s.snippetSuggestions = 113] = "snippetSuggestions", s[s.smartSelect = 114] = "smartSelect", s[s.smoothScrolling = 115] = "smoothScrolling", s[s.stickyScroll = 116] = "stickyScroll", s[s.stickyTabStops = 117] = "stickyTabStops", s[s.stopRenderingLineAfter = 118] = "stopRenderingLineAfter", s[s.suggest = 119] = "suggest", s[s.suggestFontSize = 120] = "suggestFontSize", s[s.suggestLineHeight = 121] = "suggestLineHeight", s[s.suggestOnTriggerCharacters = 122] = "suggestOnTriggerCharacters", s[s.suggestSelection = 123] = "suggestSelection", s[s.tabCompletion = 124] = "tabCompletion", s[s.tabIndex = 125] = "tabIndex", s[s.unicodeHighlighting = 126] = "unicodeHighlighting", s[s.unusualLineTerminators = 127] = "unusualLineTerminators", s[s.useShadowDOM = 128] = "useShadowDOM", s[s.useTabStops = 129] = "useTabStops", s[s.wordBreak = 130] = "wordBreak", s[s.wordSegmenterLocales = 131] = "wordSegmenterLocales", s[s.wordSeparators = 132] = "wordSeparators", s[s.wordWrap = 133] = "wordWrap", s[s.wordWrapBreakAfterCharacters = 134] = "wordWrapBreakAfterCharacters", s[s.wordWrapBreakBeforeCharacters = 135] = "wordWrapBreakBeforeCharacters", s[s.wordWrapColumn = 136] = "wordWrapColumn", s[s.wordWrapOverride1 = 137] = "wordWrapOverride1", s[s.wordWrapOverride2 = 138] = "wordWrapOverride2", s[s.wrappingIndent = 139] = "wrappingIndent", s[s.wrappingStrategy = 140] = "wrappingStrategy", s[s.showDeprecated = 141] = "showDeprecated", s[s.inlayHints = 142] = "inlayHints", s[s.editorClassName = 143] = "editorClassName", s[s.pixelRatio = 144] = "pixelRatio", s[s.tabFocusMode = 145] = "tabFocusMode", s[s.layoutInfo = 146] = "layoutInfo", s[s.wrappingInfo = 147] = "wrappingInfo", s[s.defaultColorDecorators = 148] = "defaultColorDecorators", s[s.colorDecoratorsActivatedOn = 149] = "colorDecoratorsActivatedOn", s[s.inlineCompletionsAccessibilityVerbose = 150] = "inlineCompletionsAccessibilityVerbose";
})(ew || (ew = {}));
var tw;
(function(s) {
  s[s.TextDefined = 0] = "TextDefined", s[s.LF = 1] = "LF", s[s.CRLF = 2] = "CRLF";
})(tw || (tw = {}));
var iw;
(function(s) {
  s[s.LF = 0] = "LF", s[s.CRLF = 1] = "CRLF";
})(iw || (iw = {}));
var nw;
(function(s) {
  s[s.Left = 1] = "Left", s[s.Center = 2] = "Center", s[s.Right = 3] = "Right";
})(nw || (nw = {}));
var sw;
(function(s) {
  s[s.Increase = 0] = "Increase", s[s.Decrease = 1] = "Decrease";
})(sw || (sw = {}));
var ow;
(function(s) {
  s[s.None = 0] = "None", s[s.Indent = 1] = "Indent", s[s.IndentOutdent = 2] = "IndentOutdent", s[s.Outdent = 3] = "Outdent";
})(ow || (ow = {}));
var rw;
(function(s) {
  s[s.Both = 0] = "Both", s[s.Right = 1] = "Right", s[s.Left = 2] = "Left", s[s.None = 3] = "None";
})(rw || (rw = {}));
var aw;
(function(s) {
  s[s.Type = 1] = "Type", s[s.Parameter = 2] = "Parameter";
})(aw || (aw = {}));
var lw;
(function(s) {
  s[s.Automatic = 0] = "Automatic", s[s.Explicit = 1] = "Explicit";
})(lw || (lw = {}));
var cw;
(function(s) {
  s[s.Invoke = 0] = "Invoke", s[s.Automatic = 1] = "Automatic";
})(cw || (cw = {}));
var hw;
(function(s) {
  s[s.DependsOnKbLayout = -1] = "DependsOnKbLayout", s[s.Unknown = 0] = "Unknown", s[s.Backspace = 1] = "Backspace", s[s.Tab = 2] = "Tab", s[s.Enter = 3] = "Enter", s[s.Shift = 4] = "Shift", s[s.Ctrl = 5] = "Ctrl", s[s.Alt = 6] = "Alt", s[s.PauseBreak = 7] = "PauseBreak", s[s.CapsLock = 8] = "CapsLock", s[s.Escape = 9] = "Escape", s[s.Space = 10] = "Space", s[s.PageUp = 11] = "PageUp", s[s.PageDown = 12] = "PageDown", s[s.End = 13] = "End", s[s.Home = 14] = "Home", s[s.LeftArrow = 15] = "LeftArrow", s[s.UpArrow = 16] = "UpArrow", s[s.RightArrow = 17] = "RightArrow", s[s.DownArrow = 18] = "DownArrow", s[s.Insert = 19] = "Insert", s[s.Delete = 20] = "Delete", s[s.Digit0 = 21] = "Digit0", s[s.Digit1 = 22] = "Digit1", s[s.Digit2 = 23] = "Digit2", s[s.Digit3 = 24] = "Digit3", s[s.Digit4 = 25] = "Digit4", s[s.Digit5 = 26] = "Digit5", s[s.Digit6 = 27] = "Digit6", s[s.Digit7 = 28] = "Digit7", s[s.Digit8 = 29] = "Digit8", s[s.Digit9 = 30] = "Digit9", s[s.KeyA = 31] = "KeyA", s[s.KeyB = 32] = "KeyB", s[s.KeyC = 33] = "KeyC", s[s.KeyD = 34] = "KeyD", s[s.KeyE = 35] = "KeyE", s[s.KeyF = 36] = "KeyF", s[s.KeyG = 37] = "KeyG", s[s.KeyH = 38] = "KeyH", s[s.KeyI = 39] = "KeyI", s[s.KeyJ = 40] = "KeyJ", s[s.KeyK = 41] = "KeyK", s[s.KeyL = 42] = "KeyL", s[s.KeyM = 43] = "KeyM", s[s.KeyN = 44] = "KeyN", s[s.KeyO = 45] = "KeyO", s[s.KeyP = 46] = "KeyP", s[s.KeyQ = 47] = "KeyQ", s[s.KeyR = 48] = "KeyR", s[s.KeyS = 49] = "KeyS", s[s.KeyT = 50] = "KeyT", s[s.KeyU = 51] = "KeyU", s[s.KeyV = 52] = "KeyV", s[s.KeyW = 53] = "KeyW", s[s.KeyX = 54] = "KeyX", s[s.KeyY = 55] = "KeyY", s[s.KeyZ = 56] = "KeyZ", s[s.Meta = 57] = "Meta", s[s.ContextMenu = 58] = "ContextMenu", s[s.F1 = 59] = "F1", s[s.F2 = 60] = "F2", s[s.F3 = 61] = "F3", s[s.F4 = 62] = "F4", s[s.F5 = 63] = "F5", s[s.F6 = 64] = "F6", s[s.F7 = 65] = "F7", s[s.F8 = 66] = "F8", s[s.F9 = 67] = "F9", s[s.F10 = 68] = "F10", s[s.F11 = 69] = "F11", s[s.F12 = 70] = "F12", s[s.F13 = 71] = "F13", s[s.F14 = 72] = "F14", s[s.F15 = 73] = "F15", s[s.F16 = 74] = "F16", s[s.F17 = 75] = "F17", s[s.F18 = 76] = "F18", s[s.F19 = 77] = "F19", s[s.F20 = 78] = "F20", s[s.F21 = 79] = "F21", s[s.F22 = 80] = "F22", s[s.F23 = 81] = "F23", s[s.F24 = 82] = "F24", s[s.NumLock = 83] = "NumLock", s[s.ScrollLock = 84] = "ScrollLock", s[s.Semicolon = 85] = "Semicolon", s[s.Equal = 86] = "Equal", s[s.Comma = 87] = "Comma", s[s.Minus = 88] = "Minus", s[s.Period = 89] = "Period", s[s.Slash = 90] = "Slash", s[s.Backquote = 91] = "Backquote", s[s.BracketLeft = 92] = "BracketLeft", s[s.Backslash = 93] = "Backslash", s[s.BracketRight = 94] = "BracketRight", s[s.Quote = 95] = "Quote", s[s.OEM_8 = 96] = "OEM_8", s[s.IntlBackslash = 97] = "IntlBackslash", s[s.Numpad0 = 98] = "Numpad0", s[s.Numpad1 = 99] = "Numpad1", s[s.Numpad2 = 100] = "Numpad2", s[s.Numpad3 = 101] = "Numpad3", s[s.Numpad4 = 102] = "Numpad4", s[s.Numpad5 = 103] = "Numpad5", s[s.Numpad6 = 104] = "Numpad6", s[s.Numpad7 = 105] = "Numpad7", s[s.Numpad8 = 106] = "Numpad8", s[s.Numpad9 = 107] = "Numpad9", s[s.NumpadMultiply = 108] = "NumpadMultiply", s[s.NumpadAdd = 109] = "NumpadAdd", s[s.NUMPAD_SEPARATOR = 110] = "NUMPAD_SEPARATOR", s[s.NumpadSubtract = 111] = "NumpadSubtract", s[s.NumpadDecimal = 112] = "NumpadDecimal", s[s.NumpadDivide = 113] = "NumpadDivide", s[s.KEY_IN_COMPOSITION = 114] = "KEY_IN_COMPOSITION", s[s.ABNT_C1 = 115] = "ABNT_C1", s[s.ABNT_C2 = 116] = "ABNT_C2", s[s.AudioVolumeMute = 117] = "AudioVolumeMute", s[s.AudioVolumeUp = 118] = "AudioVolumeUp", s[s.AudioVolumeDown = 119] = "AudioVolumeDown", s[s.BrowserSearch = 120] = "BrowserSearch", s[s.BrowserHome = 121] = "BrowserHome", s[s.BrowserBack = 122] = "BrowserBack", s[s.BrowserForward = 123] = "BrowserForward", s[s.MediaTrackNext = 124] = "MediaTrackNext", s[s.MediaTrackPrevious = 125] = "MediaTrackPrevious", s[s.MediaStop = 126] = "MediaStop", s[s.MediaPlayPause = 127] = "MediaPlayPause", s[s.LaunchMediaPlayer = 128] = "LaunchMediaPlayer", s[s.LaunchMail = 129] = "LaunchMail", s[s.LaunchApp2 = 130] = "LaunchApp2", s[s.Clear = 131] = "Clear", s[s.MAX_VALUE = 132] = "MAX_VALUE";
})(hw || (hw = {}));
var dw;
(function(s) {
  s[s.Hint = 1] = "Hint", s[s.Info = 2] = "Info", s[s.Warning = 4] = "Warning", s[s.Error = 8] = "Error";
})(dw || (dw = {}));
var uw;
(function(s) {
  s[s.Unnecessary = 1] = "Unnecessary", s[s.Deprecated = 2] = "Deprecated";
})(uw || (uw = {}));
var fw;
(function(s) {
  s[s.Inline = 1] = "Inline", s[s.Gutter = 2] = "Gutter";
})(fw || (fw = {}));
var gw;
(function(s) {
  s[s.Normal = 1] = "Normal", s[s.Underlined = 2] = "Underlined";
})(gw || (gw = {}));
var mw;
(function(s) {
  s[s.UNKNOWN = 0] = "UNKNOWN", s[s.TEXTAREA = 1] = "TEXTAREA", s[s.GUTTER_GLYPH_MARGIN = 2] = "GUTTER_GLYPH_MARGIN", s[s.GUTTER_LINE_NUMBERS = 3] = "GUTTER_LINE_NUMBERS", s[s.GUTTER_LINE_DECORATIONS = 4] = "GUTTER_LINE_DECORATIONS", s[s.GUTTER_VIEW_ZONE = 5] = "GUTTER_VIEW_ZONE", s[s.CONTENT_TEXT = 6] = "CONTENT_TEXT", s[s.CONTENT_EMPTY = 7] = "CONTENT_EMPTY", s[s.CONTENT_VIEW_ZONE = 8] = "CONTENT_VIEW_ZONE", s[s.CONTENT_WIDGET = 9] = "CONTENT_WIDGET", s[s.OVERVIEW_RULER = 10] = "OVERVIEW_RULER", s[s.SCROLLBAR = 11] = "SCROLLBAR", s[s.OVERLAY_WIDGET = 12] = "OVERLAY_WIDGET", s[s.OUTSIDE_EDITOR = 13] = "OUTSIDE_EDITOR";
})(mw || (mw = {}));
var pw;
(function(s) {
  s[s.AIGenerated = 1] = "AIGenerated";
})(pw || (pw = {}));
var _w;
(function(s) {
  s[s.Invoke = 0] = "Invoke", s[s.Automatic = 1] = "Automatic";
})(_w || (_w = {}));
var bw;
(function(s) {
  s[s.TOP_RIGHT_CORNER = 0] = "TOP_RIGHT_CORNER", s[s.BOTTOM_RIGHT_CORNER = 1] = "BOTTOM_RIGHT_CORNER", s[s.TOP_CENTER = 2] = "TOP_CENTER";
})(bw || (bw = {}));
var Cw;
(function(s) {
  s[s.Left = 1] = "Left", s[s.Center = 2] = "Center", s[s.Right = 4] = "Right", s[s.Full = 7] = "Full";
})(Cw || (Cw = {}));
var ww;
(function(s) {
  s[s.Word = 0] = "Word", s[s.Line = 1] = "Line", s[s.Suggest = 2] = "Suggest";
})(ww || (ww = {}));
var vw;
(function(s) {
  s[s.Left = 0] = "Left", s[s.Right = 1] = "Right", s[s.None = 2] = "None", s[s.LeftOfInjectedText = 3] = "LeftOfInjectedText", s[s.RightOfInjectedText = 4] = "RightOfInjectedText";
})(vw || (vw = {}));
var yw;
(function(s) {
  s[s.Off = 0] = "Off", s[s.On = 1] = "On", s[s.Relative = 2] = "Relative", s[s.Interval = 3] = "Interval", s[s.Custom = 4] = "Custom";
})(yw || (yw = {}));
var Sw;
(function(s) {
  s[s.None = 0] = "None", s[s.Text = 1] = "Text", s[s.Blocks = 2] = "Blocks";
})(Sw || (Sw = {}));
var Lw;
(function(s) {
  s[s.Smooth = 0] = "Smooth", s[s.Immediate = 1] = "Immediate";
})(Lw || (Lw = {}));
var kw;
(function(s) {
  s[s.Auto = 1] = "Auto", s[s.Hidden = 2] = "Hidden", s[s.Visible = 3] = "Visible";
})(kw || (kw = {}));
var xw;
(function(s) {
  s[s.LTR = 0] = "LTR", s[s.RTL = 1] = "RTL";
})(xw || (xw = {}));
var Dw;
(function(s) {
  s.Off = "off", s.OnCode = "onCode", s.On = "on";
})(Dw || (Dw = {}));
var Ew;
(function(s) {
  s[s.Invoke = 1] = "Invoke", s[s.TriggerCharacter = 2] = "TriggerCharacter", s[s.ContentChange = 3] = "ContentChange";
})(Ew || (Ew = {}));
var Iw;
(function(s) {
  s[s.File = 0] = "File", s[s.Module = 1] = "Module", s[s.Namespace = 2] = "Namespace", s[s.Package = 3] = "Package", s[s.Class = 4] = "Class", s[s.Method = 5] = "Method", s[s.Property = 6] = "Property", s[s.Field = 7] = "Field", s[s.Constructor = 8] = "Constructor", s[s.Enum = 9] = "Enum", s[s.Interface = 10] = "Interface", s[s.Function = 11] = "Function", s[s.Variable = 12] = "Variable", s[s.Constant = 13] = "Constant", s[s.String = 14] = "String", s[s.Number = 15] = "Number", s[s.Boolean = 16] = "Boolean", s[s.Array = 17] = "Array", s[s.Object = 18] = "Object", s[s.Key = 19] = "Key", s[s.Null = 20] = "Null", s[s.EnumMember = 21] = "EnumMember", s[s.Struct = 22] = "Struct", s[s.Event = 23] = "Event", s[s.Operator = 24] = "Operator", s[s.TypeParameter = 25] = "TypeParameter";
})(Iw || (Iw = {}));
var Nw;
(function(s) {
  s[s.Deprecated = 1] = "Deprecated";
})(Nw || (Nw = {}));
var Tw;
(function(s) {
  s[s.Hidden = 0] = "Hidden", s[s.Blink = 1] = "Blink", s[s.Smooth = 2] = "Smooth", s[s.Phase = 3] = "Phase", s[s.Expand = 4] = "Expand", s[s.Solid = 5] = "Solid";
})(Tw || (Tw = {}));
var Mw;
(function(s) {
  s[s.Line = 1] = "Line", s[s.Block = 2] = "Block", s[s.Underline = 3] = "Underline", s[s.LineThin = 4] = "LineThin", s[s.BlockOutline = 5] = "BlockOutline", s[s.UnderlineThin = 6] = "UnderlineThin";
})(Mw || (Mw = {}));
var Rw;
(function(s) {
  s[s.AlwaysGrowsWhenTypingAtEdges = 0] = "AlwaysGrowsWhenTypingAtEdges", s[s.NeverGrowsWhenTypingAtEdges = 1] = "NeverGrowsWhenTypingAtEdges", s[s.GrowsOnlyWhenTypingBefore = 2] = "GrowsOnlyWhenTypingBefore", s[s.GrowsOnlyWhenTypingAfter = 3] = "GrowsOnlyWhenTypingAfter";
})(Rw || (Rw = {}));
var Aw;
(function(s) {
  s[s.None = 0] = "None", s[s.Same = 1] = "Same", s[s.Indent = 2] = "Indent", s[s.DeepIndent = 3] = "DeepIndent";
})(Aw || (Aw = {}));
var Br;
let UO = (Br = class {
  static chord(e, t) {
    return mO(e, t);
  }
}, Br.CtrlCmd = 2048, Br.Shift = 1024, Br.Alt = 512, Br.WinCtrl = 256, Br);
function G2() {
  return {
    editor: void 0,
    // undefined override expected here
    languages: void 0,
    // undefined override expected here
    CancellationTokenSource: Wd,
    Emitter: O,
    KeyCode: hw,
    KeyMod: UO,
    Position: V,
    Range: R,
    Selection: ft,
    SelectionDirection: xw,
    MarkerSeverity: dw,
    MarkerTag: uw,
    Uri: Te,
    Token: Rf
  };
}
function $O(s, e) {
  const t = s;
  typeof t.vscodeWindowId != "number" && Object.defineProperty(t, "vscodeWindowId", {
    get: () => e
  });
}
const ut = window;
function Z2(s) {
  return s;
}
class KO {
  constructor(e, t) {
    this.lastCache = void 0, this.lastArgKey = void 0, typeof e == "function" ? (this._fn = e, this._computeKey = Z2) : (this._fn = t, this._computeKey = e.getCacheKey);
  }
  get(e) {
    const t = this._computeKey(e);
    return this.lastArgKey !== t && (this.lastArgKey = t, this.lastCache = this._fn(e)), this.lastCache;
  }
}
class CD {
  get cachedValues() {
    return this._map;
  }
  constructor(e, t) {
    this._map = /* @__PURE__ */ new Map(), this._map2 = /* @__PURE__ */ new Map(), typeof e == "function" ? (this._fn = e, this._computeKey = Z2) : (this._fn = t, this._computeKey = e.getCacheKey);
  }
  get(e) {
    const t = this._computeKey(e);
    if (this._map2.has(t))
      return this._map2.get(t);
    const i = this._fn(e);
    return this._map.set(e, i), this._map2.set(t, i), i;
  }
}
class Ha {
  constructor(e) {
    this.executor = e, this._didRun = !1;
  }
  /**
   * Get the wrapped value.
   *
   * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only
   * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value
   */
  get value() {
    if (!this._didRun)
      try {
        this._value = this.executor();
      } catch (e) {
        this._error = e;
      } finally {
        this._didRun = !0;
      }
    if (this._error)
      throw this._error;
    return this._value;
  }
  /**
   * Get the wrapped value without forcing evaluation.
   */
  get rawValue() {
    return this._value;
  }
}
function qO(s) {
  return !s || typeof s != "string" ? !0 : s.trim().length === 0;
}
const jO = /{(\d+)}/g;
function Pw(s, ...e) {
  return e.length === 0 ? s : s.replace(jO, function(t, i) {
    const n = parseInt(i, 10);
    return isNaN(n) || n < 0 || n >= e.length ? t : e[n];
  });
}
function GO(s) {
  return s.replace(/[<>"'&]/g, (e) => {
    switch (e) {
      case "<":
        return "&lt;";
      case ">":
        return "&gt;";
      case '"':
        return "&quot;";
      case "'":
        return "&apos;";
      case "&":
        return "&amp;";
    }
    return e;
  });
}
function Fu(s) {
  return s.replace(/[<>&]/g, function(e) {
    switch (e) {
      case "<":
        return "&lt;";
      case ">":
        return "&gt;";
      case "&":
        return "&amp;";
      default:
        return e;
    }
  });
}
function Yr(s) {
  return s.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, "\\$&");
}
function ib(s, e) {
  if (!s || !e)
    return s;
  const t = e.length;
  if (t === 0 || s.length === 0)
    return s;
  let i = 0;
  for (; s.indexOf(e, i) === i; )
    i = i + t;
  return s.substring(i);
}
function ZO(s, e) {
  if (!s || !e)
    return s;
  const t = e.length, i = s.length;
  if (t === 0 || i === 0)
    return s;
  let n = i, o = -1;
  for (; o = s.lastIndexOf(e, n - 1), !(o === -1 || o + t !== n); ) {
    if (o === 0)
      return "";
    n = o;
  }
  return s.substring(0, n);
}
function YO(s) {
  return s.replace(/[\-\\\{\}\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&").replace(/[\*]/g, ".*");
}
function Y2(s, e, t = {}) {
  if (!s)
    throw new Error("Cannot create regex from empty string");
  e || (s = Yr(s)), t.wholeWord && (/\B/.test(s.charAt(0)) || (s = "\\b" + s), /\B/.test(s.charAt(s.length - 1)) || (s = s + "\\b"));
  let i = "";
  return t.global && (i += "g"), t.matchCase || (i += "i"), t.multiline && (i += "m"), t.unicode && (i += "u"), new RegExp(s, i);
}
function QO(s) {
  return s.source === "^" || s.source === "^$" || s.source === "$" || s.source === "^\\s*$" ? !1 : !!(s.exec("") && s.lastIndex === 0);
}
function Vd(s) {
  return s.split(/\r\n|\r|\n/);
}
function On(s) {
  for (let e = 0, t = s.length; e < t; e++) {
    const i = s.charCodeAt(e);
    if (i !== 32 && i !== 9)
      return e;
  }
  return -1;
}
function en(s, e = 0, t = s.length) {
  for (let i = e; i < t; i++) {
    const n = s.charCodeAt(i);
    if (n !== 32 && n !== 9)
      return s.substring(e, i);
  }
  return s.substring(e, t);
}
function Ec(s, e = s.length - 1) {
  for (let t = e; t >= 0; t--) {
    const i = s.charCodeAt(t);
    if (i !== 32 && i !== 9)
      return t;
  }
  return -1;
}
function Ow(s, e) {
  return s < e ? -1 : s > e ? 1 : 0;
}
function DL(s, e, t = 0, i = s.length, n = 0, o = e.length) {
  for (; t < i && n < o; t++, n++) {
    const l = s.charCodeAt(t), c = e.charCodeAt(n);
    if (l < c)
      return -1;
    if (l > c)
      return 1;
  }
  const r = i - t, a = o - n;
  return r < a ? -1 : r > a ? 1 : 0;
}
function wD(s, e) {
  return Sg(s, e, 0, s.length, 0, e.length);
}
function Sg(s, e, t = 0, i = s.length, n = 0, o = e.length) {
  for (; t < i && n < o; t++, n++) {
    let l = s.charCodeAt(t), c = e.charCodeAt(n);
    if (l === c)
      continue;
    if (l >= 128 || c >= 128)
      return DL(s.toLowerCase(), e.toLowerCase(), t, i, n, o);
    hh(l) && (l -= 32), hh(c) && (c -= 32);
    const h = l - c;
    if (h !== 0)
      return h;
  }
  const r = i - t, a = o - n;
  return r < a ? -1 : r > a ? 1 : 0;
}
function em(s) {
  return s >= 48 && s <= 57;
}
function hh(s) {
  return s >= 97 && s <= 122;
}
function ga(s) {
  return s >= 65 && s <= 90;
}
function dh(s, e) {
  return s.length === e.length && Sg(s, e) === 0;
}
function EL(s, e) {
  const t = e.length;
  return e.length > s.length ? !1 : Sg(s, e, 0, t) === 0;
}
function Fw(s, e) {
  const t = Math.min(s.length, e.length);
  let i;
  for (i = 0; i < t; i++)
    if (s.charCodeAt(i) !== e.charCodeAt(i))
      return i;
  return t;
}
function Bw(s, e) {
  const t = Math.min(s.length, e.length);
  let i;
  const n = s.length - 1, o = e.length - 1;
  for (i = 0; i < t; i++)
    if (s.charCodeAt(n - i) !== e.charCodeAt(o - i))
      return i;
  return t;
}
function hi(s) {
  return 55296 <= s && s <= 56319;
}
function _d(s) {
  return 56320 <= s && s <= 57343;
}
function IL(s, e) {
  return (s - 55296 << 10) + (e - 56320) + 65536;
}
function kp(s, e, t) {
  const i = s.charCodeAt(t);
  if (hi(i) && t + 1 < e) {
    const n = s.charCodeAt(t + 1);
    if (_d(n))
      return IL(i, n);
  }
  return i;
}
function XO(s, e) {
  const t = s.charCodeAt(e - 1);
  if (_d(t) && e > 1) {
    const i = s.charCodeAt(e - 2);
    if (hi(i))
      return IL(i, t);
  }
  return t;
}
class NL {
  get offset() {
    return this._offset;
  }
  constructor(e, t = 0) {
    this._str = e, this._len = e.length, this._offset = t;
  }
  setOffset(e) {
    this._offset = e;
  }
  prevCodePoint() {
    const e = XO(this._str, this._offset);
    return this._offset -= e >= 65536 ? 2 : 1, e;
  }
  nextCodePoint() {
    const e = kp(this._str, this._len, this._offset);
    return this._offset += e >= 65536 ? 2 : 1, e;
  }
  eol() {
    return this._offset >= this._len;
  }
}
class xp {
  get offset() {
    return this._iterator.offset;
  }
  constructor(e, t = 0) {
    this._iterator = new NL(e, t);
  }
  nextGraphemeLength() {
    const e = Dp.getInstance(), t = this._iterator, i = t.offset;
    let n = e.getGraphemeBreakType(t.nextCodePoint());
    for (; !t.eol(); ) {
      const o = t.offset, r = e.getGraphemeBreakType(t.nextCodePoint());
      if (vD(n, r)) {
        t.setOffset(o);
        break;
      }
      n = r;
    }
    return t.offset - i;
  }
  prevGraphemeLength() {
    const e = Dp.getInstance(), t = this._iterator, i = t.offset;
    let n = e.getGraphemeBreakType(t.prevCodePoint());
    for (; t.offset > 0; ) {
      const o = t.offset, r = e.getGraphemeBreakType(t.prevCodePoint());
      if (vD(r, n)) {
        t.setOffset(o);
        break;
      }
      n = r;
    }
    return i - t.offset;
  }
  eol() {
    return this._iterator.eol();
  }
}
function TL(s, e) {
  return new xp(s, e).nextGraphemeLength();
}
function Q2(s, e) {
  return new xp(s, e).prevGraphemeLength();
}
function JO(s, e) {
  e > 0 && _d(s.charCodeAt(e)) && e--;
  const t = e + TL(s, e);
  return [t - Q2(s, t), t];
}
let l0;
function e6() {
  return /(?:[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u0710\u0712-\u072F\u074D-\u07A5\u07B1-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u0858\u085E-\u088E\u08A0-\u08C9\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFD3D\uFD50-\uFDC7\uFDF0-\uFDFC\uFE70-\uFEFC]|\uD802[\uDC00-\uDD1B\uDD20-\uDE00\uDE10-\uDE35\uDE40-\uDEE4\uDEEB-\uDF35\uDF40-\uDFFF]|\uD803[\uDC00-\uDD23\uDE80-\uDEA9\uDEAD-\uDF45\uDF51-\uDF81\uDF86-\uDFF6]|\uD83A[\uDC00-\uDCCF\uDD00-\uDD43\uDD4B-\uDFFF]|\uD83B[\uDC00-\uDEBB])/;
}
function Af(s) {
  return l0 || (l0 = e6()), l0.test(s);
}
const t6 = /^[\t\n\r\x20-\x7E]*$/;
function ML(s) {
  return t6.test(s);
}
const X2 = /[\u2028\u2029]/;
function J2(s) {
  return X2.test(s);
}
function za(s) {
  return s >= 11904 && s <= 55215 || s >= 63744 && s <= 64255 || s >= 65281 && s <= 65374;
}
function RL(s) {
  return s >= 127462 && s <= 127487 || s === 8986 || s === 8987 || s === 9200 || s === 9203 || s >= 9728 && s <= 10175 || s === 11088 || s === 11093 || s >= 127744 && s <= 128591 || s >= 128640 && s <= 128764 || s >= 128992 && s <= 129008 || s >= 129280 && s <= 129535 || s >= 129648 && s <= 129782;
}
const i6 = "\uFEFF";
function AL(s) {
  return !!(s && s.length > 0 && s.charCodeAt(0) === 65279);
}
function eM(s) {
  return s = s % 52, s < 26 ? String.fromCharCode(97 + s) : String.fromCharCode(65 + s - 26);
}
function vD(s, e) {
  return s === 0 ? e !== 5 && e !== 7 : s === 2 && e === 3 ? !1 : s === 4 || s === 2 || s === 3 || e === 4 || e === 2 || e === 3 ? !0 : !(s === 8 && (e === 8 || e === 9 || e === 11 || e === 12) || (s === 11 || s === 9) && (e === 9 || e === 10) || (s === 12 || s === 10) && e === 10 || e === 5 || e === 13 || e === 7 || s === 1 || s === 13 && e === 14 || s === 6 && e === 6);
}
const Fl = class Fl {
  static getInstance() {
    return Fl._INSTANCE || (Fl._INSTANCE = new Fl()), Fl._INSTANCE;
  }
  constructor() {
    this._data = n6();
  }
  getGraphemeBreakType(e) {
    if (e < 32)
      return e === 10 ? 3 : e === 13 ? 2 : 4;
    if (e < 127)
      return 0;
    const t = this._data, i = t.length / 3;
    let n = 1;
    for (; n <= i; )
      if (e < t[3 * n])
        n = 2 * n;
      else if (e > t[3 * n + 1])
        n = 2 * n + 1;
      else
        return t[3 * n + 2];
    return 0;
  }
};
Fl._INSTANCE = null;
let Dp = Fl;
function n6() {
  return JSON.parse("[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]");
}
function s6(s, e) {
  if (s === 0)
    return 0;
  const t = o6(s, e);
  if (t !== void 0)
    return t;
  const i = new NL(e, s);
  return i.prevCodePoint(), i.offset;
}
function o6(s, e) {
  const t = new NL(e, s);
  let i = t.prevCodePoint();
  for (; r6(i) || i === 65039 || i === 8419; ) {
    if (t.offset === 0)
      return;
    i = t.prevCodePoint();
  }
  if (!RL(i))
    return;
  let n = t.offset;
  return n > 0 && t.prevCodePoint() === 8205 && (n = t.offset), n;
}
function r6(s) {
  return 127995 <= s && s <= 127999;
}
const Eo = class Eo {
  static getInstance(e) {
    return Eo.cache.get(Array.from(e));
  }
  static getLocales() {
    return Eo._locales.value;
  }
  constructor(e) {
    this.confusableDictionary = e;
  }
  isAmbiguous(e) {
    return this.confusableDictionary.has(e);
  }
  /**
   * Returns the non basic ASCII code point that the given code point can be confused,
   * or undefined if such code point does note exist.
   */
  getPrimaryConfusable(e) {
    return this.confusableDictionary.get(e);
  }
  getConfusableCodePoints() {
    return new Set(this.confusableDictionary.keys());
  }
};
Eo.ambiguousCharacterData = new Ha(() => JSON.parse('{"_common":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,8218,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,8242,96,1370,96,1523,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71922,67,71913,67,65315,67,8557,67,8450,67,8493,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71919,87,71910,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,66293,90,71909,90,65338,90,8484,90,8488,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65297,49,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125,119846,109],"_default":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"cs":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"de":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"es":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"fr":[65374,126,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"it":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ja":[8211,45,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65292,44,65307,59],"ko":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pl":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pt-BR":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"qps-ploc":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ru":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"tr":[160,32,8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"zh-hans":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41],"zh-hant":[8211,45,65374,126,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65307,59]}')), Eo.cache = new KO({ getCacheKey: JSON.stringify }, (e) => {
  function t(h) {
    const d = /* @__PURE__ */ new Map();
    for (let u = 0; u < h.length; u += 2)
      d.set(h[u], h[u + 1]);
    return d;
  }
  function i(h, d) {
    const u = new Map(h);
    for (const [f, g] of d)
      u.set(f, g);
    return u;
  }
  function n(h, d) {
    if (!h)
      return d;
    const u = /* @__PURE__ */ new Map();
    for (const [f, g] of h)
      d.has(f) && u.set(f, g);
    return u;
  }
  const o = Eo.ambiguousCharacterData.value;
  let r = e.filter((h) => !h.startsWith("_") && h in o);
  r.length === 0 && (r = ["_default"]);
  let a;
  for (const h of r) {
    const d = t(o[h]);
    a = n(a, d);
  }
  const l = t(o._common), c = i(l, a);
  return new Eo(c);
}), Eo._locales = new Ha(() => Object.keys(Eo.ambiguousCharacterData.value).filter((e) => !e.startsWith("_")));
let Pf = Eo;
const Th = class Th {
  static getRawData() {
    return JSON.parse("[9,10,11,12,13,32,127,160,173,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12288,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999]");
  }
  static getData() {
    return this._data || (this._data = new Set(Th.getRawData())), this._data;
  }
  static isInvisibleCharacter(e) {
    return Th.getData().has(e);
  }
  static get codePoints() {
    return Th.getData();
  }
};
Th._data = void 0;
let Bu = Th;
const a1 = class a1 {
  constructor() {
    this.mapWindowIdToZoomFactor = /* @__PURE__ */ new Map();
  }
  getZoomFactor(e) {
    return this.mapWindowIdToZoomFactor.get(this.getWindowId(e)) ?? 1;
  }
  getWindowId(e) {
    return e.vscodeWindowId;
  }
};
a1.INSTANCE = new a1();
let Ww = a1;
function tM(s, e, t) {
  typeof e == "string" && (e = s.matchMedia(e)), e.addEventListener("change", t);
}
function a6(s) {
  return Ww.INSTANCE.getZoomFactor(s);
}
const Hd = navigator.userAgent, As = Hd.indexOf("Firefox") >= 0, nb = Hd.indexOf("AppleWebKit") >= 0, Lg = Hd.indexOf("Chrome") >= 0, Ua = !Lg && Hd.indexOf("Safari") >= 0, iM = !Lg && !Ua && nb;
Hd.indexOf("Electron/") >= 0;
const yD = Hd.indexOf("Android") >= 0;
let c0 = !1;
if (typeof ut.matchMedia == "function") {
  const s = ut.matchMedia("(display-mode: standalone) or (display-mode: window-controls-overlay)"), e = ut.matchMedia("(display-mode: fullscreen)");
  c0 = s.matches, tM(ut, s, ({ matches: t }) => {
    c0 && e.matches || (c0 = t);
  });
}
const nM = {
  clipboard: {
    writeText: Cp || document.queryCommandSupported && document.queryCommandSupported("copy") || !!(navigator && navigator.clipboard && navigator.clipboard.writeText),
    readText: Cp || !!(navigator && navigator.clipboard && navigator.clipboard.readText)
  },
  pointerEvents: ut.PointerEvent && ("ontouchstart" in ut || navigator.maxTouchPoints > 0)
};
function Vw(s, e) {
  if (typeof s == "number") {
    if (s === 0)
      return null;
    const t = (s & 65535) >>> 0, i = (s & 4294901760) >>> 16;
    return i !== 0 ? new h0([
      tm(t, e),
      tm(i, e)
    ]) : new h0([tm(t, e)]);
  } else {
    const t = [];
    for (let i = 0; i < s.length; i++)
      t.push(tm(s[i], e));
    return new h0(t);
  }
}
function tm(s, e) {
  const t = !!(s & 2048), i = !!(s & 256), n = e === 2 ? i : t, o = !!(s & 1024), r = !!(s & 512), a = e === 2 ? t : i, l = s & 255;
  return new mc(n, o, r, a, l);
}
class mc {
  constructor(e, t, i, n, o) {
    this.ctrlKey = e, this.shiftKey = t, this.altKey = i, this.metaKey = n, this.keyCode = o;
  }
  equals(e) {
    return e instanceof mc && this.ctrlKey === e.ctrlKey && this.shiftKey === e.shiftKey && this.altKey === e.altKey && this.metaKey === e.metaKey && this.keyCode === e.keyCode;
  }
  isModifierKey() {
    return this.keyCode === 0 || this.keyCode === 5 || this.keyCode === 57 || this.keyCode === 6 || this.keyCode === 4;
  }
  /**
   * Does this keybinding refer to the key code of a modifier and it also has the modifier flag?
   */
  isDuplicateModifierCase() {
    return this.ctrlKey && this.keyCode === 5 || this.shiftKey && this.keyCode === 4 || this.altKey && this.keyCode === 6 || this.metaKey && this.keyCode === 57;
  }
}
class h0 {
  constructor(e) {
    if (e.length === 0)
      throw eb("chords");
    this.chords = e;
  }
}
class l6 {
  constructor(e, t, i, n, o, r) {
    this.ctrlKey = e, this.shiftKey = t, this.altKey = i, this.metaKey = n, this.keyLabel = o, this.keyAriaLabel = r;
  }
}
class c6 {
}
function h6(s) {
  if (s.charCode) {
    const t = String.fromCharCode(s.charCode).toUpperCase();
    return Lr.fromString(t);
  }
  const e = s.keyCode;
  if (e === 3)
    return 7;
  if (As)
    switch (e) {
      case 59:
        return 85;
      case 60:
        if (wn)
          return 97;
        break;
      case 61:
        return 86;
      // based on: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode#numpad_keys
      case 107:
        return 109;
      case 109:
        return 111;
      case 173:
        return 88;
      case 224:
        if (He)
          return 57;
        break;
    }
  else if (nb) {
    if (He && e === 93)
      return 57;
    if (!He && e === 92)
      return 57;
  }
  return B2[e] || 0;
}
const d6 = He ? 256 : 2048, u6 = 512, f6 = 1024, g6 = He ? 2048 : 256;
class Lt {
  constructor(e) {
    var i;
    this._standardKeyboardEventBrand = !0;
    const t = e;
    this.browserEvent = t, this.target = t.target, this.ctrlKey = t.ctrlKey, this.shiftKey = t.shiftKey, this.altKey = t.altKey, this.metaKey = t.metaKey, this.altGraphKey = (i = t.getModifierState) == null ? void 0 : i.call(t, "AltGraph"), this.keyCode = h6(t), this.code = t.code, this.ctrlKey = this.ctrlKey || this.keyCode === 5, this.altKey = this.altKey || this.keyCode === 6, this.shiftKey = this.shiftKey || this.keyCode === 4, this.metaKey = this.metaKey || this.keyCode === 57, this._asKeybinding = this._computeKeybinding(), this._asKeyCodeChord = this._computeKeyCodeChord();
  }
  preventDefault() {
    this.browserEvent && this.browserEvent.preventDefault && this.browserEvent.preventDefault();
  }
  stopPropagation() {
    this.browserEvent && this.browserEvent.stopPropagation && this.browserEvent.stopPropagation();
  }
  toKeyCodeChord() {
    return this._asKeyCodeChord;
  }
  equals(e) {
    return this._asKeybinding === e;
  }
  _computeKeybinding() {
    let e = 0;
    this.keyCode !== 5 && this.keyCode !== 4 && this.keyCode !== 6 && this.keyCode !== 57 && (e = this.keyCode);
    let t = 0;
    return this.ctrlKey && (t |= d6), this.altKey && (t |= u6), this.shiftKey && (t |= f6), this.metaKey && (t |= g6), t |= e, t;
  }
  _computeKeyCodeChord() {
    let e = 0;
    return this.keyCode !== 5 && this.keyCode !== 4 && this.keyCode !== 6 && this.keyCode !== 57 && (e = this.keyCode), new mc(this.ctrlKey, this.shiftKey, this.altKey, this.metaKey, e);
  }
}
const SD = /* @__PURE__ */ new WeakMap();
function m6(s) {
  if (!s.parent || s.parent === s)
    return null;
  try {
    const e = s.location, t = s.parent.location;
    if (e.origin !== "null" && t.origin !== "null" && e.origin !== t.origin)
      return null;
  } catch {
    return null;
  }
  return s.parent;
}
class p6 {
  /**
   * Returns a chain of embedded windows with the same origin (which can be accessed programmatically).
   * Having a chain of length 1 might mean that the current execution environment is running outside of an iframe or inside an iframe embedded in a window with a different origin.
   */
  static getSameOriginWindowChain(e) {
    let t = SD.get(e);
    if (!t) {
      t = [], SD.set(e, t);
      let i = e, n;
      do
        n = m6(i), n ? t.push({
          window: new WeakRef(i),
          iframeElement: i.frameElement || null
        }) : t.push({
          window: new WeakRef(i),
          iframeElement: null
        }), i = n;
      while (i);
    }
    return t.slice(0);
  }
  /**
   * Returns the position of `childWindow` relative to `ancestorWindow`
   */
  static getPositionOfChildWindowRelativeToAncestorWindow(e, t) {
    if (!t || e === t)
      return {
        top: 0,
        left: 0
      };
    let i = 0, n = 0;
    const o = this.getSameOriginWindowChain(e);
    for (const r of o) {
      const a = r.window.deref();
      if (i += (a == null ? void 0 : a.scrollY) ?? 0, n += (a == null ? void 0 : a.scrollX) ?? 0, a === t || !r.iframeElement)
        break;
      const l = r.iframeElement.getBoundingClientRect();
      i += l.top, n += l.left;
    }
    return {
      top: i,
      left: n
    };
  }
}
class to {
  constructor(e, t) {
    this.timestamp = Date.now(), this.browserEvent = t, this.leftButton = t.button === 0, this.middleButton = t.button === 1, this.rightButton = t.button === 2, this.buttons = t.buttons, this.target = t.target, this.detail = t.detail || 1, t.type === "dblclick" && (this.detail = 2), this.ctrlKey = t.ctrlKey, this.shiftKey = t.shiftKey, this.altKey = t.altKey, this.metaKey = t.metaKey, typeof t.pageX == "number" ? (this.posx = t.pageX, this.posy = t.pageY) : (this.posx = t.clientX + this.target.ownerDocument.body.scrollLeft + this.target.ownerDocument.documentElement.scrollLeft, this.posy = t.clientY + this.target.ownerDocument.body.scrollTop + this.target.ownerDocument.documentElement.scrollTop);
    const i = p6.getPositionOfChildWindowRelativeToAncestorWindow(e, t.view);
    this.posx -= i.left, this.posy -= i.top;
  }
  preventDefault() {
    this.browserEvent.preventDefault();
  }
  stopPropagation() {
    this.browserEvent.stopPropagation();
  }
}
class pc {
  constructor(e, t = 0, i = 0) {
    var o;
    this.browserEvent = e || null, this.target = e ? e.target || e.targetNode || e.srcElement : null, this.deltaY = i, this.deltaX = t;
    let n = !1;
    if (Lg) {
      const r = navigator.userAgent.match(/Chrome\/(\d+)/);
      n = (r ? parseInt(r[1]) : 123) <= 122;
    }
    if (e) {
      const r = e, a = e, l = ((o = e.view) == null ? void 0 : o.devicePixelRatio) || 1;
      if (typeof r.wheelDeltaY < "u")
        n ? this.deltaY = r.wheelDeltaY / (120 * l) : this.deltaY = r.wheelDeltaY / 120;
      else if (typeof a.VERTICAL_AXIS < "u" && a.axis === a.VERTICAL_AXIS)
        this.deltaY = -a.detail / 3;
      else if (e.type === "wheel") {
        const c = e;
        c.deltaMode === c.DOM_DELTA_LINE ? As && !He ? this.deltaY = -e.deltaY / 3 : this.deltaY = -e.deltaY : this.deltaY = -e.deltaY / 40;
      }
      if (typeof r.wheelDeltaX < "u")
        Ua && Fn ? this.deltaX = -(r.wheelDeltaX / 120) : n ? this.deltaX = r.wheelDeltaX / (120 * l) : this.deltaX = r.wheelDeltaX / 120;
      else if (typeof a.HORIZONTAL_AXIS < "u" && a.axis === a.HORIZONTAL_AXIS)
        this.deltaX = -e.detail / 3;
      else if (e.type === "wheel") {
        const c = e;
        c.deltaMode === c.DOM_DELTA_LINE ? As && !He ? this.deltaX = -e.deltaX / 3 : this.deltaX = -e.deltaX : this.deltaX = -e.deltaX / 40;
      }
      this.deltaY === 0 && this.deltaX === 0 && e.wheelDelta && (n ? this.deltaY = e.wheelDelta / (120 * l) : this.deltaY = e.wheelDelta / 120);
    }
  }
  preventDefault() {
    var e;
    (e = this.browserEvent) == null || e.preventDefault();
  }
  stopPropagation() {
    var e;
    (e = this.browserEvent) == null || e.stopPropagation();
  }
}
const sM = Symbol("MicrotaskDelay");
function Hw(s) {
  return !!s && typeof s.then == "function";
}
function oM(s) {
  const e = new Wd(), t = s(e.token), i = new Promise((n, o) => {
    const r = e.token.onCancellationRequested(() => {
      r.dispose(), o(new vg());
    });
    Promise.resolve(t).then((a) => {
      r.dispose(), e.dispose(), n(a);
    }, (a) => {
      r.dispose(), e.dispose(), o(a);
    });
  });
  return new class {
    cancel() {
      e.cancel(), e.dispose();
    }
    then(n, o) {
      return i.then(n, o);
    }
    catch(n) {
      return this.then(void 0, n);
    }
    finally(n) {
      return i.finally(n);
    }
  }();
}
class _6 {
  constructor() {
    this.isDisposed = !1, this.activePromise = null, this.queuedPromise = null, this.queuedPromiseFactory = null;
  }
  queue(e) {
    if (this.isDisposed)
      return Promise.reject(new Error("Throttler is disposed"));
    if (this.activePromise) {
      if (this.queuedPromiseFactory = e, !this.queuedPromise) {
        const t = () => {
          if (this.queuedPromise = null, this.isDisposed)
            return;
          const i = this.queue(this.queuedPromiseFactory);
          return this.queuedPromiseFactory = null, i;
        };
        this.queuedPromise = new Promise((i) => {
          this.activePromise.then(t, t).then(i);
        });
      }
      return new Promise((t, i) => {
        this.queuedPromise.then(t, i);
      });
    }
    return this.activePromise = e(), new Promise((t, i) => {
      this.activePromise.then((n) => {
        this.activePromise = null, t(n);
      }, (n) => {
        this.activePromise = null, i(n);
      });
    });
  }
  dispose() {
    this.isDisposed = !0;
  }
}
const b6 = (s, e) => {
  let t = !0;
  const i = setTimeout(() => {
    t = !1, e();
  }, s);
  return {
    isTriggered: () => t,
    dispose: () => {
      clearTimeout(i), t = !1;
    }
  };
}, C6 = (s) => {
  let e = !0;
  return queueMicrotask(() => {
    e && (e = !1, s());
  }), {
    isTriggered: () => e,
    dispose: () => {
      e = !1;
    }
  };
};
class kg {
  constructor(e) {
    this.defaultDelay = e, this.deferred = null, this.completionPromise = null, this.doResolve = null, this.doReject = null, this.task = null;
  }
  trigger(e, t = this.defaultDelay) {
    this.task = e, this.cancelTimeout(), this.completionPromise || (this.completionPromise = new Promise((n, o) => {
      this.doResolve = n, this.doReject = o;
    }).then(() => {
      if (this.completionPromise = null, this.doResolve = null, this.task) {
        const n = this.task;
        return this.task = null, n();
      }
    }));
    const i = () => {
      var n;
      this.deferred = null, (n = this.doResolve) == null || n.call(this, null);
    };
    return this.deferred = t === sM ? C6(i) : b6(t, i), this.completionPromise;
  }
  isTriggered() {
    var e;
    return !!((e = this.deferred) != null && e.isTriggered());
  }
  cancel() {
    var e;
    this.cancelTimeout(), this.completionPromise && ((e = this.doReject) == null || e.call(this, new vg()), this.completionPromise = null);
  }
  cancelTimeout() {
    var e;
    (e = this.deferred) == null || e.dispose(), this.deferred = null;
  }
  dispose() {
    this.cancel();
  }
}
class rM {
  constructor(e) {
    this.delayer = new kg(e), this.throttler = new _6();
  }
  trigger(e, t) {
    return this.delayer.trigger(() => this.throttler.queue(e), t);
  }
  cancel() {
    this.delayer.cancel();
  }
  dispose() {
    this.delayer.dispose(), this.throttler.dispose();
  }
}
function Of(s, e) {
  return e ? new Promise((t, i) => {
    const n = setTimeout(() => {
      o.dispose(), t();
    }, s), o = e.onCancellationRequested(() => {
      clearTimeout(n), o.dispose(), i(new vg());
    });
  }) : oM((t) => Of(s, t));
}
function zw(s, e = 0, t) {
  const i = setTimeout(() => {
    s(), t && n.dispose();
  }, e), n = ke(() => {
    clearTimeout(i), t == null || t.deleteAndLeak(n);
  });
  return t == null || t.add(n), n;
}
class Ic {
  constructor(e, t) {
    this._isDisposed = !1, this._token = -1, typeof e == "function" && typeof t == "number" && this.setIfNotSet(e, t);
  }
  dispose() {
    this.cancel(), this._isDisposed = !0;
  }
  cancel() {
    this._token !== -1 && (clearTimeout(this._token), this._token = -1);
  }
  cancelAndSet(e, t) {
    if (this._isDisposed)
      throw new it("Calling 'cancelAndSet' on a disposed TimeoutTimer");
    this.cancel(), this._token = setTimeout(() => {
      this._token = -1, e();
    }, t);
  }
  setIfNotSet(e, t) {
    if (this._isDisposed)
      throw new it("Calling 'setIfNotSet' on a disposed TimeoutTimer");
    this._token === -1 && (this._token = setTimeout(() => {
      this._token = -1, e();
    }, t));
  }
}
class PL {
  constructor() {
    this.disposable = void 0, this.isDisposed = !1;
  }
  cancel() {
    var e;
    (e = this.disposable) == null || e.dispose(), this.disposable = void 0;
  }
  cancelAndSet(e, t, i = globalThis) {
    if (this.isDisposed)
      throw new it("Calling 'cancelAndSet' on a disposed IntervalTimer");
    this.cancel();
    const n = i.setInterval(() => {
      e();
    }, t);
    this.disposable = ke(() => {
      i.clearInterval(n), this.disposable = void 0;
    });
  }
  dispose() {
    this.cancel(), this.isDisposed = !0;
  }
}
class sn {
  constructor(e, t) {
    this.timeoutToken = -1, this.runner = e, this.timeout = t, this.timeoutHandler = this.onTimeout.bind(this);
  }
  /**
   * Dispose RunOnceScheduler
   */
  dispose() {
    this.cancel(), this.runner = null;
  }
  /**
   * Cancel current scheduled runner (if any).
   */
  cancel() {
    this.isScheduled() && (clearTimeout(this.timeoutToken), this.timeoutToken = -1);
  }
  /**
   * Cancel previous runner (if any) & schedule a new runner.
   */
  schedule(e = this.timeout) {
    this.cancel(), this.timeoutToken = setTimeout(this.timeoutHandler, e);
  }
  get delay() {
    return this.timeout;
  }
  set delay(e) {
    this.timeout = e;
  }
  /**
   * Returns true if scheduled.
   */
  isScheduled() {
    return this.timeoutToken !== -1;
  }
  onTimeout() {
    this.timeoutToken = -1, this.runner && this.doRun();
  }
  doRun() {
    var e;
    (e = this.runner) == null || e.call(this);
  }
}
let aM, Wu;
(function() {
  typeof globalThis.requestIdleCallback != "function" || typeof globalThis.cancelIdleCallback != "function" ? Wu = (s, e) => {
    D2(() => {
      if (t)
        return;
      const i = Date.now() + 15;
      e(Object.freeze({
        didTimeout: !0,
        timeRemaining() {
          return Math.max(0, i - Date.now());
        }
      }));
    });
    let t = !1;
    return {
      dispose() {
        t || (t = !0);
      }
    };
  } : Wu = (s, e, t) => {
    const i = s.requestIdleCallback(e, typeof t == "number" ? { timeout: t } : void 0);
    let n = !1;
    return {
      dispose() {
        n || (n = !0, s.cancelIdleCallback(i));
      }
    };
  }, aM = (s) => Wu(globalThis, s);
})();
class w6 {
  constructor(e, t) {
    this._didRun = !1, this._executor = () => {
      try {
        this._value = t();
      } catch (i) {
        this._error = i;
      } finally {
        this._didRun = !0;
      }
    }, this._handle = Wu(e, () => this._executor());
  }
  dispose() {
    this._handle.dispose();
  }
  get value() {
    if (this._didRun || (this._handle.dispose(), this._executor()), this._error)
      throw this._error;
    return this._value;
  }
  get isInitialized() {
    return this._didRun;
  }
}
class v6 extends w6 {
  constructor(e) {
    super(globalThis, e);
  }
}
class lM {
  get isRejected() {
    var e;
    return ((e = this.outcome) == null ? void 0 : e.outcome) === 1;
  }
  get isSettled() {
    return !!this.outcome;
  }
  constructor() {
    this.p = new Promise((e, t) => {
      this.completeCallback = e, this.errorCallback = t;
    });
  }
  complete(e) {
    return new Promise((t) => {
      this.completeCallback(e), this.outcome = { outcome: 0, value: e }, t();
    });
  }
  error(e) {
    return new Promise((t) => {
      this.errorCallback(e), this.outcome = { outcome: 1, value: e }, t();
    });
  }
  cancel() {
    return this.error(new vg());
  }
}
var Uw;
(function(s) {
  async function e(i) {
    let n;
    const o = await Promise.all(i.map((r) => r.then((a) => a, (a) => {
      n || (n = a);
    })));
    if (typeof n < "u")
      throw n;
    return o;
  }
  s.settled = e;
  function t(i) {
    return new Promise(async (n, o) => {
      try {
        await i(n, o);
      } catch (r) {
        o(r);
      }
    });
  }
  s.withAsyncBody = t;
})(Uw || (Uw = {}));
const In = class In {
  static fromArray(e) {
    return new In((t) => {
      t.emitMany(e);
    });
  }
  static fromPromise(e) {
    return new In(async (t) => {
      t.emitMany(await e);
    });
  }
  static fromPromises(e) {
    return new In(async (t) => {
      await Promise.all(e.map(async (i) => t.emitOne(await i)));
    });
  }
  static merge(e) {
    return new In(async (t) => {
      await Promise.all(e.map(async (i) => {
        for await (const n of i)
          t.emitOne(n);
      }));
    });
  }
  constructor(e, t) {
    this._state = 0, this._results = [], this._error = null, this._onReturn = t, this._onStateChanged = new O(), queueMicrotask(async () => {
      const i = {
        emitOne: (n) => this.emitOne(n),
        emitMany: (n) => this.emitMany(n),
        reject: (n) => this.reject(n)
      };
      try {
        await Promise.resolve(e(i)), this.resolve();
      } catch (n) {
        this.reject(n);
      } finally {
        i.emitOne = void 0, i.emitMany = void 0, i.reject = void 0;
      }
    });
  }
  [Symbol.asyncIterator]() {
    let e = 0;
    return {
      next: async () => {
        do {
          if (this._state === 2)
            throw this._error;
          if (e < this._results.length)
            return { done: !1, value: this._results[e++] };
          if (this._state === 1)
            return { done: !0, value: void 0 };
          await J.toPromise(this._onStateChanged.event);
        } while (!0);
      },
      return: async () => {
        var t;
        return (t = this._onReturn) == null || t.call(this), { done: !0, value: void 0 };
      }
    };
  }
  static map(e, t) {
    return new In(async (i) => {
      for await (const n of e)
        i.emitOne(t(n));
    });
  }
  map(e) {
    return In.map(this, e);
  }
  static filter(e, t) {
    return new In(async (i) => {
      for await (const n of e)
        t(n) && i.emitOne(n);
    });
  }
  filter(e) {
    return In.filter(this, e);
  }
  static coalesce(e) {
    return In.filter(e, (t) => !!t);
  }
  coalesce() {
    return In.coalesce(this);
  }
  static async toPromise(e) {
    const t = [];
    for await (const i of e)
      t.push(i);
    return t;
  }
  toPromise() {
    return In.toPromise(this);
  }
  /**
   * The value will be appended at the end.
   *
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */
  emitOne(e) {
    this._state === 0 && (this._results.push(e), this._onStateChanged.fire());
  }
  /**
   * The values will be appended at the end.
   *
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */
  emitMany(e) {
    this._state === 0 && (this._results = this._results.concat(e), this._onStateChanged.fire());
  }
  /**
   * Calling `resolve()` will mark the result array as complete.
   *
   * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */
  resolve() {
    this._state === 0 && (this._state = 1, this._onStateChanged.fire());
  }
  /**
   * Writing an error will permanently invalidate this iterable.
   * The current users will receive an error thrown, as will all future users.
   *
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */
  reject(e) {
    this._state === 0 && (this._state = 2, this._error = e, this._onStateChanged.fire());
  }
};
In.EMPTY = In.fromArray([]);
let LD = In;
/*! @license DOMPurify 3.1.7 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.1.7/LICENSE */
const {
  entries: cM,
  setPrototypeOf: kD,
  isFrozen: y6,
  getPrototypeOf: S6,
  getOwnPropertyDescriptor: L6
} = Object;
let {
  freeze: Bn,
  seal: Ps,
  create: hM
} = Object, {
  apply: $w,
  construct: Kw
} = typeof Reflect < "u" && Reflect;
Bn || (Bn = function(e) {
  return e;
});
Ps || (Ps = function(e) {
  return e;
});
$w || ($w = function(e, t, i) {
  return e.apply(t, i);
});
Kw || (Kw = function(e, t) {
  return new e(...t);
});
const im = bs(Array.prototype.forEach), xD = bs(Array.prototype.pop), iu = bs(Array.prototype.push), Km = bs(String.prototype.toLowerCase), d0 = bs(String.prototype.toString), DD = bs(String.prototype.match), nu = bs(String.prototype.replace), k6 = bs(String.prototype.indexOf), x6 = bs(String.prototype.trim), Gs = bs(Object.prototype.hasOwnProperty), xn = bs(RegExp.prototype.test), su = D6(TypeError);
function bs(s) {
  return function(e) {
    for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
      i[n - 1] = arguments[n];
    return $w(s, e, i);
  };
}
function D6(s) {
  return function() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    return Kw(s, t);
  };
}
function at(s, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Km;
  kD && kD(s, null);
  let i = e.length;
  for (; i--; ) {
    let n = e[i];
    if (typeof n == "string") {
      const o = t(n);
      o !== n && (y6(e) || (e[i] = o), n = o);
    }
    s[n] = !0;
  }
  return s;
}
function E6(s) {
  for (let e = 0; e < s.length; e++)
    Gs(s, e) || (s[e] = null);
  return s;
}
function pl(s) {
  const e = hM(null);
  for (const [t, i] of cM(s))
    Gs(s, t) && (Array.isArray(i) ? e[t] = E6(i) : i && typeof i == "object" && i.constructor === Object ? e[t] = pl(i) : e[t] = i);
  return e;
}
function ou(s, e) {
  for (; s !== null; ) {
    const i = L6(s, e);
    if (i) {
      if (i.get)
        return bs(i.get);
      if (typeof i.value == "function")
        return bs(i.value);
    }
    s = S6(s);
  }
  function t() {
    return null;
  }
  return t;
}
const ED = Bn(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), u0 = Bn(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), f0 = Bn(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), I6 = Bn(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), g0 = Bn(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), N6 = Bn(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), ID = Bn(["#text"]), ND = Bn(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), m0 = Bn(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), TD = Bn(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), nm = Bn(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), T6 = Ps(/\{\{[\w\W]*|[\w\W]*\}\}/gm), M6 = Ps(/<%[\w\W]*|[\w\W]*%>/gm), R6 = Ps(/\${[\w\W]*}/gm), A6 = Ps(/^data-[\-\w.\u00B7-\uFFFF]/), P6 = Ps(/^aria-[\-\w]+$/), dM = Ps(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), O6 = Ps(/^(?:\w+script|data):/i), F6 = Ps(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), uM = Ps(/^html$/i), B6 = Ps(/^[a-z][.\w]*(-[.\w]+)+$/i);
var MD = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MUSTACHE_EXPR: T6,
  ERB_EXPR: M6,
  TMPLIT_EXPR: R6,
  DATA_ATTR: A6,
  ARIA_ATTR: P6,
  IS_ALLOWED_URI: dM,
  IS_SCRIPT_OR_DATA: O6,
  ATTR_WHITESPACE: F6,
  DOCTYPE_NAME: uM,
  CUSTOM_ELEMENT: B6
});
const ru = {
  element: 1,
  text: 3,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9
}, W6 = function() {
  return typeof window > "u" ? null : window;
}, V6 = function(e, t) {
  if (typeof e != "object" || typeof e.createPolicy != "function")
    return null;
  let i = null;
  const n = "data-tt-policy-suffix";
  t && t.hasAttribute(n) && (i = t.getAttribute(n));
  const o = "dompurify" + (i ? "#" + i : "");
  try {
    return e.createPolicy(o, {
      createHTML(r) {
        return r;
      },
      createScriptURL(r) {
        return r;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + o + " could not be created."), null;
  }
};
function fM() {
  let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : W6();
  const e = (Ee) => fM(Ee);
  if (e.version = "3.1.7", e.removed = [], !s || !s.document || s.document.nodeType !== ru.document)
    return e.isSupported = !1, e;
  let {
    document: t
  } = s;
  const i = t, n = i.currentScript, {
    DocumentFragment: o,
    HTMLTemplateElement: r,
    Node: a,
    Element: l,
    NodeFilter: c,
    NamedNodeMap: h = s.NamedNodeMap || s.MozNamedAttrMap,
    HTMLFormElement: d,
    DOMParser: u,
    trustedTypes: f
  } = s, g = l.prototype, m = ou(g, "cloneNode"), _ = ou(g, "remove"), b = ou(g, "nextSibling"), C = ou(g, "childNodes"), v = ou(g, "parentNode");
  if (typeof r == "function") {
    const Ee = t.createElement("template");
    Ee.content && Ee.content.ownerDocument && (t = Ee.content.ownerDocument);
  }
  let w, S = "";
  const {
    implementation: L,
    createNodeIterator: k,
    createDocumentFragment: D,
    getElementsByTagName: E
  } = t, {
    importNode: U
  } = i;
  let P = {};
  e.isSupported = typeof cM == "function" && typeof v == "function" && L && L.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: B,
    ERB_EXPR: W,
    TMPLIT_EXPR: A,
    DATA_ATTR: K,
    ARIA_ATTR: Y,
    IS_SCRIPT_OR_DATA: Q,
    ATTR_WHITESPACE: ne,
    CUSTOM_ELEMENT: ie
  } = MD;
  let {
    IS_ALLOWED_URI: me
  } = MD, _e = null;
  const vt = at({}, [...ED, ...u0, ...f0, ...g0, ...ID]);
  let be = null;
  const Ze = at({}, [...ND, ...m0, ...TD, ...nm]);
  let De = Object.seal(hM(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), mt = null, Je = null, xt = !0, mi = !0, pi = !1, ws = !0, Xt = !1, vs = !0, Jo = !1, Yd = !1, Qd = !1, sa = !1, Uc = !1, $c = !1, il = !0, qg = !1;
  const jg = "user-content-";
  let Kc = !0, nl = !1, _o = {}, oa = null;
  const qc = at({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let Gg = null;
  const sl = at({}, ["audio", "video", "img", "source", "image", "track"]);
  let er = null;
  const zn = at({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), bo = "http://www.w3.org/1998/Math/MathML", tr = "http://www.w3.org/2000/svg", _i = "http://www.w3.org/1999/xhtml";
  let os = _i, jc = !1, Hs = null;
  const Et = at({}, [bo, tr, _i], d0);
  let ol = null;
  const t0 = ["application/xhtml+xml", "text/html"], i0 = "text/html";
  let ki = null, ra = null;
  const n0 = t.createElement("form"), Zg = function(z) {
    return z instanceof RegExp || z instanceof Function;
  }, Xd = function() {
    let z = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(ra && ra === z)) {
      if ((!z || typeof z != "object") && (z = {}), z = pl(z), ol = // eslint-disable-next-line unicorn/prefer-includes
      t0.indexOf(z.PARSER_MEDIA_TYPE) === -1 ? i0 : z.PARSER_MEDIA_TYPE, ki = ol === "application/xhtml+xml" ? d0 : Km, _e = Gs(z, "ALLOWED_TAGS") ? at({}, z.ALLOWED_TAGS, ki) : vt, be = Gs(z, "ALLOWED_ATTR") ? at({}, z.ALLOWED_ATTR, ki) : Ze, Hs = Gs(z, "ALLOWED_NAMESPACES") ? at({}, z.ALLOWED_NAMESPACES, d0) : Et, er = Gs(z, "ADD_URI_SAFE_ATTR") ? at(
        pl(zn),
        // eslint-disable-line indent
        z.ADD_URI_SAFE_ATTR,
        // eslint-disable-line indent
        ki
        // eslint-disable-line indent
      ) : zn, Gg = Gs(z, "ADD_DATA_URI_TAGS") ? at(
        pl(sl),
        // eslint-disable-line indent
        z.ADD_DATA_URI_TAGS,
        // eslint-disable-line indent
        ki
        // eslint-disable-line indent
      ) : sl, oa = Gs(z, "FORBID_CONTENTS") ? at({}, z.FORBID_CONTENTS, ki) : qc, mt = Gs(z, "FORBID_TAGS") ? at({}, z.FORBID_TAGS, ki) : {}, Je = Gs(z, "FORBID_ATTR") ? at({}, z.FORBID_ATTR, ki) : {}, _o = Gs(z, "USE_PROFILES") ? z.USE_PROFILES : !1, xt = z.ALLOW_ARIA_ATTR !== !1, mi = z.ALLOW_DATA_ATTR !== !1, pi = z.ALLOW_UNKNOWN_PROTOCOLS || !1, ws = z.ALLOW_SELF_CLOSE_IN_ATTR !== !1, Xt = z.SAFE_FOR_TEMPLATES || !1, vs = z.SAFE_FOR_XML !== !1, Jo = z.WHOLE_DOCUMENT || !1, sa = z.RETURN_DOM || !1, Uc = z.RETURN_DOM_FRAGMENT || !1, $c = z.RETURN_TRUSTED_TYPE || !1, Qd = z.FORCE_BODY || !1, il = z.SANITIZE_DOM !== !1, qg = z.SANITIZE_NAMED_PROPS || !1, Kc = z.KEEP_CONTENT !== !1, nl = z.IN_PLACE || !1, me = z.ALLOWED_URI_REGEXP || dM, os = z.NAMESPACE || _i, De = z.CUSTOM_ELEMENT_HANDLING || {}, z.CUSTOM_ELEMENT_HANDLING && Zg(z.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (De.tagNameCheck = z.CUSTOM_ELEMENT_HANDLING.tagNameCheck), z.CUSTOM_ELEMENT_HANDLING && Zg(z.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (De.attributeNameCheck = z.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), z.CUSTOM_ELEMENT_HANDLING && typeof z.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (De.allowCustomizedBuiltInElements = z.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Xt && (mi = !1), Uc && (sa = !0), _o && (_e = at({}, ID), be = [], _o.html === !0 && (at(_e, ED), at(be, ND)), _o.svg === !0 && (at(_e, u0), at(be, m0), at(be, nm)), _o.svgFilters === !0 && (at(_e, f0), at(be, m0), at(be, nm)), _o.mathMl === !0 && (at(_e, g0), at(be, TD), at(be, nm))), z.ADD_TAGS && (_e === vt && (_e = pl(_e)), at(_e, z.ADD_TAGS, ki)), z.ADD_ATTR && (be === Ze && (be = pl(be)), at(be, z.ADD_ATTR, ki)), z.ADD_URI_SAFE_ATTR && at(er, z.ADD_URI_SAFE_ATTR, ki), z.FORBID_CONTENTS && (oa === qc && (oa = pl(oa)), at(oa, z.FORBID_CONTENTS, ki)), Kc && (_e["#text"] = !0), Jo && at(_e, ["html", "head", "body"]), _e.table && (at(_e, ["tbody"]), delete mt.tbody), z.TRUSTED_TYPES_POLICY) {
        if (typeof z.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw su('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof z.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw su('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        w = z.TRUSTED_TYPES_POLICY, S = w.createHTML("");
      } else
        w === void 0 && (w = V6(f, n)), w !== null && typeof S == "string" && (S = w.createHTML(""));
      Bn && Bn(z), ra = z;
    }
  }, Oe = at({}, ["mi", "mo", "mn", "ms", "mtext"]), I = at({}, ["annotation-xml"]), T = at({}, ["title", "style", "font", "a", "script"]), M = at({}, [...u0, ...f0, ...I6]), F = at({}, [...g0, ...N6]), H = function(z) {
    let le = v(z);
    (!le || !le.tagName) && (le = {
      namespaceURI: os,
      tagName: "template"
    });
    const ve = Km(z.tagName), Gt = Km(le.tagName);
    return Hs[z.namespaceURI] ? z.namespaceURI === tr ? le.namespaceURI === _i ? ve === "svg" : le.namespaceURI === bo ? ve === "svg" && (Gt === "annotation-xml" || Oe[Gt]) : !!M[ve] : z.namespaceURI === bo ? le.namespaceURI === _i ? ve === "math" : le.namespaceURI === tr ? ve === "math" && I[Gt] : !!F[ve] : z.namespaceURI === _i ? le.namespaceURI === tr && !I[Gt] || le.namespaceURI === bo && !Oe[Gt] ? !1 : !F[ve] && (T[ve] || !M[ve]) : !!(ol === "application/xhtml+xml" && Hs[z.namespaceURI]) : !1;
  }, j = function(z) {
    iu(e.removed, {
      element: z
    });
    try {
      v(z).removeChild(z);
    } catch {
      _(z);
    }
  }, X = function(z, le) {
    try {
      iu(e.removed, {
        attribute: le.getAttributeNode(z),
        from: le
      });
    } catch {
      iu(e.removed, {
        attribute: null,
        from: le
      });
    }
    if (le.removeAttribute(z), z === "is" && !be[z])
      if (sa || Uc)
        try {
          j(le);
        } catch {
        }
      else
        try {
          le.setAttribute(z, "");
        } catch {
        }
  }, ce = function(z) {
    let le = null, ve = null;
    if (Qd)
      z = "<remove></remove>" + z;
    else {
      const Yi = DD(z, /^[\r\n\t ]+/);
      ve = Yi && Yi[0];
    }
    ol === "application/xhtml+xml" && os === _i && (z = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + z + "</body></html>");
    const Gt = w ? w.createHTML(z) : z;
    if (os === _i)
      try {
        le = new u().parseFromString(Gt, ol);
      } catch {
      }
    if (!le || !le.documentElement) {
      le = L.createDocument(os, "template", null);
      try {
        le.documentElement.innerHTML = jc ? S : Gt;
      } catch {
      }
    }
    const dn = le.body || le.documentElement;
    return z && ve && dn.insertBefore(t.createTextNode(ve), dn.childNodes[0] || null), os === _i ? E.call(le, Jo ? "html" : "body")[0] : Jo ? le.documentElement : dn;
  }, ge = function(z) {
    return k.call(
      z.ownerDocument || z,
      z,
      // eslint-disable-next-line no-bitwise
      c.SHOW_ELEMENT | c.SHOW_COMMENT | c.SHOW_TEXT | c.SHOW_PROCESSING_INSTRUCTION | c.SHOW_CDATA_SECTION,
      null
    );
  }, Me = function(z) {
    return z instanceof d && (typeof z.nodeName != "string" || typeof z.textContent != "string" || typeof z.removeChild != "function" || !(z.attributes instanceof h) || typeof z.removeAttribute != "function" || typeof z.setAttribute != "function" || typeof z.namespaceURI != "string" || typeof z.insertBefore != "function" || typeof z.hasChildNodes != "function");
  }, rt = function(z) {
    return typeof a == "function" && z instanceof a;
  }, dt = function(z, le, ve) {
    P[z] && im(P[z], (Gt) => {
      Gt.call(e, le, ve, ra);
    });
  }, Pt = function(z) {
    let le = null;
    if (dt("beforeSanitizeElements", z, null), Me(z))
      return j(z), !0;
    const ve = ki(z.nodeName);
    if (dt("uponSanitizeElement", z, {
      tagName: ve,
      allowedTags: _e
    }), z.hasChildNodes() && !rt(z.firstElementChild) && xn(/<[/\w]/g, z.innerHTML) && xn(/<[/\w]/g, z.textContent) || z.nodeType === ru.progressingInstruction || vs && z.nodeType === ru.comment && xn(/<[/\w]/g, z.data))
      return j(z), !0;
    if (!_e[ve] || mt[ve]) {
      if (!mt[ve] && Ln(ve) && (De.tagNameCheck instanceof RegExp && xn(De.tagNameCheck, ve) || De.tagNameCheck instanceof Function && De.tagNameCheck(ve)))
        return !1;
      if (Kc && !oa[ve]) {
        const Gt = v(z) || z.parentNode, dn = C(z) || z.childNodes;
        if (dn && Gt) {
          const Yi = dn.length;
          for (let Un = Yi - 1; Un >= 0; --Un) {
            const Co = m(dn[Un], !0);
            Co.__removalCount = (z.__removalCount || 0) + 1, Gt.insertBefore(Co, b(z));
          }
        }
      }
      return j(z), !0;
    }
    return z instanceof l && !H(z) || (ve === "noscript" || ve === "noembed" || ve === "noframes") && xn(/<\/no(script|embed|frames)/i, z.innerHTML) ? (j(z), !0) : (Xt && z.nodeType === ru.text && (le = z.textContent, im([B, W, A], (Gt) => {
      le = nu(le, Gt, " ");
    }), z.textContent !== le && (iu(e.removed, {
      element: z.cloneNode()
    }), z.textContent = le)), dt("afterSanitizeElements", z, null), !1);
  }, Ot = function(z, le, ve) {
    if (il && (le === "id" || le === "name") && (ve in t || ve in n0))
      return !1;
    if (!(mi && !Je[le] && xn(K, le))) {
      if (!(xt && xn(Y, le))) {
        if (!be[le] || Je[le]) {
          if (
            // First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            !(Ln(z) && (De.tagNameCheck instanceof RegExp && xn(De.tagNameCheck, z) || De.tagNameCheck instanceof Function && De.tagNameCheck(z)) && (De.attributeNameCheck instanceof RegExp && xn(De.attributeNameCheck, le) || De.attributeNameCheck instanceof Function && De.attributeNameCheck(le)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            le === "is" && De.allowCustomizedBuiltInElements && (De.tagNameCheck instanceof RegExp && xn(De.tagNameCheck, ve) || De.tagNameCheck instanceof Function && De.tagNameCheck(ve)))
          ) return !1;
        } else if (!er[le]) {
          if (!xn(me, nu(ve, ne, ""))) {
            if (!((le === "src" || le === "xlink:href" || le === "href") && z !== "script" && k6(ve, "data:") === 0 && Gg[z])) {
              if (!(pi && !xn(Q, nu(ve, ne, "")))) {
                if (ve)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, Ln = function(z) {
    return z !== "annotation-xml" && DD(z, ie);
  }, rs = function(z) {
    dt("beforeSanitizeAttributes", z, null);
    const {
      attributes: le
    } = z;
    if (!le)
      return;
    const ve = {
      attrName: "",
      attrValue: "",
      keepAttr: !0,
      allowedAttributes: be
    };
    let Gt = le.length;
    for (; Gt--; ) {
      const dn = le[Gt], {
        name: Yi,
        namespaceURI: Un,
        value: Co
      } = dn, eu = ki(Yi);
      let kn = Yi === "value" ? Co : x6(Co);
      if (ve.attrName = eu, ve.attrValue = kn, ve.keepAttr = !0, ve.forceKeepAttr = void 0, dt("uponSanitizeAttribute", z, ve), kn = ve.attrValue, ve.forceKeepAttr || (X(Yi, z), !ve.keepAttr))
        continue;
      if (!ws && xn(/\/>/i, kn)) {
        X(Yi, z);
        continue;
      }
      Xt && im([B, W, A], (Zx) => {
        kn = nu(kn, Zx, " ");
      });
      const Gx = ki(z.nodeName);
      if (Ot(Gx, eu, kn)) {
        if (qg && (eu === "id" || eu === "name") && (X(Yi, z), kn = jg + kn), vs && xn(/((--!?|])>)|<\/(style|title)/i, kn)) {
          X(Yi, z);
          continue;
        }
        if (w && typeof f == "object" && typeof f.getAttributeType == "function" && !Un)
          switch (f.getAttributeType(Gx, eu)) {
            case "TrustedHTML": {
              kn = w.createHTML(kn);
              break;
            }
            case "TrustedScriptURL": {
              kn = w.createScriptURL(kn);
              break;
            }
          }
        try {
          Un ? z.setAttributeNS(Un, Yi, kn) : z.setAttribute(Yi, kn), Me(z) ? j(z) : xD(e.removed);
        } catch {
        }
      }
    }
    dt("afterSanitizeAttributes", z, null);
  }, Jd = function Ee(z) {
    let le = null;
    const ve = ge(z);
    for (dt("beforeSanitizeShadowDOM", z, null); le = ve.nextNode(); )
      dt("uponSanitizeShadowNode", le, null), !Pt(le) && (le.content instanceof o && Ee(le.content), rs(le));
    dt("afterSanitizeShadowDOM", z, null);
  };
  return e.sanitize = function(Ee) {
    let z = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, le = null, ve = null, Gt = null, dn = null;
    if (jc = !Ee, jc && (Ee = "<!-->"), typeof Ee != "string" && !rt(Ee))
      if (typeof Ee.toString == "function") {
        if (Ee = Ee.toString(), typeof Ee != "string")
          throw su("dirty is not a string, aborting");
      } else
        throw su("toString is not a function");
    if (!e.isSupported)
      return Ee;
    if (Yd || Xd(z), e.removed = [], typeof Ee == "string" && (nl = !1), nl) {
      if (Ee.nodeName) {
        const Co = ki(Ee.nodeName);
        if (!_e[Co] || mt[Co])
          throw su("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (Ee instanceof a)
      le = ce("<!---->"), ve = le.ownerDocument.importNode(Ee, !0), ve.nodeType === ru.element && ve.nodeName === "BODY" || ve.nodeName === "HTML" ? le = ve : le.appendChild(ve);
    else {
      if (!sa && !Xt && !Jo && // eslint-disable-next-line unicorn/prefer-includes
      Ee.indexOf("<") === -1)
        return w && $c ? w.createHTML(Ee) : Ee;
      if (le = ce(Ee), !le)
        return sa ? null : $c ? S : "";
    }
    le && Qd && j(le.firstChild);
    const Yi = ge(nl ? Ee : le);
    for (; Gt = Yi.nextNode(); )
      Pt(Gt) || (Gt.content instanceof o && Jd(Gt.content), rs(Gt));
    if (nl)
      return Ee;
    if (sa) {
      if (Uc)
        for (dn = D.call(le.ownerDocument); le.firstChild; )
          dn.appendChild(le.firstChild);
      else
        dn = le;
      return (be.shadowroot || be.shadowrootmode) && (dn = U.call(i, dn, !0)), dn;
    }
    let Un = Jo ? le.outerHTML : le.innerHTML;
    return Jo && _e["!doctype"] && le.ownerDocument && le.ownerDocument.doctype && le.ownerDocument.doctype.name && xn(uM, le.ownerDocument.doctype.name) && (Un = "<!DOCTYPE " + le.ownerDocument.doctype.name + `>
` + Un), Xt && im([B, W, A], (Co) => {
      Un = nu(Un, Co, " ");
    }), w && $c ? w.createHTML(Un) : Un;
  }, e.setConfig = function() {
    let Ee = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Xd(Ee), Yd = !0;
  }, e.clearConfig = function() {
    ra = null, Yd = !1;
  }, e.isValidAttribute = function(Ee, z, le) {
    ra || Xd({});
    const ve = ki(Ee), Gt = ki(z);
    return Ot(ve, Gt, le);
  }, e.addHook = function(Ee, z) {
    typeof z == "function" && (P[Ee] = P[Ee] || [], iu(P[Ee], z));
  }, e.removeHook = function(Ee) {
    if (P[Ee])
      return xD(P[Ee]);
  }, e.removeHooks = function(Ee) {
    P[Ee] && (P[Ee] = []);
  }, e.removeAllHooks = function() {
    P = {};
  }, e;
}
var Go = fM();
Go.version;
Go.isSupported;
const gM = Go.sanitize;
Go.setConfig;
Go.clearConfig;
Go.isValidAttribute;
const mM = Go.addHook, pM = Go.removeHook;
Go.removeHooks;
Go.removeAllHooks;
var Ne;
(function(s) {
  s.inMemory = "inmemory", s.vscode = "vscode", s.internal = "private", s.walkThrough = "walkThrough", s.walkThroughSnippet = "walkThroughSnippet", s.http = "http", s.https = "https", s.file = "file", s.mailto = "mailto", s.untitled = "untitled", s.data = "data", s.command = "command", s.vscodeRemote = "vscode-remote", s.vscodeRemoteResource = "vscode-remote-resource", s.vscodeManagedRemoteResource = "vscode-managed-remote-resource", s.vscodeUserData = "vscode-userdata", s.vscodeCustomEditor = "vscode-custom-editor", s.vscodeNotebookCell = "vscode-notebook-cell", s.vscodeNotebookCellMetadata = "vscode-notebook-cell-metadata", s.vscodeNotebookCellMetadataDiff = "vscode-notebook-cell-metadata-diff", s.vscodeNotebookCellOutput = "vscode-notebook-cell-output", s.vscodeNotebookCellOutputDiff = "vscode-notebook-cell-output-diff", s.vscodeNotebookMetadata = "vscode-notebook-metadata", s.vscodeInteractiveInput = "vscode-interactive-input", s.vscodeSettings = "vscode-settings", s.vscodeWorkspaceTrust = "vscode-workspace-trust", s.vscodeTerminal = "vscode-terminal", s.vscodeChatCodeBlock = "vscode-chat-code-block", s.vscodeChatCodeCompareBlock = "vscode-chat-code-compare-block", s.vscodeChatSesssion = "vscode-chat-editor", s.webviewPanel = "webview-panel", s.vscodeWebview = "vscode-webview", s.extension = "extension", s.vscodeFileResource = "vscode-file", s.tmp = "tmp", s.vsls = "vsls", s.vscodeSourceControl = "vscode-scm", s.commentsInput = "comment", s.codeSetting = "code-setting", s.outputChannel = "output";
})(Ne || (Ne = {}));
function OL(s, e) {
  return Te.isUri(s) ? dh(s.scheme, e) : EL(s, e + ":");
}
function RD(s, ...e) {
  return e.some((t) => OL(s, t));
}
const H6 = "tkn";
class z6 {
  constructor() {
    this._hosts = /* @__PURE__ */ Object.create(null), this._ports = /* @__PURE__ */ Object.create(null), this._connectionTokens = /* @__PURE__ */ Object.create(null), this._preferredWebSchema = "http", this._delegate = null, this._serverRootPath = "/";
  }
  setPreferredWebSchema(e) {
    this._preferredWebSchema = e;
  }
  get _remoteResourcesPath() {
    return Kt.join(this._serverRootPath, Ne.vscodeRemoteResource);
  }
  rewrite(e) {
    if (this._delegate)
      try {
        return this._delegate(e);
      } catch (a) {
        return ht(a), e;
      }
    const t = e.authority;
    let i = this._hosts[t];
    i && i.indexOf(":") !== -1 && i.indexOf("[") === -1 && (i = `[${i}]`);
    const n = this._ports[t], o = this._connectionTokens[t];
    let r = `path=${encodeURIComponent(e.path)}`;
    return typeof o == "string" && (r += `&${H6}=${encodeURIComponent(o)}`), Te.from({
      scheme: Fd ? this._preferredWebSchema : Ne.vscodeRemoteResource,
      authority: `${i}:${n}`,
      path: this._remoteResourcesPath,
      query: r
    });
  }
}
const _M = new z6(), U6 = "vscode-app", mf = class mf {
  /**
   * Returns a URI to use in contexts where the browser is responsible
   * for loading (e.g. fetch()) or when used within the DOM.
   *
   * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.
   */
  asBrowserUri(e) {
    const t = this.toUri(e);
    return this.uriToBrowserUri(t);
  }
  /**
   * Returns a URI to use in contexts where the browser is responsible
   * for loading (e.g. fetch()) or when used within the DOM.
   *
   * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.
   */
  uriToBrowserUri(e) {
    return e.scheme === Ne.vscodeRemote ? _M.rewrite(e) : (
      // ...only ever for `file` resources
      e.scheme === Ne.file && // ...and we run in native environments
      (Cp || // ...or web worker extensions on desktop
      tP === `${Ne.vscodeFileResource}://${mf.FALLBACK_AUTHORITY}`) ? e.with({
        scheme: Ne.vscodeFileResource,
        // We need to provide an authority here so that it can serve
        // as origin for network and loading matters in chromium.
        // If the URI is not coming with an authority already, we
        // add our own
        authority: e.authority || mf.FALLBACK_AUTHORITY,
        query: null,
        fragment: null
      }) : e
    );
  }
  toUri(e, t) {
    if (Te.isUri(e))
      return e;
    if (globalThis._VSCODE_FILE_ROOT) {
      const i = globalThis._VSCODE_FILE_ROOT;
      if (/^\w[\w\d+.-]*:\/\//.test(i))
        return Te.joinPath(Te.parse(i, !0), e);
      const n = kO(i, e);
      return Te.file(n);
    }
    return Te.parse(t.toUrl(e));
  }
};
mf.FALLBACK_AUTHORITY = U6;
let qw = mf;
const sb = new qw();
var jw;
(function(s) {
  const e = /* @__PURE__ */ new Map([
    ["1", { "Cross-Origin-Opener-Policy": "same-origin" }],
    ["2", { "Cross-Origin-Embedder-Policy": "require-corp" }],
    ["3", { "Cross-Origin-Opener-Policy": "same-origin", "Cross-Origin-Embedder-Policy": "require-corp" }]
  ]);
  s.CoopAndCoep = Object.freeze(e.get("3"));
  const t = "vscode-coi";
  function i(o) {
    let r;
    typeof o == "string" ? r = new URL(o).searchParams : o instanceof URL ? r = o.searchParams : Te.isUri(o) && (r = new URL(o.toString(!0)).searchParams);
    const a = r == null ? void 0 : r.get(t);
    if (a)
      return e.get(a);
  }
  s.getHeadersFromQuery = i;
  function n(o, r, a) {
    if (!globalThis.crossOriginIsolated)
      return;
    const l = r && a ? "3" : a ? "2" : "1";
    o instanceof URLSearchParams ? o.set(t, l) : o[t] = l;
  }
  s.addSearchParam = n;
})(jw || (jw = {}));
function bM(s) {
  return ob(s, 0);
}
function ob(s, e) {
  switch (typeof s) {
    case "object":
      return s === null ? Mr(349, e) : Array.isArray(s) ? K6(s, e) : q6(s, e);
    case "string":
      return FL(s, e);
    case "boolean":
      return $6(s, e);
    case "number":
      return Mr(s, e);
    case "undefined":
      return Mr(937, e);
    default:
      return Mr(617, e);
  }
}
function Mr(s, e) {
  return (e << 5) - e + s | 0;
}
function $6(s, e) {
  return Mr(s ? 433 : 863, e);
}
function FL(s, e) {
  e = Mr(149417, e);
  for (let t = 0, i = s.length; t < i; t++)
    e = Mr(s.charCodeAt(t), e);
  return e;
}
function K6(s, e) {
  return e = Mr(104579, e), s.reduce((t, i) => ob(i, t), e);
}
function q6(s, e) {
  return e = Mr(181387, e), Object.keys(s).sort().reduce((t, i) => (t = FL(i, t), ob(s[i], t)), e);
}
function p0(s, e, t = 32) {
  const i = t - e, n = ~((1 << i) - 1);
  return (s << e | (n & s) >>> i) >>> 0;
}
function AD(s, e = 0, t = s.byteLength, i = 0) {
  for (let n = 0; n < t; n++)
    s[e + n] = i;
}
function j6(s, e, t = "0") {
  for (; s.length < e; )
    s = t + s;
  return s;
}
function au(s, e = 32) {
  return s instanceof ArrayBuffer ? Array.from(new Uint8Array(s)).map((t) => t.toString(16).padStart(2, "0")).join("") : j6((s >>> 0).toString(16), e / 4);
}
const l1 = class l1 {
  // 80 * 4 = 320
  constructor() {
    this._h0 = 1732584193, this._h1 = 4023233417, this._h2 = 2562383102, this._h3 = 271733878, this._h4 = 3285377520, this._buff = new Uint8Array(
      67
      /* to fit any utf-8 */
    ), this._buffDV = new DataView(this._buff.buffer), this._buffLen = 0, this._totalLen = 0, this._leftoverHighSurrogate = 0, this._finished = !1;
  }
  update(e) {
    const t = e.length;
    if (t === 0)
      return;
    const i = this._buff;
    let n = this._buffLen, o = this._leftoverHighSurrogate, r, a;
    for (o !== 0 ? (r = o, a = -1, o = 0) : (r = e.charCodeAt(0), a = 0); ; ) {
      let l = r;
      if (hi(r))
        if (a + 1 < t) {
          const c = e.charCodeAt(a + 1);
          _d(c) ? (a++, l = IL(r, c)) : l = 65533;
        } else {
          o = r;
          break;
        }
      else _d(r) && (l = 65533);
      if (n = this._push(i, n, l), a++, a < t)
        r = e.charCodeAt(a);
      else
        break;
    }
    this._buffLen = n, this._leftoverHighSurrogate = o;
  }
  _push(e, t, i) {
    return i < 128 ? e[t++] = i : i < 2048 ? (e[t++] = 192 | (i & 1984) >>> 6, e[t++] = 128 | (i & 63) >>> 0) : i < 65536 ? (e[t++] = 224 | (i & 61440) >>> 12, e[t++] = 128 | (i & 4032) >>> 6, e[t++] = 128 | (i & 63) >>> 0) : (e[t++] = 240 | (i & 1835008) >>> 18, e[t++] = 128 | (i & 258048) >>> 12, e[t++] = 128 | (i & 4032) >>> 6, e[t++] = 128 | (i & 63) >>> 0), t >= 64 && (this._step(), t -= 64, this._totalLen += 64, e[0] = e[64], e[1] = e[65], e[2] = e[66]), t;
  }
  digest() {
    return this._finished || (this._finished = !0, this._leftoverHighSurrogate && (this._leftoverHighSurrogate = 0, this._buffLen = this._push(
      this._buff,
      this._buffLen,
      65533
      /* SHA1Constant.UNICODE_REPLACEMENT */
    )), this._totalLen += this._buffLen, this._wrapUp()), au(this._h0) + au(this._h1) + au(this._h2) + au(this._h3) + au(this._h4);
  }
  _wrapUp() {
    this._buff[this._buffLen++] = 128, AD(this._buff, this._buffLen), this._buffLen > 56 && (this._step(), AD(this._buff));
    const e = 8 * this._totalLen;
    this._buffDV.setUint32(56, Math.floor(e / 4294967296), !1), this._buffDV.setUint32(60, e % 4294967296, !1), this._step();
  }
  _step() {
    const e = l1._bigBlock32, t = this._buffDV;
    for (let d = 0; d < 64; d += 4)
      e.setUint32(d, t.getUint32(d, !1), !1);
    for (let d = 64; d < 320; d += 4)
      e.setUint32(d, p0(e.getUint32(d - 12, !1) ^ e.getUint32(d - 32, !1) ^ e.getUint32(d - 56, !1) ^ e.getUint32(d - 64, !1), 1), !1);
    let i = this._h0, n = this._h1, o = this._h2, r = this._h3, a = this._h4, l, c, h;
    for (let d = 0; d < 80; d++)
      d < 20 ? (l = n & o | ~n & r, c = 1518500249) : d < 40 ? (l = n ^ o ^ r, c = 1859775393) : d < 60 ? (l = n & o | n & r | o & r, c = 2400959708) : (l = n ^ o ^ r, c = 3395469782), h = p0(i, 5) + l + a + c + e.getUint32(d * 4, !1) & 4294967295, a = r, r = o, o = p0(n, 30), n = i, i = h;
    this._h0 = this._h0 + i & 4294967295, this._h1 = this._h1 + n & 4294967295, this._h2 = this._h2 + o & 4294967295, this._h3 = this._h3 + r & 4294967295, this._h4 = this._h4 + a & 4294967295;
  }
};
l1._bigBlock32 = new DataView(new ArrayBuffer(320));
let Gw = l1;
const { getWindow: ue, getWindows: CM, getWindowsCount: G6, getWindowId: Ep, getWindowById: PD, onDidRegisterWindow: rb, onWillUnregisterWindow: Z6, onDidUnregisterWindow: Y6 } = (function() {
  const s = /* @__PURE__ */ new Map();
  $O(ut, 1);
  const e = { window: ut, disposables: new he() };
  s.set(ut.vscodeWindowId, e);
  const t = new O(), i = new O(), n = new O();
  function o(r, a) {
    return (typeof r == "number" ? s.get(r) : void 0) ?? (a ? e : void 0);
  }
  return {
    onDidRegisterWindow: t.event,
    onWillUnregisterWindow: n.event,
    onDidUnregisterWindow: i.event,
    registerWindow(r) {
      if (s.has(r.vscodeWindowId))
        return q.None;
      const a = new he(), l = {
        window: r,
        disposables: a.add(new he())
      };
      return s.set(r.vscodeWindowId, l), a.add(ke(() => {
        s.delete(r.vscodeWindowId), i.fire(r);
      })), a.add($(r, ee.BEFORE_UNLOAD, () => {
        n.fire(r);
      })), t.fire(l), a;
    },
    getWindows() {
      return s.values();
    },
    getWindowsCount() {
      return s.size;
    },
    getWindowId(r) {
      return r.vscodeWindowId;
    },
    hasWindow(r) {
      return s.has(r);
    },
    getWindowById: o,
    getWindow(r) {
      var c;
      const a = r;
      if ((c = a == null ? void 0 : a.ownerDocument) != null && c.defaultView)
        return a.ownerDocument.defaultView.window;
      const l = r;
      return l != null && l.view ? l.view.window : ut;
    },
    getDocument(r) {
      return ue(r).document;
    }
  };
})();
function oo(s) {
  for (; s.firstChild; )
    s.firstChild.remove();
}
class Q6 {
  constructor(e, t, i, n) {
    this._node = e, this._type = t, this._handler = i, this._options = n || !1, this._node.addEventListener(this._type, this._handler, this._options);
  }
  dispose() {
    this._handler && (this._node.removeEventListener(this._type, this._handler, this._options), this._node = null, this._handler = null);
  }
}
function $(s, e, t, i) {
  return new Q6(s, e, t, i);
}
function X6(s, e) {
  return function(t) {
    return e(new to(s, t));
  };
}
function J6(s) {
  return function(e) {
    return s(new Lt(e));
  };
}
const fi = function(e, t, i, n) {
  let o = i;
  return t === "click" || t === "mousedown" || t === "contextmenu" ? o = X6(ue(e), i) : (t === "keydown" || t === "keypress" || t === "keyup") && (o = J6(i)), $(e, t, o, n);
};
function sm(s, e, t) {
  return Wu(s, e, t);
}
let wM, Wn;
class BL extends PL {
  /**
   *
   * @param node The optional node from which the target window is determined
   */
  constructor(e) {
    super(), this.defaultTarget = e && ue(e);
  }
  cancelAndSet(e, t, i) {
    return super.cancelAndSet(e, t, i ?? this.defaultTarget);
  }
}
class _0 {
  constructor(e, t = 0) {
    this._runner = e, this.priority = t, this._canceled = !1;
  }
  dispose() {
    this._canceled = !0;
  }
  execute() {
    if (!this._canceled)
      try {
        this._runner();
      } catch (e) {
        ht(e);
      }
  }
  // Sort by priority (largest to lowest)
  static sort(e, t) {
    return t.priority - e.priority;
  }
}
(function() {
  const s = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), n = (o) => {
    t.set(o, !1);
    const r = s.get(o) ?? [];
    for (e.set(o, r), s.set(o, []), i.set(o, !0); r.length > 0; )
      r.sort(_0.sort), r.shift().execute();
    i.set(o, !1);
  };
  Wn = (o, r, a = 0) => {
    const l = Ep(o), c = new _0(r, a);
    let h = s.get(l);
    return h || (h = [], s.set(l, h)), h.push(c), t.get(l) || (t.set(l, !0), o.requestAnimationFrame(() => n(l))), c;
  }, wM = (o, r, a) => {
    const l = Ep(o);
    if (i.get(l)) {
      const c = new _0(r, a);
      let h = e.get(l);
      return h || (h = [], e.set(l, h)), h.push(c), c;
    } else
      return Wn(o, r, a);
  };
})();
function WL(s) {
  return ue(s).getComputedStyle(s, null);
}
function Zw(s, e) {
  const t = ue(s), i = t.document;
  if (s !== i.body)
    return new kr(s.clientWidth, s.clientHeight);
  if (fc && (t != null && t.visualViewport))
    return new kr(t.visualViewport.width, t.visualViewport.height);
  if (t != null && t.innerWidth && t.innerHeight)
    return new kr(t.innerWidth, t.innerHeight);
  if (i.body && i.body.clientWidth && i.body.clientHeight)
    return new kr(i.body.clientWidth, i.body.clientHeight);
  if (i.documentElement && i.documentElement.clientWidth && i.documentElement.clientHeight)
    return new kr(i.documentElement.clientWidth, i.documentElement.clientHeight);
  throw new Error("Unable to figure out browser width and height");
}
class Bt {
  // Adapted from WinJS
  // Converts a CSS positioning string for the specified element to pixels.
  static convertToPixels(e, t) {
    return parseFloat(t) || 0;
  }
  static getDimension(e, t, i) {
    const n = WL(e), o = n ? n.getPropertyValue(t) : "0";
    return Bt.convertToPixels(e, o);
  }
  static getBorderLeftWidth(e) {
    return Bt.getDimension(e, "border-left-width", "borderLeftWidth");
  }
  static getBorderRightWidth(e) {
    return Bt.getDimension(e, "border-right-width", "borderRightWidth");
  }
  static getBorderTopWidth(e) {
    return Bt.getDimension(e, "border-top-width", "borderTopWidth");
  }
  static getBorderBottomWidth(e) {
    return Bt.getDimension(e, "border-bottom-width", "borderBottomWidth");
  }
  static getPaddingLeft(e) {
    return Bt.getDimension(e, "padding-left", "paddingLeft");
  }
  static getPaddingRight(e) {
    return Bt.getDimension(e, "padding-right", "paddingRight");
  }
  static getPaddingTop(e) {
    return Bt.getDimension(e, "padding-top", "paddingTop");
  }
  static getPaddingBottom(e) {
    return Bt.getDimension(e, "padding-bottom", "paddingBottom");
  }
  static getMarginLeft(e) {
    return Bt.getDimension(e, "margin-left", "marginLeft");
  }
  static getMarginTop(e) {
    return Bt.getDimension(e, "margin-top", "marginTop");
  }
  static getMarginRight(e) {
    return Bt.getDimension(e, "margin-right", "marginRight");
  }
  static getMarginBottom(e) {
    return Bt.getDimension(e, "margin-bottom", "marginBottom");
  }
}
const Bl = class Bl {
  constructor(e, t) {
    this.width = e, this.height = t;
  }
  with(e = this.width, t = this.height) {
    return e !== this.width || t !== this.height ? new Bl(e, t) : this;
  }
  static is(e) {
    return typeof e == "object" && typeof e.height == "number" && typeof e.width == "number";
  }
  static lift(e) {
    return e instanceof Bl ? e : new Bl(e.width, e.height);
  }
  static equals(e, t) {
    return e === t ? !0 : !e || !t ? !1 : e.width === t.width && e.height === t.height;
  }
};
Bl.None = new Bl(0, 0);
let kr = Bl;
function e7(s) {
  let e = s.offsetParent, t = s.offsetTop, i = s.offsetLeft;
  for (; (s = s.parentNode) !== null && s !== s.ownerDocument.body && s !== s.ownerDocument.documentElement; ) {
    t -= s.scrollTop;
    const n = yM(s) ? null : WL(s);
    n && (i -= n.direction !== "rtl" ? s.scrollLeft : -s.scrollLeft), s === e && (i += Bt.getBorderLeftWidth(s), t += Bt.getBorderTopWidth(s), t += s.offsetTop, i += s.offsetLeft, e = s.offsetParent);
  }
  return {
    left: i,
    top: t
  };
}
function gs(s) {
  const e = s.getBoundingClientRect(), t = ue(s);
  return {
    left: e.left + t.scrollX,
    top: e.top + t.scrollY,
    width: e.width,
    height: e.height
  };
}
function vM(s) {
  let e = s, t = 1;
  do {
    const i = WL(e).zoom;
    i != null && i !== "1" && (t *= i), e = e.parentElement;
  } while (e !== null && e !== e.ownerDocument.documentElement);
  return t;
}
function VL(s) {
  const e = Bt.getMarginLeft(s) + Bt.getMarginRight(s);
  return s.offsetWidth + e;
}
function b0(s) {
  const e = Bt.getBorderLeftWidth(s) + Bt.getBorderRightWidth(s), t = Bt.getPaddingLeft(s) + Bt.getPaddingRight(s);
  return s.offsetWidth - e - t;
}
function t7(s) {
  const e = Bt.getBorderTopWidth(s) + Bt.getBorderBottomWidth(s), t = Bt.getPaddingTop(s) + Bt.getPaddingBottom(s);
  return s.offsetHeight - e - t;
}
function Yw(s) {
  const e = Bt.getMarginTop(s) + Bt.getMarginBottom(s);
  return s.offsetHeight + e;
}
function ui(s, e) {
  return !!(e != null && e.contains(s));
}
function i7(s, e, t) {
  for (; s && s.nodeType === s.ELEMENT_NODE; ) {
    if (s.classList.contains(e))
      return s;
    if (t) {
      if (typeof t == "string") {
        if (s.classList.contains(t))
          return null;
      } else if (s === t)
        return null;
    }
    s = s.parentNode;
  }
  return null;
}
function C0(s, e, t) {
  return !!i7(s, e, t);
}
function yM(s) {
  return s && !!s.host && !!s.mode;
}
function Qw(s) {
  return !!bd(s);
}
function bd(s) {
  var e;
  for (; s.parentNode; ) {
    if (s === ((e = s.ownerDocument) == null ? void 0 : e.body))
      return null;
    s = s.parentNode;
  }
  return yM(s) ? s : null;
}
function Gi() {
  let s = zL().activeElement;
  for (; s != null && s.shadowRoot; )
    s = s.shadowRoot.activeElement;
  return s;
}
function HL(s) {
  return Gi() === s;
}
function SM(s) {
  return ui(Gi(), s);
}
function zL() {
  return G6() <= 1 ? ut.document : Array.from(CM()).map(({ window: e }) => e.document).find((e) => e.hasFocus()) ?? ut.document;
}
function Lu() {
  var e;
  return ((e = zL().defaultView) == null ? void 0 : e.window) ?? ut;
}
const LM = /* @__PURE__ */ new Map();
function Os(s = ut.document.head, e, t) {
  const i = document.createElement("style");
  if (i.type = "text/css", i.media = "screen", e == null || e(i), s.appendChild(i), s === ut.document.head) {
    const n = /* @__PURE__ */ new Set();
    LM.set(i, n);
    for (const { window: o, disposables: r } of CM())
      o !== ut && r.add(n7(i, n, o));
  }
  return i;
}
function n7(s, e, t) {
  var o, r;
  const i = new he(), n = s.cloneNode(!0);
  t.document.head.appendChild(n), i.add(ke(() => n.remove()));
  for (const a of r7(s))
    (r = n.sheet) == null || r.insertRule(a.cssText, (o = n.sheet) == null ? void 0 : o.cssRules.length);
  return i.add(s7.observe(s, i, { childList: !0 })(() => {
    n.textContent = s.textContent;
  })), e.add(n), i.add(ke(() => e.delete(n))), i;
}
const s7 = new class {
  constructor() {
    this.mutationObservers = /* @__PURE__ */ new Map();
  }
  observe(s, e, t) {
    let i = this.mutationObservers.get(s);
    i || (i = /* @__PURE__ */ new Map(), this.mutationObservers.set(s, i));
    const n = bM(t);
    let o = i.get(n);
    if (o)
      o.users += 1;
    else {
      const r = new O(), a = new MutationObserver((c) => r.fire(c));
      a.observe(s, t);
      const l = o = {
        users: 1,
        observer: a,
        onDidMutate: r.event
      };
      e.add(ke(() => {
        l.users -= 1, l.users === 0 && (r.dispose(), a.disconnect(), i == null || i.delete(n), (i == null ? void 0 : i.size) === 0 && this.mutationObservers.delete(s));
      })), i.set(n, o);
    }
    return o.onDidMutate;
  }
}();
let w0 = null;
function o7() {
  return w0 || (w0 = Os()), w0;
}
function r7(s) {
  var e, t;
  return (e = s == null ? void 0 : s.sheet) != null && e.rules ? s.sheet.rules : (t = s == null ? void 0 : s.sheet) != null && t.cssRules ? s.sheet.cssRules : [];
}
function Xw(s, e, t = o7()) {
  var i;
  if (!(!t || !e)) {
    (i = t.sheet) == null || i.insertRule(`${s} {${e}}`, 0);
    for (const n of LM.get(t) ?? [])
      Xw(s, e, n);
  }
}
function yi(s) {
  return s instanceof HTMLElement || s instanceof ue(s).HTMLElement;
}
function OD(s) {
  return s instanceof HTMLAnchorElement || s instanceof ue(s).HTMLAnchorElement;
}
function a7(s) {
  return s instanceof SVGElement || s instanceof ue(s).SVGElement;
}
function UL(s) {
  return s instanceof MouseEvent || s instanceof ue(s).MouseEvent;
}
function wr(s) {
  return s instanceof KeyboardEvent || s instanceof ue(s).KeyboardEvent;
}
const ee = {
  // Mouse
  CLICK: "click",
  AUXCLICK: "auxclick",
  DBLCLICK: "dblclick",
  MOUSE_UP: "mouseup",
  MOUSE_DOWN: "mousedown",
  MOUSE_OVER: "mouseover",
  MOUSE_MOVE: "mousemove",
  MOUSE_OUT: "mouseout",
  MOUSE_LEAVE: "mouseleave",
  MOUSE_WHEEL: "wheel",
  POINTER_UP: "pointerup",
  POINTER_DOWN: "pointerdown",
  POINTER_MOVE: "pointermove",
  POINTER_LEAVE: "pointerleave",
  CONTEXT_MENU: "contextmenu",
  // Keyboard
  KEY_DOWN: "keydown",
  KEY_UP: "keyup",
  BEFORE_UNLOAD: "beforeunload",
  CHANGE: "change",
  FOCUS: "focus",
  FOCUS_IN: "focusin",
  FOCUS_OUT: "focusout",
  BLUR: "blur",
  INPUT: "input",
  // Drag
  DRAG_START: "dragstart",
  DRAG: "drag",
  DRAG_ENTER: "dragenter",
  DRAG_LEAVE: "dragleave",
  DRAG_OVER: "dragover",
  DROP: "drop",
  DRAG_END: "dragend"
};
function l7(s) {
  const e = s;
  return !!(e && typeof e.preventDefault == "function" && typeof e.stopPropagation == "function");
}
const Be = {
  stop: (s, e) => (s.preventDefault(), e && s.stopPropagation(), s)
};
function c7(s) {
  const e = [];
  for (let t = 0; s && s.nodeType === s.ELEMENT_NODE; t++)
    e[t] = s.scrollTop, s = s.parentNode;
  return e;
}
function h7(s, e) {
  for (let t = 0; s && s.nodeType === s.ELEMENT_NODE; t++)
    s.scrollTop !== e[t] && (s.scrollTop = e[t]), s = s.parentNode;
}
class Ip extends q {
  static hasFocusWithin(e) {
    if (yi(e)) {
      const t = bd(e), i = t ? t.activeElement : e.ownerDocument.activeElement;
      return ui(i, e);
    } else {
      const t = e;
      return ui(t.document.activeElement, t.document);
    }
  }
  constructor(e) {
    super(), this._onDidFocus = this._register(new O()), this.onDidFocus = this._onDidFocus.event, this._onDidBlur = this._register(new O()), this.onDidBlur = this._onDidBlur.event;
    let t = Ip.hasFocusWithin(e), i = !1;
    const n = () => {
      i = !1, t || (t = !0, this._onDidFocus.fire());
    }, o = () => {
      t && (i = !0, (yi(e) ? ue(e) : e).setTimeout(() => {
        i && (i = !1, t = !1, this._onDidBlur.fire());
      }, 0));
    };
    this._refreshStateHandler = () => {
      Ip.hasFocusWithin(e) !== t && (t ? o() : n());
    }, this._register($(e, ee.FOCUS, n, !0)), this._register($(e, ee.BLUR, o, !0)), yi(e) && (this._register($(e, ee.FOCUS_IN, () => this._refreshStateHandler())), this._register($(e, ee.FOCUS_OUT, () => this._refreshStateHandler())));
  }
}
function Ff(s) {
  return new Ip(s);
}
function d7(s, e) {
  return s.after(e), e;
}
function ae(s, ...e) {
  if (s.append(...e), e.length === 1 && typeof e[0] != "string")
    return e[0];
}
function $L(s, e) {
  return s.insertBefore(e, s.firstChild), e;
}
function on(s, ...e) {
  s.innerText = "", ae(s, ...e);
}
const u7 = /([\w\-]+)?(#([\w\-]+))?((\.([\w\-]+))*)/;
var Bf;
(function(s) {
  s.HTML = "http://www.w3.org/1999/xhtml", s.SVG = "http://www.w3.org/2000/svg";
})(Bf || (Bf = {}));
function kM(s, e, t, ...i) {
  const n = u7.exec(e);
  if (!n)
    throw new Error("Bad use of emmet");
  const o = n[1] || "div";
  let r;
  return s !== Bf.HTML ? r = document.createElementNS(s, o) : r = document.createElement(o), n[3] && (r.id = n[3]), n[4] && (r.className = n[4].replace(/\./g, " ").trim()), t && Object.entries(t).forEach(([a, l]) => {
    typeof l > "u" || (/^on\w+$/.test(a) ? r[a] = l : a === "selected" ? l && r.setAttribute(a, "true") : r.setAttribute(a, l));
  }), r.append(...i), r;
}
function pe(s, e, ...t) {
  return kM(Bf.HTML, s, e, ...t);
}
pe.SVG = function(s, e, ...t) {
  return kM(Bf.SVG, s, e, ...t);
};
function xM(...s) {
  for (const e of s)
    e.style.display = "", e.removeAttribute("aria-hidden");
}
function FD(...s) {
  for (const e of s)
    e.style.display = "none", e.setAttribute("aria-hidden", "true");
}
function BD(s, e) {
  const t = s.devicePixelRatio * e;
  return Math.max(1, Math.floor(t)) / s.devicePixelRatio;
}
function DM(s) {
  ut.open(s, "_blank", "noopener");
}
function f7(s, e) {
  const t = () => {
    e(), i = Wn(s, t);
  };
  let i = Wn(s, t);
  return ke(() => i.dispose());
}
_M.setPreferredWebSchema(/^https:/.test(ut.location.href) ? "https" : "http");
function Qr(s) {
  return s ? `url('${sb.uriToBrowserUri(s).toString(!0).replace(/'/g, "%27")}')` : "url('')";
}
function v0(s) {
  return `'${s.replace(/'/g, "%27")}'`;
}
function Hr(s, e) {
  if (s !== void 0) {
    const t = s.match(/^\s*var\((.+)\)$/);
    if (t) {
      const i = t[1].split(",", 2);
      return i.length === 2 && (e = Hr(i[1].trim(), e)), `var(${i[0]}, ${e})`;
    }
    return s;
  }
  return e;
}
function g7(s, e = !1) {
  const t = document.createElement("a");
  return mM("afterSanitizeAttributes", (i) => {
    for (const n of ["href", "src"])
      if (i.hasAttribute(n)) {
        const o = i.getAttribute(n);
        if (n === "href" && o.startsWith("#"))
          continue;
        if (t.href = o, !s.includes(t.protocol.replace(/:$/, ""))) {
          if (e && n === "src" && t.href.startsWith("data:"))
            continue;
          i.removeAttribute(n);
        }
      }
  }), ke(() => {
    pM("afterSanitizeAttributes");
  });
}
const m7 = Object.freeze([
  "a",
  "abbr",
  "b",
  "bdo",
  "blockquote",
  "br",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "dd",
  "del",
  "details",
  "dfn",
  "div",
  "dl",
  "dt",
  "em",
  "figcaption",
  "figure",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "i",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "li",
  "mark",
  "ol",
  "p",
  "pre",
  "q",
  "rp",
  "rt",
  "ruby",
  "samp",
  "small",
  "small",
  "source",
  "span",
  "strike",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "tt",
  "u",
  "ul",
  "var",
  "video",
  "wbr"
]);
class ka extends O {
  constructor() {
    super(), this._subscriptions = new he(), this._keyStatus = {
      altKey: !1,
      shiftKey: !1,
      ctrlKey: !1,
      metaKey: !1
    }, this._subscriptions.add(J.runAndSubscribe(rb, ({ window: e, disposables: t }) => this.registerListeners(e, t), { window: ut, disposables: this._subscriptions }));
  }
  registerListeners(e, t) {
    t.add($(e, "keydown", (i) => {
      if (i.defaultPrevented)
        return;
      const n = new Lt(i);
      if (!(n.keyCode === 6 && i.repeat)) {
        if (i.altKey && !this._keyStatus.altKey)
          this._keyStatus.lastKeyPressed = "alt";
        else if (i.ctrlKey && !this._keyStatus.ctrlKey)
          this._keyStatus.lastKeyPressed = "ctrl";
        else if (i.metaKey && !this._keyStatus.metaKey)
          this._keyStatus.lastKeyPressed = "meta";
        else if (i.shiftKey && !this._keyStatus.shiftKey)
          this._keyStatus.lastKeyPressed = "shift";
        else if (n.keyCode !== 6)
          this._keyStatus.lastKeyPressed = void 0;
        else
          return;
        this._keyStatus.altKey = i.altKey, this._keyStatus.ctrlKey = i.ctrlKey, this._keyStatus.metaKey = i.metaKey, this._keyStatus.shiftKey = i.shiftKey, this._keyStatus.lastKeyPressed && (this._keyStatus.event = i, this.fire(this._keyStatus));
      }
    }, !0)), t.add($(e, "keyup", (i) => {
      i.defaultPrevented || (!i.altKey && this._keyStatus.altKey ? this._keyStatus.lastKeyReleased = "alt" : !i.ctrlKey && this._keyStatus.ctrlKey ? this._keyStatus.lastKeyReleased = "ctrl" : !i.metaKey && this._keyStatus.metaKey ? this._keyStatus.lastKeyReleased = "meta" : !i.shiftKey && this._keyStatus.shiftKey ? this._keyStatus.lastKeyReleased = "shift" : this._keyStatus.lastKeyReleased = void 0, this._keyStatus.lastKeyPressed !== this._keyStatus.lastKeyReleased && (this._keyStatus.lastKeyPressed = void 0), this._keyStatus.altKey = i.altKey, this._keyStatus.ctrlKey = i.ctrlKey, this._keyStatus.metaKey = i.metaKey, this._keyStatus.shiftKey = i.shiftKey, this._keyStatus.lastKeyReleased && (this._keyStatus.event = i, this.fire(this._keyStatus)));
    }, !0)), t.add($(e.document.body, "mousedown", () => {
      this._keyStatus.lastKeyPressed = void 0;
    }, !0)), t.add($(e.document.body, "mouseup", () => {
      this._keyStatus.lastKeyPressed = void 0;
    }, !0)), t.add($(e.document.body, "mousemove", (i) => {
      i.buttons && (this._keyStatus.lastKeyPressed = void 0);
    }, !0)), t.add($(e, "blur", () => {
      this.resetKeyStatus();
    }));
  }
  get keyStatus() {
    return this._keyStatus;
  }
  /**
   * Allows to explicitly reset the key status based on more knowledge (#109062)
   */
  resetKeyStatus() {
    this.doResetKeyStatus(), this.fire(this._keyStatus);
  }
  doResetKeyStatus() {
    this._keyStatus = {
      altKey: !1,
      shiftKey: !1,
      ctrlKey: !1,
      metaKey: !1
    };
  }
  static getInstance() {
    return ka.instance || (ka.instance = new ka()), ka.instance;
  }
  dispose() {
    super.dispose(), this._subscriptions.dispose();
  }
}
class p7 extends q {
  constructor(e, t) {
    super(), this.element = e, this.callbacks = t, this.counter = 0, this.dragStartTime = 0, this.registerListeners();
  }
  registerListeners() {
    this.callbacks.onDragStart && this._register($(this.element, ee.DRAG_START, (e) => {
      var t, i;
      (i = (t = this.callbacks).onDragStart) == null || i.call(t, e);
    })), this.callbacks.onDrag && this._register($(this.element, ee.DRAG, (e) => {
      var t, i;
      (i = (t = this.callbacks).onDrag) == null || i.call(t, e);
    })), this._register($(this.element, ee.DRAG_ENTER, (e) => {
      var t, i;
      this.counter++, this.dragStartTime = e.timeStamp, (i = (t = this.callbacks).onDragEnter) == null || i.call(t, e);
    })), this._register($(this.element, ee.DRAG_OVER, (e) => {
      var t, i;
      e.preventDefault(), (i = (t = this.callbacks).onDragOver) == null || i.call(t, e, e.timeStamp - this.dragStartTime);
    })), this._register($(this.element, ee.DRAG_LEAVE, (e) => {
      var t, i;
      this.counter--, this.counter === 0 && (this.dragStartTime = 0, (i = (t = this.callbacks).onDragLeave) == null || i.call(t, e));
    })), this._register($(this.element, ee.DRAG_END, (e) => {
      var t, i;
      this.counter = 0, this.dragStartTime = 0, (i = (t = this.callbacks).onDragEnd) == null || i.call(t, e);
    })), this._register($(this.element, ee.DROP, (e) => {
      var t, i;
      this.counter = 0, this.dragStartTime = 0, (i = (t = this.callbacks).onDrop) == null || i.call(t, e);
    }));
  }
}
const _7 = /(?<tag>[\w\-]+)?(?:#(?<id>[\w\-]+))?(?<class>(?:\.(?:[\w\-]+))*)(?:@(?<name>(?:[\w\_])+))?/;
function Ue(s, ...e) {
  let t, i;
  Array.isArray(e[0]) ? (t = {}, i = e[0]) : (t = e[0] || {}, i = e[1]);
  const n = _7.exec(s);
  if (!n || !n.groups)
    throw new Error("Bad use of h");
  const o = n.groups.tag || "div", r = document.createElement(o);
  n.groups.id && (r.id = n.groups.id);
  const a = [];
  if (n.groups.class)
    for (const c of n.groups.class.split("."))
      c !== "" && a.push(c);
  if (t.className !== void 0)
    for (const c of t.className.split("."))
      c !== "" && a.push(c);
  a.length > 0 && (r.className = a.join(" "));
  const l = {};
  if (n.groups.name && (l[n.groups.name] = r), i)
    for (const c of i)
      yi(c) ? r.appendChild(c) : typeof c == "string" ? r.append(c) : "root" in c && (Object.assign(l, c), r.appendChild(c.root));
  for (const [c, h] of Object.entries(t))
    if (c !== "className")
      if (c === "style")
        for (const [d, u] of Object.entries(h))
          r.style.setProperty(WD(d), typeof u == "number" ? u + "px" : "" + u);
      else c === "tabIndex" ? r.tabIndex = h : r.setAttribute(WD(c), h.toString());
  return l.root = r, l;
}
function WD(s) {
  return s.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
class b7 extends q {
  constructor(e) {
    super(), this._onDidChange = this._register(new O()), this.onDidChange = this._onDidChange.event, this._listener = () => this._handleChange(e, !0), this._mediaQueryList = null, this._handleChange(e, !1);
  }
  _handleChange(e, t) {
    var i;
    (i = this._mediaQueryList) == null || i.removeEventListener("change", this._listener), this._mediaQueryList = e.matchMedia(`(resolution: ${e.devicePixelRatio}dppx)`), this._mediaQueryList.addEventListener("change", this._listener), t && this._onDidChange.fire();
  }
}
class C7 extends q {
  get value() {
    return this._value;
  }
  constructor(e) {
    super(), this._onDidChange = this._register(new O()), this.onDidChange = this._onDidChange.event, this._value = this._getPixelRatio(e);
    const t = this._register(new b7(e));
    this._register(t.onDidChange(() => {
      this._value = this._getPixelRatio(e), this._onDidChange.fire(this._value);
    }));
  }
  _getPixelRatio(e) {
    const t = document.createElement("canvas").getContext("2d"), i = e.devicePixelRatio || 1, n = t.webkitBackingStorePixelRatio || t.mozBackingStorePixelRatio || t.msBackingStorePixelRatio || t.oBackingStorePixelRatio || t.backingStorePixelRatio || 1;
    return i / n;
  }
}
class w7 {
  constructor() {
    this.mapWindowIdToPixelRatioMonitor = /* @__PURE__ */ new Map();
  }
  _getOrCreatePixelRatioMonitor(e) {
    const t = Ep(e);
    let i = this.mapWindowIdToPixelRatioMonitor.get(t);
    return i || (i = new C7(e), this.mapWindowIdToPixelRatioMonitor.set(t, i), J.once(Y6)(({ vscodeWindowId: n }) => {
      n === t && (i == null || i.dispose(), this.mapWindowIdToPixelRatioMonitor.delete(t));
    })), i;
  }
  getInstance(e) {
    return this._getOrCreatePixelRatioMonitor(e);
  }
}
const Np = new w7();
class EM {
  constructor(e) {
    this.domNode = e, this._maxWidth = "", this._width = "", this._height = "", this._top = "", this._left = "", this._bottom = "", this._right = "", this._paddingLeft = "", this._fontFamily = "", this._fontWeight = "", this._fontSize = "", this._fontStyle = "", this._fontFeatureSettings = "", this._fontVariationSettings = "", this._textDecoration = "", this._lineHeight = "", this._letterSpacing = "", this._className = "", this._display = "", this._position = "", this._visibility = "", this._color = "", this._backgroundColor = "", this._layerHint = !1, this._contain = "none", this._boxShadow = "";
  }
  setMaxWidth(e) {
    const t = Us(e);
    this._maxWidth !== t && (this._maxWidth = t, this.domNode.style.maxWidth = this._maxWidth);
  }
  setWidth(e) {
    const t = Us(e);
    this._width !== t && (this._width = t, this.domNode.style.width = this._width);
  }
  setHeight(e) {
    const t = Us(e);
    this._height !== t && (this._height = t, this.domNode.style.height = this._height);
  }
  setTop(e) {
    const t = Us(e);
    this._top !== t && (this._top = t, this.domNode.style.top = this._top);
  }
  setLeft(e) {
    const t = Us(e);
    this._left !== t && (this._left = t, this.domNode.style.left = this._left);
  }
  setBottom(e) {
    const t = Us(e);
    this._bottom !== t && (this._bottom = t, this.domNode.style.bottom = this._bottom);
  }
  setRight(e) {
    const t = Us(e);
    this._right !== t && (this._right = t, this.domNode.style.right = this._right);
  }
  setPaddingLeft(e) {
    const t = Us(e);
    this._paddingLeft !== t && (this._paddingLeft = t, this.domNode.style.paddingLeft = this._paddingLeft);
  }
  setFontFamily(e) {
    this._fontFamily !== e && (this._fontFamily = e, this.domNode.style.fontFamily = this._fontFamily);
  }
  setFontWeight(e) {
    this._fontWeight !== e && (this._fontWeight = e, this.domNode.style.fontWeight = this._fontWeight);
  }
  setFontSize(e) {
    const t = Us(e);
    this._fontSize !== t && (this._fontSize = t, this.domNode.style.fontSize = this._fontSize);
  }
  setFontStyle(e) {
    this._fontStyle !== e && (this._fontStyle = e, this.domNode.style.fontStyle = this._fontStyle);
  }
  setFontFeatureSettings(e) {
    this._fontFeatureSettings !== e && (this._fontFeatureSettings = e, this.domNode.style.fontFeatureSettings = this._fontFeatureSettings);
  }
  setFontVariationSettings(e) {
    this._fontVariationSettings !== e && (this._fontVariationSettings = e, this.domNode.style.fontVariationSettings = this._fontVariationSettings);
  }
  setTextDecoration(e) {
    this._textDecoration !== e && (this._textDecoration = e, this.domNode.style.textDecoration = this._textDecoration);
  }
  setLineHeight(e) {
    const t = Us(e);
    this._lineHeight !== t && (this._lineHeight = t, this.domNode.style.lineHeight = this._lineHeight);
  }
  setLetterSpacing(e) {
    const t = Us(e);
    this._letterSpacing !== t && (this._letterSpacing = t, this.domNode.style.letterSpacing = this._letterSpacing);
  }
  setClassName(e) {
    this._className !== e && (this._className = e, this.domNode.className = this._className);
  }
  toggleClassName(e, t) {
    this.domNode.classList.toggle(e, t), this._className = this.domNode.className;
  }
  setDisplay(e) {
    this._display !== e && (this._display = e, this.domNode.style.display = this._display);
  }
  setPosition(e) {
    this._position !== e && (this._position = e, this.domNode.style.position = this._position);
  }
  setVisibility(e) {
    this._visibility !== e && (this._visibility = e, this.domNode.style.visibility = this._visibility);
  }
  setColor(e) {
    this._color !== e && (this._color = e, this.domNode.style.color = this._color);
  }
  setBackgroundColor(e) {
    this._backgroundColor !== e && (this._backgroundColor = e, this.domNode.style.backgroundColor = this._backgroundColor);
  }
  setLayerHinting(e) {
    this._layerHint !== e && (this._layerHint = e, this.domNode.style.transform = this._layerHint ? "translate3d(0px, 0px, 0px)" : "");
  }
  setBoxShadow(e) {
    this._boxShadow !== e && (this._boxShadow = e, this.domNode.style.boxShadow = e);
  }
  setContain(e) {
    this._contain !== e && (this._contain = e, this.domNode.style.contain = this._contain);
  }
  setAttribute(e, t) {
    this.domNode.setAttribute(e, t);
  }
  removeAttribute(e) {
    this.domNode.removeAttribute(e);
  }
  appendChild(e) {
    this.domNode.appendChild(e.domNode);
  }
  removeChild(e) {
    this.domNode.removeChild(e.domNode);
  }
}
function Us(s) {
  return typeof s == "number" ? `${s}px` : s;
}
function je(s) {
  return new EM(s);
}
function Fi(s, e) {
  s instanceof EM ? (s.setFontFamily(e.getMassagedFontFamily()), s.setFontWeight(e.fontWeight), s.setFontSize(e.fontSize), s.setFontFeatureSettings(e.fontFeatureSettings), s.setFontVariationSettings(e.fontVariationSettings), s.setLineHeight(e.lineHeight), s.setLetterSpacing(e.letterSpacing)) : (s.style.fontFamily = e.getMassagedFontFamily(), s.style.fontWeight = e.fontWeight, s.style.fontSize = e.fontSize + "px", s.style.fontFeatureSettings = e.fontFeatureSettings, s.style.fontVariationSettings = e.fontVariationSettings, s.style.lineHeight = e.lineHeight + "px", s.style.letterSpacing = e.letterSpacing + "px");
}
class v7 {
  constructor(e, t) {
    this.chr = e, this.type = t, this.width = 0;
  }
  fulfill(e) {
    this.width = e;
  }
}
class KL {
  constructor(e, t) {
    this._bareFontInfo = e, this._requests = t, this._container = null, this._testElements = null;
  }
  read(e) {
    var t;
    this._createDomElements(), e.document.body.appendChild(this._container), this._readFromDomElements(), (t = this._container) == null || t.remove(), this._container = null, this._testElements = null;
  }
  _createDomElements() {
    const e = document.createElement("div");
    e.style.position = "absolute", e.style.top = "-50000px", e.style.width = "50000px";
    const t = document.createElement("div");
    Fi(t, this._bareFontInfo), e.appendChild(t);
    const i = document.createElement("div");
    Fi(i, this._bareFontInfo), i.style.fontWeight = "bold", e.appendChild(i);
    const n = document.createElement("div");
    Fi(n, this._bareFontInfo), n.style.fontStyle = "italic", e.appendChild(n);
    const o = [];
    for (const r of this._requests) {
      let a;
      r.type === 0 && (a = t), r.type === 2 && (a = i), r.type === 1 && (a = n), a.appendChild(document.createElement("br"));
      const l = document.createElement("span");
      KL._render(l, r), a.appendChild(l), o.push(l);
    }
    this._container = e, this._testElements = o;
  }
  static _render(e, t) {
    if (t.chr === " ") {
      let i = " ";
      for (let n = 0; n < 8; n++)
        i += i;
      e.innerText = i;
    } else {
      let i = t.chr;
      for (let n = 0; n < 8; n++)
        i += i;
      e.textContent = i;
    }
  }
  _readFromDomElements() {
    for (let e = 0, t = this._requests.length; e < t; e++) {
      const i = this._requests[e], n = this._testElements[e];
      i.fulfill(n.offsetWidth / 256);
    }
  }
}
function y7(s, e, t) {
  new KL(e, t).read(s);
}
const Ca = new class {
  constructor() {
    this._zoomLevel = 0, this._onDidChangeZoomLevel = new O(), this.onDidChangeZoomLevel = this._onDidChangeZoomLevel.event;
  }
  getZoomLevel() {
    return this._zoomLevel;
  }
  setZoomLevel(s) {
    s = Math.min(Math.max(-5, s), 20), this._zoomLevel !== s && (this._zoomLevel = s, this._onDidChangeZoomLevel.fire(this._zoomLevel));
  }
}(), S7 = He ? 1.5 : 1.35, y0 = 8;
class Zl {
  /**
   * @internal
   */
  static createFromValidatedSettings(e, t, i) {
    const n = e.get(
      49
      /* EditorOption.fontFamily */
    ), o = e.get(
      53
      /* EditorOption.fontWeight */
    ), r = e.get(
      52
      /* EditorOption.fontSize */
    ), a = e.get(
      51
      /* EditorOption.fontLigatures */
    ), l = e.get(
      54
      /* EditorOption.fontVariations */
    ), c = e.get(
      67
      /* EditorOption.lineHeight */
    ), h = e.get(
      64
      /* EditorOption.letterSpacing */
    );
    return Zl._create(n, o, r, a, l, c, h, t, i);
  }
  /**
   * @internal
   */
  static _create(e, t, i, n, o, r, a, l, c) {
    r === 0 ? r = S7 * i : r < y0 && (r = r * i), r = Math.round(r), r < y0 && (r = y0);
    const h = 1 + (c ? 0 : Ca.getZoomLevel() * 0.1);
    return i *= h, r *= h, o === Tf.TRANSLATE && (t === "normal" || t === "bold" ? o = Tf.OFF : (o = `'wght' ${parseInt(t, 10)}`, t = "normal")), new Zl({
      pixelRatio: l,
      fontFamily: e,
      fontWeight: t,
      fontSize: i,
      fontFeatureSettings: n,
      fontVariationSettings: o,
      lineHeight: r,
      letterSpacing: a
    });
  }
  /**
   * @internal
   */
  constructor(e) {
    this._bareFontInfoBrand = void 0, this.pixelRatio = e.pixelRatio, this.fontFamily = String(e.fontFamily), this.fontWeight = String(e.fontWeight), this.fontSize = e.fontSize, this.fontFeatureSettings = e.fontFeatureSettings, this.fontVariationSettings = e.fontVariationSettings, this.lineHeight = e.lineHeight | 0, this.letterSpacing = e.letterSpacing;
  }
  /**
   * @internal
   */
  getId() {
    return `${this.pixelRatio}-${this.fontFamily}-${this.fontWeight}-${this.fontSize}-${this.fontFeatureSettings}-${this.fontVariationSettings}-${this.lineHeight}-${this.letterSpacing}`;
  }
  /**
   * @internal
   */
  getMassagedFontFamily() {
    const e = es.fontFamily, t = Zl._wrapInQuotes(this.fontFamily);
    return this.fontFamily !== e ? `${t}, ${e}` : t;
  }
  static _wrapInQuotes(e) {
    return /[,"']/.test(e) ? e : /[+ ]/.test(e) ? `"${e}"` : e;
  }
}
const L7 = 2;
class Jw extends Zl {
  /**
   * @internal
   */
  constructor(e, t) {
    super(e), this._editorStylingBrand = void 0, this.version = L7, this.isTrusted = t, this.isMonospace = e.isMonospace, this.typicalHalfwidthCharacterWidth = e.typicalHalfwidthCharacterWidth, this.typicalFullwidthCharacterWidth = e.typicalFullwidthCharacterWidth, this.canUseHalfwidthRightwardsArrow = e.canUseHalfwidthRightwardsArrow, this.spaceWidth = e.spaceWidth, this.middotWidth = e.middotWidth, this.wsmiddotWidth = e.wsmiddotWidth, this.maxDigitWidth = e.maxDigitWidth;
  }
  /**
   * @internal
   */
  equals(e) {
    return this.fontFamily === e.fontFamily && this.fontWeight === e.fontWeight && this.fontSize === e.fontSize && this.fontFeatureSettings === e.fontFeatureSettings && this.fontVariationSettings === e.fontVariationSettings && this.lineHeight === e.lineHeight && this.letterSpacing === e.letterSpacing && this.typicalHalfwidthCharacterWidth === e.typicalHalfwidthCharacterWidth && this.typicalFullwidthCharacterWidth === e.typicalFullwidthCharacterWidth && this.canUseHalfwidthRightwardsArrow === e.canUseHalfwidthRightwardsArrow && this.spaceWidth === e.spaceWidth && this.middotWidth === e.middotWidth && this.wsmiddotWidth === e.wsmiddotWidth && this.maxDigitWidth === e.maxDigitWidth;
  }
}
class k7 extends q {
  constructor() {
    super(...arguments), this._cache = /* @__PURE__ */ new Map(), this._evictUntrustedReadingsTimeout = -1, this._onDidChange = this._register(new O()), this.onDidChange = this._onDidChange.event;
  }
  dispose() {
    this._evictUntrustedReadingsTimeout !== -1 && (clearTimeout(this._evictUntrustedReadingsTimeout), this._evictUntrustedReadingsTimeout = -1), super.dispose();
  }
  /**
   * Clear all cached font information and trigger a change event.
   */
  clearAllFontInfos() {
    this._cache.clear(), this._onDidChange.fire();
  }
  _ensureCache(e) {
    const t = Ep(e);
    let i = this._cache.get(t);
    return i || (i = new x7(), this._cache.set(t, i)), i;
  }
  _writeToCache(e, t, i) {
    this._ensureCache(e).put(t, i), !i.isTrusted && this._evictUntrustedReadingsTimeout === -1 && (this._evictUntrustedReadingsTimeout = e.setTimeout(() => {
      this._evictUntrustedReadingsTimeout = -1, this._evictUntrustedReadings(e);
    }, 5e3));
  }
  _evictUntrustedReadings(e) {
    const t = this._ensureCache(e), i = t.getValues();
    let n = !1;
    for (const o of i)
      o.isTrusted || (n = !0, t.remove(o));
    n && this._onDidChange.fire();
  }
  /**
   * Read font information.
   */
  readFontInfo(e, t) {
    const i = this._ensureCache(e);
    if (!i.has(t)) {
      let n = this._actualReadFontInfo(e, t);
      (n.typicalHalfwidthCharacterWidth <= 2 || n.typicalFullwidthCharacterWidth <= 2 || n.spaceWidth <= 2 || n.maxDigitWidth <= 2) && (n = new Jw({
        pixelRatio: Np.getInstance(e).value,
        fontFamily: n.fontFamily,
        fontWeight: n.fontWeight,
        fontSize: n.fontSize,
        fontFeatureSettings: n.fontFeatureSettings,
        fontVariationSettings: n.fontVariationSettings,
        lineHeight: n.lineHeight,
        letterSpacing: n.letterSpacing,
        isMonospace: n.isMonospace,
        typicalHalfwidthCharacterWidth: Math.max(n.typicalHalfwidthCharacterWidth, 5),
        typicalFullwidthCharacterWidth: Math.max(n.typicalFullwidthCharacterWidth, 5),
        canUseHalfwidthRightwardsArrow: n.canUseHalfwidthRightwardsArrow,
        spaceWidth: Math.max(n.spaceWidth, 5),
        middotWidth: Math.max(n.middotWidth, 5),
        wsmiddotWidth: Math.max(n.wsmiddotWidth, 5),
        maxDigitWidth: Math.max(n.maxDigitWidth, 5)
      }, !1)), this._writeToCache(e, t, n);
    }
    return i.get(t);
  }
  _createRequest(e, t, i, n) {
    const o = new v7(e, t);
    return i.push(o), n == null || n.push(o), o;
  }
  _actualReadFontInfo(e, t) {
    const i = [], n = [], o = this._createRequest("n", 0, i, n), r = this._createRequest("ｍ", 0, i, null), a = this._createRequest(" ", 0, i, n), l = this._createRequest("0", 0, i, n), c = this._createRequest("1", 0, i, n), h = this._createRequest("2", 0, i, n), d = this._createRequest("3", 0, i, n), u = this._createRequest("4", 0, i, n), f = this._createRequest("5", 0, i, n), g = this._createRequest("6", 0, i, n), m = this._createRequest("7", 0, i, n), _ = this._createRequest("8", 0, i, n), b = this._createRequest("9", 0, i, n), C = this._createRequest("→", 0, i, n), v = this._createRequest("￫", 0, i, null), w = this._createRequest("·", 0, i, n), S = this._createRequest("⸱", 0, i, null), L = "|/-_ilm%";
    for (let P = 0, B = L.length; P < B; P++)
      this._createRequest(L.charAt(P), 0, i, n), this._createRequest(L.charAt(P), 1, i, n), this._createRequest(L.charAt(P), 2, i, n);
    y7(e, t, i);
    const k = Math.max(l.width, c.width, h.width, d.width, u.width, f.width, g.width, m.width, _.width, b.width);
    let D = t.fontFeatureSettings === gc.OFF;
    const E = n[0].width;
    for (let P = 1, B = n.length; D && P < B; P++) {
      const W = E - n[P].width;
      if (W < -1e-3 || W > 1e-3) {
        D = !1;
        break;
      }
    }
    let U = !0;
    return D && v.width !== E && (U = !1), v.width > C.width && (U = !1), new Jw({
      pixelRatio: Np.getInstance(e).value,
      fontFamily: t.fontFamily,
      fontWeight: t.fontWeight,
      fontSize: t.fontSize,
      fontFeatureSettings: t.fontFeatureSettings,
      fontVariationSettings: t.fontVariationSettings,
      lineHeight: t.lineHeight,
      letterSpacing: t.letterSpacing,
      isMonospace: D,
      typicalHalfwidthCharacterWidth: o.width,
      typicalFullwidthCharacterWidth: r.width,
      canUseHalfwidthRightwardsArrow: U,
      spaceWidth: a.width,
      middotWidth: w.width,
      wsmiddotWidth: S.width,
      maxDigitWidth: k
    }, !0);
  }
}
class x7 {
  constructor() {
    this._keys = /* @__PURE__ */ Object.create(null), this._values = /* @__PURE__ */ Object.create(null);
  }
  has(e) {
    const t = e.getId();
    return !!this._values[t];
  }
  get(e) {
    const t = e.getId();
    return this._values[t];
  }
  put(e, t) {
    const i = e.getId();
    this._keys[i] = e, this._values[i] = t;
  }
  remove(e) {
    const t = e.getId();
    delete this._keys[t], delete this._values[t];
  }
  getValues() {
    return Object.keys(this._keys).map((e) => this._values[e]);
  }
}
const ev = new k7();
var io;
(function(s) {
  s.serviceIds = /* @__PURE__ */ new Map(), s.DI_TARGET = "$di$target", s.DI_DEPENDENCIES = "$di$dependencies";
  function e(t) {
    return t[s.DI_DEPENDENCIES] || [];
  }
  s.getServiceDependencies = e;
})(io || (io = {}));
const ot = Ve("instantiationService");
function D7(s, e, t) {
  e[io.DI_TARGET] === e ? e[io.DI_DEPENDENCIES].push({ id: s, index: t }) : (e[io.DI_DEPENDENCIES] = [{ id: s, index: t }], e[io.DI_TARGET] = e);
}
function Ve(s) {
  if (io.serviceIds.has(s))
    return io.serviceIds.get(s);
  const e = function(t, i, n) {
    if (arguments.length !== 3)
      throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
    D7(e, t, n);
  };
  return e.toString = () => s, io.serviceIds.set(s, e), e;
}
const ri = Ve("codeEditorService"), cn = Ve("modelService"), ab = Ve("textModelService");
class zr extends q {
  constructor(e, t = "", i = "", n = !0, o) {
    super(), this._onDidChange = this._register(new O()), this.onDidChange = this._onDidChange.event, this._enabled = !0, this._id = e, this._label = t, this._cssClass = i, this._enabled = n, this._actionCallback = o;
  }
  get id() {
    return this._id;
  }
  get label() {
    return this._label;
  }
  set label(e) {
    this._setLabel(e);
  }
  _setLabel(e) {
    this._label !== e && (this._label = e, this._onDidChange.fire({ label: e }));
  }
  get tooltip() {
    return this._tooltip || "";
  }
  set tooltip(e) {
    this._setTooltip(e);
  }
  _setTooltip(e) {
    this._tooltip !== e && (this._tooltip = e, this._onDidChange.fire({ tooltip: e }));
  }
  get class() {
    return this._cssClass;
  }
  set class(e) {
    this._setClass(e);
  }
  _setClass(e) {
    this._cssClass !== e && (this._cssClass = e, this._onDidChange.fire({ class: e }));
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    this._setEnabled(e);
  }
  _setEnabled(e) {
    this._enabled !== e && (this._enabled = e, this._onDidChange.fire({ enabled: e }));
  }
  get checked() {
    return this._checked;
  }
  set checked(e) {
    this._setChecked(e);
  }
  _setChecked(e) {
    this._checked !== e && (this._checked = e, this._onDidChange.fire({ checked: e }));
  }
  async run(e, t) {
    this._actionCallback && await this._actionCallback(e);
  }
}
class _c extends q {
  constructor() {
    super(...arguments), this._onWillRun = this._register(new O()), this.onWillRun = this._onWillRun.event, this._onDidRun = this._register(new O()), this.onDidRun = this._onDidRun.event;
  }
  async run(e, t) {
    if (!e.enabled)
      return;
    this._onWillRun.fire({ action: e });
    let i;
    try {
      await this.runAction(e, t);
    } catch (n) {
      i = n;
    }
    this._onDidRun.fire({ action: e, error: i });
  }
  async runAction(e, t) {
    await e.run(t);
  }
}
const pf = class pf {
  constructor() {
    this.id = pf.ID, this.label = "", this.tooltip = "", this.class = "separator", this.enabled = !1, this.checked = !1;
  }
  /**
   * Joins all non-empty lists of actions with separators.
   */
  static join(...e) {
    let t = [];
    for (const i of e)
      i.length && (t.length ? t = [...t, new pf(), ...i] : t = i);
    return t;
  }
  async run() {
  }
};
pf.ID = "vs.actions.separator";
let Zi = pf;
class lb {
  get actions() {
    return this._actions;
  }
  constructor(e, t, i, n) {
    this.tooltip = "", this.enabled = !0, this.checked = void 0, this.id = e, this.label = t, this.class = n, this._actions = i;
  }
  async run() {
  }
}
const c1 = class c1 extends zr {
  constructor() {
    super(c1.ID, p("submenu.empty", "(empty)"), void 0, !1);
  }
};
c1.ID = "vs.actions.empty";
let tv = c1;
function $h(s) {
  return {
    id: s.id,
    label: s.label,
    tooltip: s.tooltip ?? s.label,
    class: s.class,
    enabled: s.enabled ?? !0,
    checked: s.checked,
    run: async (...e) => s.run(...e)
  };
}
var iv;
(function(s) {
  function e(t) {
    return t && typeof t == "object" && typeof t.id == "string";
  }
  s.isThemeColor = e;
})(iv || (iv = {}));
var Ke;
(function(s) {
  s.iconNameSegment = "[A-Za-z0-9]+", s.iconNameExpression = "[A-Za-z0-9-]+", s.iconModifierExpression = "~[A-Za-z]+", s.iconNameCharacter = "[A-Za-z0-9~-]";
  const e = new RegExp(`^(${s.iconNameExpression})(${s.iconModifierExpression})?$`);
  function t(u) {
    const f = e.exec(u.id);
    if (!f)
      return t(re.error);
    const [, g, m] = f, _ = ["codicon", "codicon-" + g];
    return m && _.push("codicon-modifier-" + m.substring(1)), _;
  }
  s.asClassNameArray = t;
  function i(u) {
    return t(u).join(" ");
  }
  s.asClassName = i;
  function n(u) {
    return "." + t(u).join(".");
  }
  s.asCSSSelector = n;
  function o(u) {
    return u && typeof u == "object" && typeof u.id == "string" && (typeof u.color > "u" || iv.isThemeColor(u.color));
  }
  s.isThemeIcon = o;
  const r = new RegExp(`^\\$\\((${s.iconNameExpression}(?:${s.iconModifierExpression})?)\\)$`);
  function a(u) {
    const f = r.exec(u);
    if (!f)
      return;
    const [, g] = f;
    return { id: g };
  }
  s.fromString = a;
  function l(u) {
    return { id: u };
  }
  s.fromId = l;
  function c(u, f) {
    let g = u.id;
    const m = g.lastIndexOf("~");
    return m !== -1 && (g = g.substring(0, m)), f && (g = `${g}~${f}`), { id: g };
  }
  s.modify = c;
  function h(u) {
    const f = u.id.lastIndexOf("~");
    if (f !== -1)
      return u.id.substring(f + 1);
  }
  s.getModifier = h;
  function d(u, f) {
    var g, m;
    return u.id === f.id && ((g = u.color) == null ? void 0 : g.id) === ((m = f.color) == null ? void 0 : m.id);
  }
  s.isEqual = d;
})(Ke || (Ke = {}));
const ss = Ve("commandService"), Sn = new class {
  constructor() {
    this._commands = /* @__PURE__ */ new Map(), this._onDidRegisterCommand = new O(), this.onDidRegisterCommand = this._onDidRegisterCommand.event;
  }
  registerCommand(s, e) {
    if (!s)
      throw new Error("invalid command");
    if (typeof s == "string") {
      if (!e)
        throw new Error("invalid command");
      return this.registerCommand({ id: s, handler: e });
    }
    if (s.metadata && Array.isArray(s.metadata.args)) {
      const r = [];
      for (const l of s.metadata.args)
        r.push(l.constraint);
      const a = s.handler;
      s.handler = function(l, ...c) {
        return $5(c, r), a(l, ...c);
      };
    }
    const { id: t } = s;
    let i = this._commands.get(t);
    i || (i = new An(), this._commands.set(t, i));
    const n = i.unshift(s), o = ke(() => {
      n();
      const r = this._commands.get(t);
      r != null && r.isEmpty() && this._commands.delete(t);
    });
    return this._onDidRegisterCommand.fire(t), o;
  }
  registerCommandAlias(s, e) {
    return Sn.registerCommand(s, (t, ...i) => t.get(ss).executeCommand(e, ...i));
  }
  getCommand(s) {
    const e = this._commands.get(s);
    if (!(!e || e.isEmpty()))
      return Ye.first(e);
  }
  getCommands() {
    const s = /* @__PURE__ */ new Map();
    for (const e of this._commands.keys()) {
      const t = this.getCommand(e);
      t && s.set(e, t);
    }
    return s;
  }
}();
Sn.registerCommand("noop", () => {
});
function S0(...s) {
  switch (s.length) {
    case 1:
      return p("contextkey.scanner.hint.didYouMean1", "Did you mean {0}?", s[0]);
    case 2:
      return p("contextkey.scanner.hint.didYouMean2", "Did you mean {0} or {1}?", s[0], s[1]);
    case 3:
      return p("contextkey.scanner.hint.didYouMean3", "Did you mean {0}, {1} or {2}?", s[0], s[1], s[2]);
    default:
      return;
  }
}
const E7 = p("contextkey.scanner.hint.didYouForgetToOpenOrCloseQuote", "Did you forget to open or close the quote?"), I7 = p("contextkey.scanner.hint.didYouForgetToEscapeSlash", "Did you forget to escape the '/' (slash) character? Put two backslashes before it to escape, e.g., '\\\\/'."), Mh = class Mh {
  constructor() {
    this._input = "", this._start = 0, this._current = 0, this._tokens = [], this._errors = [], this.stringRe = /[a-zA-Z0-9_<>\-\./\\:\*\?\+\[\]\^,#@;"%\$\p{L}-]+/uy;
  }
  static getLexeme(e) {
    switch (e.type) {
      case 0:
        return "(";
      case 1:
        return ")";
      case 2:
        return "!";
      case 3:
        return e.isTripleEq ? "===" : "==";
      case 4:
        return e.isTripleEq ? "!==" : "!=";
      case 5:
        return "<";
      case 6:
        return "<=";
      case 7:
        return ">=";
      case 8:
        return ">=";
      case 9:
        return "=~";
      case 10:
        return e.lexeme;
      case 11:
        return "true";
      case 12:
        return "false";
      case 13:
        return "in";
      case 14:
        return "not";
      case 15:
        return "&&";
      case 16:
        return "||";
      case 17:
        return e.lexeme;
      case 18:
        return e.lexeme;
      case 19:
        return e.lexeme;
      case 20:
        return "EOF";
      default:
        throw vL(`unhandled token type: ${JSON.stringify(e)}; have you forgotten to add a case?`);
    }
  }
  reset(e) {
    return this._input = e, this._start = 0, this._current = 0, this._tokens = [], this._errors = [], this;
  }
  scan() {
    for (; !this._isAtEnd(); )
      switch (this._start = this._current, this._advance()) {
        case 40:
          this._addToken(
            0
            /* TokenType.LParen */
          );
          break;
        case 41:
          this._addToken(
            1
            /* TokenType.RParen */
          );
          break;
        case 33:
          if (this._match(
            61
            /* CharCode.Equals */
          )) {
            const t = this._match(
              61
              /* CharCode.Equals */
            );
            this._tokens.push({ type: 4, offset: this._start, isTripleEq: t });
          } else
            this._addToken(
              2
              /* TokenType.Neg */
            );
          break;
        case 39:
          this._quotedString();
          break;
        case 47:
          this._regex();
          break;
        case 61:
          if (this._match(
            61
            /* CharCode.Equals */
          )) {
            const t = this._match(
              61
              /* CharCode.Equals */
            );
            this._tokens.push({ type: 3, offset: this._start, isTripleEq: t });
          } else this._match(
            126
            /* CharCode.Tilde */
          ) ? this._addToken(
            9
            /* TokenType.RegexOp */
          ) : this._error(S0("==", "=~"));
          break;
        case 60:
          this._addToken(
            this._match(
              61
              /* CharCode.Equals */
            ) ? 6 : 5
            /* TokenType.Lt */
          );
          break;
        case 62:
          this._addToken(
            this._match(
              61
              /* CharCode.Equals */
            ) ? 8 : 7
            /* TokenType.Gt */
          );
          break;
        case 38:
          this._match(
            38
            /* CharCode.Ampersand */
          ) ? this._addToken(
            15
            /* TokenType.And */
          ) : this._error(S0("&&"));
          break;
        case 124:
          this._match(
            124
            /* CharCode.Pipe */
          ) ? this._addToken(
            16
            /* TokenType.Or */
          ) : this._error(S0("||"));
          break;
        // TODO@ulugbekna: 1) rewrite using a regex 2) reconsider what characters are considered whitespace, including unicode, nbsp, etc.
        case 32:
        case 13:
        case 9:
        case 10:
        case 160:
          break;
        default:
          this._string();
      }
    return this._start = this._current, this._addToken(
      20
      /* TokenType.EOF */
    ), Array.from(this._tokens);
  }
  _match(e) {
    return this._isAtEnd() || this._input.charCodeAt(this._current) !== e ? !1 : (this._current++, !0);
  }
  _advance() {
    return this._input.charCodeAt(this._current++);
  }
  _peek() {
    return this._isAtEnd() ? 0 : this._input.charCodeAt(this._current);
  }
  _addToken(e) {
    this._tokens.push({ type: e, offset: this._start });
  }
  _error(e) {
    const t = this._start, i = this._input.substring(this._start, this._current), n = { type: 19, offset: this._start, lexeme: i };
    this._errors.push({ offset: t, lexeme: i, additionalInfo: e }), this._tokens.push(n);
  }
  _string() {
    this.stringRe.lastIndex = this._start;
    const e = this.stringRe.exec(this._input);
    if (e) {
      this._current = this._start + e[0].length;
      const t = this._input.substring(this._start, this._current), i = Mh._keywords.get(t);
      i ? this._addToken(i) : this._tokens.push({ type: 17, lexeme: t, offset: this._start });
    }
  }
  // captures the lexeme without the leading and trailing '
  _quotedString() {
    for (; this._peek() !== 39 && !this._isAtEnd(); )
      this._advance();
    if (this._isAtEnd()) {
      this._error(E7);
      return;
    }
    this._advance(), this._tokens.push({ type: 18, lexeme: this._input.substring(this._start + 1, this._current - 1), offset: this._start + 1 });
  }
  /*
   * Lexing a regex expression: /.../[igsmyu]*
   * Based on https://github.com/microsoft/TypeScript/blob/9247ef115e617805983740ba795d7a8164babf89/src/compiler/scanner.ts#L2129-L2181
   *
   * Note that we want slashes within a regex to be escaped, e.g., /file:\\/\\/\\// should match `file:///`
   */
  _regex() {
    let e = this._current, t = !1, i = !1;
    for (; ; ) {
      if (e >= this._input.length) {
        this._current = e, this._error(I7);
        return;
      }
      const o = this._input.charCodeAt(e);
      if (t)
        t = !1;
      else if (o === 47 && !i) {
        e++;
        break;
      } else o === 91 ? i = !0 : o === 92 ? t = !0 : o === 93 && (i = !1);
      e++;
    }
    for (; e < this._input.length && Mh._regexFlags.has(this._input.charCodeAt(e)); )
      e++;
    this._current = e;
    const n = this._input.substring(this._start, this._current);
    this._tokens.push({ type: 10, lexeme: n, offset: this._start });
  }
  _isAtEnd() {
    return this._current >= this._input.length;
  }
};
Mh._regexFlags = new Set(["i", "g", "s", "m", "y", "u"].map((e) => e.charCodeAt(0))), Mh._keywords = /* @__PURE__ */ new Map([
  [
    "not",
    14
    /* TokenType.Not */
  ],
  [
    "in",
    13
    /* TokenType.In */
  ],
  [
    "false",
    12
    /* TokenType.False */
  ],
  [
    "true",
    11
    /* TokenType.True */
  ]
]);
let yl = Mh;
const Bi = /* @__PURE__ */ new Map();
Bi.set("false", !1);
Bi.set("true", !0);
Bi.set("isMac", He);
Bi.set("isLinux", wn);
Bi.set("isWindows", Fn);
Bi.set("isWeb", Fd);
Bi.set("isMacNative", He && !Fd);
Bi.set("isEdge", rP);
Bi.set("isFirefox", sP);
Bi.set("isChrome", E2);
Bi.set("isSafari", oP);
const N7 = Object.prototype.hasOwnProperty, T7 = {
  regexParsingWithErrorRecovery: !0
}, M7 = p("contextkey.parser.error.emptyString", "Empty context key expression"), R7 = p("contextkey.parser.error.emptyString.hint", "Did you forget to write an expression? You can also put 'false' or 'true' to always evaluate to false or true, respectively."), A7 = p("contextkey.parser.error.noInAfterNot", "'in' after 'not'."), VD = p("contextkey.parser.error.closingParenthesis", "closing parenthesis ')'"), P7 = p("contextkey.parser.error.unexpectedToken", "Unexpected token"), O7 = p("contextkey.parser.error.unexpectedToken.hint", "Did you forget to put && or || before the token?"), F7 = p("contextkey.parser.error.unexpectedEOF", "Unexpected end of expression"), B7 = p("contextkey.parser.error.unexpectedEOF.hint", "Did you forget to put a context key?");
var Bo;
let W7 = (Bo = class {
  constructor(e = T7) {
    this._config = e, this._scanner = new yl(), this._tokens = [], this._current = 0, this._parsingErrors = [], this._flagsGYRe = /g|y/g;
  }
  /**
   * Parse a context key expression.
   *
   * @param input the expression to parse
   * @returns the parsed expression or `undefined` if there's an error - call `lexingErrors` and `parsingErrors` to see the errors
   */
  parse(e) {
    if (e === "") {
      this._parsingErrors.push({ message: M7, offset: 0, lexeme: "", additionalInfo: R7 });
      return;
    }
    this._tokens = this._scanner.reset(e).scan(), this._current = 0, this._parsingErrors = [];
    try {
      const t = this._expr();
      if (!this._isAtEnd()) {
        const i = this._peek(), n = i.type === 17 ? O7 : void 0;
        throw this._parsingErrors.push({ message: P7, offset: i.offset, lexeme: yl.getLexeme(i), additionalInfo: n }), Bo._parseError;
      }
      return t;
    } catch (t) {
      if (t !== Bo._parseError)
        throw t;
      return;
    }
  }
  _expr() {
    return this._or();
  }
  _or() {
    const e = [this._and()];
    for (; this._matchOne(
      16
      /* TokenType.Or */
    ); ) {
      const t = this._and();
      e.push(t);
    }
    return e.length === 1 ? e[0] : et.or(...e);
  }
  _and() {
    const e = [this._term()];
    for (; this._matchOne(
      15
      /* TokenType.And */
    ); ) {
      const t = this._term();
      e.push(t);
    }
    return e.length === 1 ? e[0] : et.and(...e);
  }
  _term() {
    if (this._matchOne(
      2
      /* TokenType.Neg */
    )) {
      const e = this._peek();
      switch (e.type) {
        case 11:
          return this._advance(), rn.INSTANCE;
        case 12:
          return this._advance(), vn.INSTANCE;
        case 0: {
          this._advance();
          const t = this._expr();
          return this._consume(1, VD), t == null ? void 0 : t.negate();
        }
        case 17:
          return this._advance(), Tc.create(e.lexeme);
        default:
          throw this._errExpectedButGot("KEY | true | false | '(' expression ')'", e);
      }
    }
    return this._primary();
  }
  _primary() {
    const e = this._peek();
    switch (e.type) {
      case 11:
        return this._advance(), et.true();
      case 12:
        return this._advance(), et.false();
      case 0: {
        this._advance();
        const t = this._expr();
        return this._consume(1, VD), t;
      }
      case 17: {
        const t = e.lexeme;
        if (this._advance(), this._matchOne(
          9
          /* TokenType.RegexOp */
        )) {
          const n = this._peek();
          if (!this._config.regexParsingWithErrorRecovery) {
            if (this._advance(), n.type !== 10)
              throw this._errExpectedButGot("REGEX", n);
            const o = n.lexeme, r = o.lastIndexOf("/"), a = r === o.length - 1 ? void 0 : this._removeFlagsGY(o.substring(r + 1));
            let l;
            try {
              l = new RegExp(o.substring(1, r), a);
            } catch {
              throw this._errExpectedButGot("REGEX", n);
            }
            return Wf.create(t, l);
          }
          switch (n.type) {
            case 10:
            case 19: {
              const o = [n.lexeme];
              this._advance();
              let r = this._peek(), a = 0;
              for (let u = 0; u < n.lexeme.length; u++)
                n.lexeme.charCodeAt(u) === 40 ? a++ : n.lexeme.charCodeAt(u) === 41 && a--;
              for (; !this._isAtEnd() && r.type !== 15 && r.type !== 16; ) {
                switch (r.type) {
                  case 0:
                    a++;
                    break;
                  case 1:
                    a--;
                    break;
                  case 10:
                  case 18:
                    for (let u = 0; u < r.lexeme.length; u++)
                      r.lexeme.charCodeAt(u) === 40 ? a++ : n.lexeme.charCodeAt(u) === 41 && a--;
                }
                if (a < 0)
                  break;
                o.push(yl.getLexeme(r)), this._advance(), r = this._peek();
              }
              const l = o.join(""), c = l.lastIndexOf("/"), h = c === l.length - 1 ? void 0 : this._removeFlagsGY(l.substring(c + 1));
              let d;
              try {
                d = new RegExp(l.substring(1, c), h);
              } catch {
                throw this._errExpectedButGot("REGEX", n);
              }
              return et.regex(t, d);
            }
            case 18: {
              const o = n.lexeme;
              this._advance();
              let r = null;
              if (!qO(o)) {
                const a = o.indexOf("/"), l = o.lastIndexOf("/");
                if (a !== l && a >= 0) {
                  const c = o.slice(a + 1, l), h = o[l + 1] === "i" ? "i" : "";
                  try {
                    r = new RegExp(c, h);
                  } catch {
                    throw this._errExpectedButGot("REGEX", n);
                  }
                }
              }
              if (r === null)
                throw this._errExpectedButGot("REGEX", n);
              return Wf.create(t, r);
            }
            default:
              throw this._errExpectedButGot("REGEX", this._peek());
          }
        }
        if (this._matchOne(
          14
          /* TokenType.Not */
        )) {
          this._consume(13, A7);
          const n = this._value();
          return et.notIn(t, n);
        }
        switch (this._peek().type) {
          case 3: {
            this._advance();
            const n = this._value();
            if (this._previous().type === 18)
              return et.equals(t, n);
            switch (n) {
              case "true":
                return et.has(t);
              case "false":
                return et.not(t);
              default:
                return et.equals(t, n);
            }
          }
          case 4: {
            this._advance();
            const n = this._value();
            if (this._previous().type === 18)
              return et.notEquals(t, n);
            switch (n) {
              case "true":
                return et.not(t);
              case "false":
                return et.has(t);
              default:
                return et.notEquals(t, n);
            }
          }
          // TODO: ContextKeyExpr.smaller(key, right) accepts only `number` as `right` AND during eval of this node, we just eval to `false` if `right` is not a number
          // consequently, package.json linter should _warn_ the user if they're passing undesired things to ops
          case 5:
            return this._advance(), mb.create(t, this._value());
          case 6:
            return this._advance(), pb.create(t, this._value());
          case 7:
            return this._advance(), fb.create(t, this._value());
          case 8:
            return this._advance(), gb.create(t, this._value());
          case 13:
            return this._advance(), et.in(t, this._value());
          default:
            return et.has(t);
        }
      }
      case 20:
        throw this._parsingErrors.push({ message: F7, offset: e.offset, lexeme: "", additionalInfo: B7 }), Bo._parseError;
      default:
        throw this._errExpectedButGot(`true | false | KEY 
	| KEY '=~' REGEX 
	| KEY ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in') value`, this._peek());
    }
  }
  _value() {
    const e = this._peek();
    switch (e.type) {
      case 17:
      case 18:
        return this._advance(), e.lexeme;
      case 11:
        return this._advance(), "true";
      case 12:
        return this._advance(), "false";
      case 13:
        return this._advance(), "in";
      default:
        return "";
    }
  }
  _removeFlagsGY(e) {
    return e.replaceAll(this._flagsGYRe, "");
  }
  // careful: this can throw if current token is the initial one (ie index = 0)
  _previous() {
    return this._tokens[this._current - 1];
  }
  _matchOne(e) {
    return this._check(e) ? (this._advance(), !0) : !1;
  }
  _advance() {
    return this._isAtEnd() || this._current++, this._previous();
  }
  _consume(e, t) {
    if (this._check(e))
      return this._advance();
    throw this._errExpectedButGot(t, this._peek());
  }
  _errExpectedButGot(e, t, i) {
    const n = p("contextkey.parser.error.expectedButGot", `Expected: {0}
Received: '{1}'.`, e, yl.getLexeme(t)), o = t.offset, r = yl.getLexeme(t);
    return this._parsingErrors.push({ message: n, offset: o, lexeme: r, additionalInfo: i }), Bo._parseError;
  }
  _check(e) {
    return this._peek().type === e;
  }
  _peek() {
    return this._tokens[this._current];
  }
  _isAtEnd() {
    return this._peek().type === 20;
  }
}, Bo._parseError = new Error(), Bo);
const qx = class qx {
  static false() {
    return rn.INSTANCE;
  }
  static true() {
    return vn.INSTANCE;
  }
  static has(e) {
    return Nc.create(e);
  }
  static equals(e, t) {
    return xg.create(e, t);
  }
  static notEquals(e, t) {
    return db.create(e, t);
  }
  static regex(e, t) {
    return Wf.create(e, t);
  }
  static in(e, t) {
    return cb.create(e, t);
  }
  static notIn(e, t) {
    return hb.create(e, t);
  }
  static not(e) {
    return Tc.create(e);
  }
  static and(...e) {
    return zl.create(e, null, !0);
  }
  static or(...e) {
    return xr.create(e, null, !0);
  }
  static deserialize(e) {
    return e == null ? void 0 : this._parser.parse(e);
  }
};
qx._parser = new W7({ regexParsingWithErrorRecovery: !1 });
let et = qx;
function V7(s, e) {
  const t = s ? s.substituteConstants() : void 0, i = e ? e.substituteConstants() : void 0;
  return !t && !i ? !0 : !t || !i ? !1 : t.equals(i);
}
function Vu(s, e) {
  return s.cmp(e);
}
const h1 = class h1 {
  constructor() {
    this.type = 0;
  }
  cmp(e) {
    return this.type - e.type;
  }
  equals(e) {
    return e.type === this.type;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return !1;
  }
  serialize() {
    return "false";
  }
  keys() {
    return [];
  }
  negate() {
    return vn.INSTANCE;
  }
};
h1.INSTANCE = new h1();
let rn = h1;
const d1 = class d1 {
  constructor() {
    this.type = 1;
  }
  cmp(e) {
    return this.type - e.type;
  }
  equals(e) {
    return e.type === this.type;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return !0;
  }
  serialize() {
    return "true";
  }
  keys() {
    return [];
  }
  negate() {
    return rn.INSTANCE;
  }
};
d1.INSTANCE = new d1();
let vn = d1;
class Nc {
  static create(e, t = null) {
    const i = Bi.get(e);
    return typeof i == "boolean" ? i ? vn.INSTANCE : rn.INSTANCE : new Nc(e, t);
  }
  constructor(e, t) {
    this.key = e, this.negated = t, this.type = 2;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : NM(this.key, e.key);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key : !1;
  }
  substituteConstants() {
    const e = Bi.get(this.key);
    return typeof e == "boolean" ? e ? vn.INSTANCE : rn.INSTANCE : this;
  }
  evaluate(e) {
    return !!e.getValue(this.key);
  }
  serialize() {
    return this.key;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = Tc.create(this.key, this)), this.negated;
  }
}
class xg {
  static create(e, t, i = null) {
    if (typeof t == "boolean")
      return t ? Nc.create(e, i) : Tc.create(e, i);
    const n = Bi.get(e);
    return typeof n == "boolean" ? t === (n ? "true" : "false") ? vn.INSTANCE : rn.INSTANCE : new xg(e, t, i);
  }
  constructor(e, t, i) {
    this.key = e, this.value = t, this.negated = i, this.type = 4;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : Mc(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  substituteConstants() {
    const e = Bi.get(this.key);
    if (typeof e == "boolean") {
      const t = e ? "true" : "false";
      return this.value === t ? vn.INSTANCE : rn.INSTANCE;
    }
    return this;
  }
  evaluate(e) {
    return e.getValue(this.key) == this.value;
  }
  serialize() {
    return `${this.key} == '${this.value}'`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = db.create(this.key, this.value, this)), this.negated;
  }
}
class cb {
  static create(e, t) {
    return new cb(e, t);
  }
  constructor(e, t) {
    this.key = e, this.valueKey = t, this.type = 10, this.negated = null;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : Mc(this.key, this.valueKey, e.key, e.valueKey);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.valueKey === e.valueKey : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    const t = e.getValue(this.valueKey), i = e.getValue(this.key);
    return Array.isArray(t) ? t.includes(i) : typeof i == "string" && typeof t == "object" && t !== null ? N7.call(t, i) : !1;
  }
  serialize() {
    return `${this.key} in '${this.valueKey}'`;
  }
  keys() {
    return [this.key, this.valueKey];
  }
  negate() {
    return this.negated || (this.negated = hb.create(this.key, this.valueKey)), this.negated;
  }
}
class hb {
  static create(e, t) {
    return new hb(e, t);
  }
  constructor(e, t) {
    this.key = e, this.valueKey = t, this.type = 11, this._negated = cb.create(e, t);
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : this._negated.cmp(e._negated);
  }
  equals(e) {
    return e.type === this.type ? this._negated.equals(e._negated) : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return !this._negated.evaluate(e);
  }
  serialize() {
    return `${this.key} not in '${this.valueKey}'`;
  }
  keys() {
    return this._negated.keys();
  }
  negate() {
    return this._negated;
  }
}
class db {
  static create(e, t, i = null) {
    if (typeof t == "boolean")
      return t ? Tc.create(e, i) : Nc.create(e, i);
    const n = Bi.get(e);
    return typeof n == "boolean" ? t === (n ? "true" : "false") ? rn.INSTANCE : vn.INSTANCE : new db(e, t, i);
  }
  constructor(e, t, i) {
    this.key = e, this.value = t, this.negated = i, this.type = 5;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : Mc(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  substituteConstants() {
    const e = Bi.get(this.key);
    if (typeof e == "boolean") {
      const t = e ? "true" : "false";
      return this.value === t ? rn.INSTANCE : vn.INSTANCE;
    }
    return this;
  }
  evaluate(e) {
    return e.getValue(this.key) != this.value;
  }
  serialize() {
    return `${this.key} != '${this.value}'`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = xg.create(this.key, this.value, this)), this.negated;
  }
}
class Tc {
  static create(e, t = null) {
    const i = Bi.get(e);
    return typeof i == "boolean" ? i ? rn.INSTANCE : vn.INSTANCE : new Tc(e, t);
  }
  constructor(e, t) {
    this.key = e, this.negated = t, this.type = 3;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : NM(this.key, e.key);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key : !1;
  }
  substituteConstants() {
    const e = Bi.get(this.key);
    return typeof e == "boolean" ? e ? rn.INSTANCE : vn.INSTANCE : this;
  }
  evaluate(e) {
    return !e.getValue(this.key);
  }
  serialize() {
    return `!${this.key}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = Nc.create(this.key, this)), this.negated;
  }
}
function ub(s, e) {
  if (typeof s == "string") {
    const t = parseFloat(s);
    isNaN(t) || (s = t);
  }
  return typeof s == "string" || typeof s == "number" ? e(s) : rn.INSTANCE;
}
class fb {
  static create(e, t, i = null) {
    return ub(t, (n) => new fb(e, n, i));
  }
  constructor(e, t, i) {
    this.key = e, this.value = t, this.negated = i, this.type = 12;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : Mc(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return typeof this.value == "string" ? !1 : parseFloat(e.getValue(this.key)) > this.value;
  }
  serialize() {
    return `${this.key} > ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = pb.create(this.key, this.value, this)), this.negated;
  }
}
class gb {
  static create(e, t, i = null) {
    return ub(t, (n) => new gb(e, n, i));
  }
  constructor(e, t, i) {
    this.key = e, this.value = t, this.negated = i, this.type = 13;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : Mc(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return typeof this.value == "string" ? !1 : parseFloat(e.getValue(this.key)) >= this.value;
  }
  serialize() {
    return `${this.key} >= ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = mb.create(this.key, this.value, this)), this.negated;
  }
}
class mb {
  static create(e, t, i = null) {
    return ub(t, (n) => new mb(e, n, i));
  }
  constructor(e, t, i) {
    this.key = e, this.value = t, this.negated = i, this.type = 14;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : Mc(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return typeof this.value == "string" ? !1 : parseFloat(e.getValue(this.key)) < this.value;
  }
  serialize() {
    return `${this.key} < ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = gb.create(this.key, this.value, this)), this.negated;
  }
}
class pb {
  static create(e, t, i = null) {
    return ub(t, (n) => new pb(e, n, i));
  }
  constructor(e, t, i) {
    this.key = e, this.value = t, this.negated = i, this.type = 15;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : Mc(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return typeof this.value == "string" ? !1 : parseFloat(e.getValue(this.key)) <= this.value;
  }
  serialize() {
    return `${this.key} <= ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = fb.create(this.key, this.value, this)), this.negated;
  }
}
class Wf {
  static create(e, t) {
    return new Wf(e, t);
  }
  constructor(e, t) {
    this.key = e, this.regexp = t, this.type = 7, this.negated = null;
  }
  cmp(e) {
    if (e.type !== this.type)
      return this.type - e.type;
    if (this.key < e.key)
      return -1;
    if (this.key > e.key)
      return 1;
    const t = this.regexp ? this.regexp.source : "", i = e.regexp ? e.regexp.source : "";
    return t < i ? -1 : t > i ? 1 : 0;
  }
  equals(e) {
    if (e.type === this.type) {
      const t = this.regexp ? this.regexp.source : "", i = e.regexp ? e.regexp.source : "";
      return this.key === e.key && t === i;
    }
    return !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    const t = e.getValue(this.key);
    return this.regexp ? this.regexp.test(t) : !1;
  }
  serialize() {
    const e = this.regexp ? `/${this.regexp.source}/${this.regexp.flags}` : "/invalid/";
    return `${this.key} =~ ${e}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = qL.create(this)), this.negated;
  }
}
class qL {
  static create(e) {
    return new qL(e);
  }
  constructor(e) {
    this._actual = e, this.type = 8;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : this._actual.cmp(e._actual);
  }
  equals(e) {
    return e.type === this.type ? this._actual.equals(e._actual) : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return !this._actual.evaluate(e);
  }
  serialize() {
    return `!(${this._actual.serialize()})`;
  }
  keys() {
    return this._actual.keys();
  }
  negate() {
    return this._actual;
  }
}
function IM(s) {
  let e = null;
  for (let t = 0, i = s.length; t < i; t++) {
    const n = s[t].substituteConstants();
    if (s[t] !== n && e === null) {
      e = [];
      for (let o = 0; o < t; o++)
        e[o] = s[o];
    }
    e !== null && (e[t] = n);
  }
  return e === null ? s : e;
}
class zl {
  static create(e, t, i) {
    return zl._normalizeArr(e, t, i);
  }
  constructor(e, t) {
    this.expr = e, this.negated = t, this.type = 6;
  }
  cmp(e) {
    if (e.type !== this.type)
      return this.type - e.type;
    if (this.expr.length < e.expr.length)
      return -1;
    if (this.expr.length > e.expr.length)
      return 1;
    for (let t = 0, i = this.expr.length; t < i; t++) {
      const n = Vu(this.expr[t], e.expr[t]);
      if (n !== 0)
        return n;
    }
    return 0;
  }
  equals(e) {
    if (e.type === this.type) {
      if (this.expr.length !== e.expr.length)
        return !1;
      for (let t = 0, i = this.expr.length; t < i; t++)
        if (!this.expr[t].equals(e.expr[t]))
          return !1;
      return !0;
    }
    return !1;
  }
  substituteConstants() {
    const e = IM(this.expr);
    return e === this.expr ? this : zl.create(e, this.negated, !1);
  }
  evaluate(e) {
    for (let t = 0, i = this.expr.length; t < i; t++)
      if (!this.expr[t].evaluate(e))
        return !1;
    return !0;
  }
  static _normalizeArr(e, t, i) {
    const n = [];
    let o = !1;
    for (const r of e)
      if (r) {
        if (r.type === 1) {
          o = !0;
          continue;
        }
        if (r.type === 0)
          return rn.INSTANCE;
        if (r.type === 6) {
          n.push(...r.expr);
          continue;
        }
        n.push(r);
      }
    if (n.length === 0 && o)
      return vn.INSTANCE;
    if (n.length !== 0) {
      if (n.length === 1)
        return n[0];
      n.sort(Vu);
      for (let r = 1; r < n.length; r++)
        n[r - 1].equals(n[r]) && (n.splice(r, 1), r--);
      if (n.length === 1)
        return n[0];
      for (; n.length > 1; ) {
        const r = n[n.length - 1];
        if (r.type !== 9)
          break;
        n.pop();
        const a = n.pop(), l = n.length === 0, c = xr.create(r.expr.map((h) => zl.create([h, a], null, i)), null, l);
        c && (n.push(c), n.sort(Vu));
      }
      if (n.length === 1)
        return n[0];
      if (i) {
        for (let r = 0; r < n.length; r++)
          for (let a = r + 1; a < n.length; a++)
            if (n[r].negate().equals(n[a]))
              return rn.INSTANCE;
        if (n.length === 1)
          return n[0];
      }
      return new zl(n, t);
    }
  }
  serialize() {
    return this.expr.map((e) => e.serialize()).join(" && ");
  }
  keys() {
    const e = [];
    for (const t of this.expr)
      e.push(...t.keys());
    return e;
  }
  negate() {
    if (!this.negated) {
      const e = [];
      for (const t of this.expr)
        e.push(t.negate());
      this.negated = xr.create(e, this, !0);
    }
    return this.negated;
  }
}
class xr {
  static create(e, t, i) {
    return xr._normalizeArr(e, t, i);
  }
  constructor(e, t) {
    this.expr = e, this.negated = t, this.type = 9;
  }
  cmp(e) {
    if (e.type !== this.type)
      return this.type - e.type;
    if (this.expr.length < e.expr.length)
      return -1;
    if (this.expr.length > e.expr.length)
      return 1;
    for (let t = 0, i = this.expr.length; t < i; t++) {
      const n = Vu(this.expr[t], e.expr[t]);
      if (n !== 0)
        return n;
    }
    return 0;
  }
  equals(e) {
    if (e.type === this.type) {
      if (this.expr.length !== e.expr.length)
        return !1;
      for (let t = 0, i = this.expr.length; t < i; t++)
        if (!this.expr[t].equals(e.expr[t]))
          return !1;
      return !0;
    }
    return !1;
  }
  substituteConstants() {
    const e = IM(this.expr);
    return e === this.expr ? this : xr.create(e, this.negated, !1);
  }
  evaluate(e) {
    for (let t = 0, i = this.expr.length; t < i; t++)
      if (this.expr[t].evaluate(e))
        return !0;
    return !1;
  }
  static _normalizeArr(e, t, i) {
    let n = [], o = !1;
    if (e) {
      for (let r = 0, a = e.length; r < a; r++) {
        const l = e[r];
        if (l) {
          if (l.type === 0) {
            o = !0;
            continue;
          }
          if (l.type === 1)
            return vn.INSTANCE;
          if (l.type === 9) {
            n = n.concat(l.expr);
            continue;
          }
          n.push(l);
        }
      }
      if (n.length === 0 && o)
        return rn.INSTANCE;
      n.sort(Vu);
    }
    if (n.length !== 0) {
      if (n.length === 1)
        return n[0];
      for (let r = 1; r < n.length; r++)
        n[r - 1].equals(n[r]) && (n.splice(r, 1), r--);
      if (n.length === 1)
        return n[0];
      if (i) {
        for (let r = 0; r < n.length; r++)
          for (let a = r + 1; a < n.length; a++)
            if (n[r].negate().equals(n[a]))
              return vn.INSTANCE;
        if (n.length === 1)
          return n[0];
      }
      return new xr(n, t);
    }
  }
  serialize() {
    return this.expr.map((e) => e.serialize()).join(" || ");
  }
  keys() {
    const e = [];
    for (const t of this.expr)
      e.push(...t.keys());
    return e;
  }
  negate() {
    if (!this.negated) {
      const e = [];
      for (const t of this.expr)
        e.push(t.negate());
      for (; e.length > 1; ) {
        const t = e.shift(), i = e.shift(), n = [];
        for (const o of zD(t))
          for (const r of zD(i))
            n.push(zl.create([o, r], null, !1));
        e.unshift(xr.create(n, null, !1));
      }
      this.negated = xr.create(e, this, !0);
    }
    return this.negated;
  }
}
const Rh = class Rh extends Nc {
  static all() {
    return Rh._info.values();
  }
  constructor(e, t, i) {
    super(e, null), this._defaultValue = t, typeof i == "object" ? Rh._info.push({ ...i, key: e }) : i !== !0 && Rh._info.push({ key: e, description: i, type: t != null ? typeof t : void 0 });
  }
  bindTo(e) {
    return e.createKey(this.key, this._defaultValue);
  }
  getValue(e) {
    return e.getContextKeyValue(this.key);
  }
  toNegated() {
    return this.negate();
  }
  isEqualTo(e) {
    return xg.create(this.key, e);
  }
};
Rh._info = [];
let de = Rh;
const nt = Ve("contextKeyService");
function NM(s, e) {
  return s < e ? -1 : s > e ? 1 : 0;
}
function Mc(s, e, t, i) {
  return s < t ? -1 : s > t ? 1 : e < i ? -1 : e > i ? 1 : 0;
}
function nv(s, e) {
  if (s.type === 0 || e.type === 1)
    return !0;
  if (s.type === 9)
    return e.type === 9 ? HD(s.expr, e.expr) : !1;
  if (e.type === 9) {
    for (const t of e.expr)
      if (nv(s, t))
        return !0;
    return !1;
  }
  if (s.type === 6) {
    if (e.type === 6)
      return HD(e.expr, s.expr);
    for (const t of s.expr)
      if (nv(t, e))
        return !0;
    return !1;
  }
  return s.equals(e);
}
function HD(s, e) {
  let t = 0, i = 0;
  for (; t < s.length && i < e.length; ) {
    const n = s[t].cmp(e[i]);
    if (n < 0)
      return !1;
    n === 0 && t++, i++;
  }
  return t === s.length;
}
function zD(s) {
  return s.type === 9 ? s.expr : [s];
}
function L0(s, e) {
  if (!s)
    throw new Error(e ? `Assertion failed (${e})` : "Assertion Failed");
}
function jL(s, e = "Unreachable") {
  throw new Error(e);
}
function UD(s) {
  s || ht(new it("Soft Assertion Failed"));
}
function bc(s) {
  if (!s()) {
    debugger;
    s(), ht(new it("Assertion Failed"));
  }
}
function GL(s, e) {
  let t = 0;
  for (; t < s.length - 1; ) {
    const i = s[t], n = s[t + 1];
    if (!e(i, n))
      return !1;
    t++;
  }
  return !0;
}
class H7 {
  constructor() {
    this.data = /* @__PURE__ */ new Map();
  }
  add(e, t) {
    L0(Jn(e)), L0(_n(t)), L0(!this.data.has(e), "There is already an extension with this id"), this.data.set(e, t);
  }
  as(e) {
    return this.data.get(e) || null;
  }
}
const Li = new H7();
class ZL {
  constructor() {
    this._coreKeybindings = new An(), this._extensionKeybindings = [], this._cachedMergedKeybindings = null;
  }
  /**
   * Take current platform into account and reduce to primary & secondary.
   */
  static bindToCurrentPlatform(e) {
    if (Es === 1) {
      if (e && e.win)
        return e.win;
    } else if (Es === 2) {
      if (e && e.mac)
        return e.mac;
    } else if (e && e.linux)
      return e.linux;
    return e;
  }
  registerKeybindingRule(e) {
    const t = ZL.bindToCurrentPlatform(e), i = new he();
    if (t && t.primary) {
      const n = Vw(t.primary, Es);
      n && i.add(this._registerDefaultKeybinding(n, e.id, e.args, e.weight, 0, e.when));
    }
    if (t && Array.isArray(t.secondary))
      for (let n = 0, o = t.secondary.length; n < o; n++) {
        const r = t.secondary[n], a = Vw(r, Es);
        a && i.add(this._registerDefaultKeybinding(a, e.id, e.args, e.weight, -n - 1, e.when));
      }
    return i;
  }
  registerCommandAndKeybindingRule(e) {
    return Wo(this.registerKeybindingRule(e), Sn.registerCommand(e));
  }
  _registerDefaultKeybinding(e, t, i, n, o, r) {
    const a = this._coreKeybindings.push({
      keybinding: e,
      command: t,
      commandArgs: i,
      when: r,
      weight1: n,
      weight2: o,
      extensionId: null,
      isBuiltinExtension: !1
    });
    return this._cachedMergedKeybindings = null, ke(() => {
      a(), this._cachedMergedKeybindings = null;
    });
  }
  getDefaultKeybindings() {
    return this._cachedMergedKeybindings || (this._cachedMergedKeybindings = Array.from(this._coreKeybindings).concat(this._extensionKeybindings), this._cachedMergedKeybindings.sort(U7)), this._cachedMergedKeybindings.slice(0);
  }
}
const Dg = new ZL(), z7 = {
  EditorModes: "platform.keybindingsRegistry"
};
Li.add(z7.EditorModes, Dg);
function U7(s, e) {
  if (s.weight1 !== e.weight1)
    return s.weight1 - e.weight1;
  if (s.command && e.command) {
    if (s.command < e.command)
      return -1;
    if (s.command > e.command)
      return 1;
  }
  return s.weight2 - e.weight2;
}
var $7 = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, $D = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, qm;
function Hu(s) {
  return s.command !== void 0;
}
function K7(s) {
  return s.submenu !== void 0;
}
const x = class x {
  /**
   * Create a new `MenuId` with the unique identifier. Will throw if a menu
   * with the identifier already exists, use `MenuId.for(ident)` or a unique
   * identifier
   */
  constructor(e) {
    if (x._instances.has(e))
      throw new TypeError(`MenuId with identifier '${e}' already exists. Use MenuId.for(ident) or a unique identifier`);
    x._instances.set(e, this), this.id = e;
  }
};
x._instances = /* @__PURE__ */ new Map(), x.CommandPalette = new x("CommandPalette"), x.DebugBreakpointsContext = new x("DebugBreakpointsContext"), x.DebugCallStackContext = new x("DebugCallStackContext"), x.DebugConsoleContext = new x("DebugConsoleContext"), x.DebugVariablesContext = new x("DebugVariablesContext"), x.NotebookVariablesContext = new x("NotebookVariablesContext"), x.DebugHoverContext = new x("DebugHoverContext"), x.DebugWatchContext = new x("DebugWatchContext"), x.DebugToolBar = new x("DebugToolBar"), x.DebugToolBarStop = new x("DebugToolBarStop"), x.DebugCallStackToolbar = new x("DebugCallStackToolbar"), x.DebugCreateConfiguration = new x("DebugCreateConfiguration"), x.EditorContext = new x("EditorContext"), x.SimpleEditorContext = new x("SimpleEditorContext"), x.EditorContent = new x("EditorContent"), x.EditorLineNumberContext = new x("EditorLineNumberContext"), x.EditorContextCopy = new x("EditorContextCopy"), x.EditorContextPeek = new x("EditorContextPeek"), x.EditorContextShare = new x("EditorContextShare"), x.EditorTitle = new x("EditorTitle"), x.EditorTitleRun = new x("EditorTitleRun"), x.EditorTitleContext = new x("EditorTitleContext"), x.EditorTitleContextShare = new x("EditorTitleContextShare"), x.EmptyEditorGroup = new x("EmptyEditorGroup"), x.EmptyEditorGroupContext = new x("EmptyEditorGroupContext"), x.EditorTabsBarContext = new x("EditorTabsBarContext"), x.EditorTabsBarShowTabsSubmenu = new x("EditorTabsBarShowTabsSubmenu"), x.EditorTabsBarShowTabsZenModeSubmenu = new x("EditorTabsBarShowTabsZenModeSubmenu"), x.EditorActionsPositionSubmenu = new x("EditorActionsPositionSubmenu"), x.ExplorerContext = new x("ExplorerContext"), x.ExplorerContextShare = new x("ExplorerContextShare"), x.ExtensionContext = new x("ExtensionContext"), x.GlobalActivity = new x("GlobalActivity"), x.CommandCenter = new x("CommandCenter"), x.CommandCenterCenter = new x("CommandCenterCenter"), x.LayoutControlMenuSubmenu = new x("LayoutControlMenuSubmenu"), x.LayoutControlMenu = new x("LayoutControlMenu"), x.MenubarMainMenu = new x("MenubarMainMenu"), x.MenubarAppearanceMenu = new x("MenubarAppearanceMenu"), x.MenubarDebugMenu = new x("MenubarDebugMenu"), x.MenubarEditMenu = new x("MenubarEditMenu"), x.MenubarCopy = new x("MenubarCopy"), x.MenubarFileMenu = new x("MenubarFileMenu"), x.MenubarGoMenu = new x("MenubarGoMenu"), x.MenubarHelpMenu = new x("MenubarHelpMenu"), x.MenubarLayoutMenu = new x("MenubarLayoutMenu"), x.MenubarNewBreakpointMenu = new x("MenubarNewBreakpointMenu"), x.PanelAlignmentMenu = new x("PanelAlignmentMenu"), x.PanelPositionMenu = new x("PanelPositionMenu"), x.ActivityBarPositionMenu = new x("ActivityBarPositionMenu"), x.MenubarPreferencesMenu = new x("MenubarPreferencesMenu"), x.MenubarRecentMenu = new x("MenubarRecentMenu"), x.MenubarSelectionMenu = new x("MenubarSelectionMenu"), x.MenubarShare = new x("MenubarShare"), x.MenubarSwitchEditorMenu = new x("MenubarSwitchEditorMenu"), x.MenubarSwitchGroupMenu = new x("MenubarSwitchGroupMenu"), x.MenubarTerminalMenu = new x("MenubarTerminalMenu"), x.MenubarViewMenu = new x("MenubarViewMenu"), x.MenubarHomeMenu = new x("MenubarHomeMenu"), x.OpenEditorsContext = new x("OpenEditorsContext"), x.OpenEditorsContextShare = new x("OpenEditorsContextShare"), x.ProblemsPanelContext = new x("ProblemsPanelContext"), x.SCMInputBox = new x("SCMInputBox"), x.SCMChangesSeparator = new x("SCMChangesSeparator"), x.SCMChangesContext = new x("SCMChangesContext"), x.SCMIncomingChanges = new x("SCMIncomingChanges"), x.SCMIncomingChangesContext = new x("SCMIncomingChangesContext"), x.SCMIncomingChangesSetting = new x("SCMIncomingChangesSetting"), x.SCMOutgoingChanges = new x("SCMOutgoingChanges"), x.SCMOutgoingChangesContext = new x("SCMOutgoingChangesContext"), x.SCMOutgoingChangesSetting = new x("SCMOutgoingChangesSetting"), x.SCMIncomingChangesAllChangesContext = new x("SCMIncomingChangesAllChangesContext"), x.SCMIncomingChangesHistoryItemContext = new x("SCMIncomingChangesHistoryItemContext"), x.SCMOutgoingChangesAllChangesContext = new x("SCMOutgoingChangesAllChangesContext"), x.SCMOutgoingChangesHistoryItemContext = new x("SCMOutgoingChangesHistoryItemContext"), x.SCMChangeContext = new x("SCMChangeContext"), x.SCMResourceContext = new x("SCMResourceContext"), x.SCMResourceContextShare = new x("SCMResourceContextShare"), x.SCMResourceFolderContext = new x("SCMResourceFolderContext"), x.SCMResourceGroupContext = new x("SCMResourceGroupContext"), x.SCMSourceControl = new x("SCMSourceControl"), x.SCMSourceControlInline = new x("SCMSourceControlInline"), x.SCMSourceControlTitle = new x("SCMSourceControlTitle"), x.SCMHistoryTitle = new x("SCMHistoryTitle"), x.SCMTitle = new x("SCMTitle"), x.SearchContext = new x("SearchContext"), x.SearchActionMenu = new x("SearchActionContext"), x.StatusBarWindowIndicatorMenu = new x("StatusBarWindowIndicatorMenu"), x.StatusBarRemoteIndicatorMenu = new x("StatusBarRemoteIndicatorMenu"), x.StickyScrollContext = new x("StickyScrollContext"), x.TestItem = new x("TestItem"), x.TestItemGutter = new x("TestItemGutter"), x.TestProfilesContext = new x("TestProfilesContext"), x.TestMessageContext = new x("TestMessageContext"), x.TestMessageContent = new x("TestMessageContent"), x.TestPeekElement = new x("TestPeekElement"), x.TestPeekTitle = new x("TestPeekTitle"), x.TestCallStack = new x("TestCallStack"), x.TouchBarContext = new x("TouchBarContext"), x.TitleBarContext = new x("TitleBarContext"), x.TitleBarTitleContext = new x("TitleBarTitleContext"), x.TunnelContext = new x("TunnelContext"), x.TunnelPrivacy = new x("TunnelPrivacy"), x.TunnelProtocol = new x("TunnelProtocol"), x.TunnelPortInline = new x("TunnelInline"), x.TunnelTitle = new x("TunnelTitle"), x.TunnelLocalAddressInline = new x("TunnelLocalAddressInline"), x.TunnelOriginInline = new x("TunnelOriginInline"), x.ViewItemContext = new x("ViewItemContext"), x.ViewContainerTitle = new x("ViewContainerTitle"), x.ViewContainerTitleContext = new x("ViewContainerTitleContext"), x.ViewTitle = new x("ViewTitle"), x.ViewTitleContext = new x("ViewTitleContext"), x.CommentEditorActions = new x("CommentEditorActions"), x.CommentThreadTitle = new x("CommentThreadTitle"), x.CommentThreadActions = new x("CommentThreadActions"), x.CommentThreadAdditionalActions = new x("CommentThreadAdditionalActions"), x.CommentThreadTitleContext = new x("CommentThreadTitleContext"), x.CommentThreadCommentContext = new x("CommentThreadCommentContext"), x.CommentTitle = new x("CommentTitle"), x.CommentActions = new x("CommentActions"), x.CommentsViewThreadActions = new x("CommentsViewThreadActions"), x.InteractiveToolbar = new x("InteractiveToolbar"), x.InteractiveCellTitle = new x("InteractiveCellTitle"), x.InteractiveCellDelete = new x("InteractiveCellDelete"), x.InteractiveCellExecute = new x("InteractiveCellExecute"), x.InteractiveInputExecute = new x("InteractiveInputExecute"), x.InteractiveInputConfig = new x("InteractiveInputConfig"), x.ReplInputExecute = new x("ReplInputExecute"), x.IssueReporter = new x("IssueReporter"), x.NotebookToolbar = new x("NotebookToolbar"), x.NotebookStickyScrollContext = new x("NotebookStickyScrollContext"), x.NotebookCellTitle = new x("NotebookCellTitle"), x.NotebookCellDelete = new x("NotebookCellDelete"), x.NotebookCellInsert = new x("NotebookCellInsert"), x.NotebookCellBetween = new x("NotebookCellBetween"), x.NotebookCellListTop = new x("NotebookCellTop"), x.NotebookCellExecute = new x("NotebookCellExecute"), x.NotebookCellExecuteGoTo = new x("NotebookCellExecuteGoTo"), x.NotebookCellExecutePrimary = new x("NotebookCellExecutePrimary"), x.NotebookDiffCellInputTitle = new x("NotebookDiffCellInputTitle"), x.NotebookDiffCellMetadataTitle = new x("NotebookDiffCellMetadataTitle"), x.NotebookDiffCellOutputsTitle = new x("NotebookDiffCellOutputsTitle"), x.NotebookOutputToolbar = new x("NotebookOutputToolbar"), x.NotebookOutlineFilter = new x("NotebookOutlineFilter"), x.NotebookOutlineActionMenu = new x("NotebookOutlineActionMenu"), x.NotebookEditorLayoutConfigure = new x("NotebookEditorLayoutConfigure"), x.NotebookKernelSource = new x("NotebookKernelSource"), x.BulkEditTitle = new x("BulkEditTitle"), x.BulkEditContext = new x("BulkEditContext"), x.TimelineItemContext = new x("TimelineItemContext"), x.TimelineTitle = new x("TimelineTitle"), x.TimelineTitleContext = new x("TimelineTitleContext"), x.TimelineFilterSubMenu = new x("TimelineFilterSubMenu"), x.AccountsContext = new x("AccountsContext"), x.SidebarTitle = new x("SidebarTitle"), x.PanelTitle = new x("PanelTitle"), x.AuxiliaryBarTitle = new x("AuxiliaryBarTitle"), x.AuxiliaryBarHeader = new x("AuxiliaryBarHeader"), x.TerminalInstanceContext = new x("TerminalInstanceContext"), x.TerminalEditorInstanceContext = new x("TerminalEditorInstanceContext"), x.TerminalNewDropdownContext = new x("TerminalNewDropdownContext"), x.TerminalTabContext = new x("TerminalTabContext"), x.TerminalTabEmptyAreaContext = new x("TerminalTabEmptyAreaContext"), x.TerminalStickyScrollContext = new x("TerminalStickyScrollContext"), x.WebviewContext = new x("WebviewContext"), x.InlineCompletionsActions = new x("InlineCompletionsActions"), x.InlineEditsActions = new x("InlineEditsActions"), x.InlineEditActions = new x("InlineEditActions"), x.NewFile = new x("NewFile"), x.MergeInput1Toolbar = new x("MergeToolbar1Toolbar"), x.MergeInput2Toolbar = new x("MergeToolbar2Toolbar"), x.MergeBaseToolbar = new x("MergeBaseToolbar"), x.MergeInputResultToolbar = new x("MergeToolbarResultToolbar"), x.InlineSuggestionToolbar = new x("InlineSuggestionToolbar"), x.InlineEditToolbar = new x("InlineEditToolbar"), x.ChatContext = new x("ChatContext"), x.ChatCodeBlock = new x("ChatCodeblock"), x.ChatCompareBlock = new x("ChatCompareBlock"), x.ChatMessageTitle = new x("ChatMessageTitle"), x.ChatExecute = new x("ChatExecute"), x.ChatExecuteSecondary = new x("ChatExecuteSecondary"), x.ChatInputSide = new x("ChatInputSide"), x.AccessibleView = new x("AccessibleView"), x.MultiDiffEditorFileToolbar = new x("MultiDiffEditorFileToolbar"), x.DiffEditorHunkToolbar = new x("DiffEditorHunkToolbar"), x.DiffEditorSelectionToolbar = new x("DiffEditorSelectionToolbar");
let Ti = x;
const Rc = Ve("menuService"), _f = class _f {
  static for(e) {
    let t = this._all.get(e);
    return t || (t = new _f(e), this._all.set(e, t)), t;
  }
  static merge(e) {
    const t = /* @__PURE__ */ new Set();
    for (const i of e)
      i instanceof _f && t.add(i.id);
    return t;
  }
  constructor(e) {
    this.id = e, this.has = (t) => t === e;
  }
};
_f._all = /* @__PURE__ */ new Map();
let Sl = _f;
const Cd = new class {
  constructor() {
    this._commands = /* @__PURE__ */ new Map(), this._menuItems = /* @__PURE__ */ new Map(), this._onDidChangeMenu = new dO({
      merge: Sl.merge
    }), this.onDidChangeMenu = this._onDidChangeMenu.event;
  }
  addCommand(s) {
    return this._commands.set(s.id, s), this._onDidChangeMenu.fire(Sl.for(Ti.CommandPalette)), ke(() => {
      this._commands.delete(s.id) && this._onDidChangeMenu.fire(Sl.for(Ti.CommandPalette));
    });
  }
  getCommand(s) {
    return this._commands.get(s);
  }
  getCommands() {
    const s = /* @__PURE__ */ new Map();
    return this._commands.forEach((e, t) => s.set(t, e)), s;
  }
  appendMenuItem(s, e) {
    let t = this._menuItems.get(s);
    t || (t = new An(), this._menuItems.set(s, t));
    const i = t.push(e);
    return this._onDidChangeMenu.fire(Sl.for(s)), ke(() => {
      i(), this._onDidChangeMenu.fire(Sl.for(s));
    });
  }
  appendMenuItems(s) {
    const e = new he();
    for (const { id: t, item: i } of s)
      e.add(this.appendMenuItem(t, i));
    return e;
  }
  getMenuItems(s) {
    let e;
    return this._menuItems.has(s) ? e = [...this._menuItems.get(s)] : e = [], s === Ti.CommandPalette && this._appendImplicitItems(e), e;
  }
  _appendImplicitItems(s) {
    const e = /* @__PURE__ */ new Set();
    for (const t of s)
      Hu(t) && (e.add(t.command.id), t.alt && e.add(t.alt.id));
    this._commands.forEach((t, i) => {
      e.has(i) || s.push({ command: t });
    });
  }
}();
class zu extends lb {
  constructor(e, t, i) {
    super(`submenuitem.${e.submenu.id}`, typeof e.title == "string" ? e.title : e.title.value, i, "submenu"), this.item = e, this.hideActions = t;
  }
}
let Ur = qm = class {
  static label(e, t) {
    return t != null && t.renderShortTitle && e.shortTitle ? typeof e.shortTitle == "string" ? e.shortTitle : e.shortTitle.value : typeof e.title == "string" ? e.title : e.title.value;
  }
  constructor(e, t, i, n, o, r, a) {
    var c;
    this.hideActions = n, this.menuKeybinding = o, this._commandService = a, this.id = e.id, this.label = qm.label(e, i), this.tooltip = (typeof e.tooltip == "string" ? e.tooltip : (c = e.tooltip) == null ? void 0 : c.value) ?? "", this.enabled = !e.precondition || r.contextMatchesRules(e.precondition), this.checked = void 0;
    let l;
    if (e.toggled) {
      const h = e.toggled.condition ? e.toggled : { condition: e.toggled };
      this.checked = r.contextMatchesRules(h.condition), this.checked && h.tooltip && (this.tooltip = typeof h.tooltip == "string" ? h.tooltip : h.tooltip.value), this.checked && Ke.isThemeIcon(h.icon) && (l = h.icon), this.checked && h.title && (this.label = typeof h.title == "string" ? h.title : h.title.value);
    }
    l || (l = Ke.isThemeIcon(e.icon) ? e.icon : void 0), this.item = e, this.alt = t ? new qm(t, void 0, i, n, void 0, r, a) : void 0, this._options = i, this.class = l && Ke.asClassName(l);
  }
  run(...e) {
    var i, n;
    let t = [];
    return (i = this._options) != null && i.arg && (t = [...t, this._options.arg]), (n = this._options) != null && n.shouldForwardArgs && (t = [...t, ...e]), this._commandService.executeCommand(this.id, ...t);
  }
};
Ur = qm = $7([
  $D(5, nt),
  $D(6, ss)
], Ur);
const Ac = Ve("telemetryService"), uo = Ve("logService");
var mn;
(function(s) {
  s[s.Off = 0] = "Off", s[s.Trace = 1] = "Trace", s[s.Debug = 2] = "Debug", s[s.Info = 3] = "Info", s[s.Warning = 4] = "Warning", s[s.Error = 5] = "Error";
})(mn || (mn = {}));
const TM = mn.Info;
class MM extends q {
  constructor() {
    super(...arguments), this.level = TM, this._onDidChangeLogLevel = this._register(new O()), this.onDidChangeLogLevel = this._onDidChangeLogLevel.event;
  }
  setLevel(e) {
    this.level !== e && (this.level = e, this._onDidChangeLogLevel.fire(this.level));
  }
  getLevel() {
    return this.level;
  }
  checkLogLevel(e) {
    return this.level !== mn.Off && this.level <= e;
  }
}
class q7 extends MM {
  constructor(e = TM, t = !0) {
    super(), this.useColors = t, this.setLevel(e);
  }
  trace(e, ...t) {
    this.checkLogLevel(mn.Trace) && (this.useColors ? console.log("%cTRACE", "color: #888", e, ...t) : console.log(e, ...t));
  }
  debug(e, ...t) {
    this.checkLogLevel(mn.Debug) && (this.useColors ? console.log("%cDEBUG", "background: #eee; color: #888", e, ...t) : console.log(e, ...t));
  }
  info(e, ...t) {
    this.checkLogLevel(mn.Info) && (this.useColors ? console.log("%c INFO", "color: #33f", e, ...t) : console.log(e, ...t));
  }
  warn(e, ...t) {
    this.checkLogLevel(mn.Warning) && (this.useColors ? console.log("%c WARN", "color: #993", e, ...t) : console.log(e, ...t));
  }
  error(e, ...t) {
    this.checkLogLevel(mn.Error) && (this.useColors ? console.log("%c  ERR", "color: #f33", e, ...t) : console.error(e, ...t));
  }
}
class j7 extends MM {
  constructor(e) {
    super(), this.loggers = e, e.length && this.setLevel(e[0].getLevel());
  }
  setLevel(e) {
    for (const t of this.loggers)
      t.setLevel(e);
    super.setLevel(e);
  }
  trace(e, ...t) {
    for (const i of this.loggers)
      i.trace(e, ...t);
  }
  debug(e, ...t) {
    for (const i of this.loggers)
      i.debug(e, ...t);
  }
  info(e, ...t) {
    for (const i of this.loggers)
      i.info(e, ...t);
  }
  warn(e, ...t) {
    for (const i of this.loggers)
      i.warn(e, ...t);
  }
  error(e, ...t) {
    for (const i of this.loggers)
      i.error(e, ...t);
  }
  dispose() {
    for (const e of this.loggers)
      e.dispose();
    super.dispose();
  }
}
function G7(s) {
  switch (s) {
    case mn.Trace:
      return "trace";
    case mn.Debug:
      return "debug";
    case mn.Info:
      return "info";
    case mn.Warning:
      return "warn";
    case mn.Error:
      return "error";
    case mn.Off:
      return "off";
  }
}
new de("logLevel", G7(mn.Info));
class _b {
  constructor(e) {
    this.id = e.id, this.precondition = e.precondition, this._kbOpts = e.kbOpts, this._menuOpts = e.menuOpts, this.metadata = e.metadata;
  }
  register() {
    if (Array.isArray(this._menuOpts) ? this._menuOpts.forEach(this._registerMenuItem, this) : this._menuOpts && this._registerMenuItem(this._menuOpts), this._kbOpts) {
      const e = Array.isArray(this._kbOpts) ? this._kbOpts : [this._kbOpts];
      for (const t of e) {
        let i = t.kbExpr;
        this.precondition && (i ? i = et.and(i, this.precondition) : i = this.precondition);
        const n = {
          id: this.id,
          weight: t.weight,
          args: t.args,
          when: i,
          primary: t.primary,
          secondary: t.secondary,
          win: t.win,
          linux: t.linux,
          mac: t.mac
        };
        Dg.registerKeybindingRule(n);
      }
    }
    Sn.registerCommand({
      id: this.id,
      handler: (e, t) => this.runCommand(e, t),
      metadata: this.metadata
    });
  }
  _registerMenuItem(e) {
    Cd.appendMenuItem(e.menuId, {
      group: e.group,
      command: {
        id: this.id,
        title: e.title,
        icon: e.icon,
        precondition: this.precondition
      },
      when: e.when,
      order: e.order
    });
  }
}
class YL extends _b {
  constructor() {
    super(...arguments), this._implementations = [];
  }
  /**
   * A higher priority gets to be looked at first
   */
  addImplementation(e, t, i, n) {
    return this._implementations.push({ priority: e, name: t, implementation: i, when: n }), this._implementations.sort((o, r) => r.priority - o.priority), {
      dispose: () => {
        for (let o = 0; o < this._implementations.length; o++)
          if (this._implementations[o].implementation === i) {
            this._implementations.splice(o, 1);
            return;
          }
      }
    };
  }
  runCommand(e, t) {
    const i = e.get(uo), n = e.get(nt);
    i.trace(`Executing Command '${this.id}' which has ${this._implementations.length} bound.`);
    for (const o of this._implementations) {
      if (o.when) {
        const a = n.getContext(Gi());
        if (!o.when.evaluate(a))
          continue;
      }
      const r = o.implementation(e, t);
      if (r)
        return i.trace(`Command '${this.id}' was handled by '${o.name}'.`), typeof r == "boolean" ? void 0 : r;
    }
    i.trace(`The Command '${this.id}' was not handled by any implementation.`);
  }
}
class RM extends _b {
  constructor(e, t) {
    super(t), this.command = e;
  }
  runCommand(e, t) {
    return this.command.runCommand(e, t);
  }
}
class Cc extends _b {
  /**
   * Create a command class that is bound to a certain editor contribution.
   */
  static bindToContribution(e) {
    return class extends Cc {
      constructor(i) {
        super(i), this._callback = i.handler;
      }
      runEditorCommand(i, n, o) {
        const r = e(n);
        r && this._callback(r, o);
      }
    };
  }
  static runEditorCommand(e, t, i, n) {
    const o = e.get(ri), r = o.getFocusedCodeEditor() || o.getActiveCodeEditor();
    if (r)
      return r.invokeWithinContext((a) => {
        if (a.get(nt).contextMatchesRules(i ?? void 0))
          return n(a, r, t);
      });
  }
  runCommand(e, t) {
    return Cc.runEditorCommand(e, t, this.precondition, (i, n, o) => this.runEditorCommand(i, n, o));
  }
}
function ye(s) {
  return Oo.INSTANCE.registerEditorCommand(s), s;
}
function AM(s, e, t) {
  Oo.INSTANCE.registerEditorContribution(s, e, t);
}
var Kh;
(function(s) {
  function e(r) {
    return Oo.INSTANCE.getEditorCommand(r);
  }
  s.getEditorCommand = e;
  function t() {
    return Oo.INSTANCE.getEditorActions();
  }
  s.getEditorActions = t;
  function i() {
    return Oo.INSTANCE.getEditorContributions();
  }
  s.getEditorContributions = i;
  function n(r) {
    return Oo.INSTANCE.getEditorContributions().filter((a) => r.indexOf(a.id) >= 0);
  }
  s.getSomeEditorContributions = n;
  function o() {
    return Oo.INSTANCE.getDiffEditorContributions();
  }
  s.getDiffEditorContributions = o;
})(Kh || (Kh = {}));
const Z7 = {
  EditorCommonContributions: "editor.contributions"
}, u1 = class u1 {
  constructor() {
    this.editorContributions = [], this.diffEditorContributions = [], this.editorActions = [], this.editorCommands = /* @__PURE__ */ Object.create(null);
  }
  registerEditorContribution(e, t, i) {
    this.editorContributions.push({ id: e, ctor: t, instantiation: i });
  }
  getEditorContributions() {
    return this.editorContributions.slice(0);
  }
  getDiffEditorContributions() {
    return this.diffEditorContributions.slice(0);
  }
  registerEditorAction(e) {
    e.register(), this.editorActions.push(e);
  }
  getEditorActions() {
    return this.editorActions;
  }
  registerEditorCommand(e) {
    e.register(), this.editorCommands[e.id] = e;
  }
  getEditorCommand(e) {
    return this.editorCommands[e] || null;
  }
};
u1.INSTANCE = new u1();
let Oo = u1;
Li.add(Z7.EditorCommonContributions, Oo.INSTANCE);
function Eg(s) {
  return s.register(), s;
}
const PM = Eg(new YL({
  id: "undo",
  precondition: void 0,
  kbOpts: {
    weight: 0,
    primary: 2104
    /* KeyCode.KeyZ */
  },
  menuOpts: [{
    menuId: Ti.MenubarEditMenu,
    group: "1_do",
    title: p({ key: "miUndo", comment: ["&& denotes a mnemonic"] }, "&&Undo"),
    order: 1
  }, {
    menuId: Ti.CommandPalette,
    group: "",
    title: p("undo", "Undo"),
    order: 1
  }]
}));
Eg(new RM(PM, { id: "default:undo", precondition: void 0 }));
const OM = Eg(new YL({
  id: "redo",
  precondition: void 0,
  kbOpts: {
    weight: 0,
    primary: 2103,
    secondary: [
      3128
      /* KeyCode.KeyZ */
    ],
    mac: {
      primary: 3128
      /* KeyCode.KeyZ */
    }
  },
  menuOpts: [{
    menuId: Ti.MenubarEditMenu,
    group: "1_do",
    title: p({ key: "miRedo", comment: ["&& denotes a mnemonic"] }, "&&Redo"),
    order: 2
  }, {
    menuId: Ti.CommandPalette,
    group: "",
    title: p("redo", "Redo"),
    order: 1
  }]
}));
Eg(new RM(OM, { id: "default:redo", precondition: void 0 }));
const Y7 = Eg(new YL({
  id: "editor.action.selectAll",
  precondition: void 0,
  kbOpts: {
    weight: 0,
    kbExpr: null,
    primary: 2079
    /* KeyCode.KeyA */
  },
  menuOpts: [{
    menuId: Ti.MenubarSelectionMenu,
    group: "1_basic",
    title: p({ key: "miSelectAll", comment: ["&& denotes a mnemonic"] }, "&&Select All"),
    order: 1
  }, {
    menuId: Ti.CommandPalette,
    group: "",
    title: p("selectAll", "Select All"),
    order: 1
  }]
})), KD = "default", Q7 = "$initialize";
let qD = !1;
function sv(s) {
  Fd && (qD || (qD = !0, console.warn("Could not create web worker(s). Falling back to loading web worker code in main thread, which might cause UI freezes. Please see https://github.com/microsoft/monaco-editor#faq")), console.warn(s.message));
}
class X7 {
  constructor(e, t, i, n, o) {
    this.vsWorker = e, this.req = t, this.channel = i, this.method = n, this.args = o, this.type = 0;
  }
}
class jD {
  constructor(e, t, i, n) {
    this.vsWorker = e, this.seq = t, this.res = i, this.err = n, this.type = 1;
  }
}
class J7 {
  constructor(e, t, i, n, o) {
    this.vsWorker = e, this.req = t, this.channel = i, this.eventName = n, this.arg = o, this.type = 2;
  }
}
class e3 {
  constructor(e, t, i) {
    this.vsWorker = e, this.req = t, this.event = i, this.type = 3;
  }
}
class t3 {
  constructor(e, t) {
    this.vsWorker = e, this.req = t, this.type = 4;
  }
}
class i3 {
  constructor(e) {
    this._workerId = -1, this._handler = e, this._lastSentReq = 0, this._pendingReplies = /* @__PURE__ */ Object.create(null), this._pendingEmitters = /* @__PURE__ */ new Map(), this._pendingEvents = /* @__PURE__ */ new Map();
  }
  setWorkerId(e) {
    this._workerId = e;
  }
  sendMessage(e, t, i) {
    const n = String(++this._lastSentReq);
    return new Promise((o, r) => {
      this._pendingReplies[n] = {
        resolve: o,
        reject: r
      }, this._send(new X7(this._workerId, n, e, t, i));
    });
  }
  listen(e, t, i) {
    let n = null;
    const o = new O({
      onWillAddFirstListener: () => {
        n = String(++this._lastSentReq), this._pendingEmitters.set(n, o), this._send(new J7(this._workerId, n, e, t, i));
      },
      onDidRemoveLastListener: () => {
        this._pendingEmitters.delete(n), this._send(new t3(this._workerId, n)), n = null;
      }
    });
    return o.event;
  }
  handleMessage(e) {
    !e || !e.vsWorker || this._workerId !== -1 && e.vsWorker !== this._workerId || this._handleMessage(e);
  }
  createProxyToRemoteChannel(e, t) {
    const i = {
      get: (n, o) => (typeof o == "string" && !n[o] && (BM(o) ? n[o] = (r) => this.listen(e, o, r) : FM(o) ? n[o] = this.listen(e, o, void 0) : o.charCodeAt(0) === 36 && (n[o] = async (...r) => (await (t == null ? void 0 : t()), this.sendMessage(e, o, r)))), n[o])
    };
    return new Proxy(/* @__PURE__ */ Object.create(null), i);
  }
  _handleMessage(e) {
    switch (e.type) {
      case 1:
        return this._handleReplyMessage(e);
      case 0:
        return this._handleRequestMessage(e);
      case 2:
        return this._handleSubscribeEventMessage(e);
      case 3:
        return this._handleEventMessage(e);
      case 4:
        return this._handleUnsubscribeEventMessage(e);
    }
  }
  _handleReplyMessage(e) {
    if (!this._pendingReplies[e.seq]) {
      console.warn("Got reply to unknown seq");
      return;
    }
    const t = this._pendingReplies[e.seq];
    if (delete this._pendingReplies[e.seq], e.err) {
      let i = e.err;
      e.err.$isError && (i = new Error(), i.name = e.err.name, i.message = e.err.message, i.stack = e.err.stack), t.reject(i);
      return;
    }
    t.resolve(e.res);
  }
  _handleRequestMessage(e) {
    const t = e.req;
    this._handler.handleMessage(e.channel, e.method, e.args).then((n) => {
      this._send(new jD(this._workerId, t, n, void 0));
    }, (n) => {
      n.detail instanceof Error && (n.detail = sD(n.detail)), this._send(new jD(this._workerId, t, void 0, sD(n)));
    });
  }
  _handleSubscribeEventMessage(e) {
    const t = e.req, i = this._handler.handleEvent(e.channel, e.eventName, e.arg)((n) => {
      this._send(new e3(this._workerId, t, n));
    });
    this._pendingEvents.set(t, i);
  }
  _handleEventMessage(e) {
    if (!this._pendingEmitters.has(e.req)) {
      console.warn("Got event for unknown req");
      return;
    }
    this._pendingEmitters.get(e.req).fire(e.event);
  }
  _handleUnsubscribeEventMessage(e) {
    if (!this._pendingEvents.has(e.req)) {
      console.warn("Got unsubscribe for unknown req");
      return;
    }
    this._pendingEvents.get(e.req).dispose(), this._pendingEvents.delete(e.req);
  }
  _send(e) {
    const t = [];
    if (e.type === 0)
      for (let i = 0; i < e.args.length; i++)
        e.args[i] instanceof ArrayBuffer && t.push(e.args[i]);
    else e.type === 1 && e.res instanceof ArrayBuffer && t.push(e.res);
    this._handler.sendMessage(e, t);
  }
}
class n3 extends q {
  constructor(e, t) {
    super(), this._localChannels = /* @__PURE__ */ new Map(), this._worker = this._register(e.create({
      amdModuleId: "vs/base/common/worker/simpleWorker",
      esmModuleLocation: t.esmModuleLocation,
      label: t.label
    }, (o) => {
      this._protocol.handleMessage(o);
    }, (o) => {
      ht(o);
    })), this._protocol = new i3({
      sendMessage: (o, r) => {
        this._worker.postMessage(o, r);
      },
      handleMessage: (o, r, a) => this._handleMessage(o, r, a),
      handleEvent: (o, r, a) => this._handleEvent(o, r, a)
    }), this._protocol.setWorkerId(this._worker.getId());
    let i = null;
    const n = globalThis.require;
    typeof n < "u" && typeof n.getConfig == "function" ? i = n.getConfig() : typeof globalThis.requirejs < "u" && (i = globalThis.requirejs.s.contexts._.config), this._onModuleLoaded = this._protocol.sendMessage(KD, Q7, [
      this._worker.getId(),
      JSON.parse(JSON.stringify(i)),
      t.amdModuleId
    ]), this.proxy = this._protocol.createProxyToRemoteChannel(KD, async () => {
      await this._onModuleLoaded;
    }), this._onModuleLoaded.catch((o) => {
      this._onError("Worker failed to load " + t.amdModuleId, o);
    });
  }
  _handleMessage(e, t, i) {
    const n = this._localChannels.get(e);
    if (!n)
      return Promise.reject(new Error(`Missing channel ${e} on main thread`));
    if (typeof n[t] != "function")
      return Promise.reject(new Error(`Missing method ${t} on main thread channel ${e}`));
    try {
      return Promise.resolve(n[t].apply(n, i));
    } catch (o) {
      return Promise.reject(o);
    }
  }
  _handleEvent(e, t, i) {
    const n = this._localChannels.get(e);
    if (!n)
      throw new Error(`Missing channel ${e} on main thread`);
    if (BM(t)) {
      const o = n[t].call(n, i);
      if (typeof o != "function")
        throw new Error(`Missing dynamic event ${t} on main thread channel ${e}.`);
      return o;
    }
    if (FM(t)) {
      const o = n[t];
      if (typeof o != "function")
        throw new Error(`Missing event ${t} on main thread channel ${e}.`);
      return o;
    }
    throw new Error(`Malformed event name ${t}`);
  }
  setChannel(e, t) {
    this._localChannels.set(e, t);
  }
  _onError(e, t) {
    console.error(e), console.info(t);
  }
}
function FM(s) {
  return s[0] === "o" && s[1] === "n" && ga(s.charCodeAt(2));
}
function BM(s) {
  return /^onDynamic/.test(s) && ga(s.charCodeAt(9));
}
function Pc(s, e) {
  var i;
  const t = globalThis.MonacoEnvironment;
  if (t != null && t.createTrustedTypesPolicy)
    try {
      return t.createTrustedTypesPolicy(s, e);
    } catch (n) {
      ht(n);
      return;
    }
  try {
    return (i = globalThis.trustedTypes) == null ? void 0 : i.createPolicy(s, e);
  } catch (n) {
    ht(n);
    return;
  }
}
let uh;
typeof self == "object" && self.constructor && self.constructor.name === "DedicatedWorkerGlobalScope" && globalThis.workerttPolicy !== void 0 ? uh = globalThis.workerttPolicy : uh = Pc("defaultWorkerFactory", { createScriptURL: (s) => s });
function s3(s, e) {
  const t = globalThis.MonacoEnvironment;
  if (t) {
    if (typeof t.getWorker == "function")
      return t.getWorker("workerMain.js", e);
    if (typeof t.getWorkerUrl == "function") {
      const i = t.getWorkerUrl("workerMain.js", e);
      return new Worker(uh ? uh.createScriptURL(i) : i, { name: e, type: "module" });
    }
  }
  if (s) {
    const i = o3(e, s.toString(!0)), n = new Worker(uh ? uh.createScriptURL(i) : i, { name: e, type: "module" });
    return r3(n);
  }
  throw new Error("You must define a function MonacoEnvironment.getWorkerUrl or MonacoEnvironment.getWorker");
}
function o3(s, e, t) {
  if (!(/^((http:)|(https:)|(file:)|(vscode-file:))/.test(e) && e.substring(0, globalThis.origin.length) !== globalThis.origin)) {
    const o = e.lastIndexOf("?"), r = e.lastIndexOf("#", o), a = o > 0 ? new URLSearchParams(e.substring(o + 1, ~r ? r : void 0)) : new URLSearchParams();
    jw.addSearchParam(a, !0, !0), a.toString() ? e = `${e}?${a.toString()}#${s}` : e = `${e}#${s}`;
  }
  const n = new Blob([fL([
    `/*${s}*/`,
    void 0,
    `globalThis._VSCODE_NLS_MESSAGES = ${JSON.stringify(S2())};`,
    `globalThis._VSCODE_NLS_LANGUAGE = ${JSON.stringify(mL())};`,
    `globalThis._VSCODE_FILE_ROOT = '${globalThis._VSCODE_FILE_ROOT}';`,
    "const ttPolicy = globalThis.trustedTypes?.createPolicy('defaultWorkerFactory', { createScriptURL: value => value });",
    "globalThis.workerttPolicy = ttPolicy;",
    `await import(ttPolicy?.createScriptURL('${e}') ?? '${e}');`,
    "globalThis.postMessage({ type: 'vscode-worker-ready' });",
    // in ESM signal we are ready after the async import
    `/*${s}*/`
  ]).join("")], { type: "application/javascript" });
  return URL.createObjectURL(n);
}
function r3(s) {
  return new Promise((e, t) => {
    s.onmessage = function(i) {
      i.data.type === "vscode-worker-ready" && (s.onmessage = null, e(s));
    }, s.onerror = t;
  });
}
function a3(s) {
  return typeof s.then == "function";
}
class l3 extends q {
  constructor(e, t, i, n, o, r) {
    super(), this.id = i, this.label = n;
    const a = s3(e, n);
    a3(a) ? this.worker = a : this.worker = Promise.resolve(a), this.postMessage(t, []), this.worker.then((l) => {
      l.onmessage = function(c) {
        o(c.data);
      }, l.onmessageerror = r, typeof l.addEventListener == "function" && l.addEventListener("error", r);
    }), this._register(ke(() => {
      var l;
      (l = this.worker) == null || l.then((c) => {
        c.onmessage = null, c.onmessageerror = null, c.removeEventListener("error", r), c.terminate();
      }), this.worker = null;
    }));
  }
  getId() {
    return this.id;
  }
  postMessage(e, t) {
    var i;
    (i = this.worker) == null || i.then((n) => {
      try {
        n.postMessage(e, t);
      } catch (o) {
        ht(o), ht(new Error(`FAILED to post message to '${this.label}'-worker`, { cause: o }));
      }
    });
  }
}
class c3 {
  constructor(e, t) {
    this.amdModuleId = e, this.label = t, this.esmModuleLocation = sb.asBrowserUri(`${e}.esm.js`);
  }
}
const f1 = class f1 {
  constructor() {
    this._webWorkerFailedBeforeError = !1;
  }
  create(e, t, i) {
    const n = ++f1.LAST_WORKER_ID;
    if (this._webWorkerFailedBeforeError)
      throw this._webWorkerFailedBeforeError;
    return new l3(e.esmModuleLocation, e.amdModuleId, n, e.label || "anonymous" + n, t, (o) => {
      sv(o), this._webWorkerFailedBeforeError = o, i(o);
    });
  }
};
f1.LAST_WORKER_ID = 0;
let ov = f1;
function h3(s, e) {
  const t = typeof s == "string" ? new c3(s, e) : s;
  return new n3(new ov(), t);
}
var nn;
(function(s) {
  s[s.None = 0] = "None", s[s.Indent = 1] = "Indent", s[s.IndentOutdent = 2] = "IndentOutdent", s[s.Outdent = 3] = "Outdent";
})(nn || (nn = {}));
class k0 {
  constructor(e) {
    if (this._neutralCharacter = null, this._neutralCharacterSearched = !1, this.open = e.open, this.close = e.close, this._inString = !0, this._inComment = !0, this._inRegEx = !0, Array.isArray(e.notIn))
      for (let t = 0, i = e.notIn.length; t < i; t++)
        switch (e.notIn[t]) {
          case "string":
            this._inString = !1;
            break;
          case "comment":
            this._inComment = !1;
            break;
          case "regex":
            this._inRegEx = !1;
            break;
        }
  }
  isOK(e) {
    switch (e) {
      case 0:
        return !0;
      case 1:
        return this._inComment;
      case 2:
        return this._inString;
      case 3:
        return this._inRegEx;
    }
  }
  shouldAutoClose(e, t) {
    if (e.getTokenCount() === 0)
      return !0;
    const i = e.findTokenIndexAtOffset(t - 2), n = e.getStandardTokenType(i);
    return this.isOK(n);
  }
  _findNeutralCharacterInRange(e, t) {
    for (let i = e; i <= t; i++) {
      const n = String.fromCharCode(i);
      if (!this.open.includes(n) && !this.close.includes(n))
        return n;
    }
    return null;
  }
  /**
   * Find a character in the range [0-9a-zA-Z] that does not appear in the open or close
   */
  findNeutralCharacter() {
    return this._neutralCharacterSearched || (this._neutralCharacterSearched = !0, this._neutralCharacter || (this._neutralCharacter = this._findNeutralCharacterInRange(
      48,
      57
      /* CharCode.Digit9 */
    )), this._neutralCharacter || (this._neutralCharacter = this._findNeutralCharacterInRange(
      97,
      122
      /* CharCode.z */
    )), this._neutralCharacter || (this._neutralCharacter = this._findNeutralCharacterInRange(
      65,
      90
      /* CharCode.Z */
    ))), this._neutralCharacter;
  }
}
class d3 {
  constructor(e) {
    this.autoClosingPairsOpenByStart = /* @__PURE__ */ new Map(), this.autoClosingPairsOpenByEnd = /* @__PURE__ */ new Map(), this.autoClosingPairsCloseByStart = /* @__PURE__ */ new Map(), this.autoClosingPairsCloseByEnd = /* @__PURE__ */ new Map(), this.autoClosingPairsCloseSingleChar = /* @__PURE__ */ new Map();
    for (const t of e)
      lu(this.autoClosingPairsOpenByStart, t.open.charAt(0), t), lu(this.autoClosingPairsOpenByEnd, t.open.charAt(t.open.length - 1), t), lu(this.autoClosingPairsCloseByStart, t.close.charAt(0), t), lu(this.autoClosingPairsCloseByEnd, t.close.charAt(t.close.length - 1), t), t.close.length === 1 && t.open.length === 1 && lu(this.autoClosingPairsCloseSingleChar, t.close, t);
  }
}
function lu(s, e, t) {
  s.has(e) ? s.get(e).push(t) : s.set(e, [t]);
}
const Ah = class Ah {
  constructor(e) {
    if (e.autoClosingPairs ? this._autoClosingPairs = e.autoClosingPairs.map((t) => new k0(t)) : e.brackets ? this._autoClosingPairs = e.brackets.map((t) => new k0({ open: t[0], close: t[1] })) : this._autoClosingPairs = [], e.__electricCharacterSupport && e.__electricCharacterSupport.docComment) {
      const t = e.__electricCharacterSupport.docComment;
      this._autoClosingPairs.push(new k0({ open: t.open, close: t.close || "" }));
    }
    this._autoCloseBeforeForQuotes = typeof e.autoCloseBefore == "string" ? e.autoCloseBefore : Ah.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES, this._autoCloseBeforeForBrackets = typeof e.autoCloseBefore == "string" ? e.autoCloseBefore : Ah.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS, this._surroundingPairs = e.surroundingPairs || this._autoClosingPairs;
  }
  getAutoClosingPairs() {
    return this._autoClosingPairs;
  }
  getAutoCloseBeforeSet(e) {
    return e ? this._autoCloseBeforeForQuotes : this._autoCloseBeforeForBrackets;
  }
  getSurroundingPairs() {
    return this._surroundingPairs;
  }
};
Ah.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES = `;:.,=}])> 
	`, Ah.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS = `'"\`;:.,=}])> 
	`;
let rv = Ah;
function Ul(s, e) {
  const t = s.getCount(), i = s.findTokenIndexAtOffset(e), n = s.getLanguageId(i);
  let o = i;
  for (; o + 1 < t && s.getLanguageId(o + 1) === n; )
    o++;
  let r = i;
  for (; r > 0 && s.getLanguageId(r - 1) === n; )
    r--;
  return new u3(s, n, r, o + 1, s.getStartOffset(r), s.getEndOffset(o));
}
class u3 {
  constructor(e, t, i, n, o, r) {
    this._scopedLineTokensBrand = void 0, this._actual = e, this.languageId = t, this._firstTokenIndex = i, this._lastTokenIndex = n, this.firstCharOffset = o, this._lastCharOffset = r, this.languageIdCodec = e.languageIdCodec;
  }
  getLineContent() {
    return this._actual.getLineContent().substring(this.firstCharOffset, this._lastCharOffset);
  }
  getLineLength() {
    return this._lastCharOffset - this.firstCharOffset;
  }
  getActualLineContentBefore(e) {
    return this._actual.getLineContent().substring(0, this.firstCharOffset + e);
  }
  getTokenCount() {
    return this._lastTokenIndex - this._firstTokenIndex;
  }
  findTokenIndexAtOffset(e) {
    return this._actual.findTokenIndexAtOffset(e + this.firstCharOffset) - this._firstTokenIndex;
  }
  getStandardTokenType(e) {
    return this._actual.getStandardTokenType(e + this._firstTokenIndex);
  }
  toIViewLineTokens() {
    return this._actual.sliceAndInflate(this.firstCharOffset, this._lastCharOffset, 0);
  }
}
function Lo(s) {
  return (s & 3) !== 0;
}
const GD = typeof Buffer < "u";
let x0;
class QL {
  /**
   * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for
   * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,
   * which is not transferrable.
   */
  static wrap(e) {
    return GD && !Buffer.isBuffer(e) && (e = Buffer.from(e.buffer, e.byteOffset, e.byteLength)), new QL(e);
  }
  constructor(e) {
    this.buffer = e, this.byteLength = this.buffer.byteLength;
  }
  toString() {
    return GD ? this.buffer.toString() : (x0 || (x0 = new TextDecoder()), x0.decode(this.buffer));
  }
}
function f3(s, e) {
  return s[e + 0] << 0 >>> 0 | s[e + 1] << 8 >>> 0;
}
function g3(s, e, t) {
  s[t + 0] = e & 255, e = e >>> 8, s[t + 1] = e & 255;
}
function Zs(s, e) {
  return s[e] * 2 ** 24 + s[e + 1] * 2 ** 16 + s[e + 2] * 2 ** 8 + s[e + 3];
}
function Ys(s, e, t) {
  s[t + 3] = e, e = e >>> 8, s[t + 2] = e, e = e >>> 8, s[t + 1] = e, e = e >>> 8, s[t] = e;
}
function ZD(s, e) {
  return s[e];
}
function YD(s, e, t) {
  s[t] = e;
}
let D0;
function WM() {
  return D0 || (D0 = new TextDecoder("UTF-16LE")), D0;
}
let E0;
function m3() {
  return E0 || (E0 = new TextDecoder("UTF-16BE")), E0;
}
let I0;
function VM() {
  return I0 || (I0 = nP() ? WM() : m3()), I0;
}
function p3(s, e, t) {
  const i = new Uint16Array(s.buffer, e, t);
  return t > 0 && (i[0] === 65279 || i[0] === 65534) ? _3(s, e, t) : WM().decode(i);
}
function _3(s, e, t) {
  const i = [];
  let n = 0;
  for (let o = 0; o < t; o++) {
    const r = f3(s, e);
    e += 2, i[n++] = String.fromCharCode(r);
  }
  return i.join("");
}
class bb {
  constructor(e) {
    this._capacity = e | 0, this._buffer = new Uint16Array(this._capacity), this._completedStrings = null, this._bufferLength = 0;
  }
  reset() {
    this._completedStrings = null, this._bufferLength = 0;
  }
  build() {
    return this._completedStrings !== null ? (this._flushBuffer(), this._completedStrings.join("")) : this._buildBuffer();
  }
  _buildBuffer() {
    if (this._bufferLength === 0)
      return "";
    const e = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);
    return VM().decode(e);
  }
  _flushBuffer() {
    const e = this._buildBuffer();
    this._bufferLength = 0, this._completedStrings === null ? this._completedStrings = [e] : this._completedStrings[this._completedStrings.length] = e;
  }
  /**
   * Append a char code (<2^16)
   */
  appendCharCode(e) {
    const t = this._capacity - this._bufferLength;
    t <= 1 && (t === 0 || hi(e)) && this._flushBuffer(), this._buffer[this._bufferLength++] = e;
  }
  /**
   * Append an ASCII char code (<2^8)
   */
  appendASCIICharCode(e) {
    this._bufferLength === this._capacity && this._flushBuffer(), this._buffer[this._bufferLength++] = e;
  }
  appendString(e) {
    const t = e.length;
    if (this._bufferLength + t >= this._capacity) {
      this._flushBuffer(), this._completedStrings[this._completedStrings.length] = e;
      return;
    }
    for (let i = 0; i < t; i++)
      this._buffer[this._bufferLength++] = e.charCodeAt(i);
  }
}
class Tp {
  constructor(e, t, i, n, o, r) {
    this._richEditBracketBrand = void 0, this.languageId = e, this.index = t, this.open = i, this.close = n, this.forwardRegex = o, this.reversedRegex = r, this._openSet = Tp._toSet(this.open), this._closeSet = Tp._toSet(this.close);
  }
  /**
   * Check if the provided `text` is an open bracket in this group.
   */
  isOpen(e) {
    return this._openSet.has(e);
  }
  /**
   * Check if the provided `text` is a close bracket in this group.
   */
  isClose(e) {
    return this._closeSet.has(e);
  }
  static _toSet(e) {
    const t = /* @__PURE__ */ new Set();
    for (const i of e)
      t.add(i);
    return t;
  }
}
function b3(s) {
  const e = s.length;
  s = s.map((r) => [r[0].toLowerCase(), r[1].toLowerCase()]);
  const t = [];
  for (let r = 0; r < e; r++)
    t[r] = r;
  const i = (r, a) => {
    const [l, c] = r, [h, d] = a;
    return l === h || l === d || c === h || c === d;
  }, n = (r, a) => {
    const l = Math.min(r, a), c = Math.max(r, a);
    for (let h = 0; h < e; h++)
      t[h] === c && (t[h] = l);
  };
  for (let r = 0; r < e; r++) {
    const a = s[r];
    for (let l = r + 1; l < e; l++) {
      const c = s[l];
      i(a, c) && n(t[r], t[l]);
    }
  }
  const o = [];
  for (let r = 0; r < e; r++) {
    const a = [], l = [];
    for (let c = 0; c < e; c++)
      if (t[c] === r) {
        const [h, d] = s[c];
        a.push(h), l.push(d);
      }
    a.length > 0 && o.push({
      open: a,
      close: l
    });
  }
  return o;
}
class C3 {
  constructor(e, t) {
    this._richEditBracketsBrand = void 0;
    const i = b3(t);
    this.brackets = i.map((n, o) => new Tp(e, o, n.open, n.close, w3(n.open, n.close, i, o), v3(n.open, n.close, i, o))), this.forwardRegex = y3(this.brackets), this.reversedRegex = S3(this.brackets), this.textIsBracket = {}, this.textIsOpenBracket = {}, this.maxBracketLength = 0;
    for (const n of this.brackets) {
      for (const o of n.open)
        this.textIsBracket[o] = n, this.textIsOpenBracket[o] = !0, this.maxBracketLength = Math.max(this.maxBracketLength, o.length);
      for (const o of n.close)
        this.textIsBracket[o] = n, this.textIsOpenBracket[o] = !1, this.maxBracketLength = Math.max(this.maxBracketLength, o.length);
    }
  }
}
function HM(s, e, t, i) {
  for (let n = 0, o = e.length; n < o; n++) {
    if (n === t)
      continue;
    const r = e[n];
    for (const a of r.open)
      a.indexOf(s) >= 0 && i.push(a);
    for (const a of r.close)
      a.indexOf(s) >= 0 && i.push(a);
  }
}
function zM(s, e) {
  return s.length - e.length;
}
function Cb(s) {
  if (s.length <= 1)
    return s;
  const e = [], t = /* @__PURE__ */ new Set();
  for (const i of s)
    t.has(i) || (e.push(i), t.add(i));
  return e;
}
function w3(s, e, t, i) {
  let n = [];
  n = n.concat(s), n = n.concat(e);
  for (let o = 0, r = n.length; o < r; o++)
    HM(n[o], t, i, n);
  return n = Cb(n), n.sort(zM), n.reverse(), Ig(n);
}
function v3(s, e, t, i) {
  let n = [];
  n = n.concat(s), n = n.concat(e);
  for (let o = 0, r = n.length; o < r; o++)
    HM(n[o], t, i, n);
  return n = Cb(n), n.sort(zM), n.reverse(), Ig(n.map(XL));
}
function y3(s) {
  let e = [];
  for (const t of s) {
    for (const i of t.open)
      e.push(i);
    for (const i of t.close)
      e.push(i);
  }
  return e = Cb(e), Ig(e);
}
function S3(s) {
  let e = [];
  for (const t of s) {
    for (const i of t.open)
      e.push(i);
    for (const i of t.close)
      e.push(i);
  }
  return e = Cb(e), Ig(e.map(XL));
}
function L3(s) {
  const e = /^[\w ]+$/.test(s);
  return s = Yr(s), e ? `\\b${s}\\b` : s;
}
function Ig(s, e) {
  const t = `(${s.map(L3).join(")|(")})`;
  return Y2(t, !0, e);
}
const XL = /* @__PURE__ */ (function() {
  function s(i) {
    const n = new Uint16Array(i.length);
    let o = 0;
    for (let r = i.length - 1; r >= 0; r--)
      n[o++] = i.charCodeAt(r);
    return VM().decode(n);
  }
  let e = null, t = null;
  return function(n) {
    return e !== n && (e = n, t = s(e)), t;
  };
})();
class Ss {
  static _findPrevBracketInText(e, t, i, n) {
    const o = i.match(e);
    if (!o)
      return null;
    const r = i.length - (o.index || 0), a = o[0].length, l = n + r;
    return new R(t, l - a + 1, t, l + 1);
  }
  static findPrevBracketInRange(e, t, i, n, o) {
    const a = XL(i).substring(i.length - o, i.length - n);
    return this._findPrevBracketInText(e, t, a, n);
  }
  static findNextBracketInText(e, t, i, n) {
    const o = i.match(e);
    if (!o)
      return null;
    const r = o.index || 0, a = o[0].length;
    if (a === 0)
      return null;
    const l = n + r;
    return new R(t, l + 1, t, l + 1 + a);
  }
  static findNextBracketInRange(e, t, i, n, o) {
    const r = i.substring(n, o);
    return this.findNextBracketInText(e, t, r, n);
  }
}
class k3 {
  constructor(e) {
    this._richEditBrackets = e;
  }
  getElectricCharacters() {
    const e = [];
    if (this._richEditBrackets)
      for (const t of this._richEditBrackets.brackets)
        for (const i of t.close) {
          const n = i.charAt(i.length - 1);
          e.push(n);
        }
    return uc(e);
  }
  onElectricCharacter(e, t, i) {
    if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0)
      return null;
    const n = t.findTokenIndexAtOffset(i - 1);
    if (Lo(t.getStandardTokenType(n)))
      return null;
    const o = this._richEditBrackets.reversedRegex, r = t.getLineContent().substring(0, i - 1) + e, a = Ss.findPrevBracketInRange(o, 1, r, 0, r.length);
    if (!a)
      return null;
    const l = r.substring(a.startColumn - 1, a.endColumn - 1).toLowerCase();
    if (this._richEditBrackets.textIsOpenBracket[l])
      return null;
    const h = t.getActualLineContentBefore(a.startColumn - 1);
    return /^\s*$/.test(h) ? {
      matchOpenBracket: l
    } : null;
  }
}
function om(s) {
  return s.global && (s.lastIndex = 0), !0;
}
class x3 {
  constructor(e) {
    this._indentationRules = e;
  }
  shouldIncrease(e) {
    return !!(this._indentationRules && this._indentationRules.increaseIndentPattern && om(this._indentationRules.increaseIndentPattern) && this._indentationRules.increaseIndentPattern.test(e));
  }
  shouldDecrease(e) {
    return !!(this._indentationRules && this._indentationRules.decreaseIndentPattern && om(this._indentationRules.decreaseIndentPattern) && this._indentationRules.decreaseIndentPattern.test(e));
  }
  shouldIndentNextLine(e) {
    return !!(this._indentationRules && this._indentationRules.indentNextLinePattern && om(this._indentationRules.indentNextLinePattern) && this._indentationRules.indentNextLinePattern.test(e));
  }
  shouldIgnore(e) {
    return !!(this._indentationRules && this._indentationRules.unIndentedLinePattern && om(this._indentationRules.unIndentedLinePattern) && this._indentationRules.unIndentedLinePattern.test(e));
  }
  getIndentMetadata(e) {
    let t = 0;
    return this.shouldIncrease(e) && (t += 1), this.shouldDecrease(e) && (t += 2), this.shouldIndentNextLine(e) && (t += 4), this.shouldIgnore(e) && (t += 8), t;
  }
}
class fh {
  constructor(e) {
    e = e || {}, e.brackets = e.brackets || [
      ["(", ")"],
      ["{", "}"],
      ["[", "]"]
    ], this._brackets = [], e.brackets.forEach((t) => {
      const i = fh._createOpenBracketRegExp(t[0]), n = fh._createCloseBracketRegExp(t[1]);
      i && n && this._brackets.push({
        open: t[0],
        openRegExp: i,
        close: t[1],
        closeRegExp: n
      });
    }), this._regExpRules = e.onEnterRules || [];
  }
  onEnter(e, t, i, n) {
    if (e >= 3)
      for (let o = 0, r = this._regExpRules.length; o < r; o++) {
        const a = this._regExpRules[o];
        if ([{
          reg: a.beforeText,
          text: i
        }, {
          reg: a.afterText,
          text: n
        }, {
          reg: a.previousLineText,
          text: t
        }].every((c) => c.reg ? (c.reg.lastIndex = 0, c.reg.test(c.text)) : !0))
          return a.action;
      }
    if (e >= 2 && i.length > 0 && n.length > 0)
      for (let o = 0, r = this._brackets.length; o < r; o++) {
        const a = this._brackets[o];
        if (a.openRegExp.test(i) && a.closeRegExp.test(n))
          return { indentAction: nn.IndentOutdent };
      }
    if (e >= 2 && i.length > 0) {
      for (let o = 0, r = this._brackets.length; o < r; o++)
        if (this._brackets[o].openRegExp.test(i))
          return { indentAction: nn.Indent };
    }
    return null;
  }
  static _createOpenBracketRegExp(e) {
    let t = Yr(e);
    return /\B/.test(t.charAt(0)) || (t = "\\b" + t), t += "\\s*$", fh._safeRegExp(t);
  }
  static _createCloseBracketRegExp(e) {
    let t = Yr(e);
    return /\B/.test(t.charAt(t.length - 1)) || (t = t + "\\b"), t = "^\\s*" + t, fh._safeRegExp(t);
  }
  static _safeRegExp(e) {
    try {
      return new RegExp(e);
    } catch (t) {
      return ht(t), null;
    }
  }
}
const Vt = Ve("configurationService");
function av(s, e) {
  const t = /* @__PURE__ */ Object.create(null);
  for (const i in s)
    UM(t, i, s[i], e);
  return t;
}
function UM(s, e, t, i) {
  const n = e.split("."), o = n.pop();
  let r = s;
  for (let a = 0; a < n.length; a++) {
    const l = n[a];
    let c = r[l];
    switch (typeof c) {
      case "undefined":
        c = r[l] = /* @__PURE__ */ Object.create(null);
        break;
      case "object":
        if (c === null) {
          i(`Ignoring ${e} as ${n.slice(0, a + 1).join(".")} is null`);
          return;
        }
        break;
      default:
        i(`Ignoring ${e} as ${n.slice(0, a + 1).join(".")} is ${JSON.stringify(c)}`);
        return;
    }
    r = c;
  }
  if (typeof r == "object" && r !== null)
    try {
      r[o] = t;
    } catch {
      i(`Ignoring ${e} as ${n.join(".")} is ${JSON.stringify(r)}`);
    }
  else
    i(`Ignoring ${e} as ${n.join(".")} is ${JSON.stringify(r)}`);
}
function D3(s, e) {
  const t = e.split(".");
  $M(s, t);
}
function $M(s, e) {
  const t = e.shift();
  if (e.length === 0) {
    delete s[t];
    return;
  }
  if (Object.keys(s).indexOf(t) !== -1) {
    const i = s[t];
    typeof i == "object" && !Array.isArray(i) && ($M(i, e), Object.keys(i).length === 0 && delete s[t]);
  }
}
function QD(s, e, t) {
  function i(r, a) {
    let l = r;
    for (const c of a) {
      if (typeof l != "object" || l === null)
        return;
      l = l[c];
    }
    return l;
  }
  const n = e.split("."), o = i(s, n);
  return typeof o > "u" ? t : o;
}
function E3(s) {
  return s.replace(/[\[\]]/g, "");
}
const gi = Ve("languageService");
class Ro {
  constructor(e, t = [], i = !1) {
    this.ctor = e, this.staticArguments = t, this.supportsDelayedInstantiation = i;
  }
}
const KM = [];
function Ge(s, e, t) {
  e instanceof Ro || (e = new Ro(e, [], !!t)), KM.push([s, e]);
}
function XD() {
  return KM;
}
const Dr = Object.freeze({
  text: "text/plain",
  binary: "application/octet-stream",
  unknown: "application/unknown",
  markdown: "text/markdown",
  latex: "text/latex",
  uriList: "text/uri-list"
}), wb = {
  JSONContribution: "base.contributions.json"
};
function I3(s) {
  return s.length > 0 && s.charAt(s.length - 1) === "#" ? s.substring(0, s.length - 1) : s;
}
class N3 {
  constructor() {
    this._onDidChangeSchema = new O(), this.schemasById = {};
  }
  registerSchema(e, t) {
    this.schemasById[I3(e)] = t, this._onDidChangeSchema.fire(e);
  }
  notifySchemaChanged(e) {
    this._onDidChangeSchema.fire(e);
  }
}
const T3 = new N3();
Li.add(wb.JSONContribution, T3);
const Oc = {
  Configuration: "base.contributions.configuration"
}, rm = "vscode://schemas/settings/resourceLanguage", JD = Li.as(wb.JSONContribution);
class M3 {
  constructor() {
    this.registeredConfigurationDefaults = [], this.overrideIdentifiers = /* @__PURE__ */ new Set(), this._onDidSchemaChange = new O(), this._onDidUpdateConfiguration = new O(), this.configurationDefaultsOverrides = /* @__PURE__ */ new Map(), this.defaultLanguageConfigurationOverridesNode = {
      id: "defaultOverrides",
      title: p("defaultLanguageConfigurationOverrides.title", "Default Language Configuration Overrides"),
      properties: {}
    }, this.configurationContributors = [this.defaultLanguageConfigurationOverridesNode], this.resourceLanguageSettingsSchema = {
      properties: {},
      patternProperties: {},
      additionalProperties: !0,
      allowTrailingCommas: !0,
      allowComments: !0
    }, this.configurationProperties = {}, this.policyConfigurations = /* @__PURE__ */ new Map(), this.excludedConfigurationProperties = {}, JD.registerSchema(rm, this.resourceLanguageSettingsSchema), this.registerOverridePropertyPatternKey();
  }
  registerConfiguration(e, t = !0) {
    this.registerConfigurations([e], t);
  }
  registerConfigurations(e, t = !0) {
    const i = /* @__PURE__ */ new Set();
    this.doRegisterConfigurations(e, t, i), JD.registerSchema(rm, this.resourceLanguageSettingsSchema), this._onDidSchemaChange.fire(), this._onDidUpdateConfiguration.fire({ properties: i });
  }
  registerDefaultConfigurations(e) {
    const t = /* @__PURE__ */ new Set();
    this.doRegisterDefaultConfigurations(e, t), this._onDidSchemaChange.fire(), this._onDidUpdateConfiguration.fire({ properties: t, defaultsOverrides: !0 });
  }
  doRegisterDefaultConfigurations(e, t) {
    this.registeredConfigurationDefaults.push(...e);
    const i = [];
    for (const { overrides: n, source: o } of e)
      for (const r in n) {
        t.add(r);
        const a = this.configurationDefaultsOverrides.get(r) ?? this.configurationDefaultsOverrides.set(r, { configurationDefaultOverrides: [] }).get(r), l = n[r];
        if (a.configurationDefaultOverrides.push({ value: l, source: o }), $a.test(r)) {
          const c = this.mergeDefaultConfigurationsForOverrideIdentifier(r, l, o, a.configurationDefaultOverrideValue);
          if (!c)
            continue;
          a.configurationDefaultOverrideValue = c, this.updateDefaultOverrideProperty(r, c, o), i.push(...Mp(r));
        } else {
          const c = this.mergeDefaultConfigurationsForConfigurationProperty(r, l, o, a.configurationDefaultOverrideValue);
          if (!c)
            continue;
          a.configurationDefaultOverrideValue = c;
          const h = this.configurationProperties[r];
          h && (this.updatePropertyDefaultValue(r, h), this.updateSchema(r, h));
        }
      }
    this.doRegisterOverrideIdentifiers(i);
  }
  updateDefaultOverrideProperty(e, t, i) {
    const n = {
      type: "object",
      default: t.value,
      description: p("defaultLanguageConfiguration.description", "Configure settings to be overridden for the {0} language.", E3(e)),
      $ref: rm,
      defaultDefaultValue: t.value,
      source: i,
      defaultValueSource: i
    };
    this.configurationProperties[e] = n, this.defaultLanguageConfigurationOverridesNode.properties[e] = n;
  }
  mergeDefaultConfigurationsForOverrideIdentifier(e, t, i, n) {
    const o = (n == null ? void 0 : n.value) || {}, r = (n == null ? void 0 : n.source) ?? /* @__PURE__ */ new Map();
    if (!(r instanceof Map)) {
      console.error("objectConfigurationSources is not a Map");
      return;
    }
    for (const a of Object.keys(t)) {
      const l = t[a];
      if (_n(l) && (fs(o[a]) || _n(o[a]))) {
        if (o[a] = { ...o[a] ?? {}, ...l }, i)
          for (const h in l)
            r.set(`${a}.${h}`, i);
      } else
        o[a] = l, i ? r.set(a, i) : r.delete(a);
    }
    return { value: o, source: r };
  }
  mergeDefaultConfigurationsForConfigurationProperty(e, t, i, n) {
    const o = this.configurationProperties[e], r = (n == null ? void 0 : n.value) ?? (o == null ? void 0 : o.defaultDefaultValue);
    let a = i;
    if (_n(t) && (o !== void 0 && o.type === "object" || o === void 0 && (fs(r) || _n(r)))) {
      if (a = (n == null ? void 0 : n.source) ?? /* @__PURE__ */ new Map(), !(a instanceof Map)) {
        console.error("defaultValueSource is not a Map");
        return;
      }
      for (const c in t)
        i && a.set(`${e}.${c}`, i);
      t = { ..._n(r) ? r : {}, ...t };
    }
    return { value: t, source: a };
  }
  registerOverrideIdentifiers(e) {
    this.doRegisterOverrideIdentifiers(e), this._onDidSchemaChange.fire();
  }
  doRegisterOverrideIdentifiers(e) {
    for (const t of e)
      this.overrideIdentifiers.add(t);
    this.updateOverridePropertyPatternKey();
  }
  doRegisterConfigurations(e, t, i) {
    e.forEach((n) => {
      this.validateAndRegisterProperties(n, t, n.extensionInfo, n.restrictedProperties, void 0, i), this.configurationContributors.push(n), this.registerJSONConfiguration(n);
    });
  }
  validateAndRegisterProperties(e, t = !0, i, n, o = 3, r) {
    var c;
    o = Zn(e.scope) ? o : e.scope;
    const a = e.properties;
    if (a)
      for (const h in a) {
        const d = a[h];
        if (t && P3(h, d)) {
          delete a[h];
          continue;
        }
        if (d.source = i, d.defaultDefaultValue = a[h].default, this.updatePropertyDefaultValue(h, d), $a.test(h) ? d.scope = void 0 : (d.scope = Zn(d.scope) ? o : d.scope, d.restricted = Zn(d.restricted) ? !!(n != null && n.includes(h)) : d.restricted), a[h].hasOwnProperty("included") && !a[h].included) {
          this.excludedConfigurationProperties[h] = a[h], delete a[h];
          continue;
        } else
          this.configurationProperties[h] = a[h], (c = a[h].policy) != null && c.name && this.policyConfigurations.set(a[h].policy.name, h);
        !a[h].deprecationMessage && a[h].markdownDeprecationMessage && (a[h].deprecationMessage = a[h].markdownDeprecationMessage), r.add(h);
      }
    const l = e.allOf;
    if (l)
      for (const h of l)
        this.validateAndRegisterProperties(h, t, i, n, o, r);
  }
  getConfigurationProperties() {
    return this.configurationProperties;
  }
  getPolicyConfigurations() {
    return this.policyConfigurations;
  }
  registerJSONConfiguration(e) {
    const t = (i) => {
      const n = i.properties;
      if (n)
        for (const r in n)
          this.updateSchema(r, n[r]);
      const o = i.allOf;
      o == null || o.forEach(t);
    };
    t(e);
  }
  updateSchema(e, t) {
    switch (t.scope) {
      case 1:
        break;
      case 2:
        break;
      case 6:
        break;
      case 3:
        break;
      case 4:
        break;
      case 5:
        this.resourceLanguageSettingsSchema.properties[e] = t;
        break;
    }
  }
  updateOverridePropertyPatternKey() {
    for (const e of this.overrideIdentifiers.values()) {
      const t = `[${e}]`, i = {
        type: "object",
        description: p("overrideSettings.defaultDescription", "Configure editor settings to be overridden for a language."),
        errorMessage: p("overrideSettings.errorMessage", "This setting does not support per-language configuration."),
        $ref: rm
      };
      this.updatePropertyDefaultValue(t, i);
    }
  }
  registerOverridePropertyPatternKey() {
    p("overrideSettings.defaultDescription", "Configure editor settings to be overridden for a language."), p("overrideSettings.errorMessage", "This setting does not support per-language configuration."), this._onDidSchemaChange.fire();
  }
  updatePropertyDefaultValue(e, t) {
    var r;
    const i = (r = this.configurationDefaultsOverrides.get(e)) == null ? void 0 : r.configurationDefaultOverrideValue;
    let n, o;
    i && (!t.disallowConfigurationDefault || !i.source) && (n = i.value, o = i.source), fs(n) && (n = t.defaultDefaultValue, o = void 0), fs(n) && (n = A3(t.type)), t.default = n, t.defaultValueSource = o;
  }
}
const qM = "\\[([^\\]]+)\\]", eE = new RegExp(qM, "g"), R3 = `^(${qM})+$`, $a = new RegExp(R3);
function Mp(s) {
  const e = [];
  if ($a.test(s)) {
    let t = eE.exec(s);
    for (; t != null && t.length; ) {
      const i = t[1].trim();
      i && e.push(i), t = eE.exec(s);
    }
  }
  return uc(e);
}
function A3(s) {
  switch (Array.isArray(s) ? s[0] : s) {
    case "boolean":
      return !1;
    case "integer":
    case "number":
      return 0;
    case "string":
      return "";
    case "array":
      return [];
    case "object":
      return {};
    default:
      return null;
  }
}
const jm = new M3();
Li.add(Oc.Configuration, jm);
function P3(s, e) {
  var t, i, n, o;
  return s.trim() ? $a.test(s) ? p("config.property.languageDefault", "Cannot register '{0}'. This matches property pattern '\\\\[.*\\\\]$' for describing language specific editor settings. Use 'configurationDefaults' contribution.", s) : jm.getConfigurationProperties()[s] !== void 0 ? p("config.property.duplicate", "Cannot register '{0}'. This property is already registered.", s) : (t = e.policy) != null && t.name && jm.getPolicyConfigurations().get((i = e.policy) == null ? void 0 : i.name) !== void 0 ? p("config.policy.duplicate", "Cannot register '{0}'. The associated policy {1} is already registered with {2}.", s, (n = e.policy) == null ? void 0 : n.name, jm.getPolicyConfigurations().get((o = e.policy) == null ? void 0 : o.name)) : null : p("config.property.empty", "Cannot register an empty property");
}
const O3 = {
  ModesRegistry: "editor.modesRegistry"
};
class F3 {
  constructor() {
    this._onDidChangeLanguages = new O(), this.onDidChangeLanguages = this._onDidChangeLanguages.event, this._languages = [];
  }
  registerLanguage(e) {
    return this._languages.push(e), this._onDidChangeLanguages.fire(void 0), {
      dispose: () => {
        for (let t = 0, i = this._languages.length; t < i; t++)
          if (this._languages[t] === e) {
            this._languages.splice(t, 1);
            return;
          }
      }
    };
  }
  getLanguages() {
    return this._languages;
  }
}
const wd = new F3();
Li.add(O3.ModesRegistry, wd);
const Ms = "plaintext", B3 = ".txt";
wd.registerLanguage({
  id: Ms,
  extensions: [B3],
  aliases: [p("plainText.alias", "Plain Text"), "text"],
  mimetypes: [Dr.text]
});
Li.as(Oc.Configuration).registerDefaultConfigurations([{
  overrides: {
    "[plaintext]": {
      "editor.unicodeHighlight.ambiguousCharacters": !1,
      "editor.unicodeHighlight.invisibleCharacters": !1
    }
  }
}]);
class W3 {
  constructor(e, t) {
    this.languageId = e;
    const i = t.brackets ? tE(t.brackets) : [], n = new CD((a) => {
      const l = /* @__PURE__ */ new Set();
      return {
        info: new V3(this, a, l),
        closing: l
      };
    }), o = new CD((a) => {
      const l = /* @__PURE__ */ new Set(), c = /* @__PURE__ */ new Set();
      return {
        info: new H3(this, a, l, c),
        opening: l,
        openingColorized: c
      };
    });
    for (const [a, l] of i) {
      const c = n.get(a), h = o.get(l);
      c.closing.add(h.info), h.opening.add(c.info);
    }
    const r = t.colorizedBracketPairs ? tE(t.colorizedBracketPairs) : i.filter((a) => !(a[0] === "<" && a[1] === ">"));
    for (const [a, l] of r) {
      const c = n.get(a), h = o.get(l);
      c.closing.add(h.info), h.openingColorized.add(c.info), h.opening.add(c.info);
    }
    this._openingBrackets = new Map([...n.cachedValues].map(([a, l]) => [a, l.info])), this._closingBrackets = new Map([...o.cachedValues].map(([a, l]) => [a, l.info]));
  }
  /**
   * No two brackets have the same bracket text.
  */
  get openingBrackets() {
    return [...this._openingBrackets.values()];
  }
  /**
   * No two brackets have the same bracket text.
  */
  get closingBrackets() {
    return [...this._closingBrackets.values()];
  }
  getOpeningBracketInfo(e) {
    return this._openingBrackets.get(e);
  }
  getClosingBracketInfo(e) {
    return this._closingBrackets.get(e);
  }
  getBracketInfo(e) {
    return this.getOpeningBracketInfo(e) || this.getClosingBracketInfo(e);
  }
  getBracketRegExp(e) {
    const t = Array.from([...this._openingBrackets.keys(), ...this._closingBrackets.keys()]);
    return Ig(t, e);
  }
}
function tE(s) {
  return s.filter(([e, t]) => e !== "" && t !== "");
}
class jM {
  constructor(e, t) {
    this.config = e, this.bracketText = t;
  }
  get languageId() {
    return this.config.languageId;
  }
}
class V3 extends jM {
  constructor(e, t, i) {
    super(e, t), this.openedBrackets = i, this.isOpeningBracket = !0;
  }
}
class H3 extends jM {
  constructor(e, t, i, n) {
    super(e, t), this.openingBrackets = i, this.openingColorizedBrackets = n, this.isOpeningBracket = !1;
  }
  /**
   * Checks if this bracket closes the given other bracket.
   * If the bracket infos come from different configurations, this method will return false.
  */
  closes(e) {
    return e.config !== this.config ? !1 : this.openingBrackets.has(e);
  }
  closesColorized(e) {
    return e.config !== this.config ? !1 : this.openingColorizedBrackets.has(e);
  }
  getOpeningBrackets() {
    return [...this.openingBrackets];
  }
}
var z3 = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, iE = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
class N0 {
  constructor(e) {
    this.languageId = e;
  }
  affects(e) {
    return this.languageId ? this.languageId === e : !0;
  }
}
const Zo = Ve("languageConfigurationService");
let lv = class extends q {
  constructor(e, t) {
    super(), this.configurationService = e, this.languageService = t, this._registry = this._register(new q3()), this.onDidChangeEmitter = this._register(new O()), this.onDidChange = this.onDidChangeEmitter.event, this.configurations = /* @__PURE__ */ new Map();
    const i = new Set(Object.values(cv));
    this._register(this.configurationService.onDidChangeConfiguration((n) => {
      const o = n.change.keys.some((a) => i.has(a)), r = n.change.overrides.filter(([a, l]) => l.some((c) => i.has(c))).map(([a]) => a);
      if (o)
        this.configurations.clear(), this.onDidChangeEmitter.fire(new N0(void 0));
      else
        for (const a of r)
          this.languageService.isRegisteredLanguageId(a) && (this.configurations.delete(a), this.onDidChangeEmitter.fire(new N0(a)));
    })), this._register(this._registry.onDidChange((n) => {
      this.configurations.delete(n.languageId), this.onDidChangeEmitter.fire(new N0(n.languageId));
    }));
  }
  register(e, t, i) {
    return this._registry.register(e, t, i);
  }
  getLanguageConfiguration(e) {
    let t = this.configurations.get(e);
    return t || (t = U3(e, this._registry, this.configurationService, this.languageService), this.configurations.set(e, t)), t;
  }
};
lv = z3([
  iE(0, Vt),
  iE(1, gi)
], lv);
function U3(s, e, t, i) {
  let n = e.getLanguageConfiguration(s);
  if (!n) {
    if (!i.isRegisteredLanguageId(s))
      return new qh(s, {});
    n = new qh(s, {});
  }
  const o = $3(n.languageId, t), r = ZM([n.underlyingConfig, o]);
  return new qh(n.languageId, r);
}
const cv = {
  brackets: "editor.language.brackets",
  colorizedBracketPairs: "editor.language.colorizedBracketPairs"
};
function $3(s, e) {
  const t = e.getValue(cv.brackets, {
    overrideIdentifier: s
  }), i = e.getValue(cv.colorizedBracketPairs, {
    overrideIdentifier: s
  });
  return {
    brackets: nE(t),
    colorizedBracketPairs: nE(i)
  };
}
function nE(s) {
  if (Array.isArray(s))
    return s.map((e) => {
      if (!(!Array.isArray(e) || e.length !== 2))
        return [e[0], e[1]];
    }).filter((e) => !!e);
}
function GM(s, e, t) {
  const i = s.getLineContent(e);
  let n = en(i);
  return n.length > t - 1 && (n = n.substring(0, t - 1)), n;
}
class K3 {
  constructor(e) {
    this.languageId = e, this._resolved = null, this._entries = [], this._order = 0, this._resolved = null;
  }
  register(e, t) {
    const i = new sE(e, t, ++this._order);
    return this._entries.push(i), this._resolved = null, ke(() => {
      for (let n = 0; n < this._entries.length; n++)
        if (this._entries[n] === i) {
          this._entries.splice(n, 1), this._resolved = null;
          break;
        }
    });
  }
  getResolvedConfiguration() {
    if (!this._resolved) {
      const e = this._resolve();
      e && (this._resolved = new qh(this.languageId, e));
    }
    return this._resolved;
  }
  _resolve() {
    return this._entries.length === 0 ? null : (this._entries.sort(sE.cmp), ZM(this._entries.map((e) => e.configuration)));
  }
}
function ZM(s) {
  let e = {
    comments: void 0,
    brackets: void 0,
    wordPattern: void 0,
    indentationRules: void 0,
    onEnterRules: void 0,
    autoClosingPairs: void 0,
    surroundingPairs: void 0,
    autoCloseBefore: void 0,
    folding: void 0,
    colorizedBracketPairs: void 0,
    __electricCharacterSupport: void 0
  };
  for (const t of s)
    e = {
      comments: t.comments || e.comments,
      brackets: t.brackets || e.brackets,
      wordPattern: t.wordPattern || e.wordPattern,
      indentationRules: t.indentationRules || e.indentationRules,
      onEnterRules: t.onEnterRules || e.onEnterRules,
      autoClosingPairs: t.autoClosingPairs || e.autoClosingPairs,
      surroundingPairs: t.surroundingPairs || e.surroundingPairs,
      autoCloseBefore: t.autoCloseBefore || e.autoCloseBefore,
      folding: t.folding || e.folding,
      colorizedBracketPairs: t.colorizedBracketPairs || e.colorizedBracketPairs,
      __electricCharacterSupport: t.__electricCharacterSupport || e.__electricCharacterSupport
    };
  return e;
}
class sE {
  constructor(e, t, i) {
    this.configuration = e, this.priority = t, this.order = i;
  }
  static cmp(e, t) {
    return e.priority === t.priority ? e.order - t.order : e.priority - t.priority;
  }
}
class oE {
  constructor(e) {
    this.languageId = e;
  }
}
class q3 extends q {
  constructor() {
    super(), this._entries = /* @__PURE__ */ new Map(), this._onDidChange = this._register(new O()), this.onDidChange = this._onDidChange.event, this._register(this.register(Ms, {
      brackets: [
        ["(", ")"],
        ["[", "]"],
        ["{", "}"]
      ],
      surroundingPairs: [
        { open: "{", close: "}" },
        { open: "[", close: "]" },
        { open: "(", close: ")" },
        { open: "<", close: ">" },
        { open: '"', close: '"' },
        { open: "'", close: "'" },
        { open: "`", close: "`" }
      ],
      colorizedBracketPairs: [],
      folding: {
        offSide: !0
      }
    }, 0));
  }
  /**
   * @param priority Use a higher number for higher priority
   */
  register(e, t, i = 0) {
    let n = this._entries.get(e);
    n || (n = new K3(e), this._entries.set(e, n));
    const o = n.register(t, i);
    return this._onDidChange.fire(new oE(e)), ke(() => {
      o.dispose(), this._onDidChange.fire(new oE(e));
    });
  }
  getLanguageConfiguration(e) {
    const t = this._entries.get(e);
    return (t == null ? void 0 : t.getResolvedConfiguration()) || null;
  }
}
class qh {
  constructor(e, t) {
    this.languageId = e, this.underlyingConfig = t, this._brackets = null, this._electricCharacter = null, this._onEnterSupport = this.underlyingConfig.brackets || this.underlyingConfig.indentationRules || this.underlyingConfig.onEnterRules ? new fh(this.underlyingConfig) : null, this.comments = qh._handleComments(this.underlyingConfig), this.characterPair = new rv(this.underlyingConfig), this.wordDefinition = this.underlyingConfig.wordPattern || bL, this.indentationRules = this.underlyingConfig.indentationRules, this.underlyingConfig.indentationRules ? this.indentRulesSupport = new x3(this.underlyingConfig.indentationRules) : this.indentRulesSupport = null, this.foldingRules = this.underlyingConfig.folding || {}, this.bracketsNew = new W3(e, this.underlyingConfig);
  }
  getWordDefinition() {
    return CL(this.wordDefinition);
  }
  get brackets() {
    return !this._brackets && this.underlyingConfig.brackets && (this._brackets = new C3(this.languageId, this.underlyingConfig.brackets)), this._brackets;
  }
  get electricCharacter() {
    return this._electricCharacter || (this._electricCharacter = new k3(this.brackets)), this._electricCharacter;
  }
  onEnter(e, t, i, n) {
    return this._onEnterSupport ? this._onEnterSupport.onEnter(e, t, i, n) : null;
  }
  getAutoClosingPairs() {
    return new d3(this.characterPair.getAutoClosingPairs());
  }
  getAutoCloseBeforeSet(e) {
    return this.characterPair.getAutoCloseBeforeSet(e);
  }
  getSurroundingPairs() {
    return this.characterPair.getSurroundingPairs();
  }
  static _handleComments(e) {
    const t = e.comments;
    if (!t)
      return null;
    const i = {};
    if (t.lineComment && (i.lineCommentToken = t.lineComment), t.blockComment) {
      const [n, o] = t.blockComment;
      i.blockCommentStartToken = n, i.blockCommentEndToken = o;
    }
    return i;
  }
}
Ge(
  Zo,
  lv,
  1
  /* InstantiationType.Delayed */
);
class ha {
  /**
   * Constructs a new DiffChange with the given sequence information
   * and content.
   */
  constructor(e, t, i, n) {
    this.originalStart = e, this.originalLength = t, this.modifiedStart = i, this.modifiedLength = n;
  }
  /**
   * The end point (exclusive) of the change in the original sequence.
   */
  getOriginalEnd() {
    return this.originalStart + this.originalLength;
  }
  /**
   * The end point (exclusive) of the change in the modified sequence.
   */
  getModifiedEnd() {
    return this.modifiedStart + this.modifiedLength;
  }
}
class rE {
  constructor(e) {
    this.source = e;
  }
  getElements() {
    const e = this.source, t = new Int32Array(e.length);
    for (let i = 0, n = e.length; i < n; i++)
      t[i] = e.charCodeAt(i);
    return t;
  }
}
function j3(s, e, t) {
  return new Er(new rE(s), new rE(e)).ComputeDiff(t).changes;
}
class Zc {
  static Assert(e, t) {
    if (!e)
      throw new Error(t);
  }
}
class Yc {
  /**
   * Copies a range of elements from an Array starting at the specified source index and pastes
   * them to another Array starting at the specified destination index. The length and the indexes
   * are specified as 64-bit integers.
   * sourceArray:
   *		The Array that contains the data to copy.
   * sourceIndex:
   *		A 64-bit integer that represents the index in the sourceArray at which copying begins.
   * destinationArray:
   *		The Array that receives the data.
   * destinationIndex:
   *		A 64-bit integer that represents the index in the destinationArray at which storing begins.
   * length:
   *		A 64-bit integer that represents the number of elements to copy.
   */
  static Copy(e, t, i, n, o) {
    for (let r = 0; r < o; r++)
      i[n + r] = e[t + r];
  }
  static Copy2(e, t, i, n, o) {
    for (let r = 0; r < o; r++)
      i[n + r] = e[t + r];
  }
}
class aE {
  /**
   * Constructs a new DiffChangeHelper for the given DiffSequences.
   */
  constructor() {
    this.m_changes = [], this.m_originalStart = 1073741824, this.m_modifiedStart = 1073741824, this.m_originalCount = 0, this.m_modifiedCount = 0;
  }
  /**
   * Marks the beginning of the next change in the set of differences.
   */
  MarkNextChange() {
    (this.m_originalCount > 0 || this.m_modifiedCount > 0) && this.m_changes.push(new ha(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount)), this.m_originalCount = 0, this.m_modifiedCount = 0, this.m_originalStart = 1073741824, this.m_modifiedStart = 1073741824;
  }
  /**
   * Adds the original element at the given position to the elements
   * affected by the current change. The modified index gives context
   * to the change position with respect to the original sequence.
   * @param originalIndex The index of the original element to add.
   * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.
   */
  AddOriginalElement(e, t) {
    this.m_originalStart = Math.min(this.m_originalStart, e), this.m_modifiedStart = Math.min(this.m_modifiedStart, t), this.m_originalCount++;
  }
  /**
   * Adds the modified element at the given position to the elements
   * affected by the current change. The original index gives context
   * to the change position with respect to the modified sequence.
   * @param originalIndex The index of the original element that provides corresponding position in the original sequence.
   * @param modifiedIndex The index of the modified element to add.
   */
  AddModifiedElement(e, t) {
    this.m_originalStart = Math.min(this.m_originalStart, e), this.m_modifiedStart = Math.min(this.m_modifiedStart, t), this.m_modifiedCount++;
  }
  /**
   * Retrieves all of the changes marked by the class.
   */
  getChanges() {
    return (this.m_originalCount > 0 || this.m_modifiedCount > 0) && this.MarkNextChange(), this.m_changes;
  }
  /**
   * Retrieves all of the changes marked by the class in the reverse order
   */
  getReverseChanges() {
    return (this.m_originalCount > 0 || this.m_modifiedCount > 0) && this.MarkNextChange(), this.m_changes.reverse(), this.m_changes;
  }
}
class Er {
  /**
   * Constructs the DiffFinder
   */
  constructor(e, t, i = null) {
    this.ContinueProcessingPredicate = i, this._originalSequence = e, this._modifiedSequence = t;
    const [n, o, r] = Er._getElements(e), [a, l, c] = Er._getElements(t);
    this._hasStrings = r && c, this._originalStringElements = n, this._originalElementsOrHash = o, this._modifiedStringElements = a, this._modifiedElementsOrHash = l, this.m_forwardHistory = [], this.m_reverseHistory = [];
  }
  static _isStringArray(e) {
    return e.length > 0 && typeof e[0] == "string";
  }
  static _getElements(e) {
    const t = e.getElements();
    if (Er._isStringArray(t)) {
      const i = new Int32Array(t.length);
      for (let n = 0, o = t.length; n < o; n++)
        i[n] = FL(t[n], 0);
      return [t, i, !0];
    }
    return t instanceof Int32Array ? [[], t, !1] : [[], new Int32Array(t), !1];
  }
  ElementsAreEqual(e, t) {
    return this._originalElementsOrHash[e] !== this._modifiedElementsOrHash[t] ? !1 : this._hasStrings ? this._originalStringElements[e] === this._modifiedStringElements[t] : !0;
  }
  ElementsAreStrictEqual(e, t) {
    if (!this.ElementsAreEqual(e, t))
      return !1;
    const i = Er._getStrictElement(this._originalSequence, e), n = Er._getStrictElement(this._modifiedSequence, t);
    return i === n;
  }
  static _getStrictElement(e, t) {
    return typeof e.getStrictElement == "function" ? e.getStrictElement(t) : null;
  }
  OriginalElementsAreEqual(e, t) {
    return this._originalElementsOrHash[e] !== this._originalElementsOrHash[t] ? !1 : this._hasStrings ? this._originalStringElements[e] === this._originalStringElements[t] : !0;
  }
  ModifiedElementsAreEqual(e, t) {
    return this._modifiedElementsOrHash[e] !== this._modifiedElementsOrHash[t] ? !1 : this._hasStrings ? this._modifiedStringElements[e] === this._modifiedStringElements[t] : !0;
  }
  ComputeDiff(e) {
    return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, e);
  }
  /**
   * Computes the differences between the original and modified input
   * sequences on the bounded range.
   * @returns An array of the differences between the two input sequences.
   */
  _ComputeDiff(e, t, i, n, o) {
    const r = [!1];
    let a = this.ComputeDiffRecursive(e, t, i, n, r);
    return o && (a = this.PrettifyChanges(a)), {
      quitEarly: r[0],
      changes: a
    };
  }
  /**
   * Private helper method which computes the differences on the bounded range
   * recursively.
   * @returns An array of the differences between the two input sequences.
   */
  ComputeDiffRecursive(e, t, i, n, o) {
    for (o[0] = !1; e <= t && i <= n && this.ElementsAreEqual(e, i); )
      e++, i++;
    for (; t >= e && n >= i && this.ElementsAreEqual(t, n); )
      t--, n--;
    if (e > t || i > n) {
      let d;
      return i <= n ? (Zc.Assert(e === t + 1, "originalStart should only be one more than originalEnd"), d = [
        new ha(e, 0, i, n - i + 1)
      ]) : e <= t ? (Zc.Assert(i === n + 1, "modifiedStart should only be one more than modifiedEnd"), d = [
        new ha(e, t - e + 1, i, 0)
      ]) : (Zc.Assert(e === t + 1, "originalStart should only be one more than originalEnd"), Zc.Assert(i === n + 1, "modifiedStart should only be one more than modifiedEnd"), d = []), d;
    }
    const r = [0], a = [0], l = this.ComputeRecursionPoint(e, t, i, n, r, a, o), c = r[0], h = a[0];
    if (l !== null)
      return l;
    if (!o[0]) {
      const d = this.ComputeDiffRecursive(e, c, i, h, o);
      let u = [];
      return o[0] ? u = [
        new ha(c + 1, t - (c + 1) + 1, h + 1, n - (h + 1) + 1)
      ] : u = this.ComputeDiffRecursive(c + 1, t, h + 1, n, o), this.ConcatenateChanges(d, u);
    }
    return [
      new ha(e, t - e + 1, i, n - i + 1)
    ];
  }
  WALKTRACE(e, t, i, n, o, r, a, l, c, h, d, u, f, g, m, _, b, C) {
    let v = null, w = null, S = new aE(), L = t, k = i, D = f[0] - _[0] - n, E = -1073741824, U = this.m_forwardHistory.length - 1;
    do {
      const P = D + e;
      P === L || P < k && c[P - 1] < c[P + 1] ? (d = c[P + 1], g = d - D - n, d < E && S.MarkNextChange(), E = d, S.AddModifiedElement(d + 1, g), D = P + 1 - e) : (d = c[P - 1] + 1, g = d - D - n, d < E && S.MarkNextChange(), E = d - 1, S.AddOriginalElement(d, g + 1), D = P - 1 - e), U >= 0 && (c = this.m_forwardHistory[U], e = c[0], L = 1, k = c.length - 1);
    } while (--U >= -1);
    if (v = S.getReverseChanges(), C[0]) {
      let P = f[0] + 1, B = _[0] + 1;
      if (v !== null && v.length > 0) {
        const W = v[v.length - 1];
        P = Math.max(P, W.getOriginalEnd()), B = Math.max(B, W.getModifiedEnd());
      }
      w = [
        new ha(P, u - P + 1, B, m - B + 1)
      ];
    } else {
      S = new aE(), L = r, k = a, D = f[0] - _[0] - l, E = 1073741824, U = b ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;
      do {
        const P = D + o;
        P === L || P < k && h[P - 1] >= h[P + 1] ? (d = h[P + 1] - 1, g = d - D - l, d > E && S.MarkNextChange(), E = d + 1, S.AddOriginalElement(d + 1, g + 1), D = P + 1 - o) : (d = h[P - 1], g = d - D - l, d > E && S.MarkNextChange(), E = d, S.AddModifiedElement(d + 1, g + 1), D = P - 1 - o), U >= 0 && (h = this.m_reverseHistory[U], o = h[0], L = 1, k = h.length - 1);
      } while (--U >= -1);
      w = S.getChanges();
    }
    return this.ConcatenateChanges(v, w);
  }
  /**
   * Given the range to compute the diff on, this method finds the point:
   * (midOriginal, midModified)
   * that exists in the middle of the LCS of the two sequences and
   * is the point at which the LCS problem may be broken down recursively.
   * This method will try to keep the LCS trace in memory. If the LCS recursion
   * point is calculated and the full trace is available in memory, then this method
   * will return the change list.
   * @param originalStart The start bound of the original sequence range
   * @param originalEnd The end bound of the original sequence range
   * @param modifiedStart The start bound of the modified sequence range
   * @param modifiedEnd The end bound of the modified sequence range
   * @param midOriginal The middle point of the original sequence range
   * @param midModified The middle point of the modified sequence range
   * @returns The diff changes, if available, otherwise null
   */
  ComputeRecursionPoint(e, t, i, n, o, r, a) {
    let l = 0, c = 0, h = 0, d = 0, u = 0, f = 0;
    e--, i--, o[0] = 0, r[0] = 0, this.m_forwardHistory = [], this.m_reverseHistory = [];
    const g = t - e + (n - i), m = g + 1, _ = new Int32Array(m), b = new Int32Array(m), C = n - i, v = t - e, w = e - i, S = t - n, k = (v - C) % 2 === 0;
    _[C] = e, b[v] = t, a[0] = !1;
    for (let D = 1; D <= g / 2 + 1; D++) {
      let E = 0, U = 0;
      h = this.ClipDiagonalBound(C - D, D, C, m), d = this.ClipDiagonalBound(C + D, D, C, m);
      for (let B = h; B <= d; B += 2) {
        B === h || B < d && _[B - 1] < _[B + 1] ? l = _[B + 1] : l = _[B - 1] + 1, c = l - (B - C) - w;
        const W = l;
        for (; l < t && c < n && this.ElementsAreEqual(l + 1, c + 1); )
          l++, c++;
        if (_[B] = l, l + c > E + U && (E = l, U = c), !k && Math.abs(B - v) <= D - 1 && l >= b[B])
          return o[0] = l, r[0] = c, W <= b[B] && D <= 1448 ? this.WALKTRACE(C, h, d, w, v, u, f, S, _, b, l, t, o, c, n, r, k, a) : null;
      }
      const P = (E - e + (U - i) - D) / 2;
      if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(E, P))
        return a[0] = !0, o[0] = E, r[0] = U, P > 0 && D <= 1448 ? this.WALKTRACE(C, h, d, w, v, u, f, S, _, b, l, t, o, c, n, r, k, a) : (e++, i++, [
          new ha(e, t - e + 1, i, n - i + 1)
        ]);
      u = this.ClipDiagonalBound(v - D, D, v, m), f = this.ClipDiagonalBound(v + D, D, v, m);
      for (let B = u; B <= f; B += 2) {
        B === u || B < f && b[B - 1] >= b[B + 1] ? l = b[B + 1] - 1 : l = b[B - 1], c = l - (B - v) - S;
        const W = l;
        for (; l > e && c > i && this.ElementsAreEqual(l, c); )
          l--, c--;
        if (b[B] = l, k && Math.abs(B - C) <= D && l <= _[B])
          return o[0] = l, r[0] = c, W >= _[B] && D <= 1448 ? this.WALKTRACE(C, h, d, w, v, u, f, S, _, b, l, t, o, c, n, r, k, a) : null;
      }
      if (D <= 1447) {
        let B = new Int32Array(d - h + 2);
        B[0] = C - h + 1, Yc.Copy2(_, h, B, 1, d - h + 1), this.m_forwardHistory.push(B), B = new Int32Array(f - u + 2), B[0] = v - u + 1, Yc.Copy2(b, u, B, 1, f - u + 1), this.m_reverseHistory.push(B);
      }
    }
    return this.WALKTRACE(C, h, d, w, v, u, f, S, _, b, l, t, o, c, n, r, k, a);
  }
  /**
   * Shifts the given changes to provide a more intuitive diff.
   * While the first element in a diff matches the first element after the diff,
   * we shift the diff down.
   *
   * @param changes The list of changes to shift
   * @returns The shifted changes
   */
  PrettifyChanges(e) {
    for (let t = 0; t < e.length; t++) {
      const i = e[t], n = t < e.length - 1 ? e[t + 1].originalStart : this._originalElementsOrHash.length, o = t < e.length - 1 ? e[t + 1].modifiedStart : this._modifiedElementsOrHash.length, r = i.originalLength > 0, a = i.modifiedLength > 0;
      for (; i.originalStart + i.originalLength < n && i.modifiedStart + i.modifiedLength < o && (!r || this.OriginalElementsAreEqual(i.originalStart, i.originalStart + i.originalLength)) && (!a || this.ModifiedElementsAreEqual(i.modifiedStart, i.modifiedStart + i.modifiedLength)); ) {
        const c = this.ElementsAreStrictEqual(i.originalStart, i.modifiedStart);
        if (this.ElementsAreStrictEqual(i.originalStart + i.originalLength, i.modifiedStart + i.modifiedLength) && !c)
          break;
        i.originalStart++, i.modifiedStart++;
      }
      const l = [null];
      if (t < e.length - 1 && this.ChangesOverlap(e[t], e[t + 1], l)) {
        e[t] = l[0], e.splice(t + 1, 1), t--;
        continue;
      }
    }
    for (let t = e.length - 1; t >= 0; t--) {
      const i = e[t];
      let n = 0, o = 0;
      if (t > 0) {
        const d = e[t - 1];
        n = d.originalStart + d.originalLength, o = d.modifiedStart + d.modifiedLength;
      }
      const r = i.originalLength > 0, a = i.modifiedLength > 0;
      let l = 0, c = this._boundaryScore(i.originalStart, i.originalLength, i.modifiedStart, i.modifiedLength);
      for (let d = 1; ; d++) {
        const u = i.originalStart - d, f = i.modifiedStart - d;
        if (u < n || f < o || r && !this.OriginalElementsAreEqual(u, u + i.originalLength) || a && !this.ModifiedElementsAreEqual(f, f + i.modifiedLength))
          break;
        const m = (u === n && f === o ? 5 : 0) + this._boundaryScore(u, i.originalLength, f, i.modifiedLength);
        m > c && (c = m, l = d);
      }
      i.originalStart -= l, i.modifiedStart -= l;
      const h = [null];
      if (t > 0 && this.ChangesOverlap(e[t - 1], e[t], h)) {
        e[t - 1] = h[0], e.splice(t, 1), t++;
        continue;
      }
    }
    if (this._hasStrings)
      for (let t = 1, i = e.length; t < i; t++) {
        const n = e[t - 1], o = e[t], r = o.originalStart - n.originalStart - n.originalLength, a = n.originalStart, l = o.originalStart + o.originalLength, c = l - a, h = n.modifiedStart, d = o.modifiedStart + o.modifiedLength, u = d - h;
        if (r < 5 && c < 20 && u < 20) {
          const f = this._findBetterContiguousSequence(a, c, h, u, r);
          if (f) {
            const [g, m] = f;
            (g !== n.originalStart + n.originalLength || m !== n.modifiedStart + n.modifiedLength) && (n.originalLength = g - n.originalStart, n.modifiedLength = m - n.modifiedStart, o.originalStart = g + r, o.modifiedStart = m + r, o.originalLength = l - o.originalStart, o.modifiedLength = d - o.modifiedStart);
          }
        }
      }
    return e;
  }
  _findBetterContiguousSequence(e, t, i, n, o) {
    if (t < o || n < o)
      return null;
    const r = e + t - o + 1, a = i + n - o + 1;
    let l = 0, c = 0, h = 0;
    for (let d = e; d < r; d++)
      for (let u = i; u < a; u++) {
        const f = this._contiguousSequenceScore(d, u, o);
        f > 0 && f > l && (l = f, c = d, h = u);
      }
    return l > 0 ? [c, h] : null;
  }
  _contiguousSequenceScore(e, t, i) {
    let n = 0;
    for (let o = 0; o < i; o++) {
      if (!this.ElementsAreEqual(e + o, t + o))
        return 0;
      n += this._originalStringElements[e + o].length;
    }
    return n;
  }
  _OriginalIsBoundary(e) {
    return e <= 0 || e >= this._originalElementsOrHash.length - 1 ? !0 : this._hasStrings && /^\s*$/.test(this._originalStringElements[e]);
  }
  _OriginalRegionIsBoundary(e, t) {
    if (this._OriginalIsBoundary(e) || this._OriginalIsBoundary(e - 1))
      return !0;
    if (t > 0) {
      const i = e + t;
      if (this._OriginalIsBoundary(i - 1) || this._OriginalIsBoundary(i))
        return !0;
    }
    return !1;
  }
  _ModifiedIsBoundary(e) {
    return e <= 0 || e >= this._modifiedElementsOrHash.length - 1 ? !0 : this._hasStrings && /^\s*$/.test(this._modifiedStringElements[e]);
  }
  _ModifiedRegionIsBoundary(e, t) {
    if (this._ModifiedIsBoundary(e) || this._ModifiedIsBoundary(e - 1))
      return !0;
    if (t > 0) {
      const i = e + t;
      if (this._ModifiedIsBoundary(i - 1) || this._ModifiedIsBoundary(i))
        return !0;
    }
    return !1;
  }
  _boundaryScore(e, t, i, n) {
    const o = this._OriginalRegionIsBoundary(e, t) ? 1 : 0, r = this._ModifiedRegionIsBoundary(i, n) ? 1 : 0;
    return o + r;
  }
  /**
   * Concatenates the two input DiffChange lists and returns the resulting
   * list.
   * @param The left changes
   * @param The right changes
   * @returns The concatenated list
   */
  ConcatenateChanges(e, t) {
    const i = [];
    if (e.length === 0 || t.length === 0)
      return t.length > 0 ? t : e;
    if (this.ChangesOverlap(e[e.length - 1], t[0], i)) {
      const n = new Array(e.length + t.length - 1);
      return Yc.Copy(e, 0, n, 0, e.length - 1), n[e.length - 1] = i[0], Yc.Copy(t, 1, n, e.length, t.length - 1), n;
    } else {
      const n = new Array(e.length + t.length);
      return Yc.Copy(e, 0, n, 0, e.length), Yc.Copy(t, 0, n, e.length, t.length), n;
    }
  }
  /**
   * Returns true if the two changes overlap and can be merged into a single
   * change
   * @param left The left change
   * @param right The right change
   * @param mergedChange The merged change if the two overlap, null otherwise
   * @returns True if the two changes overlap
   */
  ChangesOverlap(e, t, i) {
    if (Zc.Assert(e.originalStart <= t.originalStart, "Left change is not less than or equal to right change"), Zc.Assert(e.modifiedStart <= t.modifiedStart, "Left change is not less than or equal to right change"), e.originalStart + e.originalLength >= t.originalStart || e.modifiedStart + e.modifiedLength >= t.modifiedStart) {
      const n = e.originalStart;
      let o = e.originalLength;
      const r = e.modifiedStart;
      let a = e.modifiedLength;
      return e.originalStart + e.originalLength >= t.originalStart && (o = t.originalStart + t.originalLength - e.originalStart), e.modifiedStart + e.modifiedLength >= t.modifiedStart && (a = t.modifiedStart + t.modifiedLength - e.modifiedStart), i[0] = new ha(n, o, r, a), !0;
    } else
      return i[0] = null, !1;
  }
  /**
   * Helper method used to clip a diagonal index to the range of valid
   * diagonals. This also decides whether or not the diagonal index,
   * if it exceeds the boundary, should be clipped to the boundary or clipped
   * one inside the boundary depending on the Even/Odd status of the boundary
   * and numDifferences.
   * @param diagonal The index of the diagonal to clip.
   * @param numDifferences The current number of differences being iterated upon.
   * @param diagonalBaseIndex The base reference diagonal.
   * @param numDiagonals The total number of diagonals.
   * @returns The clipped diagonal index.
   */
  ClipDiagonalBound(e, t, i, n) {
    if (e >= 0 && e < n)
      return e;
    const o = i, r = n - i - 1, a = t % 2 === 0;
    if (e < 0) {
      const l = o % 2 === 0;
      return a === l ? 0 : 1;
    } else {
      const l = r % 2 === 0;
      return a === l ? n - 1 : n - 2;
    }
  }
}
function Rp(s) {
  return s < 0 ? 0 : s > 255 ? 255 : s | 0;
}
function Qc(s) {
  return s < 0 ? 0 : s > 4294967295 ? 4294967295 : s | 0;
}
class Ng {
  constructor(e) {
    const t = Rp(e);
    this._defaultValue = t, this._asciiMap = Ng._createAsciiMap(t), this._map = /* @__PURE__ */ new Map();
  }
  static _createAsciiMap(e) {
    const t = new Uint8Array(256);
    return t.fill(e), t;
  }
  set(e, t) {
    const i = Rp(t);
    e >= 0 && e < 256 ? this._asciiMap[e] = i : this._map.set(e, i);
  }
  get(e) {
    return e >= 0 && e < 256 ? this._asciiMap[e] : this._map.get(e) || this._defaultValue;
  }
  clear() {
    this._asciiMap.fill(this._defaultValue), this._map.clear();
  }
}
class G3 {
  constructor(e, t, i) {
    const n = new Uint8Array(e * t);
    for (let o = 0, r = e * t; o < r; o++)
      n[o] = i;
    this._data = n, this.rows = e, this.cols = t;
  }
  get(e, t) {
    return this._data[e * this.cols + t];
  }
  set(e, t, i) {
    this._data[e * this.cols + t] = i;
  }
}
class Z3 {
  constructor(e) {
    let t = 0, i = 0;
    for (let o = 0, r = e.length; o < r; o++) {
      const [a, l, c] = e[o];
      l > t && (t = l), a > i && (i = a), c > i && (i = c);
    }
    t++, i++;
    const n = new G3(
      i,
      t,
      0
      /* State.Invalid */
    );
    for (let o = 0, r = e.length; o < r; o++) {
      const [a, l, c] = e[o];
      n.set(a, l, c);
    }
    this._states = n, this._maxCharCode = t;
  }
  nextState(e, t) {
    return t < 0 || t >= this._maxCharCode ? 0 : this._states.get(e, t);
  }
}
let T0 = null;
function Y3() {
  return T0 === null && (T0 = new Z3([
    [
      1,
      104,
      2
      /* State.H */
    ],
    [
      1,
      72,
      2
      /* State.H */
    ],
    [
      1,
      102,
      6
      /* State.F */
    ],
    [
      1,
      70,
      6
      /* State.F */
    ],
    [
      2,
      116,
      3
      /* State.HT */
    ],
    [
      2,
      84,
      3
      /* State.HT */
    ],
    [
      3,
      116,
      4
      /* State.HTT */
    ],
    [
      3,
      84,
      4
      /* State.HTT */
    ],
    [
      4,
      112,
      5
      /* State.HTTP */
    ],
    [
      4,
      80,
      5
      /* State.HTTP */
    ],
    [
      5,
      115,
      9
      /* State.BeforeColon */
    ],
    [
      5,
      83,
      9
      /* State.BeforeColon */
    ],
    [
      5,
      58,
      10
      /* State.AfterColon */
    ],
    [
      6,
      105,
      7
      /* State.FI */
    ],
    [
      6,
      73,
      7
      /* State.FI */
    ],
    [
      7,
      108,
      8
      /* State.FIL */
    ],
    [
      7,
      76,
      8
      /* State.FIL */
    ],
    [
      8,
      101,
      9
      /* State.BeforeColon */
    ],
    [
      8,
      69,
      9
      /* State.BeforeColon */
    ],
    [
      9,
      58,
      10
      /* State.AfterColon */
    ],
    [
      10,
      47,
      11
      /* State.AlmostThere */
    ],
    [
      11,
      47,
      12
      /* State.End */
    ]
  ])), T0;
}
let cu = null;
function Q3() {
  if (cu === null) {
    cu = new Ng(
      0
      /* CharacterClass.None */
    );
    const s = ` 	<>'"、。｡､，．：；‘〈「『〔（［｛｢｣｝］）〕』」〉’｀～…`;
    for (let t = 0; t < s.length; t++)
      cu.set(
        s.charCodeAt(t),
        1
        /* CharacterClass.ForceTermination */
      );
    const e = ".,;:";
    for (let t = 0; t < e.length; t++)
      cu.set(
        e.charCodeAt(t),
        2
        /* CharacterClass.CannotEndIn */
      );
  }
  return cu;
}
class Ap {
  static _createLink(e, t, i, n, o) {
    let r = o - 1;
    do {
      const a = t.charCodeAt(r);
      if (e.get(a) !== 2)
        break;
      r--;
    } while (r > n);
    if (n > 0) {
      const a = t.charCodeAt(n - 1), l = t.charCodeAt(r);
      (a === 40 && l === 41 || a === 91 && l === 93 || a === 123 && l === 125) && r--;
    }
    return {
      range: {
        startLineNumber: i,
        startColumn: n + 1,
        endLineNumber: i,
        endColumn: r + 2
      },
      url: t.substring(n, r + 1)
    };
  }
  static computeLinks(e, t = Y3()) {
    const i = Q3(), n = [];
    for (let o = 1, r = e.getLineCount(); o <= r; o++) {
      const a = e.getLineContent(o), l = a.length;
      let c = 0, h = 0, d = 0, u = 1, f = !1, g = !1, m = !1, _ = !1;
      for (; c < l; ) {
        let b = !1;
        const C = a.charCodeAt(c);
        if (u === 13) {
          let v;
          switch (C) {
            case 40:
              f = !0, v = 0;
              break;
            case 41:
              v = f ? 0 : 1;
              break;
            case 91:
              m = !0, g = !0, v = 0;
              break;
            case 93:
              m = !1, v = g ? 0 : 1;
              break;
            case 123:
              _ = !0, v = 0;
              break;
            case 125:
              v = _ ? 0 : 1;
              break;
            // The following three rules make it that ' or " or ` are allowed inside links
            // only if the link is wrapped by some other quote character
            case 39:
            case 34:
            case 96:
              d === C ? v = 1 : d === 39 || d === 34 || d === 96 ? v = 0 : v = 1;
              break;
            case 42:
              v = d === 42 ? 1 : 0;
              break;
            case 124:
              v = d === 124 ? 1 : 0;
              break;
            case 32:
              v = m ? 0 : 1;
              break;
            default:
              v = i.get(C);
          }
          v === 1 && (n.push(Ap._createLink(i, a, o, h, c)), b = !0);
        } else if (u === 12) {
          let v;
          C === 91 ? (g = !0, v = 0) : v = i.get(C), v === 1 ? b = !0 : u = 13;
        } else
          u = t.nextState(u, C), u === 0 && (b = !0);
        b && (u = 1, f = !1, g = !1, _ = !1, h = c + 1, d = C), c++;
      }
      u === 13 && n.push(Ap._createLink(i, a, o, h, l));
    }
    return n;
  }
}
function X3(s) {
  return !s || typeof s.getLineCount != "function" || typeof s.getLineContent != "function" ? [] : Ap.computeLinks(s);
}
const g1 = class g1 {
  constructor() {
    this._defaultValueSet = [
      ["true", "false"],
      ["True", "False"],
      ["Private", "Public", "Friend", "ReadOnly", "Partial", "Protected", "WriteOnly"],
      ["public", "protected", "private"]
    ];
  }
  navigateValueSet(e, t, i, n, o) {
    if (e && t) {
      const r = this.doNavigateValueSet(t, o);
      if (r)
        return {
          range: e,
          value: r
        };
    }
    if (i && n) {
      const r = this.doNavigateValueSet(n, o);
      if (r)
        return {
          range: i,
          value: r
        };
    }
    return null;
  }
  doNavigateValueSet(e, t) {
    const i = this.numberReplace(e, t);
    return i !== null ? i : this.textReplace(e, t);
  }
  numberReplace(e, t) {
    const i = Math.pow(10, e.length - (e.lastIndexOf(".") + 1));
    let n = Number(e);
    const o = parseFloat(e);
    return !isNaN(n) && !isNaN(o) && n === o ? n === 0 && !t ? null : (n = Math.floor(n * i), n += t ? i : -i, String(n / i)) : null;
  }
  textReplace(e, t) {
    return this.valueSetsReplace(this._defaultValueSet, e, t);
  }
  valueSetsReplace(e, t, i) {
    let n = null;
    for (let o = 0, r = e.length; n === null && o < r; o++)
      n = this.valueSetReplace(e[o], t, i);
    return n;
  }
  valueSetReplace(e, t, i) {
    let n = e.indexOf(t);
    return n >= 0 ? (n += i ? 1 : -1, n < 0 ? n = e.length - 1 : n %= e.length, e[n]) : null;
  }
};
g1.INSTANCE = new g1();
let hv = g1;
const bf = class bf {
  static getChannel(e) {
    return e.getChannel(bf.CHANNEL_NAME);
  }
  static setChannel(e, t) {
    e.setChannel(bf.CHANNEL_NAME, t);
  }
};
bf.CHANNEL_NAME = "editorWorkerHost";
let dv = bf;
var lE, cE;
class J3 {
  constructor(e, t) {
    this.uri = e, this.value = t;
  }
}
function e9(s) {
  return Array.isArray(s);
}
const Wl = class Wl {
  constructor(e, t) {
    if (this[lE] = "ResourceMap", e instanceof Wl)
      this.map = new Map(e.map), this.toKey = t ?? Wl.defaultToKey;
    else if (e9(e)) {
      this.map = /* @__PURE__ */ new Map(), this.toKey = t ?? Wl.defaultToKey;
      for (const [i, n] of e)
        this.set(i, n);
    } else
      this.map = /* @__PURE__ */ new Map(), this.toKey = e ?? Wl.defaultToKey;
  }
  set(e, t) {
    return this.map.set(this.toKey(e), new J3(e, t)), this;
  }
  get(e) {
    var t;
    return (t = this.map.get(this.toKey(e))) == null ? void 0 : t.value;
  }
  has(e) {
    return this.map.has(this.toKey(e));
  }
  get size() {
    return this.map.size;
  }
  clear() {
    this.map.clear();
  }
  delete(e) {
    return this.map.delete(this.toKey(e));
  }
  forEach(e, t) {
    typeof t < "u" && (e = e.bind(t));
    for (const [i, n] of this.map)
      e(n.value, n.uri, this);
  }
  *values() {
    for (const e of this.map.values())
      yield e.value;
  }
  *keys() {
    for (const e of this.map.values())
      yield e.uri;
  }
  *entries() {
    for (const e of this.map.values())
      yield [e.uri, e.value];
  }
  *[(lE = Symbol.toStringTag, Symbol.iterator)]() {
    for (const [, e] of this.map)
      yield [e.uri, e.value];
  }
};
Wl.defaultToKey = (e) => e.toString();
let ts = Wl;
class t9 {
  constructor() {
    this[cE] = "LinkedMap", this._map = /* @__PURE__ */ new Map(), this._head = void 0, this._tail = void 0, this._size = 0, this._state = 0;
  }
  clear() {
    this._map.clear(), this._head = void 0, this._tail = void 0, this._size = 0, this._state++;
  }
  isEmpty() {
    return !this._head && !this._tail;
  }
  get size() {
    return this._size;
  }
  get first() {
    var e;
    return (e = this._head) == null ? void 0 : e.value;
  }
  get last() {
    var e;
    return (e = this._tail) == null ? void 0 : e.value;
  }
  has(e) {
    return this._map.has(e);
  }
  get(e, t = 0) {
    const i = this._map.get(e);
    if (i)
      return t !== 0 && this.touch(i, t), i.value;
  }
  set(e, t, i = 0) {
    let n = this._map.get(e);
    if (n)
      n.value = t, i !== 0 && this.touch(n, i);
    else {
      switch (n = { key: e, value: t, next: void 0, previous: void 0 }, i) {
        case 0:
          this.addItemLast(n);
          break;
        case 1:
          this.addItemFirst(n);
          break;
        case 2:
          this.addItemLast(n);
          break;
        default:
          this.addItemLast(n);
          break;
      }
      this._map.set(e, n), this._size++;
    }
    return this;
  }
  delete(e) {
    return !!this.remove(e);
  }
  remove(e) {
    const t = this._map.get(e);
    if (t)
      return this._map.delete(e), this.removeItem(t), this._size--, t.value;
  }
  shift() {
    if (!this._head && !this._tail)
      return;
    if (!this._head || !this._tail)
      throw new Error("Invalid list");
    const e = this._head;
    return this._map.delete(e.key), this.removeItem(e), this._size--, e.value;
  }
  forEach(e, t) {
    const i = this._state;
    let n = this._head;
    for (; n; ) {
      if (t ? e.bind(t)(n.value, n.key, this) : e(n.value, n.key, this), this._state !== i)
        throw new Error("LinkedMap got modified during iteration.");
      n = n.next;
    }
  }
  keys() {
    const e = this, t = this._state;
    let i = this._head;
    const n = {
      [Symbol.iterator]() {
        return n;
      },
      next() {
        if (e._state !== t)
          throw new Error("LinkedMap got modified during iteration.");
        if (i) {
          const o = { value: i.key, done: !1 };
          return i = i.next, o;
        } else
          return { value: void 0, done: !0 };
      }
    };
    return n;
  }
  values() {
    const e = this, t = this._state;
    let i = this._head;
    const n = {
      [Symbol.iterator]() {
        return n;
      },
      next() {
        if (e._state !== t)
          throw new Error("LinkedMap got modified during iteration.");
        if (i) {
          const o = { value: i.value, done: !1 };
          return i = i.next, o;
        } else
          return { value: void 0, done: !0 };
      }
    };
    return n;
  }
  entries() {
    const e = this, t = this._state;
    let i = this._head;
    const n = {
      [Symbol.iterator]() {
        return n;
      },
      next() {
        if (e._state !== t)
          throw new Error("LinkedMap got modified during iteration.");
        if (i) {
          const o = { value: [i.key, i.value], done: !1 };
          return i = i.next, o;
        } else
          return { value: void 0, done: !0 };
      }
    };
    return n;
  }
  [(cE = Symbol.toStringTag, Symbol.iterator)]() {
    return this.entries();
  }
  trimOld(e) {
    if (e >= this.size)
      return;
    if (e === 0) {
      this.clear();
      return;
    }
    let t = this._head, i = this.size;
    for (; t && i > e; )
      this._map.delete(t.key), t = t.next, i--;
    this._head = t, this._size = i, t && (t.previous = void 0), this._state++;
  }
  trimNew(e) {
    if (e >= this.size)
      return;
    if (e === 0) {
      this.clear();
      return;
    }
    let t = this._tail, i = this.size;
    for (; t && i > e; )
      this._map.delete(t.key), t = t.previous, i--;
    this._tail = t, this._size = i, t && (t.next = void 0), this._state++;
  }
  addItemFirst(e) {
    if (!this._head && !this._tail)
      this._tail = e;
    else if (this._head)
      e.next = this._head, this._head.previous = e;
    else
      throw new Error("Invalid list");
    this._head = e, this._state++;
  }
  addItemLast(e) {
    if (!this._head && !this._tail)
      this._head = e;
    else if (this._tail)
      e.previous = this._tail, this._tail.next = e;
    else
      throw new Error("Invalid list");
    this._tail = e, this._state++;
  }
  removeItem(e) {
    if (e === this._head && e === this._tail)
      this._head = void 0, this._tail = void 0;
    else if (e === this._head) {
      if (!e.next)
        throw new Error("Invalid list");
      e.next.previous = void 0, this._head = e.next;
    } else if (e === this._tail) {
      if (!e.previous)
        throw new Error("Invalid list");
      e.previous.next = void 0, this._tail = e.previous;
    } else {
      const t = e.next, i = e.previous;
      if (!t || !i)
        throw new Error("Invalid list");
      t.previous = i, i.next = t;
    }
    e.next = void 0, e.previous = void 0, this._state++;
  }
  touch(e, t) {
    if (!this._head || !this._tail)
      throw new Error("Invalid list");
    if (!(t !== 1 && t !== 2)) {
      if (t === 1) {
        if (e === this._head)
          return;
        const i = e.next, n = e.previous;
        e === this._tail ? (n.next = void 0, this._tail = n) : (i.previous = n, n.next = i), e.previous = void 0, e.next = this._head, this._head.previous = e, this._head = e, this._state++;
      } else if (t === 2) {
        if (e === this._tail)
          return;
        const i = e.next, n = e.previous;
        e === this._head ? (i.previous = void 0, this._head = i) : (i.previous = n, n.next = i), e.next = void 0, e.previous = this._tail, this._tail.next = e, this._tail = e, this._state++;
      }
    }
  }
  toJSON() {
    const e = [];
    return this.forEach((t, i) => {
      e.push([i, t]);
    }), e;
  }
  fromJSON(e) {
    this.clear();
    for (const [t, i] of e)
      this.set(t, i);
  }
}
class i9 extends t9 {
  constructor(e, t = 1) {
    super(), this._limit = e, this._ratio = Math.min(Math.max(0, t), 1);
  }
  get limit() {
    return this._limit;
  }
  set limit(e) {
    this._limit = e, this.checkTrim();
  }
  get(e, t = 2) {
    return super.get(e, t);
  }
  peek(e) {
    return super.get(
      e,
      0
      /* Touch.None */
    );
  }
  set(e, t) {
    return super.set(
      e,
      t,
      2
      /* Touch.AsNew */
    ), this;
  }
  checkTrim() {
    this.size > this._limit && this.trim(Math.round(this._limit * this._ratio));
  }
}
class Tg extends i9 {
  constructor(e, t = 1) {
    super(e, t);
  }
  trim(e) {
    this.trimOld(e);
  }
  set(e, t) {
    return super.set(e, t), this.checkTrim(), this;
  }
}
class n9 {
  constructor(e) {
    if (this._m1 = /* @__PURE__ */ new Map(), this._m2 = /* @__PURE__ */ new Map(), e)
      for (const [t, i] of e)
        this.set(t, i);
  }
  clear() {
    this._m1.clear(), this._m2.clear();
  }
  set(e, t) {
    this._m1.set(e, t), this._m2.set(t, e);
  }
  get(e) {
    return this._m1.get(e);
  }
  getKey(e) {
    return this._m2.get(e);
  }
  delete(e) {
    const t = this._m1.get(e);
    return t === void 0 ? !1 : (this._m1.delete(e), this._m2.delete(t), !0);
  }
  keys() {
    return this._m1.keys();
  }
  values() {
    return this._m1.values();
  }
}
class YM {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  add(e, t) {
    let i = this.map.get(e);
    i || (i = /* @__PURE__ */ new Set(), this.map.set(e, i)), i.add(t);
  }
  delete(e, t) {
    const i = this.map.get(e);
    i && (i.delete(t), i.size === 0 && this.map.delete(e));
  }
  forEach(e, t) {
    const i = this.map.get(e);
    i && i.forEach(t);
  }
  get(e) {
    const t = this.map.get(e);
    return t || /* @__PURE__ */ new Set();
  }
}
class s9 extends Ng {
  constructor(e, t) {
    super(
      0
      /* WordCharacterClass.Regular */
    ), this._segmenter = null, this._cachedLine = null, this._cachedSegments = [], this.intlSegmenterLocales = t, this.intlSegmenterLocales.length > 0 ? this._segmenter = new Intl.Segmenter(this.intlSegmenterLocales, { granularity: "word" }) : this._segmenter = null;
    for (let i = 0, n = e.length; i < n; i++)
      this.set(
        e.charCodeAt(i),
        2
        /* WordCharacterClass.WordSeparator */
      );
    this.set(
      32,
      1
      /* WordCharacterClass.Whitespace */
    ), this.set(
      9,
      1
      /* WordCharacterClass.Whitespace */
    );
  }
  findPrevIntlWordBeforeOrAtOffset(e, t) {
    let i = null;
    for (const n of this._getIntlSegmenterWordsOnLine(e)) {
      if (n.index > t)
        break;
      i = n;
    }
    return i;
  }
  findNextIntlWordAtOrAfterOffset(e, t) {
    for (const i of this._getIntlSegmenterWordsOnLine(e))
      if (!(i.index < t))
        return i;
    return null;
  }
  _getIntlSegmenterWordsOnLine(e) {
    return this._segmenter ? this._cachedLine === e ? this._cachedSegments : (this._cachedLine = e, this._cachedSegments = this._filterWordSegments(this._segmenter.segment(e)), this._cachedSegments) : [];
  }
  _filterWordSegments(e) {
    const t = [];
    for (const i of e)
      this._isWordLike(i) && t.push(i);
    return t;
  }
  _isWordLike(e) {
    return !!e.isWordLike;
  }
}
const hE = new Tg(10);
function vd(s, e) {
  const t = `${s}/${e.join(",")}`;
  let i = hE.get(t);
  return i || (i = new s9(s, e), hE.set(t, i)), i;
}
var Pp;
(function(s) {
  s[s.Left = 1] = "Left", s[s.Center = 2] = "Center", s[s.Right = 4] = "Right", s[s.Full = 7] = "Full";
})(Pp || (Pp = {}));
var Ka;
(function(s) {
  s[s.Left = 1] = "Left", s[s.Center = 2] = "Center", s[s.Right = 3] = "Right";
})(Ka || (Ka = {}));
var yd;
(function(s) {
  s[s.Both = 0] = "Both", s[s.Right = 1] = "Right", s[s.Left = 2] = "Left", s[s.None = 3] = "None";
})(yd || (yd = {}));
class Gm {
  get originalIndentSize() {
    return this._indentSizeIsTabSize ? "tabSize" : this.indentSize;
  }
  /**
   * @internal
   */
  constructor(e) {
    this._textModelResolvedOptionsBrand = void 0, this.tabSize = Math.max(1, e.tabSize | 0), e.indentSize === "tabSize" ? (this.indentSize = this.tabSize, this._indentSizeIsTabSize = !0) : (this.indentSize = Math.max(1, e.indentSize | 0), this._indentSizeIsTabSize = !1), this.insertSpaces = !!e.insertSpaces, this.defaultEOL = e.defaultEOL | 0, this.trimAutoWhitespace = !!e.trimAutoWhitespace, this.bracketPairColorizationOptions = e.bracketPairColorizationOptions;
  }
  /**
   * @internal
   */
  equals(e) {
    return this.tabSize === e.tabSize && this._indentSizeIsTabSize === e._indentSizeIsTabSize && this.indentSize === e.indentSize && this.insertSpaces === e.insertSpaces && this.defaultEOL === e.defaultEOL && this.trimAutoWhitespace === e.trimAutoWhitespace && Pn(this.bracketPairColorizationOptions, e.bracketPairColorizationOptions);
  }
  /**
   * @internal
   */
  createChangeEvent(e) {
    return {
      tabSize: this.tabSize !== e.tabSize,
      indentSize: this.indentSize !== e.indentSize,
      insertSpaces: this.insertSpaces !== e.insertSpaces,
      trimAutoWhitespace: this.trimAutoWhitespace !== e.trimAutoWhitespace
    };
  }
}
class Vf {
  /**
   * @internal
   */
  constructor(e, t) {
    this._findMatchBrand = void 0, this.range = e, this.matches = t;
  }
}
function o9(s) {
  return s && typeof s.read == "function";
}
class M0 {
  constructor(e, t, i, n, o, r) {
    this.identifier = e, this.range = t, this.text = i, this.forceMoveMarkers = n, this.isAutoWhitespaceEdit = o, this._isTracked = r;
  }
}
class r9 {
  constructor(e, t, i) {
    this.regex = e, this.wordSeparators = t, this.simpleSearch = i;
  }
}
class a9 {
  constructor(e, t, i) {
    this.reverseEdits = e, this.changes = t, this.trimAutoWhitespaceLineNumbers = i;
  }
}
function l9(s) {
  return !s.isTooLargeForSyncing() && !s.isForSimpleWidget;
}
const c9 = 999;
class Xc {
  constructor(e, t, i, n) {
    this.searchString = e, this.isRegex = t, this.matchCase = i, this.wordSeparators = n;
  }
  parseSearchRequest() {
    if (this.searchString === "")
      return null;
    let e;
    this.isRegex ? e = h9(this.searchString) : e = this.searchString.indexOf(`
`) >= 0;
    let t = null;
    try {
      t = Y2(this.searchString, this.isRegex, {
        matchCase: this.matchCase,
        wholeWord: !1,
        multiline: e,
        global: !0,
        unicode: !0
      });
    } catch {
      return null;
    }
    if (!t)
      return null;
    let i = !this.isRegex && !e;
    return i && this.searchString.toLowerCase() !== this.searchString.toUpperCase() && (i = this.matchCase), new r9(t, this.wordSeparators ? vd(this.wordSeparators, []) : null, i ? this.searchString : null);
  }
}
function h9(s) {
  if (!s || s.length === 0)
    return !1;
  for (let e = 0, t = s.length; e < t; e++) {
    const i = s.charCodeAt(e);
    if (i === 10)
      return !0;
    if (i === 92) {
      if (e++, e >= t)
        break;
      const n = s.charCodeAt(e);
      if (n === 110 || n === 114 || n === 87)
        return !0;
    }
  }
  return !1;
}
function Ll(s, e, t) {
  if (!t)
    return new Vf(s, null);
  const i = [];
  for (let n = 0, o = e.length; n < o; n++)
    i[n] = e[n];
  return new Vf(s, i);
}
class dE {
  constructor(e) {
    const t = [];
    let i = 0;
    for (let n = 0, o = e.length; n < o; n++)
      e.charCodeAt(n) === 10 && (t[i++] = n);
    this._lineFeedsOffsets = t;
  }
  findLineFeedCountBeforeOffset(e) {
    const t = this._lineFeedsOffsets;
    let i = 0, n = t.length - 1;
    if (n === -1 || e <= t[0])
      return 0;
    for (; i < n; ) {
      const o = i + ((n - i) / 2 >> 0);
      t[o] >= e ? n = o - 1 : t[o + 1] >= e ? (i = o, n = o) : i = o + 1;
    }
    return i + 1;
  }
}
class am {
  static findMatches(e, t, i, n, o) {
    const r = t.parseSearchRequest();
    return r ? r.regex.multiline ? this._doFindMatchesMultiline(e, i, new gh(r.wordSeparators, r.regex), n, o) : this._doFindMatchesLineByLine(e, i, r, n, o) : [];
  }
  /**
   * Multiline search always executes on the lines concatenated with \n.
   * We must therefore compensate for the count of \n in case the model is CRLF
   */
  static _getMultilineMatchRange(e, t, i, n, o, r) {
    let a, l = 0;
    n ? (l = n.findLineFeedCountBeforeOffset(o), a = t + o + l) : a = t + o;
    let c;
    if (n) {
      const f = n.findLineFeedCountBeforeOffset(o + r.length) - l;
      c = a + r.length + f;
    } else
      c = a + r.length;
    const h = e.getPositionAt(a), d = e.getPositionAt(c);
    return new R(h.lineNumber, h.column, d.lineNumber, d.column);
  }
  static _doFindMatchesMultiline(e, t, i, n, o) {
    const r = e.getOffsetAt(t.getStartPosition()), a = e.getValueInRange(
      t,
      1
      /* EndOfLinePreference.LF */
    ), l = e.getEOL() === `\r
` ? new dE(a) : null, c = [];
    let h = 0, d;
    for (i.reset(0); d = i.next(a); )
      if (c[h++] = Ll(this._getMultilineMatchRange(e, r, a, l, d.index, d[0]), d, n), h >= o)
        return c;
    return c;
  }
  static _doFindMatchesLineByLine(e, t, i, n, o) {
    const r = [];
    let a = 0;
    if (t.startLineNumber === t.endLineNumber) {
      const c = e.getLineContent(t.startLineNumber).substring(t.startColumn - 1, t.endColumn - 1);
      return a = this._findMatchesInLine(i, c, t.startLineNumber, t.startColumn - 1, a, r, n, o), r;
    }
    const l = e.getLineContent(t.startLineNumber).substring(t.startColumn - 1);
    a = this._findMatchesInLine(i, l, t.startLineNumber, t.startColumn - 1, a, r, n, o);
    for (let c = t.startLineNumber + 1; c < t.endLineNumber && a < o; c++)
      a = this._findMatchesInLine(i, e.getLineContent(c), c, 0, a, r, n, o);
    if (a < o) {
      const c = e.getLineContent(t.endLineNumber).substring(0, t.endColumn - 1);
      a = this._findMatchesInLine(i, c, t.endLineNumber, 0, a, r, n, o);
    }
    return r;
  }
  static _findMatchesInLine(e, t, i, n, o, r, a, l) {
    const c = e.wordSeparators;
    if (!a && e.simpleSearch) {
      const u = e.simpleSearch, f = u.length, g = t.length;
      let m = -f;
      for (; (m = t.indexOf(u, m + f)) !== -1; )
        if ((!c || JL(c, t, g, m, f)) && (r[o++] = new Vf(new R(i, m + 1 + n, i, m + 1 + f + n), null), o >= l))
          return o;
      return o;
    }
    const h = new gh(e.wordSeparators, e.regex);
    let d;
    h.reset(0);
    do
      if (d = h.next(t), d && (r[o++] = Ll(new R(i, d.index + 1 + n, i, d.index + 1 + d[0].length + n), d, a), o >= l))
        return o;
    while (d);
    return o;
  }
  static findNextMatch(e, t, i, n) {
    const o = t.parseSearchRequest();
    if (!o)
      return null;
    const r = new gh(o.wordSeparators, o.regex);
    return o.regex.multiline ? this._doFindNextMatchMultiline(e, i, r, n) : this._doFindNextMatchLineByLine(e, i, r, n);
  }
  static _doFindNextMatchMultiline(e, t, i, n) {
    const o = new V(t.lineNumber, 1), r = e.getOffsetAt(o), a = e.getLineCount(), l = e.getValueInRange(
      new R(o.lineNumber, o.column, a, e.getLineMaxColumn(a)),
      1
      /* EndOfLinePreference.LF */
    ), c = e.getEOL() === `\r
` ? new dE(l) : null;
    i.reset(t.column - 1);
    const h = i.next(l);
    return h ? Ll(this._getMultilineMatchRange(e, r, l, c, h.index, h[0]), h, n) : t.lineNumber !== 1 || t.column !== 1 ? this._doFindNextMatchMultiline(e, new V(1, 1), i, n) : null;
  }
  static _doFindNextMatchLineByLine(e, t, i, n) {
    const o = e.getLineCount(), r = t.lineNumber, a = e.getLineContent(r), l = this._findFirstMatchInLine(i, a, r, t.column, n);
    if (l)
      return l;
    for (let c = 1; c <= o; c++) {
      const h = (r + c - 1) % o, d = e.getLineContent(h + 1), u = this._findFirstMatchInLine(i, d, h + 1, 1, n);
      if (u)
        return u;
    }
    return null;
  }
  static _findFirstMatchInLine(e, t, i, n, o) {
    e.reset(n - 1);
    const r = e.next(t);
    return r ? Ll(new R(i, r.index + 1, i, r.index + 1 + r[0].length), r, o) : null;
  }
  static findPreviousMatch(e, t, i, n) {
    const o = t.parseSearchRequest();
    if (!o)
      return null;
    const r = new gh(o.wordSeparators, o.regex);
    return o.regex.multiline ? this._doFindPreviousMatchMultiline(e, i, r, n) : this._doFindPreviousMatchLineByLine(e, i, r, n);
  }
  static _doFindPreviousMatchMultiline(e, t, i, n) {
    const o = this._doFindMatchesMultiline(e, new R(1, 1, t.lineNumber, t.column), i, n, 10 * c9);
    if (o.length > 0)
      return o[o.length - 1];
    const r = e.getLineCount();
    return t.lineNumber !== r || t.column !== e.getLineMaxColumn(r) ? this._doFindPreviousMatchMultiline(e, new V(r, e.getLineMaxColumn(r)), i, n) : null;
  }
  static _doFindPreviousMatchLineByLine(e, t, i, n) {
    const o = e.getLineCount(), r = t.lineNumber, a = e.getLineContent(r).substring(0, t.column - 1), l = this._findLastMatchInLine(i, a, r, n);
    if (l)
      return l;
    for (let c = 1; c <= o; c++) {
      const h = (o + r - c - 1) % o, d = e.getLineContent(h + 1), u = this._findLastMatchInLine(i, d, h + 1, n);
      if (u)
        return u;
    }
    return null;
  }
  static _findLastMatchInLine(e, t, i, n) {
    let o = null, r;
    for (e.reset(0); r = e.next(t); )
      o = Ll(new R(i, r.index + 1, i, r.index + 1 + r[0].length), r, n);
    return o;
  }
}
function d9(s, e, t, i, n) {
  if (i === 0)
    return !0;
  const o = e.charCodeAt(i - 1);
  if (s.get(o) !== 0 || o === 13 || o === 10)
    return !0;
  if (n > 0) {
    const r = e.charCodeAt(i);
    if (s.get(r) !== 0)
      return !0;
  }
  return !1;
}
function u9(s, e, t, i, n) {
  if (i + n === t)
    return !0;
  const o = e.charCodeAt(i + n);
  if (s.get(o) !== 0 || o === 13 || o === 10)
    return !0;
  if (n > 0) {
    const r = e.charCodeAt(i + n - 1);
    if (s.get(r) !== 0)
      return !0;
  }
  return !1;
}
function JL(s, e, t, i, n) {
  return d9(s, e, t, i, n) && u9(s, e, t, i, n);
}
class gh {
  constructor(e, t) {
    this._wordSeparators = e, this._searchRegex = t, this._prevMatchStartIndex = -1, this._prevMatchLength = 0;
  }
  reset(e) {
    this._searchRegex.lastIndex = e, this._prevMatchStartIndex = -1, this._prevMatchLength = 0;
  }
  next(e) {
    const t = e.length;
    let i;
    do {
      if (this._prevMatchStartIndex + this._prevMatchLength === t || (i = this._searchRegex.exec(e), !i))
        return null;
      const n = i.index, o = i[0].length;
      if (n === this._prevMatchStartIndex && o === this._prevMatchLength) {
        if (o === 0) {
          kp(e, t, this._searchRegex.lastIndex) > 65535 ? this._searchRegex.lastIndex += 2 : this._searchRegex.lastIndex += 1;
          continue;
        }
        return null;
      }
      if (this._prevMatchStartIndex = n, this._prevMatchLength = o, !this._wordSeparators || JL(this._wordSeparators, e, t, n, o))
        return i;
    } while (i);
    return null;
  }
}
class f9 {
  static computeUnicodeHighlights(e, t, i) {
    const n = i ? i.startLineNumber : 1, o = i ? i.endLineNumber : e.getLineCount(), r = new uE(t), a = r.getCandidateCodePoints();
    let l;
    a === "allNonBasicAscii" ? l = new RegExp("[^\\t\\n\\r\\x20-\\x7E]", "g") : l = new RegExp(`${g9(Array.from(a))}`, "g");
    const c = new gh(null, l), h = [];
    let d = !1, u, f = 0, g = 0, m = 0;
    e: for (let _ = n, b = o; _ <= b; _++) {
      const C = e.getLineContent(_), v = C.length;
      c.reset(0);
      do
        if (u = c.next(C), u) {
          let w = u.index, S = u.index + u[0].length;
          if (w > 0) {
            const E = C.charCodeAt(w - 1);
            hi(E) && w--;
          }
          if (S + 1 < v) {
            const E = C.charCodeAt(S - 1);
            hi(E) && S++;
          }
          const L = C.substring(w, S);
          let k = Nf(w + 1, bL, C, 0);
          k && k.endColumn <= w + 1 && (k = null);
          const D = r.shouldHighlightNonBasicASCII(L, k ? k.word : null);
          if (D !== 0) {
            if (D === 3 ? f++ : D === 2 ? g++ : D === 1 ? m++ : jL(), h.length >= 1e3) {
              d = !0;
              break e;
            }
            h.push(new R(_, w + 1, _, S + 1));
          }
        }
      while (u);
    }
    return {
      ranges: h,
      hasMore: d,
      ambiguousCharacterCount: f,
      invisibleCharacterCount: g,
      nonBasicAsciiCharacterCount: m
    };
  }
  static computeUnicodeHighlightReason(e, t) {
    const i = new uE(t);
    switch (i.shouldHighlightNonBasicASCII(e, null)) {
      case 0:
        return null;
      case 2:
        return {
          kind: 1
          /* UnicodeHighlighterReasonKind.Invisible */
        };
      case 3: {
        const o = e.codePointAt(0), r = i.ambiguousCharacters.getPrimaryConfusable(o), a = Pf.getLocales().filter((l) => !Pf.getInstance(/* @__PURE__ */ new Set([...t.allowedLocales, l])).isAmbiguous(o));
        return { kind: 0, confusableWith: String.fromCodePoint(r), notAmbiguousInLocales: a };
      }
      case 1:
        return {
          kind: 2
          /* UnicodeHighlighterReasonKind.NonBasicAscii */
        };
    }
  }
}
function g9(s, e) {
  return `[${Yr(s.map((i) => String.fromCodePoint(i)).join(""))}]`;
}
class uE {
  constructor(e) {
    this.options = e, this.allowedCodePoints = new Set(e.allowedCodePoints), this.ambiguousCharacters = Pf.getInstance(new Set(e.allowedLocales));
  }
  getCandidateCodePoints() {
    if (this.options.nonBasicASCII)
      return "allNonBasicAscii";
    const e = /* @__PURE__ */ new Set();
    if (this.options.invisibleCharacters)
      for (const t of Bu.codePoints)
        fE(String.fromCodePoint(t)) || e.add(t);
    if (this.options.ambiguousCharacters)
      for (const t of this.ambiguousCharacters.getConfusableCodePoints())
        e.add(t);
    for (const t of this.allowedCodePoints)
      e.delete(t);
    return e;
  }
  shouldHighlightNonBasicASCII(e, t) {
    const i = e.codePointAt(0);
    if (this.allowedCodePoints.has(i))
      return 0;
    if (this.options.nonBasicASCII)
      return 1;
    let n = !1, o = !1;
    if (t)
      for (const r of t) {
        const a = r.codePointAt(0), l = ML(r);
        n = n || l, !l && !this.ambiguousCharacters.isAmbiguous(a) && !Bu.isInvisibleCharacter(a) && (o = !0);
      }
    return (
      /* Don't allow mixing weird looking characters with ASCII */
      !n && /* Is there an obviously weird looking character? */
      o ? 0 : this.options.invisibleCharacters && !fE(e) && Bu.isInvisibleCharacter(i) ? 2 : this.options.ambiguousCharacters && this.ambiguousCharacters.isAmbiguous(i) ? 3 : 0
    );
  }
}
function fE(s) {
  return s === " " || s === `
` || s === "	";
}
class Zm {
  constructor(e, t, i) {
    this.changes = e, this.moves = t, this.hitTimeout = i;
  }
}
class QM {
  constructor(e, t) {
    this.lineRangeMapping = e, this.changes = t;
  }
}
class xe {
  static addRange(e, t) {
    let i = 0;
    for (; i < t.length && t[i].endExclusive < e.start; )
      i++;
    let n = i;
    for (; n < t.length && t[n].start <= e.endExclusive; )
      n++;
    if (i === n)
      t.splice(i, 0, e);
    else {
      const o = Math.min(e.start, t[i].start), r = Math.max(e.endExclusive, t[n - 1].endExclusive);
      t.splice(i, n - i, new xe(o, r));
    }
  }
  static tryCreate(e, t) {
    if (!(e > t))
      return new xe(e, t);
  }
  static ofLength(e) {
    return new xe(0, e);
  }
  static ofStartAndLength(e, t) {
    return new xe(e, e + t);
  }
  constructor(e, t) {
    if (this.start = e, this.endExclusive = t, e > t)
      throw new it(`Invalid range: ${this.toString()}`);
  }
  get isEmpty() {
    return this.start === this.endExclusive;
  }
  delta(e) {
    return new xe(this.start + e, this.endExclusive + e);
  }
  deltaStart(e) {
    return new xe(this.start + e, this.endExclusive);
  }
  deltaEnd(e) {
    return new xe(this.start, this.endExclusive + e);
  }
  get length() {
    return this.endExclusive - this.start;
  }
  toString() {
    return `[${this.start}, ${this.endExclusive})`;
  }
  contains(e) {
    return this.start <= e && e < this.endExclusive;
  }
  /**
   * for all numbers n: range1.contains(n) or range2.contains(n) => range1.join(range2).contains(n)
   * The joined range is the smallest range that contains both ranges.
   */
  join(e) {
    return new xe(Math.min(this.start, e.start), Math.max(this.endExclusive, e.endExclusive));
  }
  /**
   * for all numbers n: range1.contains(n) and range2.contains(n) <=> range1.intersect(range2).contains(n)
   *
   * The resulting range is empty if the ranges do not intersect, but touch.
   * If the ranges don't even touch, the result is undefined.
   */
  intersect(e) {
    const t = Math.max(this.start, e.start), i = Math.min(this.endExclusive, e.endExclusive);
    if (t <= i)
      return new xe(t, i);
  }
  intersects(e) {
    const t = Math.max(this.start, e.start), i = Math.min(this.endExclusive, e.endExclusive);
    return t < i;
  }
  isBefore(e) {
    return this.endExclusive <= e.start;
  }
  isAfter(e) {
    return this.start >= e.endExclusive;
  }
  slice(e) {
    return e.slice(this.start, this.endExclusive);
  }
  substring(e) {
    return e.substring(this.start, this.endExclusive);
  }
  /**
   * Returns the given value if it is contained in this instance, otherwise the closest value that is contained.
   * The range must not be empty.
   */
  clip(e) {
    if (this.isEmpty)
      throw new it(`Invalid clipping range: ${this.toString()}`);
    return Math.max(this.start, Math.min(this.endExclusive - 1, e));
  }
  /**
   * Returns `r := value + k * length` such that `r` is contained in this range.
   * The range must not be empty.
   *
   * E.g. `[5, 10).clipCyclic(10) === 5`, `[5, 10).clipCyclic(11) === 6` and `[5, 10).clipCyclic(4) === 9`.
   */
  clipCyclic(e) {
    if (this.isEmpty)
      throw new it(`Invalid clipping range: ${this.toString()}`);
    return e < this.start ? this.endExclusive - (this.start - e) % this.length : e >= this.endExclusive ? this.start + (e - this.start) % this.length : e;
  }
  forEach(e) {
    for (let t = this.start; t < this.endExclusive; t++)
      e(t);
  }
}
class ek {
  constructor() {
    this._sortedRanges = [];
  }
  addRange(e) {
    let t = 0;
    for (; t < this._sortedRanges.length && this._sortedRanges[t].endExclusive < e.start; )
      t++;
    let i = t;
    for (; i < this._sortedRanges.length && this._sortedRanges[i].start <= e.endExclusive; )
      i++;
    if (t === i)
      this._sortedRanges.splice(t, 0, e);
    else {
      const n = Math.min(e.start, this._sortedRanges[t].start), o = Math.max(e.endExclusive, this._sortedRanges[i - 1].endExclusive);
      this._sortedRanges.splice(t, i - t, new xe(n, o));
    }
  }
  toString() {
    return this._sortedRanges.map((e) => e.toString()).join(", ");
  }
  /**
   * Returns of there is a value that is contained in this instance and the given range.
   */
  intersectsStrict(e) {
    let t = 0;
    for (; t < this._sortedRanges.length && this._sortedRanges[t].endExclusive <= e.start; )
      t++;
    return t < this._sortedRanges.length && this._sortedRanges[t].start < e.endExclusive;
  }
  intersectWithRange(e) {
    const t = new ek();
    for (const i of this._sortedRanges) {
      const n = i.intersect(e);
      n && t.addRange(n);
    }
    return t;
  }
  intersectWithRangeLength(e) {
    return this.intersectWithRange(e).length;
  }
  get length() {
    return this._sortedRanges.reduce((e, t) => e + t.length, 0);
  }
}
function Op(s, e) {
  const t = m9(s, e);
  if (t !== -1)
    return s[t];
}
function m9(s, e, t = s.length - 1) {
  for (let i = t; i >= 0; i--) {
    const n = s[i];
    if (e(n))
      return i;
  }
  return -1;
}
function Sd(s, e) {
  const t = Hf(s, e);
  return t === -1 ? void 0 : s[t];
}
function Hf(s, e, t = 0, i = s.length) {
  let n = t, o = i;
  for (; n < o; ) {
    const r = Math.floor((n + o) / 2);
    e(s[r]) ? n = r + 1 : o = r;
  }
  return n - 1;
}
function p9(s, e) {
  const t = uv(s, e);
  return t === s.length ? void 0 : s[t];
}
function uv(s, e, t = 0, i = s.length) {
  let n = t, o = i;
  for (; n < o; ) {
    const r = Math.floor((n + o) / 2);
    e(s[r]) ? o = r : n = r + 1;
  }
  return n;
}
const m1 = class m1 {
  constructor(e) {
    this._array = e, this._findLastMonotonousLastIdx = 0;
  }
  /**
   * The predicate must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!
   * For subsequent calls, current predicate must be weaker than (or equal to) the previous predicate, i.e. more entries must be `true`.
   */
  findLastMonotonous(e) {
    if (m1.assertInvariants) {
      if (this._prevFindLastPredicate) {
        for (const i of this._array)
          if (this._prevFindLastPredicate(i) && !e(i))
            throw new Error("MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.");
      }
      this._prevFindLastPredicate = e;
    }
    const t = Hf(this._array, e, this._findLastMonotonousLastIdx);
    return this._findLastMonotonousLastIdx = t + 1, t === -1 ? void 0 : this._array[t];
  }
};
m1.assertInvariants = !1;
let Fp = m1;
function XM(s, e) {
  if (s.length === 0)
    return;
  let t = s[0];
  for (let i = 1; i < s.length; i++) {
    const n = s[i];
    e(n, t) > 0 && (t = n);
  }
  return t;
}
function _9(s, e) {
  if (s.length === 0)
    return;
  let t = s[0];
  for (let i = 1; i < s.length; i++) {
    const n = s[i];
    e(n, t) >= 0 && (t = n);
  }
  return t;
}
function b9(s, e) {
  return XM(s, (t, i) => -e(t, i));
}
function C9(s, e) {
  if (s.length === 0)
    return -1;
  let t = 0;
  for (let i = 1; i < s.length; i++) {
    const n = s[i];
    e(n, s[t]) > 0 && (t = i);
  }
  return t;
}
let we = class lr {
  static fromRangeInclusive(e) {
    return new lr(e.startLineNumber, e.endLineNumber + 1);
  }
  /**
   * @param lineRanges An array of sorted line ranges.
   */
  static joinMany(e) {
    if (e.length === 0)
      return [];
    let t = new hs(e[0].slice());
    for (let i = 1; i < e.length; i++)
      t = t.getUnion(new hs(e[i].slice()));
    return t.ranges;
  }
  static join(e) {
    if (e.length === 0)
      throw new it("lineRanges cannot be empty");
    let t = e[0].startLineNumber, i = e[0].endLineNumberExclusive;
    for (let n = 1; n < e.length; n++)
      t = Math.min(t, e[n].startLineNumber), i = Math.max(i, e[n].endLineNumberExclusive);
    return new lr(t, i);
  }
  static ofLength(e, t) {
    return new lr(e, e + t);
  }
  /**
   * @internal
   */
  static deserialize(e) {
    return new lr(e[0], e[1]);
  }
  constructor(e, t) {
    if (e > t)
      throw new it(`startLineNumber ${e} cannot be after endLineNumberExclusive ${t}`);
    this.startLineNumber = e, this.endLineNumberExclusive = t;
  }
  /**
   * Indicates if this line range contains the given line number.
   */
  contains(e) {
    return this.startLineNumber <= e && e < this.endLineNumberExclusive;
  }
  /**
   * Indicates if this line range is empty.
   */
  get isEmpty() {
    return this.startLineNumber === this.endLineNumberExclusive;
  }
  /**
   * Moves this line range by the given offset of line numbers.
   */
  delta(e) {
    return new lr(this.startLineNumber + e, this.endLineNumberExclusive + e);
  }
  deltaLength(e) {
    return new lr(this.startLineNumber, this.endLineNumberExclusive + e);
  }
  /**
   * The number of lines this line range spans.
   */
  get length() {
    return this.endLineNumberExclusive - this.startLineNumber;
  }
  /**
   * Creates a line range that combines this and the given line range.
   */
  join(e) {
    return new lr(Math.min(this.startLineNumber, e.startLineNumber), Math.max(this.endLineNumberExclusive, e.endLineNumberExclusive));
  }
  toString() {
    return `[${this.startLineNumber},${this.endLineNumberExclusive})`;
  }
  /**
   * The resulting range is empty if the ranges do not intersect, but touch.
   * If the ranges don't even touch, the result is undefined.
   */
  intersect(e) {
    const t = Math.max(this.startLineNumber, e.startLineNumber), i = Math.min(this.endLineNumberExclusive, e.endLineNumberExclusive);
    if (t <= i)
      return new lr(t, i);
  }
  intersectsStrict(e) {
    return this.startLineNumber < e.endLineNumberExclusive && e.startLineNumber < this.endLineNumberExclusive;
  }
  overlapOrTouch(e) {
    return this.startLineNumber <= e.endLineNumberExclusive && e.startLineNumber <= this.endLineNumberExclusive;
  }
  equals(e) {
    return this.startLineNumber === e.startLineNumber && this.endLineNumberExclusive === e.endLineNumberExclusive;
  }
  toInclusiveRange() {
    return this.isEmpty ? null : new R(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);
  }
  /**
   * @deprecated Using this function is discouraged because it might lead to bugs: The end position is not guaranteed to be a valid position!
  */
  toExclusiveRange() {
    return new R(this.startLineNumber, 1, this.endLineNumberExclusive, 1);
  }
  mapToLineArray(e) {
    const t = [];
    for (let i = this.startLineNumber; i < this.endLineNumberExclusive; i++)
      t.push(e(i));
    return t;
  }
  forEach(e) {
    for (let t = this.startLineNumber; t < this.endLineNumberExclusive; t++)
      e(t);
  }
  /**
   * @internal
   */
  serialize() {
    return [this.startLineNumber, this.endLineNumberExclusive];
  }
  includes(e) {
    return this.startLineNumber <= e && e < this.endLineNumberExclusive;
  }
  /**
   * Converts this 1-based line range to a 0-based offset range (subtracts 1!).
   * @internal
   */
  toOffsetRange() {
    return new xe(this.startLineNumber - 1, this.endLineNumberExclusive - 1);
  }
};
class hs {
  constructor(e = []) {
    this._normalizedRanges = e;
  }
  get ranges() {
    return this._normalizedRanges;
  }
  addRange(e) {
    if (e.length === 0)
      return;
    const t = uv(this._normalizedRanges, (n) => n.endLineNumberExclusive >= e.startLineNumber), i = Hf(this._normalizedRanges, (n) => n.startLineNumber <= e.endLineNumberExclusive) + 1;
    if (t === i)
      this._normalizedRanges.splice(t, 0, e);
    else if (t === i - 1) {
      const n = this._normalizedRanges[t];
      this._normalizedRanges[t] = n.join(e);
    } else {
      const n = this._normalizedRanges[t].join(this._normalizedRanges[i - 1]).join(e);
      this._normalizedRanges.splice(t, i - t, n);
    }
  }
  contains(e) {
    const t = Sd(this._normalizedRanges, (i) => i.startLineNumber <= e);
    return !!t && t.endLineNumberExclusive > e;
  }
  intersects(e) {
    const t = Sd(this._normalizedRanges, (i) => i.startLineNumber < e.endLineNumberExclusive);
    return !!t && t.endLineNumberExclusive > e.startLineNumber;
  }
  getUnion(e) {
    if (this._normalizedRanges.length === 0)
      return e;
    if (e._normalizedRanges.length === 0)
      return this;
    const t = [];
    let i = 0, n = 0, o = null;
    for (; i < this._normalizedRanges.length || n < e._normalizedRanges.length; ) {
      let r = null;
      if (i < this._normalizedRanges.length && n < e._normalizedRanges.length) {
        const a = this._normalizedRanges[i], l = e._normalizedRanges[n];
        a.startLineNumber < l.startLineNumber ? (r = a, i++) : (r = l, n++);
      } else i < this._normalizedRanges.length ? (r = this._normalizedRanges[i], i++) : (r = e._normalizedRanges[n], n++);
      o === null ? o = r : o.endLineNumberExclusive >= r.startLineNumber ? o = new we(o.startLineNumber, Math.max(o.endLineNumberExclusive, r.endLineNumberExclusive)) : (t.push(o), o = r);
    }
    return o !== null && t.push(o), new hs(t);
  }
  /**
   * Subtracts all ranges in this set from `range` and returns the result.
   */
  subtractFrom(e) {
    const t = uv(this._normalizedRanges, (r) => r.endLineNumberExclusive >= e.startLineNumber), i = Hf(this._normalizedRanges, (r) => r.startLineNumber <= e.endLineNumberExclusive) + 1;
    if (t === i)
      return new hs([e]);
    const n = [];
    let o = e.startLineNumber;
    for (let r = t; r < i; r++) {
      const a = this._normalizedRanges[r];
      a.startLineNumber > o && n.push(new we(o, a.startLineNumber)), o = a.endLineNumberExclusive;
    }
    return o < e.endLineNumberExclusive && n.push(new we(o, e.endLineNumberExclusive)), new hs(n);
  }
  toString() {
    return this._normalizedRanges.map((e) => e.toString()).join(", ");
  }
  getIntersection(e) {
    const t = [];
    let i = 0, n = 0;
    for (; i < this._normalizedRanges.length && n < e._normalizedRanges.length; ) {
      const o = this._normalizedRanges[i], r = e._normalizedRanges[n], a = o.intersect(r);
      a && !a.isEmpty && t.push(a), o.endLineNumberExclusive < r.endLineNumberExclusive ? i++ : n++;
    }
    return new hs(t);
  }
  getWithDelta(e) {
    return new hs(this._normalizedRanges.map((t) => t.delta(e)));
  }
}
const pa = class pa {
  static betweenPositions(e, t) {
    return e.lineNumber === t.lineNumber ? new pa(0, t.column - e.column) : new pa(t.lineNumber - e.lineNumber, t.column - 1);
  }
  static ofRange(e) {
    return pa.betweenPositions(e.getStartPosition(), e.getEndPosition());
  }
  static ofText(e) {
    let t = 0, i = 0;
    for (const n of e)
      n === `
` ? (t++, i = 0) : i++;
    return new pa(t, i);
  }
  constructor(e, t) {
    this.lineCount = e, this.columnCount = t;
  }
  isGreaterThanOrEqualTo(e) {
    return this.lineCount !== e.lineCount ? this.lineCount > e.lineCount : this.columnCount >= e.columnCount;
  }
  createRange(e) {
    return this.lineCount === 0 ? new R(e.lineNumber, e.column, e.lineNumber, e.column + this.columnCount) : new R(e.lineNumber, e.column, e.lineNumber + this.lineCount, this.columnCount + 1);
  }
  addToPosition(e) {
    return this.lineCount === 0 ? new V(e.lineNumber, e.column + this.columnCount) : new V(e.lineNumber + this.lineCount, this.columnCount + 1);
  }
  toString() {
    return `${this.lineCount},${this.columnCount}`;
  }
};
pa.zero = new pa(0, 0);
let qa = pa;
class w9 {
  constructor(e) {
    this.text = e, this.lineStartOffsetByLineIdx = [], this.lineStartOffsetByLineIdx.push(0);
    for (let t = 0; t < e.length; t++)
      e.charAt(t) === `
` && this.lineStartOffsetByLineIdx.push(t + 1);
  }
  getOffset(e) {
    return this.lineStartOffsetByLineIdx[e.lineNumber - 1] + e.column - 1;
  }
  getOffsetRange(e) {
    return new xe(this.getOffset(e.getStartPosition()), this.getOffset(e.getEndPosition()));
  }
  get textLength() {
    const e = this.lineStartOffsetByLineIdx.length - 1;
    return new qa(e, this.text.length - this.lineStartOffsetByLineIdx[e]);
  }
}
class v9 {
  constructor(e) {
    this.edits = e, bc(() => GL(e, (t, i) => t.range.getEndPosition().isBeforeOrEqual(i.range.getStartPosition())));
  }
  apply(e) {
    let t = "", i = new V(1, 1);
    for (const o of this.edits) {
      const r = o.range, a = r.getStartPosition(), l = r.getEndPosition(), c = gE(i, a);
      c.isEmpty() || (t += e.getValueOfRange(c)), t += o.text, i = l;
    }
    const n = gE(i, e.endPositionExclusive);
    return n.isEmpty() || (t += e.getValueOfRange(n)), t;
  }
  applyToString(e) {
    const t = new S9(e);
    return this.apply(t);
  }
  getNewRanges() {
    const e = [];
    let t = 0, i = 0, n = 0;
    for (const o of this.edits) {
      const r = qa.ofText(o.text), a = V.lift({
        lineNumber: o.range.startLineNumber + i,
        column: o.range.startColumn + (o.range.startLineNumber === t ? n : 0)
      }), l = r.createRange(a);
      e.push(l), i = l.endLineNumber - o.range.endLineNumber, n = l.endColumn - o.range.endColumn, t = o.range.endLineNumber;
    }
    return e;
  }
}
class y9 {
  constructor(e, t) {
    this.range = e, this.text = t;
  }
  toSingleEditOperation() {
    return {
      range: this.range,
      text: this.text
    };
  }
}
function gE(s, e) {
  if (s.lineNumber === e.lineNumber && s.column === Number.MAX_SAFE_INTEGER)
    return R.fromPositions(e, e);
  if (!s.isBeforeOrEqual(e))
    throw new it("start must be before end");
  return new R(s.lineNumber, s.column, e.lineNumber, e.column);
}
class JM {
  get endPositionExclusive() {
    return this.length.addToPosition(new V(1, 1));
  }
}
class S9 extends JM {
  constructor(e) {
    super(), this.value = e, this._t = new w9(this.value);
  }
  getValueOfRange(e) {
    return this._t.getOffsetRange(e).substring(this.value);
  }
  get length() {
    return this._t.textLength;
  }
}
class ji {
  static inverse(e, t, i) {
    const n = [];
    let o = 1, r = 1;
    for (const l of e) {
      const c = new ji(new we(o, l.original.startLineNumber), new we(r, l.modified.startLineNumber));
      c.modified.isEmpty || n.push(c), o = l.original.endLineNumberExclusive, r = l.modified.endLineNumberExclusive;
    }
    const a = new ji(new we(o, t + 1), new we(r, i + 1));
    return a.modified.isEmpty || n.push(a), n;
  }
  static clip(e, t, i) {
    const n = [];
    for (const o of e) {
      const r = o.original.intersect(t), a = o.modified.intersect(i);
      r && !r.isEmpty && a && !a.isEmpty && n.push(new ji(r, a));
    }
    return n;
  }
  constructor(e, t) {
    this.original = e, this.modified = t;
  }
  toString() {
    return `{${this.original.toString()}->${this.modified.toString()}}`;
  }
  flip() {
    return new ji(this.modified, this.original);
  }
  join(e) {
    return new ji(this.original.join(e.original), this.modified.join(e.modified));
  }
  /**
   * This method assumes that the LineRangeMapping describes a valid diff!
   * I.e. if one range is empty, the other range cannot be the entire document.
   * It avoids various problems when the line range points to non-existing line-numbers.
  */
  toRangeMapping() {
    const e = this.original.toInclusiveRange(), t = this.modified.toInclusiveRange();
    if (e && t)
      return new Gn(e, t);
    if (this.original.startLineNumber === 1 || this.modified.startLineNumber === 1) {
      if (!(this.modified.startLineNumber === 1 && this.original.startLineNumber === 1))
        throw new it("not a valid diff");
      return new Gn(new R(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1), new R(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1));
    } else
      return new Gn(new R(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), new R(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER));
  }
  /**
   * This method assumes that the LineRangeMapping describes a valid diff!
   * I.e. if one range is empty, the other range cannot be the entire document.
   * It avoids various problems when the line range points to non-existing line-numbers.
  */
  toRangeMapping2(e, t) {
    if (mE(this.original.endLineNumberExclusive, e) && mE(this.modified.endLineNumberExclusive, t))
      return new Gn(new R(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1), new R(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1));
    if (!this.original.isEmpty && !this.modified.isEmpty)
      return new Gn(R.fromPositions(new V(this.original.startLineNumber, 1), Jc(new V(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), e)), R.fromPositions(new V(this.modified.startLineNumber, 1), Jc(new V(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), t)));
    if (this.original.startLineNumber > 1 && this.modified.startLineNumber > 1)
      return new Gn(R.fromPositions(Jc(new V(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER), e), Jc(new V(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), e)), R.fromPositions(Jc(new V(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER), t), Jc(new V(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), t)));
    throw new it();
  }
}
function Jc(s, e) {
  if (s.lineNumber < 1)
    return new V(1, 1);
  if (s.lineNumber > e.length)
    return new V(e.length, e[e.length - 1].length + 1);
  const t = e[s.lineNumber - 1];
  return s.column > t.length + 1 ? new V(s.lineNumber, t.length + 1) : s;
}
function mE(s, e) {
  return s >= 1 && s <= e.length;
}
class is extends ji {
  static fromRangeMappings(e) {
    const t = we.join(e.map((n) => we.fromRangeInclusive(n.originalRange))), i = we.join(e.map((n) => we.fromRangeInclusive(n.modifiedRange)));
    return new is(t, i, e);
  }
  constructor(e, t, i) {
    super(e, t), this.innerChanges = i;
  }
  flip() {
    var e;
    return new is(this.modified, this.original, (e = this.innerChanges) == null ? void 0 : e.map((t) => t.flip()));
  }
  withInnerChangesFromLineRanges() {
    return new is(this.original, this.modified, [this.toRangeMapping()]);
  }
}
class Gn {
  static assertSorted(e) {
    for (let t = 1; t < e.length; t++) {
      const i = e[t - 1], n = e[t];
      if (!(i.originalRange.getEndPosition().isBeforeOrEqual(n.originalRange.getStartPosition()) && i.modifiedRange.getEndPosition().isBeforeOrEqual(n.modifiedRange.getStartPosition())))
        throw new it("Range mappings must be sorted");
    }
  }
  constructor(e, t) {
    this.originalRange = e, this.modifiedRange = t;
  }
  toString() {
    return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;
  }
  flip() {
    return new Gn(this.modifiedRange, this.originalRange);
  }
  /**
   * Creates a single text edit that describes the change from the original to the modified text.
  */
  toTextEdit(e) {
    const t = e.getValueOfRange(this.modifiedRange);
    return new y9(this.originalRange, t);
  }
}
const L9 = 3;
class k9 {
  computeDiff(e, t, i) {
    var l;
    const o = new E9(e, t, {
      maxComputationTime: i.maxComputationTimeMs,
      shouldIgnoreTrimWhitespace: i.ignoreTrimWhitespace,
      shouldComputeCharChanges: !0,
      shouldMakePrettyDiff: !0,
      shouldPostProcessCharChanges: !0
    }).computeDiff(), r = [];
    let a = null;
    for (const c of o.changes) {
      let h;
      c.originalEndLineNumber === 0 ? h = new we(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1) : h = new we(c.originalStartLineNumber, c.originalEndLineNumber + 1);
      let d;
      c.modifiedEndLineNumber === 0 ? d = new we(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1) : d = new we(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);
      let u = new is(h, d, (l = c.charChanges) == null ? void 0 : l.map((f) => new Gn(new R(f.originalStartLineNumber, f.originalStartColumn, f.originalEndLineNumber, f.originalEndColumn), new R(f.modifiedStartLineNumber, f.modifiedStartColumn, f.modifiedEndLineNumber, f.modifiedEndColumn))));
      a && (a.modified.endLineNumberExclusive === u.modified.startLineNumber || a.original.endLineNumberExclusive === u.original.startLineNumber) && (u = new is(a.original.join(u.original), a.modified.join(u.modified), a.innerChanges && u.innerChanges ? a.innerChanges.concat(u.innerChanges) : void 0), r.pop()), r.push(u), a = u;
    }
    return bc(() => GL(r, (c, h) => h.original.startLineNumber - c.original.endLineNumberExclusive === h.modified.startLineNumber - c.modified.endLineNumberExclusive && // There has to be an unchanged line in between (otherwise both diffs should have been joined)
    c.original.endLineNumberExclusive < h.original.startLineNumber && c.modified.endLineNumberExclusive < h.modified.startLineNumber)), new Zm(r, [], o.quitEarly);
  }
}
function eR(s, e, t, i) {
  return new Er(s, e, t).ComputeDiff(i);
}
let pE = class {
  constructor(e) {
    const t = [], i = [];
    for (let n = 0, o = e.length; n < o; n++)
      t[n] = fv(e[n], 1), i[n] = gv(e[n], 1);
    this.lines = e, this._startColumns = t, this._endColumns = i;
  }
  getElements() {
    const e = [];
    for (let t = 0, i = this.lines.length; t < i; t++)
      e[t] = this.lines[t].substring(this._startColumns[t] - 1, this._endColumns[t] - 1);
    return e;
  }
  getStrictElement(e) {
    return this.lines[e];
  }
  getStartLineNumber(e) {
    return e + 1;
  }
  getEndLineNumber(e) {
    return e + 1;
  }
  createCharSequence(e, t, i) {
    const n = [], o = [], r = [];
    let a = 0;
    for (let l = t; l <= i; l++) {
      const c = this.lines[l], h = e ? this._startColumns[l] : 1, d = e ? this._endColumns[l] : c.length + 1;
      for (let u = h; u < d; u++)
        n[a] = c.charCodeAt(u - 1), o[a] = l + 1, r[a] = u, a++;
      !e && l < i && (n[a] = 10, o[a] = l + 1, r[a] = c.length + 1, a++);
    }
    return new x9(n, o, r);
  }
};
class x9 {
  constructor(e, t, i) {
    this._charCodes = e, this._lineNumbers = t, this._columns = i;
  }
  toString() {
    return "[" + this._charCodes.map((e, t) => (e === 10 ? "\\n" : String.fromCharCode(e)) + `-(${this._lineNumbers[t]},${this._columns[t]})`).join(", ") + "]";
  }
  _assertIndex(e, t) {
    if (e < 0 || e >= t.length)
      throw new Error("Illegal index");
  }
  getElements() {
    return this._charCodes;
  }
  getStartLineNumber(e) {
    return e > 0 && e === this._lineNumbers.length ? this.getEndLineNumber(e - 1) : (this._assertIndex(e, this._lineNumbers), this._lineNumbers[e]);
  }
  getEndLineNumber(e) {
    return e === -1 ? this.getStartLineNumber(e + 1) : (this._assertIndex(e, this._lineNumbers), this._charCodes[e] === 10 ? this._lineNumbers[e] + 1 : this._lineNumbers[e]);
  }
  getStartColumn(e) {
    return e > 0 && e === this._columns.length ? this.getEndColumn(e - 1) : (this._assertIndex(e, this._columns), this._columns[e]);
  }
  getEndColumn(e) {
    return e === -1 ? this.getStartColumn(e + 1) : (this._assertIndex(e, this._columns), this._charCodes[e] === 10 ? 1 : this._columns[e] + 1);
  }
}
class jh {
  constructor(e, t, i, n, o, r, a, l) {
    this.originalStartLineNumber = e, this.originalStartColumn = t, this.originalEndLineNumber = i, this.originalEndColumn = n, this.modifiedStartLineNumber = o, this.modifiedStartColumn = r, this.modifiedEndLineNumber = a, this.modifiedEndColumn = l;
  }
  static createFromDiffChange(e, t, i) {
    const n = t.getStartLineNumber(e.originalStart), o = t.getStartColumn(e.originalStart), r = t.getEndLineNumber(e.originalStart + e.originalLength - 1), a = t.getEndColumn(e.originalStart + e.originalLength - 1), l = i.getStartLineNumber(e.modifiedStart), c = i.getStartColumn(e.modifiedStart), h = i.getEndLineNumber(e.modifiedStart + e.modifiedLength - 1), d = i.getEndColumn(e.modifiedStart + e.modifiedLength - 1);
    return new jh(n, o, r, a, l, c, h, d);
  }
}
function D9(s) {
  if (s.length <= 1)
    return s;
  const e = [s[0]];
  let t = e[0];
  for (let i = 1, n = s.length; i < n; i++) {
    const o = s[i], r = o.originalStart - (t.originalStart + t.originalLength), a = o.modifiedStart - (t.modifiedStart + t.modifiedLength);
    Math.min(r, a) < L9 ? (t.originalLength = o.originalStart + o.originalLength - t.originalStart, t.modifiedLength = o.modifiedStart + o.modifiedLength - t.modifiedStart) : (e.push(o), t = o);
  }
  return e;
}
class Uu {
  constructor(e, t, i, n, o) {
    this.originalStartLineNumber = e, this.originalEndLineNumber = t, this.modifiedStartLineNumber = i, this.modifiedEndLineNumber = n, this.charChanges = o;
  }
  static createFromDiffResult(e, t, i, n, o, r, a) {
    let l, c, h, d, u;
    if (t.originalLength === 0 ? (l = i.getStartLineNumber(t.originalStart) - 1, c = 0) : (l = i.getStartLineNumber(t.originalStart), c = i.getEndLineNumber(t.originalStart + t.originalLength - 1)), t.modifiedLength === 0 ? (h = n.getStartLineNumber(t.modifiedStart) - 1, d = 0) : (h = n.getStartLineNumber(t.modifiedStart), d = n.getEndLineNumber(t.modifiedStart + t.modifiedLength - 1)), r && t.originalLength > 0 && t.originalLength < 20 && t.modifiedLength > 0 && t.modifiedLength < 20 && o()) {
      const f = i.createCharSequence(e, t.originalStart, t.originalStart + t.originalLength - 1), g = n.createCharSequence(e, t.modifiedStart, t.modifiedStart + t.modifiedLength - 1);
      if (f.getElements().length > 0 && g.getElements().length > 0) {
        let m = eR(f, g, o, !0).changes;
        a && (m = D9(m)), u = [];
        for (let _ = 0, b = m.length; _ < b; _++)
          u.push(jh.createFromDiffChange(m[_], f, g));
      }
    }
    return new Uu(l, c, h, d, u);
  }
}
class E9 {
  constructor(e, t, i) {
    this.shouldComputeCharChanges = i.shouldComputeCharChanges, this.shouldPostProcessCharChanges = i.shouldPostProcessCharChanges, this.shouldIgnoreTrimWhitespace = i.shouldIgnoreTrimWhitespace, this.shouldMakePrettyDiff = i.shouldMakePrettyDiff, this.originalLines = e, this.modifiedLines = t, this.original = new pE(e), this.modified = new pE(t), this.continueLineDiff = _E(i.maxComputationTime), this.continueCharDiff = _E(i.maxComputationTime === 0 ? 0 : Math.min(i.maxComputationTime, 5e3));
  }
  computeDiff() {
    if (this.original.lines.length === 1 && this.original.lines[0].length === 0)
      return this.modified.lines.length === 1 && this.modified.lines[0].length === 0 ? {
        quitEarly: !1,
        changes: []
      } : {
        quitEarly: !1,
        changes: [{
          originalStartLineNumber: 1,
          originalEndLineNumber: 1,
          modifiedStartLineNumber: 1,
          modifiedEndLineNumber: this.modified.lines.length,
          charChanges: void 0
        }]
      };
    if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0)
      return {
        quitEarly: !1,
        changes: [{
          originalStartLineNumber: 1,
          originalEndLineNumber: this.original.lines.length,
          modifiedStartLineNumber: 1,
          modifiedEndLineNumber: 1,
          charChanges: void 0
        }]
      };
    const e = eR(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff), t = e.changes, i = e.quitEarly;
    if (this.shouldIgnoreTrimWhitespace) {
      const a = [];
      for (let l = 0, c = t.length; l < c; l++)
        a.push(Uu.createFromDiffResult(this.shouldIgnoreTrimWhitespace, t[l], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
      return {
        quitEarly: i,
        changes: a
      };
    }
    const n = [];
    let o = 0, r = 0;
    for (let a = -1, l = t.length; a < l; a++) {
      const c = a + 1 < l ? t[a + 1] : null, h = c ? c.originalStart : this.originalLines.length, d = c ? c.modifiedStart : this.modifiedLines.length;
      for (; o < h && r < d; ) {
        const u = this.originalLines[o], f = this.modifiedLines[r];
        if (u !== f) {
          {
            let g = fv(u, 1), m = fv(f, 1);
            for (; g > 1 && m > 1; ) {
              const _ = u.charCodeAt(g - 2), b = f.charCodeAt(m - 2);
              if (_ !== b)
                break;
              g--, m--;
            }
            (g > 1 || m > 1) && this._pushTrimWhitespaceCharChange(n, o + 1, 1, g, r + 1, 1, m);
          }
          {
            let g = gv(u, 1), m = gv(f, 1);
            const _ = u.length + 1, b = f.length + 1;
            for (; g < _ && m < b; ) {
              const C = u.charCodeAt(g - 1), v = u.charCodeAt(m - 1);
              if (C !== v)
                break;
              g++, m++;
            }
            (g < _ || m < b) && this._pushTrimWhitespaceCharChange(n, o + 1, g, _, r + 1, m, b);
          }
        }
        o++, r++;
      }
      c && (n.push(Uu.createFromDiffResult(this.shouldIgnoreTrimWhitespace, c, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges)), o += c.originalLength, r += c.modifiedLength);
    }
    return {
      quitEarly: i,
      changes: n
    };
  }
  _pushTrimWhitespaceCharChange(e, t, i, n, o, r, a) {
    if (this._mergeTrimWhitespaceCharChange(e, t, i, n, o, r, a))
      return;
    let l;
    this.shouldComputeCharChanges && (l = [new jh(t, i, t, n, o, r, o, a)]), e.push(new Uu(t, t, o, o, l));
  }
  _mergeTrimWhitespaceCharChange(e, t, i, n, o, r, a) {
    const l = e.length;
    if (l === 0)
      return !1;
    const c = e[l - 1];
    return c.originalEndLineNumber === 0 || c.modifiedEndLineNumber === 0 ? !1 : c.originalEndLineNumber === t && c.modifiedEndLineNumber === o ? (this.shouldComputeCharChanges && c.charChanges && c.charChanges.push(new jh(t, i, t, n, o, r, o, a)), !0) : c.originalEndLineNumber + 1 === t && c.modifiedEndLineNumber + 1 === o ? (c.originalEndLineNumber = t, c.modifiedEndLineNumber = o, this.shouldComputeCharChanges && c.charChanges && c.charChanges.push(new jh(t, i, t, n, o, r, o, a)), !0) : !1;
  }
}
function fv(s, e) {
  const t = On(s);
  return t === -1 ? e : t + 1;
}
function gv(s, e) {
  const t = Ec(s);
  return t === -1 ? e : t + 2;
}
function _E(s) {
  if (s === 0)
    return () => !0;
  const e = Date.now();
  return () => Date.now() - e < s;
}
class $r {
  static trivial(e, t) {
    return new $r([new ti(xe.ofLength(e.length), xe.ofLength(t.length))], !1);
  }
  static trivialTimedOut(e, t) {
    return new $r([new ti(xe.ofLength(e.length), xe.ofLength(t.length))], !0);
  }
  constructor(e, t) {
    this.diffs = e, this.hitTimeout = t;
  }
}
class ti {
  static invert(e, t) {
    const i = [];
    return _2(e, (n, o) => {
      i.push(ti.fromOffsetPairs(n ? n.getEndExclusives() : Rr.zero, o ? o.getStarts() : new Rr(t, (n ? n.seq2Range.endExclusive - n.seq1Range.endExclusive : 0) + t)));
    }), i;
  }
  static fromOffsetPairs(e, t) {
    return new ti(new xe(e.offset1, t.offset1), new xe(e.offset2, t.offset2));
  }
  static assertSorted(e) {
    let t;
    for (const i of e) {
      if (t && !(t.seq1Range.endExclusive <= i.seq1Range.start && t.seq2Range.endExclusive <= i.seq2Range.start))
        throw new it("Sequence diffs must be sorted");
      t = i;
    }
  }
  constructor(e, t) {
    this.seq1Range = e, this.seq2Range = t;
  }
  swap() {
    return new ti(this.seq2Range, this.seq1Range);
  }
  toString() {
    return `${this.seq1Range} <-> ${this.seq2Range}`;
  }
  join(e) {
    return new ti(this.seq1Range.join(e.seq1Range), this.seq2Range.join(e.seq2Range));
  }
  delta(e) {
    return e === 0 ? this : new ti(this.seq1Range.delta(e), this.seq2Range.delta(e));
  }
  deltaStart(e) {
    return e === 0 ? this : new ti(this.seq1Range.deltaStart(e), this.seq2Range.deltaStart(e));
  }
  deltaEnd(e) {
    return e === 0 ? this : new ti(this.seq1Range.deltaEnd(e), this.seq2Range.deltaEnd(e));
  }
  intersect(e) {
    const t = this.seq1Range.intersect(e.seq1Range), i = this.seq2Range.intersect(e.seq2Range);
    if (!(!t || !i))
      return new ti(t, i);
  }
  getStarts() {
    return new Rr(this.seq1Range.start, this.seq2Range.start);
  }
  getEndExclusives() {
    return new Rr(this.seq1Range.endExclusive, this.seq2Range.endExclusive);
  }
}
const Vl = class Vl {
  constructor(e, t) {
    this.offset1 = e, this.offset2 = t;
  }
  toString() {
    return `${this.offset1} <-> ${this.offset2}`;
  }
  delta(e) {
    return e === 0 ? this : new Vl(this.offset1 + e, this.offset2 + e);
  }
  equals(e) {
    return this.offset1 === e.offset1 && this.offset2 === e.offset2;
  }
};
Vl.zero = new Vl(0, 0), Vl.max = new Vl(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
let Rr = Vl;
const p1 = class p1 {
  isValid() {
    return !0;
  }
};
p1.instance = new p1();
let zf = p1;
class I9 {
  constructor(e) {
    if (this.timeout = e, this.startTime = Date.now(), this.valid = !0, e <= 0)
      throw new it("timeout must be positive");
  }
  // Recommendation: Set a log-point `{this.disable()}` in the body
  isValid() {
    if (!(Date.now() - this.startTime < this.timeout) && this.valid) {
      this.valid = !1;
      debugger;
    }
    return this.valid;
  }
}
class R0 {
  constructor(e, t) {
    this.width = e, this.height = t, this.array = [], this.array = new Array(e * t);
  }
  get(e, t) {
    return this.array[e + t * this.width];
  }
  set(e, t, i) {
    this.array[e + t * this.width] = i;
  }
}
function mv(s) {
  return s === 32 || s === 9;
}
const Cf = class Cf {
  static getKey(e) {
    let t = this.chrKeys.get(e);
    return t === void 0 && (t = this.chrKeys.size, this.chrKeys.set(e, t)), t;
  }
  constructor(e, t, i) {
    this.range = e, this.lines = t, this.source = i, this.histogram = [];
    let n = 0;
    for (let o = e.startLineNumber - 1; o < e.endLineNumberExclusive - 1; o++) {
      const r = t[o];
      for (let l = 0; l < r.length; l++) {
        n++;
        const c = r[l], h = Cf.getKey(c);
        this.histogram[h] = (this.histogram[h] || 0) + 1;
      }
      n++;
      const a = Cf.getKey(`
`);
      this.histogram[a] = (this.histogram[a] || 0) + 1;
    }
    this.totalCount = n;
  }
  computeSimilarity(e) {
    let t = 0;
    const i = Math.max(this.histogram.length, e.histogram.length);
    for (let n = 0; n < i; n++)
      t += Math.abs((this.histogram[n] ?? 0) - (e.histogram[n] ?? 0));
    return 1 - t / (this.totalCount + e.totalCount);
  }
};
Cf.chrKeys = /* @__PURE__ */ new Map();
let Bp = Cf;
class N9 {
  compute(e, t, i = zf.instance, n) {
    if (e.length === 0 || t.length === 0)
      return $r.trivial(e, t);
    const o = new R0(e.length, t.length), r = new R0(e.length, t.length), a = new R0(e.length, t.length);
    for (let g = 0; g < e.length; g++)
      for (let m = 0; m < t.length; m++) {
        if (!i.isValid())
          return $r.trivialTimedOut(e, t);
        const _ = g === 0 ? 0 : o.get(g - 1, m), b = m === 0 ? 0 : o.get(g, m - 1);
        let C;
        e.getElement(g) === t.getElement(m) ? (g === 0 || m === 0 ? C = 0 : C = o.get(g - 1, m - 1), g > 0 && m > 0 && r.get(g - 1, m - 1) === 3 && (C += a.get(g - 1, m - 1)), C += n ? n(g, m) : 1) : C = -1;
        const v = Math.max(_, b, C);
        if (v === C) {
          const w = g > 0 && m > 0 ? a.get(g - 1, m - 1) : 0;
          a.set(g, m, w + 1), r.set(g, m, 3);
        } else v === _ ? (a.set(g, m, 0), r.set(g, m, 1)) : v === b && (a.set(g, m, 0), r.set(g, m, 2));
        o.set(g, m, v);
      }
    const l = [];
    let c = e.length, h = t.length;
    function d(g, m) {
      (g + 1 !== c || m + 1 !== h) && l.push(new ti(new xe(g + 1, c), new xe(m + 1, h))), c = g, h = m;
    }
    let u = e.length - 1, f = t.length - 1;
    for (; u >= 0 && f >= 0; )
      r.get(u, f) === 3 ? (d(u, f), u--, f--) : r.get(u, f) === 1 ? u-- : f--;
    return d(-1, -1), l.reverse(), new $r(l, !1);
  }
}
class tR {
  compute(e, t, i = zf.instance) {
    if (e.length === 0 || t.length === 0)
      return $r.trivial(e, t);
    const n = e, o = t;
    function r(m, _) {
      for (; m < n.length && _ < o.length && n.getElement(m) === o.getElement(_); )
        m++, _++;
      return m;
    }
    let a = 0;
    const l = new T9();
    l.set(0, r(0, 0));
    const c = new M9();
    c.set(0, l.get(0) === 0 ? null : new bE(null, 0, 0, l.get(0)));
    let h = 0;
    e: for (; ; ) {
      if (a++, !i.isValid())
        return $r.trivialTimedOut(n, o);
      const m = -Math.min(a, o.length + a % 2), _ = Math.min(a, n.length + a % 2);
      for (h = m; h <= _; h += 2) {
        const b = h === _ ? -1 : l.get(h + 1), C = h === m ? -1 : l.get(h - 1) + 1, v = Math.min(Math.max(b, C), n.length), w = v - h;
        if (v > n.length || w > o.length)
          continue;
        const S = r(v, w);
        l.set(h, S);
        const L = v === b ? c.get(h + 1) : c.get(h - 1);
        if (c.set(h, S !== v ? new bE(L, v, w, S - v) : L), l.get(h) === n.length && l.get(h) - h === o.length)
          break e;
      }
    }
    let d = c.get(h);
    const u = [];
    let f = n.length, g = o.length;
    for (; ; ) {
      const m = d ? d.x + d.length : 0, _ = d ? d.y + d.length : 0;
      if ((m !== f || _ !== g) && u.push(new ti(new xe(m, f), new xe(_, g))), !d)
        break;
      f = d.x, g = d.y, d = d.prev;
    }
    return u.reverse(), new $r(u, !1);
  }
}
class bE {
  constructor(e, t, i, n) {
    this.prev = e, this.x = t, this.y = i, this.length = n;
  }
}
class T9 {
  constructor() {
    this.positiveArr = new Int32Array(10), this.negativeArr = new Int32Array(10);
  }
  get(e) {
    return e < 0 ? (e = -e - 1, this.negativeArr[e]) : this.positiveArr[e];
  }
  set(e, t) {
    if (e < 0) {
      if (e = -e - 1, e >= this.negativeArr.length) {
        const i = this.negativeArr;
        this.negativeArr = new Int32Array(i.length * 2), this.negativeArr.set(i);
      }
      this.negativeArr[e] = t;
    } else {
      if (e >= this.positiveArr.length) {
        const i = this.positiveArr;
        this.positiveArr = new Int32Array(i.length * 2), this.positiveArr.set(i);
      }
      this.positiveArr[e] = t;
    }
  }
}
class M9 {
  constructor() {
    this.positiveArr = [], this.negativeArr = [];
  }
  get(e) {
    return e < 0 ? (e = -e - 1, this.negativeArr[e]) : this.positiveArr[e];
  }
  set(e, t) {
    e < 0 ? (e = -e - 1, this.negativeArr[e] = t) : this.positiveArr[e] = t;
  }
}
class Wp {
  constructor(e, t, i) {
    this.lines = e, this.range = t, this.considerWhitespaceChanges = i, this.elements = [], this.firstElementOffsetByLineIdx = [], this.lineStartOffsets = [], this.trimmedWsLengthsByLineIdx = [], this.firstElementOffsetByLineIdx.push(0);
    for (let n = this.range.startLineNumber; n <= this.range.endLineNumber; n++) {
      let o = e[n - 1], r = 0;
      n === this.range.startLineNumber && this.range.startColumn > 1 && (r = this.range.startColumn - 1, o = o.substring(r)), this.lineStartOffsets.push(r);
      let a = 0;
      if (!i) {
        const c = o.trimStart();
        a = o.length - c.length, o = c.trimEnd();
      }
      this.trimmedWsLengthsByLineIdx.push(a);
      const l = n === this.range.endLineNumber ? Math.min(this.range.endColumn - 1 - r - a, o.length) : o.length;
      for (let c = 0; c < l; c++)
        this.elements.push(o.charCodeAt(c));
      n < this.range.endLineNumber && (this.elements.push(10), this.firstElementOffsetByLineIdx.push(this.elements.length));
    }
  }
  toString() {
    return `Slice: "${this.text}"`;
  }
  get text() {
    return this.getText(new xe(0, this.length));
  }
  getText(e) {
    return this.elements.slice(e.start, e.endExclusive).map((t) => String.fromCharCode(t)).join("");
  }
  getElement(e) {
    return this.elements[e];
  }
  get length() {
    return this.elements.length;
  }
  getBoundaryScore(e) {
    const t = wE(e > 0 ? this.elements[e - 1] : -1), i = wE(e < this.elements.length ? this.elements[e] : -1);
    if (t === 7 && i === 8)
      return 0;
    if (t === 8)
      return 150;
    let n = 0;
    return t !== i && (n += 10, t === 0 && i === 1 && (n += 1)), n += CE(t), n += CE(i), n;
  }
  translateOffset(e, t = "right") {
    const i = Hf(this.firstElementOffsetByLineIdx, (o) => o <= e), n = e - this.firstElementOffsetByLineIdx[i];
    return new V(this.range.startLineNumber + i, 1 + this.lineStartOffsets[i] + n + (n === 0 && t === "left" ? 0 : this.trimmedWsLengthsByLineIdx[i]));
  }
  translateRange(e) {
    const t = this.translateOffset(e.start, "right"), i = this.translateOffset(e.endExclusive, "left");
    return i.isBefore(t) ? R.fromPositions(i, i) : R.fromPositions(t, i);
  }
  /**
   * Finds the word that contains the character at the given offset
   */
  findWordContaining(e) {
    if (e < 0 || e >= this.elements.length || !A0(this.elements[e]))
      return;
    let t = e;
    for (; t > 0 && A0(this.elements[t - 1]); )
      t--;
    let i = e;
    for (; i < this.elements.length && A0(this.elements[i]); )
      i++;
    return new xe(t, i);
  }
  countLinesIn(e) {
    return this.translateOffset(e.endExclusive).lineNumber - this.translateOffset(e.start).lineNumber;
  }
  isStronglyEqual(e, t) {
    return this.elements[e] === this.elements[t];
  }
  extendToFullLines(e) {
    const t = Sd(this.firstElementOffsetByLineIdx, (n) => n <= e.start) ?? 0, i = p9(this.firstElementOffsetByLineIdx, (n) => e.endExclusive <= n) ?? this.elements.length;
    return new xe(t, i);
  }
}
function A0(s) {
  return s >= 97 && s <= 122 || s >= 65 && s <= 90 || s >= 48 && s <= 57;
}
const R9 = {
  0: 0,
  1: 0,
  2: 0,
  3: 10,
  4: 2,
  5: 30,
  6: 3,
  7: 10,
  8: 10
};
function CE(s) {
  return R9[s];
}
function wE(s) {
  return s === 10 ? 8 : s === 13 ? 7 : mv(s) ? 6 : s >= 97 && s <= 122 ? 0 : s >= 65 && s <= 90 ? 1 : s >= 48 && s <= 57 ? 2 : s === -1 ? 3 : s === 44 || s === 59 ? 5 : 4;
}
function A9(s, e, t, i, n, o) {
  let { moves: r, excludedChanges: a } = O9(s, e, t, o);
  if (!o.isValid())
    return [];
  const l = s.filter((h) => !a.has(h)), c = F9(l, i, n, e, t, o);
  return EC(r, c), r = B9(r), r = r.filter((h) => {
    const d = h.original.toOffsetRange().slice(e).map((f) => f.trim());
    return d.join(`
`).length >= 15 && P9(d, (f) => f.length >= 2) >= 2;
  }), r = W9(s, r), r;
}
function P9(s, e) {
  let t = 0;
  for (const i of s)
    e(i) && t++;
  return t;
}
function O9(s, e, t, i) {
  const n = [], o = s.filter((l) => l.modified.isEmpty && l.original.length >= 3).map((l) => new Bp(l.original, e, l)), r = new Set(s.filter((l) => l.original.isEmpty && l.modified.length >= 3).map((l) => new Bp(l.modified, t, l))), a = /* @__PURE__ */ new Set();
  for (const l of o) {
    let c = -1, h;
    for (const d of r) {
      const u = l.computeSimilarity(d);
      u > c && (c = u, h = d);
    }
    if (c > 0.9 && h && (r.delete(h), n.push(new ji(l.range, h.range)), a.add(l.source), a.add(h.source)), !i.isValid())
      return { moves: n, excludedChanges: a };
  }
  return { moves: n, excludedChanges: a };
}
function F9(s, e, t, i, n, o) {
  const r = [], a = new YM();
  for (const u of s)
    for (let f = u.original.startLineNumber; f < u.original.endLineNumberExclusive - 2; f++) {
      const g = `${e[f - 1]}:${e[f + 1 - 1]}:${e[f + 2 - 1]}`;
      a.add(g, { range: new we(f, f + 3) });
    }
  const l = [];
  s.sort(Ts((u) => u.modified.startLineNumber, Aa));
  for (const u of s) {
    let f = [];
    for (let g = u.modified.startLineNumber; g < u.modified.endLineNumberExclusive - 2; g++) {
      const m = `${t[g - 1]}:${t[g + 1 - 1]}:${t[g + 2 - 1]}`, _ = new we(g, g + 3), b = [];
      a.forEach(m, ({ range: C }) => {
        for (const w of f)
          if (w.originalLineRange.endLineNumberExclusive + 1 === C.endLineNumberExclusive && w.modifiedLineRange.endLineNumberExclusive + 1 === _.endLineNumberExclusive) {
            w.originalLineRange = new we(w.originalLineRange.startLineNumber, C.endLineNumberExclusive), w.modifiedLineRange = new we(w.modifiedLineRange.startLineNumber, _.endLineNumberExclusive), b.push(w);
            return;
          }
        const v = {
          modifiedLineRange: _,
          originalLineRange: C
        };
        l.push(v), b.push(v);
      }), f = b;
    }
    if (!o.isValid())
      return [];
  }
  l.sort(z5(Ts((u) => u.modifiedLineRange.length, Aa)));
  const c = new hs(), h = new hs();
  for (const u of l) {
    const f = u.modifiedLineRange.startLineNumber - u.originalLineRange.startLineNumber, g = c.subtractFrom(u.modifiedLineRange), m = h.subtractFrom(u.originalLineRange).getWithDelta(f), _ = g.getIntersection(m);
    for (const b of _.ranges) {
      if (b.length < 3)
        continue;
      const C = b, v = b.delta(-f);
      r.push(new ji(v, C)), c.addRange(C), h.addRange(v);
    }
  }
  r.sort(Ts((u) => u.original.startLineNumber, Aa));
  const d = new Fp(s);
  for (let u = 0; u < r.length; u++) {
    const f = r[u], g = d.findLastMonotonous((L) => L.original.startLineNumber <= f.original.startLineNumber), m = Sd(s, (L) => L.modified.startLineNumber <= f.modified.startLineNumber), _ = Math.max(f.original.startLineNumber - g.original.startLineNumber, f.modified.startLineNumber - m.modified.startLineNumber), b = d.findLastMonotonous((L) => L.original.startLineNumber < f.original.endLineNumberExclusive), C = Sd(s, (L) => L.modified.startLineNumber < f.modified.endLineNumberExclusive), v = Math.max(b.original.endLineNumberExclusive - f.original.endLineNumberExclusive, C.modified.endLineNumberExclusive - f.modified.endLineNumberExclusive);
    let w;
    for (w = 0; w < _; w++) {
      const L = f.original.startLineNumber - w - 1, k = f.modified.startLineNumber - w - 1;
      if (L > i.length || k > n.length || c.contains(k) || h.contains(L) || !vE(i[L - 1], n[k - 1], o))
        break;
    }
    w > 0 && (h.addRange(new we(f.original.startLineNumber - w, f.original.startLineNumber)), c.addRange(new we(f.modified.startLineNumber - w, f.modified.startLineNumber)));
    let S;
    for (S = 0; S < v; S++) {
      const L = f.original.endLineNumberExclusive + S, k = f.modified.endLineNumberExclusive + S;
      if (L > i.length || k > n.length || c.contains(k) || h.contains(L) || !vE(i[L - 1], n[k - 1], o))
        break;
    }
    S > 0 && (h.addRange(new we(f.original.endLineNumberExclusive, f.original.endLineNumberExclusive + S)), c.addRange(new we(f.modified.endLineNumberExclusive, f.modified.endLineNumberExclusive + S))), (w > 0 || S > 0) && (r[u] = new ji(new we(f.original.startLineNumber - w, f.original.endLineNumberExclusive + S), new we(f.modified.startLineNumber - w, f.modified.endLineNumberExclusive + S)));
  }
  return r;
}
function vE(s, e, t) {
  if (s.trim() === e.trim())
    return !0;
  if (s.length > 300 && e.length > 300)
    return !1;
  const n = new tR().compute(new Wp([s], new R(1, 1, 1, s.length), !1), new Wp([e], new R(1, 1, 1, e.length), !1), t);
  let o = 0;
  const r = ti.invert(n.diffs, s.length);
  for (const h of r)
    h.seq1Range.forEach((d) => {
      mv(s.charCodeAt(d)) || o++;
    });
  function a(h) {
    let d = 0;
    for (let u = 0; u < s.length; u++)
      mv(h.charCodeAt(u)) || d++;
    return d;
  }
  const l = a(s.length > e.length ? s : e);
  return o / l > 0.6 && l > 10;
}
function B9(s) {
  if (s.length === 0)
    return s;
  s.sort(Ts((t) => t.original.startLineNumber, Aa));
  const e = [s[0]];
  for (let t = 1; t < s.length; t++) {
    const i = e[e.length - 1], n = s[t], o = n.original.startLineNumber - i.original.endLineNumberExclusive, r = n.modified.startLineNumber - i.modified.endLineNumberExclusive;
    if (o >= 0 && r >= 0 && o + r <= 2) {
      e[e.length - 1] = i.join(n);
      continue;
    }
    e.push(n);
  }
  return e;
}
function W9(s, e) {
  const t = new Fp(s);
  return e = e.filter((i) => {
    const n = t.findLastMonotonous((a) => a.original.startLineNumber < i.original.endLineNumberExclusive) || new ji(new we(1, 1), new we(1, 1)), o = Sd(s, (a) => a.modified.startLineNumber < i.modified.endLineNumberExclusive);
    return n !== o;
  }), e;
}
function pv(s, e, t) {
  let i = t;
  return i = yE(s, e, i), i = yE(s, e, i), i = V9(s, e, i), i;
}
function yE(s, e, t) {
  if (t.length === 0)
    return t;
  const i = [];
  i.push(t[0]);
  for (let o = 1; o < t.length; o++) {
    const r = i[i.length - 1];
    let a = t[o];
    if (a.seq1Range.isEmpty || a.seq2Range.isEmpty) {
      const l = a.seq1Range.start - r.seq1Range.endExclusive;
      let c;
      for (c = 1; c <= l && !(s.getElement(a.seq1Range.start - c) !== s.getElement(a.seq1Range.endExclusive - c) || e.getElement(a.seq2Range.start - c) !== e.getElement(a.seq2Range.endExclusive - c)); c++)
        ;
      if (c--, c === l) {
        i[i.length - 1] = new ti(new xe(r.seq1Range.start, a.seq1Range.endExclusive - l), new xe(r.seq2Range.start, a.seq2Range.endExclusive - l));
        continue;
      }
      a = a.delta(-c);
    }
    i.push(a);
  }
  const n = [];
  for (let o = 0; o < i.length - 1; o++) {
    const r = i[o + 1];
    let a = i[o];
    if (a.seq1Range.isEmpty || a.seq2Range.isEmpty) {
      const l = r.seq1Range.start - a.seq1Range.endExclusive;
      let c;
      for (c = 0; c < l && !(!s.isStronglyEqual(a.seq1Range.start + c, a.seq1Range.endExclusive + c) || !e.isStronglyEqual(a.seq2Range.start + c, a.seq2Range.endExclusive + c)); c++)
        ;
      if (c === l) {
        i[o + 1] = new ti(new xe(a.seq1Range.start + l, r.seq1Range.endExclusive), new xe(a.seq2Range.start + l, r.seq2Range.endExclusive));
        continue;
      }
      c > 0 && (a = a.delta(c));
    }
    n.push(a);
  }
  return i.length > 0 && n.push(i[i.length - 1]), n;
}
function V9(s, e, t) {
  if (!s.getBoundaryScore || !e.getBoundaryScore)
    return t;
  for (let i = 0; i < t.length; i++) {
    const n = i > 0 ? t[i - 1] : void 0, o = t[i], r = i + 1 < t.length ? t[i + 1] : void 0, a = new xe(n ? n.seq1Range.endExclusive + 1 : 0, r ? r.seq1Range.start - 1 : s.length), l = new xe(n ? n.seq2Range.endExclusive + 1 : 0, r ? r.seq2Range.start - 1 : e.length);
    o.seq1Range.isEmpty ? t[i] = SE(o, s, e, a, l) : o.seq2Range.isEmpty && (t[i] = SE(o.swap(), e, s, l, a).swap());
  }
  return t;
}
function SE(s, e, t, i, n) {
  let r = 1;
  for (; s.seq1Range.start - r >= i.start && s.seq2Range.start - r >= n.start && t.isStronglyEqual(s.seq2Range.start - r, s.seq2Range.endExclusive - r) && r < 100; )
    r++;
  r--;
  let a = 0;
  for (; s.seq1Range.start + a < i.endExclusive && s.seq2Range.endExclusive + a < n.endExclusive && t.isStronglyEqual(s.seq2Range.start + a, s.seq2Range.endExclusive + a) && a < 100; )
    a++;
  if (r === 0 && a === 0)
    return s;
  let l = 0, c = -1;
  for (let h = -r; h <= a; h++) {
    const d = s.seq2Range.start + h, u = s.seq2Range.endExclusive + h, f = s.seq1Range.start + h, g = e.getBoundaryScore(f) + t.getBoundaryScore(d) + t.getBoundaryScore(u);
    g > c && (c = g, l = h);
  }
  return s.delta(l);
}
function H9(s, e, t) {
  const i = [];
  for (const n of t) {
    const o = i[i.length - 1];
    if (!o) {
      i.push(n);
      continue;
    }
    n.seq1Range.start - o.seq1Range.endExclusive <= 2 || n.seq2Range.start - o.seq2Range.endExclusive <= 2 ? i[i.length - 1] = new ti(o.seq1Range.join(n.seq1Range), o.seq2Range.join(n.seq2Range)) : i.push(n);
  }
  return i;
}
function z9(s, e, t) {
  const i = ti.invert(t, s.length), n = [];
  let o = new Rr(0, 0);
  function r(l, c) {
    if (l.offset1 < o.offset1 || l.offset2 < o.offset2)
      return;
    const h = s.findWordContaining(l.offset1), d = e.findWordContaining(l.offset2);
    if (!h || !d)
      return;
    let u = new ti(h, d);
    const f = u.intersect(c);
    let g = f.seq1Range.length, m = f.seq2Range.length;
    for (; i.length > 0; ) {
      const _ = i[0];
      if (!(_.seq1Range.intersects(u.seq1Range) || _.seq2Range.intersects(u.seq2Range)))
        break;
      const C = s.findWordContaining(_.seq1Range.start), v = e.findWordContaining(_.seq2Range.start), w = new ti(C, v), S = w.intersect(_);
      if (g += S.seq1Range.length, m += S.seq2Range.length, u = u.join(w), u.seq1Range.endExclusive >= _.seq1Range.endExclusive)
        i.shift();
      else
        break;
    }
    g + m < (u.seq1Range.length + u.seq2Range.length) * 2 / 3 && n.push(u), o = u.getEndExclusives();
  }
  for (; i.length > 0; ) {
    const l = i.shift();
    l.seq1Range.isEmpty || (r(l.getStarts(), l), r(l.getEndExclusives().delta(-1), l));
  }
  return U9(t, n);
}
function U9(s, e) {
  const t = [];
  for (; s.length > 0 || e.length > 0; ) {
    const i = s[0], n = e[0];
    let o;
    i && (!n || i.seq1Range.start < n.seq1Range.start) ? o = s.shift() : o = e.shift(), t.length > 0 && t[t.length - 1].seq1Range.endExclusive >= o.seq1Range.start ? t[t.length - 1] = t[t.length - 1].join(o) : t.push(o);
  }
  return t;
}
function $9(s, e, t) {
  let i = t;
  if (i.length === 0)
    return i;
  let n = 0, o;
  do {
    o = !1;
    const r = [
      i[0]
    ];
    for (let a = 1; a < i.length; a++) {
      let l = function(u, f) {
        const g = new xe(h.seq1Range.endExclusive, c.seq1Range.start);
        return s.getText(g).replace(/\s/g, "").length <= 4 && (u.seq1Range.length + u.seq2Range.length > 5 || f.seq1Range.length + f.seq2Range.length > 5);
      };
      const c = i[a], h = r[r.length - 1];
      l(h, c) ? (o = !0, r[r.length - 1] = r[r.length - 1].join(c)) : r.push(c);
    }
    i = r;
  } while (n++ < 10 && o);
  return i;
}
function K9(s, e, t) {
  let i = t;
  if (i.length === 0)
    return i;
  let n = 0, o;
  do {
    o = !1;
    const a = [
      i[0]
    ];
    for (let l = 1; l < i.length; l++) {
      let c = function(f, g) {
        const m = new xe(d.seq1Range.endExclusive, h.seq1Range.start);
        if (s.countLinesIn(m) > 5 || m.length > 500)
          return !1;
        const b = s.getText(m).trim();
        if (b.length > 20 || b.split(/\r\n|\r|\n/).length > 1)
          return !1;
        const C = s.countLinesIn(f.seq1Range), v = f.seq1Range.length, w = e.countLinesIn(f.seq2Range), S = f.seq2Range.length, L = s.countLinesIn(g.seq1Range), k = g.seq1Range.length, D = e.countLinesIn(g.seq2Range), E = g.seq2Range.length, U = 130;
        function P(B) {
          return Math.min(B, U);
        }
        return Math.pow(Math.pow(P(C * 40 + v), 1.5) + Math.pow(P(w * 40 + S), 1.5), 1.5) + Math.pow(Math.pow(P(L * 40 + k), 1.5) + Math.pow(P(D * 40 + E), 1.5), 1.5) > (U ** 1.5) ** 1.5 * 1.3;
      };
      const h = i[l], d = a[a.length - 1];
      c(d, h) ? (o = !0, a[a.length - 1] = a[a.length - 1].join(h)) : a.push(h);
    }
    i = a;
  } while (n++ < 10 && o);
  const r = [];
  return F5(i, (a, l, c) => {
    let h = l;
    function d(b) {
      return b.length > 0 && b.trim().length <= 3 && l.seq1Range.length + l.seq2Range.length > 100;
    }
    const u = s.extendToFullLines(l.seq1Range), f = s.getText(new xe(u.start, l.seq1Range.start));
    d(f) && (h = h.deltaStart(-f.length));
    const g = s.getText(new xe(l.seq1Range.endExclusive, u.endExclusive));
    d(g) && (h = h.deltaEnd(g.length));
    const m = ti.fromOffsetPairs(a ? a.getEndExclusives() : Rr.zero, c ? c.getStarts() : Rr.max), _ = h.intersect(m);
    r.length > 0 && _.getStarts().equals(r[r.length - 1].getEndExclusives()) ? r[r.length - 1] = r[r.length - 1].join(_) : r.push(_);
  }), r;
}
class LE {
  constructor(e, t) {
    this.trimmedHash = e, this.lines = t;
  }
  getElement(e) {
    return this.trimmedHash[e];
  }
  get length() {
    return this.trimmedHash.length;
  }
  getBoundaryScore(e) {
    const t = e === 0 ? 0 : kE(this.lines[e - 1]), i = e === this.lines.length ? 0 : kE(this.lines[e]);
    return 1e3 - (t + i);
  }
  getText(e) {
    return this.lines.slice(e.start, e.endExclusive).join(`
`);
  }
  isStronglyEqual(e, t) {
    return this.lines[e] === this.lines[t];
  }
}
function kE(s) {
  let e = 0;
  for (; e < s.length && (s.charCodeAt(e) === 32 || s.charCodeAt(e) === 9); )
    e++;
  return e;
}
class iR {
  constructor() {
    this.dynamicProgrammingDiffing = new N9(), this.myersDiffingAlgorithm = new tR();
  }
  computeDiff(e, t, i) {
    if (e.length <= 1 && oi(e, t, (S, L) => S === L))
      return new Zm([], [], !1);
    if (e.length === 1 && e[0].length === 0 || t.length === 1 && t[0].length === 0)
      return new Zm([
        new is(new we(1, e.length + 1), new we(1, t.length + 1), [
          new Gn(new R(1, 1, e.length, e[e.length - 1].length + 1), new R(1, 1, t.length, t[t.length - 1].length + 1))
        ])
      ], [], !1);
    const n = i.maxComputationTimeMs === 0 ? zf.instance : new I9(i.maxComputationTimeMs), o = !i.ignoreTrimWhitespace, r = /* @__PURE__ */ new Map();
    function a(S) {
      let L = r.get(S);
      return L === void 0 && (L = r.size, r.set(S, L)), L;
    }
    const l = e.map((S) => a(S.trim())), c = t.map((S) => a(S.trim())), h = new LE(l, e), d = new LE(c, t), u = h.length + d.length < 1700 ? this.dynamicProgrammingDiffing.compute(h, d, n, (S, L) => e[S] === t[L] ? t[L].length === 0 ? 0.1 : 1 + Math.log(1 + t[L].length) : 0.99) : this.myersDiffingAlgorithm.compute(h, d, n);
    let f = u.diffs, g = u.hitTimeout;
    f = pv(h, d, f), f = $9(h, d, f);
    const m = [], _ = (S) => {
      if (o)
        for (let L = 0; L < S; L++) {
          const k = b + L, D = C + L;
          if (e[k] !== t[D]) {
            const E = this.refineDiff(e, t, new ti(new xe(k, k + 1), new xe(D, D + 1)), n, o);
            for (const U of E.mappings)
              m.push(U);
            E.hitTimeout && (g = !0);
          }
        }
    };
    let b = 0, C = 0;
    for (const S of f) {
      bc(() => S.seq1Range.start - b === S.seq2Range.start - C);
      const L = S.seq1Range.start - b;
      _(L), b = S.seq1Range.endExclusive, C = S.seq2Range.endExclusive;
      const k = this.refineDiff(e, t, S, n, o);
      k.hitTimeout && (g = !0);
      for (const D of k.mappings)
        m.push(D);
    }
    _(e.length - b);
    const v = xE(m, e, t);
    let w = [];
    return i.computeMoves && (w = this.computeMoves(v, e, t, l, c, n, o)), bc(() => {
      function S(k, D) {
        if (k.lineNumber < 1 || k.lineNumber > D.length)
          return !1;
        const E = D[k.lineNumber - 1];
        return !(k.column < 1 || k.column > E.length + 1);
      }
      function L(k, D) {
        return !(k.startLineNumber < 1 || k.startLineNumber > D.length + 1 || k.endLineNumberExclusive < 1 || k.endLineNumberExclusive > D.length + 1);
      }
      for (const k of v) {
        if (!k.innerChanges)
          return !1;
        for (const D of k.innerChanges)
          if (!(S(D.modifiedRange.getStartPosition(), t) && S(D.modifiedRange.getEndPosition(), t) && S(D.originalRange.getStartPosition(), e) && S(D.originalRange.getEndPosition(), e)))
            return !1;
        if (!L(k.modified, t) || !L(k.original, e))
          return !1;
      }
      return !0;
    }), new Zm(v, w, g);
  }
  computeMoves(e, t, i, n, o, r, a) {
    return A9(e, t, i, n, o, r).map((h) => {
      const d = this.refineDiff(t, i, new ti(h.original.toOffsetRange(), h.modified.toOffsetRange()), r, a), u = xE(d.mappings, t, i, !0);
      return new QM(h, u);
    });
  }
  refineDiff(e, t, i, n, o) {
    const a = j9(i).toRangeMapping2(e, t), l = new Wp(e, a.originalRange, o), c = new Wp(t, a.modifiedRange, o), h = l.length + c.length < 500 ? this.dynamicProgrammingDiffing.compute(l, c, n) : this.myersDiffingAlgorithm.compute(l, c, n);
    let d = h.diffs;
    return d = pv(l, c, d), d = z9(l, c, d), d = H9(l, c, d), d = K9(l, c, d), {
      mappings: d.map((f) => new Gn(l.translateRange(f.seq1Range), c.translateRange(f.seq2Range))),
      hitTimeout: h.hitTimeout
    };
  }
}
function xE(s, e, t, i = !1) {
  const n = [];
  for (const o of uL(s.map((r) => q9(r, e, t)), (r, a) => r.original.overlapOrTouch(a.original) || r.modified.overlapOrTouch(a.modified))) {
    const r = o[0], a = o[o.length - 1];
    n.push(new is(r.original.join(a.original), r.modified.join(a.modified), o.map((l) => l.innerChanges[0])));
  }
  return bc(() => !i && n.length > 0 && (n[0].modified.startLineNumber !== n[0].original.startLineNumber || t.length - n[n.length - 1].modified.endLineNumberExclusive !== e.length - n[n.length - 1].original.endLineNumberExclusive) ? !1 : GL(n, (o, r) => r.original.startLineNumber - o.original.endLineNumberExclusive === r.modified.startLineNumber - o.modified.endLineNumberExclusive && // There has to be an unchanged line in between (otherwise both diffs should have been joined)
  o.original.endLineNumberExclusive < r.original.startLineNumber && o.modified.endLineNumberExclusive < r.modified.startLineNumber)), n;
}
function q9(s, e, t) {
  let i = 0, n = 0;
  s.modifiedRange.endColumn === 1 && s.originalRange.endColumn === 1 && s.originalRange.startLineNumber + i <= s.originalRange.endLineNumber && s.modifiedRange.startLineNumber + i <= s.modifiedRange.endLineNumber && (n = -1), s.modifiedRange.startColumn - 1 >= t[s.modifiedRange.startLineNumber - 1].length && s.originalRange.startColumn - 1 >= e[s.originalRange.startLineNumber - 1].length && s.originalRange.startLineNumber <= s.originalRange.endLineNumber + n && s.modifiedRange.startLineNumber <= s.modifiedRange.endLineNumber + n && (i = 1);
  const o = new we(s.originalRange.startLineNumber + i, s.originalRange.endLineNumber + 1 + n), r = new we(s.modifiedRange.startLineNumber + i, s.modifiedRange.endLineNumber + 1 + n);
  return new is(o, r, [s]);
}
function j9(s) {
  return new ji(new we(s.seq1Range.start + 1, s.seq1Range.endExclusive + 1), new we(s.seq2Range.start + 1, s.seq2Range.endExclusive + 1));
}
const DE = {
  getLegacy: () => new k9(),
  getDefault: () => new iR()
};
function Ba(s, e) {
  const t = Math.pow(10, e);
  return Math.round(s * t) / t;
}
class qe {
  constructor(e, t, i, n = 1) {
    this._rgbaBrand = void 0, this.r = Math.min(255, Math.max(0, e)) | 0, this.g = Math.min(255, Math.max(0, t)) | 0, this.b = Math.min(255, Math.max(0, i)) | 0, this.a = Ba(Math.max(Math.min(1, n), 0), 3);
  }
  static equals(e, t) {
    return e.r === t.r && e.g === t.g && e.b === t.b && e.a === t.a;
  }
}
class xs {
  constructor(e, t, i, n) {
    this._hslaBrand = void 0, this.h = Math.max(Math.min(360, e), 0) | 0, this.s = Ba(Math.max(Math.min(1, t), 0), 3), this.l = Ba(Math.max(Math.min(1, i), 0), 3), this.a = Ba(Math.max(Math.min(1, n), 0), 3);
  }
  static equals(e, t) {
    return e.h === t.h && e.s === t.s && e.l === t.l && e.a === t.a;
  }
  /**
   * Converts an RGB color value to HSL. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
   * Assumes r, g, and b are contained in the set [0, 255] and
   * returns h in the set [0, 360], s, and l in the set [0, 1].
   */
  static fromRGBA(e) {
    const t = e.r / 255, i = e.g / 255, n = e.b / 255, o = e.a, r = Math.max(t, i, n), a = Math.min(t, i, n);
    let l = 0, c = 0;
    const h = (a + r) / 2, d = r - a;
    if (d > 0) {
      switch (c = Math.min(h <= 0.5 ? d / (2 * h) : d / (2 - 2 * h), 1), r) {
        case t:
          l = (i - n) / d + (i < n ? 6 : 0);
          break;
        case i:
          l = (n - t) / d + 2;
          break;
        case n:
          l = (t - i) / d + 4;
          break;
      }
      l *= 60, l = Math.round(l);
    }
    return new xs(l, c, h, o);
  }
  static _hue2rgb(e, t, i) {
    return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? e + (t - e) * 6 * i : i < 1 / 2 ? t : i < 2 / 3 ? e + (t - e) * (2 / 3 - i) * 6 : e;
  }
  /**
   * Converts an HSL color value to RGB. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
   * Assumes h in the set [0, 360] s, and l are contained in the set [0, 1] and
   * returns r, g, and b in the set [0, 255].
   */
  static toRGBA(e) {
    const t = e.h / 360, { s: i, l: n, a: o } = e;
    let r, a, l;
    if (i === 0)
      r = a = l = n;
    else {
      const c = n < 0.5 ? n * (1 + i) : n + i - n * i, h = 2 * n - c;
      r = xs._hue2rgb(h, c, t + 1 / 3), a = xs._hue2rgb(h, c, t), l = xs._hue2rgb(h, c, t - 1 / 3);
    }
    return new qe(Math.round(r * 255), Math.round(a * 255), Math.round(l * 255), o);
  }
}
class mh {
  constructor(e, t, i, n) {
    this._hsvaBrand = void 0, this.h = Math.max(Math.min(360, e), 0) | 0, this.s = Ba(Math.max(Math.min(1, t), 0), 3), this.v = Ba(Math.max(Math.min(1, i), 0), 3), this.a = Ba(Math.max(Math.min(1, n), 0), 3);
  }
  static equals(e, t) {
    return e.h === t.h && e.s === t.s && e.v === t.v && e.a === t.a;
  }
  // from http://www.rapidtables.com/convert/color/rgb-to-hsv.htm
  static fromRGBA(e) {
    const t = e.r / 255, i = e.g / 255, n = e.b / 255, o = Math.max(t, i, n), r = Math.min(t, i, n), a = o - r, l = o === 0 ? 0 : a / o;
    let c;
    return a === 0 ? c = 0 : o === t ? c = ((i - n) / a % 6 + 6) % 6 : o === i ? c = (n - t) / a + 2 : c = (t - i) / a + 4, new mh(Math.round(c * 60), l, o, e.a);
  }
  // from http://www.rapidtables.com/convert/color/hsv-to-rgb.htm
  static toRGBA(e) {
    const { h: t, s: i, v: n, a: o } = e, r = n * i, a = r * (1 - Math.abs(t / 60 % 2 - 1)), l = n - r;
    let [c, h, d] = [0, 0, 0];
    return t < 60 ? (c = r, h = a) : t < 120 ? (c = a, h = r) : t < 180 ? (h = r, d = a) : t < 240 ? (h = a, d = r) : t < 300 ? (c = a, d = r) : t <= 360 && (c = r, d = a), c = Math.round((c + l) * 255), h = Math.round((h + l) * 255), d = Math.round((d + l) * 255), new qe(c, h, d, o);
  }
}
const At = class At {
  static fromHex(e) {
    return At.Format.CSS.parseHex(e) || At.red;
  }
  static equals(e, t) {
    return !e && !t ? !0 : !e || !t ? !1 : e.equals(t);
  }
  get hsla() {
    return this._hsla ? this._hsla : xs.fromRGBA(this.rgba);
  }
  get hsva() {
    return this._hsva ? this._hsva : mh.fromRGBA(this.rgba);
  }
  constructor(e) {
    if (e)
      if (e instanceof qe)
        this.rgba = e;
      else if (e instanceof xs)
        this._hsla = e, this.rgba = xs.toRGBA(e);
      else if (e instanceof mh)
        this._hsva = e, this.rgba = mh.toRGBA(e);
      else
        throw new Error("Invalid color ctor argument");
    else throw new Error("Color needs a value");
  }
  equals(e) {
    return !!e && qe.equals(this.rgba, e.rgba) && xs.equals(this.hsla, e.hsla) && mh.equals(this.hsva, e.hsva);
  }
  /**
   * http://www.w3.org/TR/WCAG20/#relativeluminancedef
   * Returns the number in the set [0, 1]. O => Darkest Black. 1 => Lightest white.
   */
  getRelativeLuminance() {
    const e = At._relativeLuminanceForComponent(this.rgba.r), t = At._relativeLuminanceForComponent(this.rgba.g), i = At._relativeLuminanceForComponent(this.rgba.b), n = 0.2126 * e + 0.7152 * t + 0.0722 * i;
    return Ba(n, 4);
  }
  static _relativeLuminanceForComponent(e) {
    const t = e / 255;
    return t <= 0.03928 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4);
  }
  /**
   *	http://24ways.org/2010/calculating-color-contrast
   *  Return 'true' if lighter color otherwise 'false'
   */
  isLighter() {
    return (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1e3 >= 128;
  }
  isLighterThan(e) {
    const t = this.getRelativeLuminance(), i = e.getRelativeLuminance();
    return t > i;
  }
  isDarkerThan(e) {
    const t = this.getRelativeLuminance(), i = e.getRelativeLuminance();
    return t < i;
  }
  lighten(e) {
    return new At(new xs(this.hsla.h, this.hsla.s, this.hsla.l + this.hsla.l * e, this.hsla.a));
  }
  darken(e) {
    return new At(new xs(this.hsla.h, this.hsla.s, this.hsla.l - this.hsla.l * e, this.hsla.a));
  }
  transparent(e) {
    const { r: t, g: i, b: n, a: o } = this.rgba;
    return new At(new qe(t, i, n, o * e));
  }
  isTransparent() {
    return this.rgba.a === 0;
  }
  isOpaque() {
    return this.rgba.a === 1;
  }
  opposite() {
    return new At(new qe(255 - this.rgba.r, 255 - this.rgba.g, 255 - this.rgba.b, this.rgba.a));
  }
  makeOpaque(e) {
    if (this.isOpaque() || e.rgba.a !== 1)
      return this;
    const { r: t, g: i, b: n, a: o } = this.rgba;
    return new At(new qe(e.rgba.r - o * (e.rgba.r - t), e.rgba.g - o * (e.rgba.g - i), e.rgba.b - o * (e.rgba.b - n), 1));
  }
  toString() {
    return this._toString || (this._toString = At.Format.CSS.format(this)), this._toString;
  }
  static getLighterColor(e, t, i) {
    if (e.isLighterThan(t))
      return e;
    i = i || 0.5;
    const n = e.getRelativeLuminance(), o = t.getRelativeLuminance();
    return i = i * (o - n) / o, e.lighten(i);
  }
  static getDarkerColor(e, t, i) {
    if (e.isDarkerThan(t))
      return e;
    i = i || 0.5;
    const n = e.getRelativeLuminance(), o = t.getRelativeLuminance();
    return i = i * (n - o) / n, e.darken(i);
  }
};
At.white = new At(new qe(255, 255, 255, 1)), At.black = new At(new qe(0, 0, 0, 1)), At.red = new At(new qe(255, 0, 0, 1)), At.blue = new At(new qe(0, 0, 255, 1)), At.green = new At(new qe(0, 255, 0, 1)), At.cyan = new At(new qe(0, 255, 255, 1)), At.lightgrey = new At(new qe(211, 211, 211, 1)), At.transparent = new At(new qe(0, 0, 0, 0));
let Z = At;
(function(s) {
  (function(e) {
    (function(t) {
      function i(f) {
        return f.rgba.a === 1 ? `rgb(${f.rgba.r}, ${f.rgba.g}, ${f.rgba.b})` : s.Format.CSS.formatRGBA(f);
      }
      t.formatRGB = i;
      function n(f) {
        return `rgba(${f.rgba.r}, ${f.rgba.g}, ${f.rgba.b}, ${+f.rgba.a.toFixed(2)})`;
      }
      t.formatRGBA = n;
      function o(f) {
        return f.hsla.a === 1 ? `hsl(${f.hsla.h}, ${(f.hsla.s * 100).toFixed(2)}%, ${(f.hsla.l * 100).toFixed(2)}%)` : s.Format.CSS.formatHSLA(f);
      }
      t.formatHSL = o;
      function r(f) {
        return `hsla(${f.hsla.h}, ${(f.hsla.s * 100).toFixed(2)}%, ${(f.hsla.l * 100).toFixed(2)}%, ${f.hsla.a.toFixed(2)})`;
      }
      t.formatHSLA = r;
      function a(f) {
        const g = f.toString(16);
        return g.length !== 2 ? "0" + g : g;
      }
      function l(f) {
        return `#${a(f.rgba.r)}${a(f.rgba.g)}${a(f.rgba.b)}`;
      }
      t.formatHex = l;
      function c(f, g = !1) {
        return g && f.rgba.a === 1 ? s.Format.CSS.formatHex(f) : `#${a(f.rgba.r)}${a(f.rgba.g)}${a(f.rgba.b)}${a(Math.round(f.rgba.a * 255))}`;
      }
      t.formatHexA = c;
      function h(f) {
        return f.isOpaque() ? s.Format.CSS.formatHex(f) : s.Format.CSS.formatRGBA(f);
      }
      t.format = h;
      function d(f) {
        const g = f.length;
        if (g === 0 || f.charCodeAt(0) !== 35)
          return null;
        if (g === 7) {
          const m = 16 * u(f.charCodeAt(1)) + u(f.charCodeAt(2)), _ = 16 * u(f.charCodeAt(3)) + u(f.charCodeAt(4)), b = 16 * u(f.charCodeAt(5)) + u(f.charCodeAt(6));
          return new s(new qe(m, _, b, 1));
        }
        if (g === 9) {
          const m = 16 * u(f.charCodeAt(1)) + u(f.charCodeAt(2)), _ = 16 * u(f.charCodeAt(3)) + u(f.charCodeAt(4)), b = 16 * u(f.charCodeAt(5)) + u(f.charCodeAt(6)), C = 16 * u(f.charCodeAt(7)) + u(f.charCodeAt(8));
          return new s(new qe(m, _, b, C / 255));
        }
        if (g === 4) {
          const m = u(f.charCodeAt(1)), _ = u(f.charCodeAt(2)), b = u(f.charCodeAt(3));
          return new s(new qe(16 * m + m, 16 * _ + _, 16 * b + b));
        }
        if (g === 5) {
          const m = u(f.charCodeAt(1)), _ = u(f.charCodeAt(2)), b = u(f.charCodeAt(3)), C = u(f.charCodeAt(4));
          return new s(new qe(16 * m + m, 16 * _ + _, 16 * b + b, (16 * C + C) / 255));
        }
        return null;
      }
      t.parseHex = d;
      function u(f) {
        switch (f) {
          case 48:
            return 0;
          case 49:
            return 1;
          case 50:
            return 2;
          case 51:
            return 3;
          case 52:
            return 4;
          case 53:
            return 5;
          case 54:
            return 6;
          case 55:
            return 7;
          case 56:
            return 8;
          case 57:
            return 9;
          case 97:
            return 10;
          case 65:
            return 10;
          case 98:
            return 11;
          case 66:
            return 11;
          case 99:
            return 12;
          case 67:
            return 12;
          case 100:
            return 13;
          case 68:
            return 13;
          case 101:
            return 14;
          case 69:
            return 14;
          case 102:
            return 15;
          case 70:
            return 15;
        }
        return 0;
      }
    })(e.CSS || (e.CSS = {}));
  })(s.Format || (s.Format = {}));
})(Z || (Z = {}));
function nR(s) {
  const e = [];
  for (const t of s) {
    const i = Number(t);
    (i || i === 0 && t.replace(/\s/g, "") !== "") && e.push(i);
  }
  return e;
}
function tk(s, e, t, i) {
  return {
    red: s / 255,
    blue: t / 255,
    green: e / 255,
    alpha: i
  };
}
function hu(s, e) {
  const t = e.index, i = e[0].length;
  if (!t)
    return;
  const n = s.positionAt(t);
  return {
    startLineNumber: n.lineNumber,
    startColumn: n.column,
    endLineNumber: n.lineNumber,
    endColumn: n.column + i
  };
}
function G9(s, e) {
  if (!s)
    return;
  const t = Z.Format.CSS.parseHex(e);
  if (t)
    return {
      range: s,
      color: tk(t.rgba.r, t.rgba.g, t.rgba.b, t.rgba.a)
    };
}
function EE(s, e, t) {
  if (!s || e.length !== 1)
    return;
  const n = e[0].values(), o = nR(n);
  return {
    range: s,
    color: tk(o[0], o[1], o[2], t ? o[3] : 1)
  };
}
function IE(s, e, t) {
  if (!s || e.length !== 1)
    return;
  const n = e[0].values(), o = nR(n), r = new Z(new xs(o[0], o[1] / 100, o[2] / 100, t ? o[3] : 1));
  return {
    range: s,
    color: tk(r.rgba.r, r.rgba.g, r.rgba.b, r.rgba.a)
  };
}
function du(s, e) {
  return typeof s == "string" ? [...s.matchAll(e)] : s.findMatches(e);
}
function Z9(s) {
  const e = [], i = du(s, /\b(rgb|rgba|hsl|hsla)(\([0-9\s,.\%]*\))|(#)([A-Fa-f0-9]{3})\b|(#)([A-Fa-f0-9]{4})\b|(#)([A-Fa-f0-9]{6})\b|(#)([A-Fa-f0-9]{8})\b/gm);
  if (i.length > 0)
    for (const n of i) {
      const o = n.filter((c) => c !== void 0), r = o[1], a = o[2];
      if (!a)
        continue;
      let l;
      if (r === "rgb") {
        const c = /^\(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*\)$/gm;
        l = EE(hu(s, n), du(a, c), !1);
      } else if (r === "rgba") {
        const c = /^\(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\s*\)$/gm;
        l = EE(hu(s, n), du(a, c), !0);
      } else if (r === "hsl") {
        const c = /^\(\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*\)$/gm;
        l = IE(hu(s, n), du(a, c), !1);
      } else if (r === "hsla") {
        const c = /^\(\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\s*\)$/gm;
        l = IE(hu(s, n), du(a, c), !0);
      } else r === "#" && (l = G9(hu(s, n), r + a));
      l && e.push(l);
    }
  return e;
}
function Y9(s) {
  return !s || typeof s.getValue != "function" || typeof s.positionAt != "function" ? [] : Z9(s);
}
const NE = new RegExp("\\bMARK:\\s*(.*)$", "d"), Q9 = /^-+|-+$/g;
function X9(s, e) {
  var i;
  let t = [];
  if (e.findRegionSectionHeaders && ((i = e.foldingRules) != null && i.markers)) {
    const n = J9(s, e);
    t = t.concat(n);
  }
  if (e.findMarkSectionHeaders) {
    const n = eF(s);
    t = t.concat(n);
  }
  return t;
}
function J9(s, e) {
  const t = [], i = s.getLineCount();
  for (let n = 1; n <= i; n++) {
    const o = s.getLineContent(n), r = o.match(e.foldingRules.markers.start);
    if (r) {
      const a = { startLineNumber: n, startColumn: r[0].length + 1, endLineNumber: n, endColumn: o.length + 1 };
      if (a.endColumn > a.startColumn) {
        const l = {
          range: a,
          ...sR(o.substring(r[0].length)),
          shouldBeInComments: !1
        };
        (l.text || l.hasSeparatorLine) && t.push(l);
      }
    }
  }
  return t;
}
function eF(s) {
  const e = [], t = s.getLineCount();
  for (let i = 1; i <= t; i++) {
    const n = s.getLineContent(i);
    tF(n, i, e);
  }
  return e;
}
function tF(s, e, t) {
  NE.lastIndex = 0;
  const i = NE.exec(s);
  if (i) {
    const n = i.indices[1][0] + 1, o = i.indices[1][1] + 1, r = { startLineNumber: e, startColumn: n, endLineNumber: e, endColumn: o };
    if (r.endColumn > r.startColumn) {
      const a = {
        range: r,
        ...sR(i[1]),
        shouldBeInComments: !0
      };
      (a.text || a.hasSeparatorLine) && t.push(a);
    }
  }
}
function sR(s) {
  s = s.trim();
  const e = s.startsWith("-");
  return s = s.replace(Q9, ""), { text: s, hasSeparatorLine: e };
}
class iF {
  constructor(e) {
    this.values = e, this.prefixSum = new Uint32Array(e.length), this.prefixSumValidIndex = new Int32Array(1), this.prefixSumValidIndex[0] = -1;
  }
  insertValues(e, t) {
    e = Qc(e);
    const i = this.values, n = this.prefixSum, o = t.length;
    return o === 0 ? !1 : (this.values = new Uint32Array(i.length + o), this.values.set(i.subarray(0, e), 0), this.values.set(i.subarray(e), e + o), this.values.set(t, e), e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1), this.prefixSum = new Uint32Array(this.values.length), this.prefixSumValidIndex[0] >= 0 && this.prefixSum.set(n.subarray(0, this.prefixSumValidIndex[0] + 1)), !0);
  }
  setValue(e, t) {
    return e = Qc(e), t = Qc(t), this.values[e] === t ? !1 : (this.values[e] = t, e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1), !0);
  }
  removeValues(e, t) {
    e = Qc(e), t = Qc(t);
    const i = this.values, n = this.prefixSum;
    if (e >= i.length)
      return !1;
    const o = i.length - e;
    return t >= o && (t = o), t === 0 ? !1 : (this.values = new Uint32Array(i.length - t), this.values.set(i.subarray(0, e), 0), this.values.set(i.subarray(e + t), e), this.prefixSum = new Uint32Array(this.values.length), e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1), this.prefixSumValidIndex[0] >= 0 && this.prefixSum.set(n.subarray(0, this.prefixSumValidIndex[0] + 1)), !0);
  }
  getTotalSum() {
    return this.values.length === 0 ? 0 : this._getPrefixSum(this.values.length - 1);
  }
  /**
   * Returns the sum of the first `index + 1` many items.
   * @returns `SUM(0 <= j <= index, values[j])`.
   */
  getPrefixSum(e) {
    return e < 0 ? 0 : (e = Qc(e), this._getPrefixSum(e));
  }
  _getPrefixSum(e) {
    if (e <= this.prefixSumValidIndex[0])
      return this.prefixSum[e];
    let t = this.prefixSumValidIndex[0] + 1;
    t === 0 && (this.prefixSum[0] = this.values[0], t++), e >= this.values.length && (e = this.values.length - 1);
    for (let i = t; i <= e; i++)
      this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];
    return this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], e), this.prefixSum[e];
  }
  getIndexOf(e) {
    e = Math.floor(e), this.getTotalSum();
    let t = 0, i = this.values.length - 1, n = 0, o = 0, r = 0;
    for (; t <= i; )
      if (n = t + (i - t) / 2 | 0, o = this.prefixSum[n], r = o - this.values[n], e < r)
        i = n - 1;
      else if (e >= o)
        t = n + 1;
      else
        break;
    return new oR(n, e - r);
  }
}
class nF {
  constructor(e) {
    this._values = e, this._isValid = !1, this._validEndIndex = -1, this._prefixSum = [], this._indexBySum = [];
  }
  /**
   * @returns SUM(0 <= j < values.length, values[j])
   */
  getTotalSum() {
    return this._ensureValid(), this._indexBySum.length;
  }
  /**
   * Returns the sum of the first `count` many items.
   * @returns `SUM(0 <= j < count, values[j])`.
   */
  getPrefixSum(e) {
    return this._ensureValid(), e === 0 ? 0 : this._prefixSum[e - 1];
  }
  /**
   * @returns `result`, such that `getPrefixSum(result.index) + result.remainder = sum`
   */
  getIndexOf(e) {
    this._ensureValid();
    const t = this._indexBySum[e], i = t > 0 ? this._prefixSum[t - 1] : 0;
    return new oR(t, e - i);
  }
  removeValues(e, t) {
    this._values.splice(e, t), this._invalidate(e);
  }
  insertValues(e, t) {
    this._values = X1(this._values, e, t), this._invalidate(e);
  }
  _invalidate(e) {
    this._isValid = !1, this._validEndIndex = Math.min(this._validEndIndex, e - 1);
  }
  _ensureValid() {
    if (!this._isValid) {
      for (let e = this._validEndIndex + 1, t = this._values.length; e < t; e++) {
        const i = this._values[e], n = e > 0 ? this._prefixSum[e - 1] : 0;
        this._prefixSum[e] = n + i;
        for (let o = 0; o < i; o++)
          this._indexBySum[n + o] = e;
      }
      this._prefixSum.length = this._values.length, this._indexBySum.length = this._prefixSum[this._prefixSum.length - 1], this._isValid = !0, this._validEndIndex = this._values.length - 1;
    }
  }
  setValue(e, t) {
    this._values[e] !== t && (this._values[e] = t, this._invalidate(e));
  }
}
class oR {
  constructor(e, t) {
    this.index = e, this.remainder = t, this._prefixSumIndexOfResultBrand = void 0, this.index = e, this.remainder = t;
  }
}
class sF {
  constructor(e, t, i, n) {
    this._uri = e, this._lines = t, this._eol = i, this._versionId = n, this._lineStarts = null, this._cachedTextValue = null;
  }
  dispose() {
    this._lines.length = 0;
  }
  get version() {
    return this._versionId;
  }
  getText() {
    return this._cachedTextValue === null && (this._cachedTextValue = this._lines.join(this._eol)), this._cachedTextValue;
  }
  onEvents(e) {
    e.eol && e.eol !== this._eol && (this._eol = e.eol, this._lineStarts = null);
    const t = e.changes;
    for (const i of t)
      this._acceptDeleteRange(i.range), this._acceptInsertText(new V(i.range.startLineNumber, i.range.startColumn), i.text);
    this._versionId = e.versionId, this._cachedTextValue = null;
  }
  _ensureLineStarts() {
    if (!this._lineStarts) {
      const e = this._eol.length, t = this._lines.length, i = new Uint32Array(t);
      for (let n = 0; n < t; n++)
        i[n] = this._lines[n].length + e;
      this._lineStarts = new iF(i);
    }
  }
  /**
   * All changes to a line's text go through this method
   */
  _setLineText(e, t) {
    this._lines[e] = t, this._lineStarts && this._lineStarts.setValue(e, this._lines[e].length + this._eol.length);
  }
  _acceptDeleteRange(e) {
    if (e.startLineNumber === e.endLineNumber) {
      if (e.startColumn === e.endColumn)
        return;
      this._setLineText(e.startLineNumber - 1, this._lines[e.startLineNumber - 1].substring(0, e.startColumn - 1) + this._lines[e.startLineNumber - 1].substring(e.endColumn - 1));
      return;
    }
    this._setLineText(e.startLineNumber - 1, this._lines[e.startLineNumber - 1].substring(0, e.startColumn - 1) + this._lines[e.endLineNumber - 1].substring(e.endColumn - 1)), this._lines.splice(e.startLineNumber, e.endLineNumber - e.startLineNumber), this._lineStarts && this._lineStarts.removeValues(e.startLineNumber, e.endLineNumber - e.startLineNumber);
  }
  _acceptInsertText(e, t) {
    if (t.length === 0)
      return;
    const i = Vd(t);
    if (i.length === 1) {
      this._setLineText(e.lineNumber - 1, this._lines[e.lineNumber - 1].substring(0, e.column - 1) + i[0] + this._lines[e.lineNumber - 1].substring(e.column - 1));
      return;
    }
    i[i.length - 1] += this._lines[e.lineNumber - 1].substring(e.column - 1), this._setLineText(e.lineNumber - 1, this._lines[e.lineNumber - 1].substring(0, e.column - 1) + i[0]);
    const n = new Uint32Array(i.length - 1);
    for (let o = 1; o < i.length; o++)
      this._lines.splice(e.lineNumber + o - 1, 0, i[o]), n[o - 1] = i[o].length + this._eol.length;
    this._lineStarts && this._lineStarts.insertValues(e.lineNumber, n);
  }
}
const TE = 60 * 1e3;
class oF extends q {
  constructor(e, t, i = !1) {
    if (super(), this._syncedModels = /* @__PURE__ */ Object.create(null), this._syncedModelsLastUsedTime = /* @__PURE__ */ Object.create(null), this._proxy = e, this._modelService = t, !i) {
      const n = new PL();
      n.cancelAndSet(() => this._checkStopModelSync(), Math.round(TE / 2)), this._register(n);
    }
  }
  dispose() {
    for (const e in this._syncedModels)
      Ri(this._syncedModels[e]);
    this._syncedModels = /* @__PURE__ */ Object.create(null), this._syncedModelsLastUsedTime = /* @__PURE__ */ Object.create(null), super.dispose();
  }
  ensureSyncedResources(e, t = !1) {
    for (const i of e) {
      const n = i.toString();
      this._syncedModels[n] || this._beginModelSync(i, t), this._syncedModels[n] && (this._syncedModelsLastUsedTime[n] = (/* @__PURE__ */ new Date()).getTime());
    }
  }
  _checkStopModelSync() {
    const e = (/* @__PURE__ */ new Date()).getTime(), t = [];
    for (const i in this._syncedModelsLastUsedTime)
      e - this._syncedModelsLastUsedTime[i] > TE && t.push(i);
    for (const i of t)
      this._stopModelSync(i);
  }
  _beginModelSync(e, t) {
    const i = this._modelService.getModel(e);
    if (!i || !t && i.isTooLargeForSyncing())
      return;
    const n = e.toString();
    this._proxy.$acceptNewModel({
      url: i.uri.toString(),
      lines: i.getLinesContent(),
      EOL: i.getEOL(),
      versionId: i.getVersionId()
    });
    const o = new he();
    o.add(i.onDidChangeContent((r) => {
      this._proxy.$acceptModelChanged(n.toString(), r);
    })), o.add(i.onWillDispose(() => {
      this._stopModelSync(n);
    })), o.add(ke(() => {
      this._proxy.$acceptRemovedModel(n);
    })), this._syncedModels[n] = o;
  }
  _stopModelSync(e) {
    const t = this._syncedModels[e];
    delete this._syncedModels[e], delete this._syncedModelsLastUsedTime[e], Ri(t);
  }
}
class rF {
  constructor() {
    this._models = /* @__PURE__ */ Object.create(null);
  }
  getModel(e) {
    return this._models[e];
  }
  getModels() {
    const e = [];
    return Object.keys(this._models).forEach((t) => e.push(this._models[t])), e;
  }
  $acceptNewModel(e) {
    this._models[e.url] = new aF(Te.parse(e.url), e.lines, e.EOL, e.versionId);
  }
  $acceptModelChanged(e, t) {
    if (!this._models[e])
      return;
    this._models[e].onEvents(t);
  }
  $acceptRemovedModel(e) {
    this._models[e] && delete this._models[e];
  }
}
class aF extends sF {
  get uri() {
    return this._uri;
  }
  get eol() {
    return this._eol;
  }
  getValue() {
    return this.getText();
  }
  findMatches(e) {
    const t = [];
    for (let i = 0; i < this._lines.length; i++) {
      const n = this._lines[i], o = this.offsetAt(new V(i + 1, 1)), r = n.matchAll(e);
      for (const a of r)
        (a.index || a.index === 0) && (a.index = a.index + o), t.push(a);
    }
    return t;
  }
  getLinesContent() {
    return this._lines.slice(0);
  }
  getLineCount() {
    return this._lines.length;
  }
  getLineContent(e) {
    return this._lines[e - 1];
  }
  getWordAtPosition(e, t) {
    const i = Nf(e.column, CL(t), this._lines[e.lineNumber - 1], 0);
    return i ? new R(e.lineNumber, i.startColumn, e.lineNumber, i.endColumn) : null;
  }
  words(e) {
    const t = this._lines, i = this._wordenize.bind(this);
    let n = 0, o = "", r = 0, a = [];
    return {
      *[Symbol.iterator]() {
        for (; ; )
          if (r < a.length) {
            const l = o.substring(a[r].start, a[r].end);
            r += 1, yield l;
          } else if (n < t.length)
            o = t[n], a = i(o, e), r = 0, n += 1;
          else
            break;
      }
    };
  }
  getLineWords(e, t) {
    const i = this._lines[e - 1], n = this._wordenize(i, t), o = [];
    for (const r of n)
      o.push({
        word: i.substring(r.start, r.end),
        startColumn: r.start + 1,
        endColumn: r.end + 1
      });
    return o;
  }
  _wordenize(e, t) {
    const i = [];
    let n;
    for (t.lastIndex = 0; (n = t.exec(e)) && n[0].length !== 0; )
      i.push({ start: n.index, end: n.index + n[0].length });
    return i;
  }
  getValueInRange(e) {
    if (e = this._validateRange(e), e.startLineNumber === e.endLineNumber)
      return this._lines[e.startLineNumber - 1].substring(e.startColumn - 1, e.endColumn - 1);
    const t = this._eol, i = e.startLineNumber - 1, n = e.endLineNumber - 1, o = [];
    o.push(this._lines[i].substring(e.startColumn - 1));
    for (let r = i + 1; r < n; r++)
      o.push(this._lines[r]);
    return o.push(this._lines[n].substring(0, e.endColumn - 1)), o.join(t);
  }
  offsetAt(e) {
    return e = this._validatePosition(e), this._ensureLineStarts(), this._lineStarts.getPrefixSum(e.lineNumber - 2) + (e.column - 1);
  }
  positionAt(e) {
    e = Math.floor(e), e = Math.max(0, e), this._ensureLineStarts();
    const t = this._lineStarts.getIndexOf(e), i = this._lines[t.index].length;
    return {
      lineNumber: 1 + t.index,
      column: 1 + Math.min(t.remainder, i)
    };
  }
  _validateRange(e) {
    const t = this._validatePosition({ lineNumber: e.startLineNumber, column: e.startColumn }), i = this._validatePosition({ lineNumber: e.endLineNumber, column: e.endColumn });
    return t.lineNumber !== e.startLineNumber || t.column !== e.startColumn || i.lineNumber !== e.endLineNumber || i.column !== e.endColumn ? {
      startLineNumber: t.lineNumber,
      startColumn: t.column,
      endLineNumber: i.lineNumber,
      endColumn: i.column
    } : e;
  }
  _validatePosition(e) {
    if (!V.isIPosition(e))
      throw new Error("bad position");
    let { lineNumber: t, column: i } = e, n = !1;
    if (t < 1)
      t = 1, i = 1, n = !0;
    else if (t > this._lines.length)
      t = this._lines.length, i = this._lines[t - 1].length + 1, n = !0;
    else {
      const o = this._lines[t - 1].length + 1;
      i < 1 ? (i = 1, n = !0) : i > o && (i = o, n = !0);
    }
    return n ? { lineNumber: t, column: i } : e;
  }
}
const _1 = class _1 {
  constructor() {
    this._workerTextModelSyncServer = new rF();
  }
  dispose() {
  }
  _getModel(e) {
    return this._workerTextModelSyncServer.getModel(e);
  }
  _getModels() {
    return this._workerTextModelSyncServer.getModels();
  }
  $acceptNewModel(e) {
    this._workerTextModelSyncServer.$acceptNewModel(e);
  }
  $acceptModelChanged(e, t) {
    this._workerTextModelSyncServer.$acceptModelChanged(e, t);
  }
  $acceptRemovedModel(e) {
    this._workerTextModelSyncServer.$acceptRemovedModel(e);
  }
  async $computeUnicodeHighlights(e, t, i) {
    const n = this._getModel(e);
    return n ? f9.computeUnicodeHighlights(n, t, i) : { ranges: [], hasMore: !1, ambiguousCharacterCount: 0, invisibleCharacterCount: 0, nonBasicAsciiCharacterCount: 0 };
  }
  async $findSectionHeaders(e, t) {
    const i = this._getModel(e);
    return i ? X9(i, t) : [];
  }
  // ---- BEGIN diff --------------------------------------------------------------------------
  async $computeDiff(e, t, i, n) {
    const o = this._getModel(e), r = this._getModel(t);
    return !o || !r ? null : Ym.computeDiff(o, r, i, n);
  }
  static computeDiff(e, t, i, n) {
    const o = n === "advanced" ? DE.getDefault() : DE.getLegacy(), r = e.getLinesContent(), a = t.getLinesContent(), l = o.computeDiff(r, a, i), c = l.changes.length > 0 ? !1 : this._modelsAreIdentical(e, t);
    function h(d) {
      return d.map((u) => {
        var f;
        return [u.original.startLineNumber, u.original.endLineNumberExclusive, u.modified.startLineNumber, u.modified.endLineNumberExclusive, (f = u.innerChanges) == null ? void 0 : f.map((g) => [
          g.originalRange.startLineNumber,
          g.originalRange.startColumn,
          g.originalRange.endLineNumber,
          g.originalRange.endColumn,
          g.modifiedRange.startLineNumber,
          g.modifiedRange.startColumn,
          g.modifiedRange.endLineNumber,
          g.modifiedRange.endColumn
        ])];
      });
    }
    return {
      identical: c,
      quitEarly: l.hitTimeout,
      changes: h(l.changes),
      moves: l.moves.map((d) => [
        d.lineRangeMapping.original.startLineNumber,
        d.lineRangeMapping.original.endLineNumberExclusive,
        d.lineRangeMapping.modified.startLineNumber,
        d.lineRangeMapping.modified.endLineNumberExclusive,
        h(d.changes)
      ])
    };
  }
  static _modelsAreIdentical(e, t) {
    const i = e.getLineCount(), n = t.getLineCount();
    if (i !== n)
      return !1;
    for (let o = 1; o <= i; o++) {
      const r = e.getLineContent(o), a = t.getLineContent(o);
      if (r !== a)
        return !1;
    }
    return !0;
  }
  async $computeMoreMinimalEdits(e, t, i) {
    const n = this._getModel(e);
    if (!n)
      return t;
    const o = [];
    let r;
    t = t.slice(0).sort((l, c) => {
      if (l.range && c.range)
        return R.compareRangesUsingStarts(l.range, c.range);
      const h = l.range ? 0 : 1, d = c.range ? 0 : 1;
      return h - d;
    });
    let a = 0;
    for (let l = 1; l < t.length; l++)
      R.getEndPosition(t[a].range).equals(R.getStartPosition(t[l].range)) ? (t[a].range = R.fromPositions(R.getStartPosition(t[a].range), R.getEndPosition(t[l].range)), t[a].text += t[l].text) : (a++, t[a] = t[l]);
    t.length = a + 1;
    for (let { range: l, text: c, eol: h } of t) {
      if (typeof h == "number" && (r = h), R.isEmpty(l) && !c)
        continue;
      const d = n.getValueInRange(l);
      if (c = c.replace(/\r\n|\n|\r/g, n.eol), d === c)
        continue;
      if (Math.max(c.length, d.length) > Ym._diffLimit) {
        o.push({ range: l, text: c });
        continue;
      }
      const u = j3(d, c, i), f = n.offsetAt(R.lift(l).getStartPosition());
      for (const g of u) {
        const m = n.positionAt(f + g.originalStart), _ = n.positionAt(f + g.originalStart + g.originalLength), b = {
          text: c.substr(g.modifiedStart, g.modifiedLength),
          range: { startLineNumber: m.lineNumber, startColumn: m.column, endLineNumber: _.lineNumber, endColumn: _.column }
        };
        n.getValueInRange(b.range) !== b.text && o.push(b);
      }
    }
    return typeof r == "number" && o.push({ eol: r, text: "", range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } }), o;
  }
  // ---- END minimal edits ---------------------------------------------------------------
  async $computeLinks(e) {
    const t = this._getModel(e);
    return t ? X3(t) : null;
  }
  // --- BEGIN default document colors -----------------------------------------------------------
  async $computeDefaultDocumentColors(e) {
    const t = this._getModel(e);
    return t ? Y9(t) : null;
  }
  async $textualSuggest(e, t, i, n) {
    const o = new Dc(), r = new RegExp(i, n), a = /* @__PURE__ */ new Set();
    e: for (const l of e) {
      const c = this._getModel(l);
      if (c) {
        for (const h of c.words(r))
          if (!(h === t || !isNaN(Number(h))) && (a.add(h), a.size > Ym._suggestionsLimit))
            break e;
      }
    }
    return { words: Array.from(a), duration: o.elapsed() };
  }
  // ---- END suggest --------------------------------------------------------------------------
  //#region -- word ranges --
  async $computeWordRanges(e, t, i, n) {
    const o = this._getModel(e);
    if (!o)
      return /* @__PURE__ */ Object.create(null);
    const r = new RegExp(i, n), a = /* @__PURE__ */ Object.create(null);
    for (let l = t.startLineNumber; l < t.endLineNumber; l++) {
      const c = o.getLineWords(l, r);
      for (const h of c) {
        if (!isNaN(Number(h.word)))
          continue;
        let d = a[h.word];
        d || (d = [], a[h.word] = d), d.push({
          startLineNumber: l,
          startColumn: h.startColumn,
          endLineNumber: l,
          endColumn: h.endColumn
        });
      }
    }
    return a;
  }
  //#endregion
  async $navigateValueSet(e, t, i, n, o) {
    const r = this._getModel(e);
    if (!r)
      return null;
    const a = new RegExp(n, o);
    t.startColumn === t.endColumn && (t = {
      startLineNumber: t.startLineNumber,
      startColumn: t.startColumn,
      endLineNumber: t.endLineNumber,
      endColumn: t.endColumn + 1
    });
    const l = r.getValueInRange(t), c = r.getWordAtPosition({ lineNumber: t.startLineNumber, column: t.startColumn }, a);
    if (!c)
      return null;
    const h = r.getValueInRange(c);
    return hv.INSTANCE.navigateValueSet(t, l, c, h, i);
  }
};
_1._diffLimit = 1e5, _1._suggestionsLimit = 1e4;
let _v = _1;
class Ym extends _v {
  constructor(e, t) {
    super(), this._host = e, this._foreignModuleFactory = t, this._foreignModule = null;
  }
  async $ping() {
    return "pong";
  }
  // ---- BEGIN foreign module support --------------------------------------------------------------------------
  $loadForeignModule(e, t, i) {
    const r = {
      host: G5(i, (a, l) => this._host.$fhr(a, l)),
      getMirrorModels: () => this._getModels()
    };
    return this._foreignModuleFactory ? (this._foreignModule = this._foreignModuleFactory(r, t), Promise.resolve(NC(this._foreignModule))) : new Promise((a, l) => {
      const c = (h) => {
        this._foreignModule = h.create(r, t), a(NC(this._foreignModule));
      };
      import(`${sb.asBrowserUri(`${e}.js`).toString(!0)}`).then(c).catch(l);
    });
  }
  // foreign method request
  $fmr(e, t) {
    if (!this._foreignModule || typeof this._foreignModule[e] != "function")
      return Promise.reject(new Error("Missing requestHandler or method: " + e));
    try {
      return Promise.resolve(this._foreignModule[e].apply(this._foreignModule, t));
    } catch (i) {
      return Promise.reject(i);
    }
  }
}
typeof importScripts == "function" && (globalThis.monaco = G2());
const ik = Ve("textResourceConfigurationService"), rR = Ve("textResourcePropertiesService"), gt = Ve("ILanguageFeaturesService");
var nk = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, kl = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const ME = 300 * 1e3;
function xl(s, e) {
  const t = s.getModel(e);
  return !(!t || t.isTooLargeForSyncing());
}
let bv = class extends q {
  constructor(e, t, i, n, o, r) {
    super(), this._languageConfigurationService = o, this._modelService = t, this._workerManager = this._register(new Cv(e, this._modelService)), this._logService = n, this._register(r.linkProvider.register({ language: "*", hasAccessToAllModels: !0 }, {
      provideLinks: async (a, l) => {
        if (!xl(this._modelService, a.uri))
          return Promise.resolve({ links: [] });
        const h = await (await this._workerWithResources([a.uri])).$computeLinks(a.uri.toString());
        return h && { links: h };
      }
    })), this._register(r.completionProvider.register("*", new lF(this._workerManager, i, this._modelService, this._languageConfigurationService)));
  }
  dispose() {
    super.dispose();
  }
  canComputeUnicodeHighlights(e) {
    return xl(this._modelService, e);
  }
  async computedUnicodeHighlights(e, t, i) {
    return (await this._workerWithResources([e])).$computeUnicodeHighlights(e.toString(), t, i);
  }
  async computeDiff(e, t, i, n) {
    const r = await (await this._workerWithResources(
      [e, t],
      /* forceLargeModels */
      !0
    )).$computeDiff(e.toString(), t.toString(), i, n);
    if (!r)
      return null;
    return {
      identical: r.identical,
      quitEarly: r.quitEarly,
      changes: l(r.changes),
      moves: r.moves.map((c) => new QM(new ji(new we(c[0], c[1]), new we(c[2], c[3])), l(c[4])))
    };
    function l(c) {
      return c.map((h) => {
        var d;
        return new is(new we(h[0], h[1]), new we(h[2], h[3]), (d = h[4]) == null ? void 0 : d.map((u) => new Gn(new R(u[0], u[1], u[2], u[3]), new R(u[4], u[5], u[6], u[7]))));
      });
    }
  }
  async computeMoreMinimalEdits(e, t, i = !1) {
    if (Q1(t)) {
      if (!xl(this._modelService, e))
        return Promise.resolve(t);
      const n = Dc.create(), o = this._workerWithResources([e]).then((r) => r.$computeMoreMinimalEdits(e.toString(), t, i));
      return o.finally(() => this._logService.trace("FORMAT#computeMoreMinimalEdits", e.toString(!0), n.elapsed())), Promise.race([o, Of(1e3).then(() => t)]);
    } else
      return Promise.resolve(void 0);
  }
  canNavigateValueSet(e) {
    return xl(this._modelService, e);
  }
  async navigateValueSet(e, t, i) {
    const n = this._modelService.getModel(e);
    if (!n)
      return null;
    const o = this._languageConfigurationService.getLanguageConfiguration(n.getLanguageId()).getWordDefinition(), r = o.source, a = o.flags;
    return (await this._workerWithResources([e])).$navigateValueSet(e.toString(), t, i, r, a);
  }
  canComputeWordRanges(e) {
    return xl(this._modelService, e);
  }
  async computeWordRanges(e, t) {
    const i = this._modelService.getModel(e);
    if (!i)
      return Promise.resolve(null);
    const n = this._languageConfigurationService.getLanguageConfiguration(i.getLanguageId()).getWordDefinition(), o = n.source, r = n.flags;
    return (await this._workerWithResources([e])).$computeWordRanges(e.toString(), t, o, r);
  }
  async findSectionHeaders(e, t) {
    return (await this._workerWithResources([e])).$findSectionHeaders(e.toString(), t);
  }
  async computeDefaultDocumentColors(e) {
    return (await this._workerWithResources([e])).$computeDefaultDocumentColors(e.toString());
  }
  async _workerWithResources(e, t = !1) {
    return await (await this._workerManager.withWorker()).workerWithSyncedResources(e, t);
  }
};
bv = nk([
  kl(1, cn),
  kl(2, ik),
  kl(3, uo),
  kl(4, Zo),
  kl(5, gt)
], bv);
class lF {
  constructor(e, t, i, n) {
    this.languageConfigurationService = n, this._debugDisplayName = "wordbasedCompletions", this._workerManager = e, this._configurationService = t, this._modelService = i;
  }
  async provideCompletionItems(e, t) {
    const i = this._configurationService.getValue(e.uri, t, "editor");
    if (i.wordBasedSuggestions === "off")
      return;
    const n = [];
    if (i.wordBasedSuggestions === "currentDocument")
      xl(this._modelService, e.uri) && n.push(e.uri);
    else
      for (const d of this._modelService.getModels())
        xl(this._modelService, d.uri) && (d === e ? n.unshift(d.uri) : (i.wordBasedSuggestions === "allDocuments" || d.getLanguageId() === e.getLanguageId()) && n.push(d.uri));
    if (n.length === 0)
      return;
    const o = this.languageConfigurationService.getLanguageConfiguration(e.getLanguageId()).getWordDefinition(), r = e.getWordAtPosition(t), a = r ? new R(t.lineNumber, r.startColumn, t.lineNumber, r.endColumn) : R.fromPositions(t), l = a.setEndPosition(t.lineNumber, t.column), h = await (await this._workerManager.withWorker()).textualSuggest(n, r == null ? void 0 : r.word, o);
    if (h)
      return {
        duration: h.duration,
        suggestions: h.words.map((d) => ({
          kind: 18,
          label: d,
          insertText: d,
          range: { insert: l, replace: a }
        }))
      };
  }
}
let Cv = class extends q {
  constructor(e, t) {
    super(), this._workerDescriptor = e, this._modelService = t, this._editorWorkerClient = null, this._lastWorkerUsedTime = (/* @__PURE__ */ new Date()).getTime(), this._register(new BL()).cancelAndSet(() => this._checkStopIdleWorker(), Math.round(ME / 2), ut), this._register(this._modelService.onModelRemoved((n) => this._checkStopEmptyWorker()));
  }
  dispose() {
    this._editorWorkerClient && (this._editorWorkerClient.dispose(), this._editorWorkerClient = null), super.dispose();
  }
  /**
   * Check if the model service has no more models and stop the worker if that is the case.
   */
  _checkStopEmptyWorker() {
    if (!this._editorWorkerClient)
      return;
    this._modelService.getModels().length === 0 && (this._editorWorkerClient.dispose(), this._editorWorkerClient = null);
  }
  /**
   * Check if the worker has been idle for a while and then stop it.
   */
  _checkStopIdleWorker() {
    if (!this._editorWorkerClient)
      return;
    (/* @__PURE__ */ new Date()).getTime() - this._lastWorkerUsedTime > ME && (this._editorWorkerClient.dispose(), this._editorWorkerClient = null);
  }
  withWorker() {
    return this._lastWorkerUsedTime = (/* @__PURE__ */ new Date()).getTime(), this._editorWorkerClient || (this._editorWorkerClient = new Vp(this._workerDescriptor, !1, this._modelService)), Promise.resolve(this._editorWorkerClient);
  }
};
Cv = nk([
  kl(1, cn)
], Cv);
class cF {
  constructor(e) {
    this._instance = e, this.proxy = this._instance;
  }
  dispose() {
    this._instance.dispose();
  }
  setChannel(e, t) {
    throw new Error("Not supported");
  }
}
let Vp = class extends q {
  constructor(e, t, i) {
    super(), this._workerDescriptor = e, this._disposed = !1, this._modelService = i, this._keepIdleModels = t, this._worker = null, this._modelManager = null;
  }
  // foreign host request
  fhr(e, t) {
    throw new Error("Not implemented!");
  }
  _getOrCreateWorker() {
    if (!this._worker)
      try {
        this._worker = this._register(h3(this._workerDescriptor)), dv.setChannel(this._worker, this._createEditorWorkerHost());
      } catch (e) {
        sv(e), this._worker = this._createFallbackLocalWorker();
      }
    return this._worker;
  }
  async _getProxy() {
    try {
      const e = this._getOrCreateWorker().proxy;
      return await e.$ping(), e;
    } catch (e) {
      return sv(e), this._worker = this._createFallbackLocalWorker(), this._worker.proxy;
    }
  }
  _createFallbackLocalWorker() {
    return new cF(new Ym(this._createEditorWorkerHost(), null));
  }
  _createEditorWorkerHost() {
    return {
      $fhr: (e, t) => this.fhr(e, t)
    };
  }
  _getOrCreateModelManager(e) {
    return this._modelManager || (this._modelManager = this._register(new oF(e, this._modelService, this._keepIdleModels))), this._modelManager;
  }
  async workerWithSyncedResources(e, t = !1) {
    if (this._disposed)
      return Promise.reject(iO());
    const i = await this._getProxy();
    return this._getOrCreateModelManager(i).ensureSyncedResources(e, t), i;
  }
  async textualSuggest(e, t, i) {
    const n = await this.workerWithSyncedResources(e), o = i.source, r = i.flags;
    return n.$textualSuggest(e.map((a) => a.toString()), t, o, r);
  }
  dispose() {
    super.dispose(), this._disposed = !0;
  }
};
Vp = nk([
  kl(2, cn)
], Vp);
var ms;
(function(s) {
  s.DARK = "dark", s.LIGHT = "light", s.HIGH_CONTRAST_DARK = "hcDark", s.HIGH_CONTRAST_LIGHT = "hcLight";
})(ms || (ms = {}));
function Gh(s) {
  return s === ms.HIGH_CONTRAST_DARK || s === ms.HIGH_CONTRAST_LIGHT;
}
function vb(s) {
  return s === ms.DARK || s === ms.HIGH_CONTRAST_DARK;
}
const Ws = Ve("themeService");
function eh(s) {
  return { id: s };
}
function wv(s) {
  switch (s) {
    case ms.DARK:
      return "vs-dark";
    case ms.HIGH_CONTRAST_DARK:
      return "hc-black";
    case ms.HIGH_CONTRAST_LIGHT:
      return "hc-light";
    default:
      return "vs";
  }
}
const aR = {
  ThemingContribution: "base.contributions.theming"
};
class hF {
  constructor() {
    this.themingParticipants = [], this.themingParticipants = [], this.onThemingParticipantAddedEmitter = new O();
  }
  onColorThemeChange(e) {
    return this.themingParticipants.push(e), this.onThemingParticipantAddedEmitter.fire(e), ke(() => {
      const t = this.themingParticipants.indexOf(e);
      this.themingParticipants.splice(t, 1);
    });
  }
  getThemingParticipants() {
    return this.themingParticipants;
  }
}
const lR = new hF();
Li.add(aR.ThemingContribution, lR);
function Jr(s) {
  return lR.onColorThemeChange(s);
}
class dF extends q {
  constructor(e) {
    super(), this.themeService = e, this.theme = e.getColorTheme(), this._register(this.themeService.onDidColorThemeChange((t) => this.onThemeChange(t)));
  }
  onThemeChange(e) {
    this.theme = e, this.updateStyles();
  }
  updateStyles() {
  }
}
var uF = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, fF = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let vv = class extends q {
  constructor(e) {
    super(), this._themeService = e, this._onWillCreateCodeEditor = this._register(new O()), this._onCodeEditorAdd = this._register(new O()), this.onCodeEditorAdd = this._onCodeEditorAdd.event, this._onCodeEditorRemove = this._register(new O()), this.onCodeEditorRemove = this._onCodeEditorRemove.event, this._onWillCreateDiffEditor = this._register(new O()), this._onDiffEditorAdd = this._register(new O()), this.onDiffEditorAdd = this._onDiffEditorAdd.event, this._onDiffEditorRemove = this._register(new O()), this.onDiffEditorRemove = this._onDiffEditorRemove.event, this._decorationOptionProviders = /* @__PURE__ */ new Map(), this._codeEditorOpenHandlers = new An(), this._modelProperties = /* @__PURE__ */ new Map(), this._codeEditors = /* @__PURE__ */ Object.create(null), this._diffEditors = /* @__PURE__ */ Object.create(null), this._globalStyleSheet = null;
  }
  willCreateCodeEditor() {
    this._onWillCreateCodeEditor.fire();
  }
  addCodeEditor(e) {
    this._codeEditors[e.getId()] = e, this._onCodeEditorAdd.fire(e);
  }
  removeCodeEditor(e) {
    delete this._codeEditors[e.getId()] && this._onCodeEditorRemove.fire(e);
  }
  listCodeEditors() {
    return Object.keys(this._codeEditors).map((e) => this._codeEditors[e]);
  }
  willCreateDiffEditor() {
    this._onWillCreateDiffEditor.fire();
  }
  addDiffEditor(e) {
    this._diffEditors[e.getId()] = e, this._onDiffEditorAdd.fire(e);
  }
  listDiffEditors() {
    return Object.keys(this._diffEditors).map((e) => this._diffEditors[e]);
  }
  getFocusedCodeEditor() {
    let e = null;
    const t = this.listCodeEditors();
    for (const i of t) {
      if (i.hasTextFocus())
        return i;
      i.hasWidgetFocus() && (e = i);
    }
    return e;
  }
  removeDecorationType(e) {
    const t = this._decorationOptionProviders.get(e);
    t && (t.refCount--, t.refCount <= 0 && (this._decorationOptionProviders.delete(e), t.dispose(), this.listCodeEditors().forEach((i) => i.removeDecorationsByType(e))));
  }
  setModelProperty(e, t, i) {
    const n = e.toString();
    let o;
    this._modelProperties.has(n) ? o = this._modelProperties.get(n) : (o = /* @__PURE__ */ new Map(), this._modelProperties.set(n, o)), o.set(t, i);
  }
  getModelProperty(e, t) {
    const i = e.toString();
    if (this._modelProperties.has(i))
      return this._modelProperties.get(i).get(t);
  }
  async openCodeEditor(e, t, i) {
    for (const n of this._codeEditorOpenHandlers) {
      const o = await n(e, t, i);
      if (o !== null)
        return o;
    }
    return null;
  }
  registerCodeEditorOpenHandler(e) {
    const t = this._codeEditorOpenHandlers.unshift(e);
    return ke(t);
  }
};
vv = uF([
  fF(0, Ws)
], vv);
var gF = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, RE = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let Hp = class extends vv {
  constructor(e, t) {
    super(t), this._register(this.onCodeEditorAdd(() => this._checkContextKey())), this._register(this.onCodeEditorRemove(() => this._checkContextKey())), this._editorIsOpen = e.createKey("editorIsOpen", !1), this._activeCodeEditor = null, this._register(this.registerCodeEditorOpenHandler(async (i, n, o) => n ? this.doOpenEditor(n, i) : null));
  }
  _checkContextKey() {
    let e = !1;
    for (const t of this.listCodeEditors())
      if (!t.isSimpleWidget) {
        e = !0;
        break;
      }
    this._editorIsOpen.set(e);
  }
  setActiveCodeEditor(e) {
    this._activeCodeEditor = e;
  }
  getActiveCodeEditor() {
    return this._activeCodeEditor;
  }
  doOpenEditor(e, t) {
    if (!this.findModel(e, t.resource)) {
      if (t.resource) {
        const o = t.resource.scheme;
        if (o === Ne.http || o === Ne.https)
          return DM(t.resource.toString()), e;
      }
      return null;
    }
    const n = t.options ? t.options.selection : null;
    if (n)
      if (typeof n.endLineNumber == "number" && typeof n.endColumn == "number")
        e.setSelection(n), e.revealRangeInCenter(
          n,
          1
          /* ScrollType.Immediate */
        );
      else {
        const o = {
          lineNumber: n.startLineNumber,
          column: n.startColumn
        };
        e.setPosition(o), e.revealPositionInCenter(
          o,
          1
          /* ScrollType.Immediate */
        );
      }
    return e;
  }
  findModel(e, t) {
    const i = e.getModel();
    return i && i.uri.toString() !== t.toString() ? null : i;
  }
};
Hp = gF([
  RE(0, nt),
  RE(1, Ws)
], Hp);
Ge(
  ri,
  Hp,
  0
  /* InstantiationType.Eager */
);
const Xa = Ve("layoutService");
var cR = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, hR = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let zp = class {
  get mainContainer() {
    var e;
    return ((e = gL(this._codeEditorService.listCodeEditors())) == null ? void 0 : e.getContainerDomNode()) ?? ut.document.body;
  }
  get activeContainer() {
    const e = this._codeEditorService.getFocusedCodeEditor() ?? this._codeEditorService.getActiveCodeEditor();
    return (e == null ? void 0 : e.getContainerDomNode()) ?? this.mainContainer;
  }
  get mainContainerDimension() {
    return Zw(this.mainContainer);
  }
  get activeContainerDimension() {
    return Zw(this.activeContainer);
  }
  get containers() {
    return fL(this._codeEditorService.listCodeEditors().map((e) => e.getContainerDomNode()));
  }
  getContainer() {
    return this.activeContainer;
  }
  whenContainerStylesLoaded() {
  }
  focus() {
    var e;
    (e = this._codeEditorService.getFocusedCodeEditor()) == null || e.focus();
  }
  constructor(e) {
    this._codeEditorService = e, this.onDidLayoutMainContainer = J.None, this.onDidLayoutActiveContainer = J.None, this.onDidLayoutContainer = J.None, this.onDidChangeActiveContainer = J.None, this.onDidAddContainer = J.None, this.mainContainerOffset = { top: 0, quickPickTop: 0 }, this.activeContainerOffset = { top: 0, quickPickTop: 0 };
  }
};
zp = cR([
  hR(0, ri)
], zp);
let yv = class extends zp {
  get mainContainer() {
    return this._container;
  }
  constructor(e, t) {
    super(t), this._container = e;
  }
};
yv = cR([
  hR(1, ri)
], yv);
Ge(
  Xa,
  zp,
  1
  /* InstantiationType.Delayed */
);
var Uf;
(function(s) {
  s[s.Ignore = 0] = "Ignore", s[s.Info = 1] = "Info", s[s.Warning = 2] = "Warning", s[s.Error = 3] = "Error";
})(Uf || (Uf = {}));
(function(s) {
  const e = "error", t = "warning", i = "warn", n = "info", o = "ignore";
  function r(l) {
    return l ? dh(e, l) ? s.Error : dh(t, l) || dh(i, l) ? s.Warning : dh(n, l) ? s.Info : s.Ignore : s.Ignore;
  }
  s.fromValue = r;
  function a(l) {
    switch (l) {
      case s.Error:
        return e;
      case s.Warning:
        return t;
      case s.Info:
        return n;
      default:
        return o;
    }
  }
  s.toString = a;
})(Uf || (Uf = {}));
const Jt = Uf, dR = Ve("dialogService");
var mF = Jt;
const fo = Ve("notificationService");
class pF {
}
const sk = Ve("undoRedoService");
class uR {
  constructor(e, t) {
    this.resource = e, this.elements = t;
  }
}
const Ph = class Ph {
  constructor() {
    this.id = Ph._ID++, this.order = 1;
  }
  nextOrder() {
    return this.id === 0 ? 0 : this.order++;
  }
};
Ph._ID = 0, Ph.None = new Ph();
let Sv = Ph;
const Oh = class Oh {
  constructor() {
    this.id = Oh._ID++, this.order = 1;
  }
  nextOrder() {
    return this.id === 0 ? 0 : this.order++;
  }
};
Oh._ID = 0, Oh.None = new Oh();
let Dl = Oh;
var _F = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, AE = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
function lm(s) {
  return s.scheme === Ne.file ? s.fsPath : s.path;
}
let fR = 0;
class cm {
  constructor(e, t, i, n, o, r, a) {
    this.id = ++fR, this.type = 0, this.actual = e, this.label = e.label, this.confirmBeforeUndo = e.confirmBeforeUndo || !1, this.resourceLabel = t, this.strResource = i, this.resourceLabels = [this.resourceLabel], this.strResources = [this.strResource], this.groupId = n, this.groupOrder = o, this.sourceId = r, this.sourceOrder = a, this.isValid = !0;
  }
  setValid(e) {
    this.isValid = e;
  }
  toString() {
    return `[id:${this.id}] [group:${this.groupId}] [${this.isValid ? "  VALID" : "INVALID"}] ${this.actual.constructor.name} - ${this.actual}`;
  }
}
class PE {
  constructor(e, t) {
    this.resourceLabel = e, this.reason = t;
  }
}
class OE {
  constructor() {
    this.elements = /* @__PURE__ */ new Map();
  }
  createMessage() {
    const e = [], t = [];
    for (const [, n] of this.elements)
      (n.reason === 0 ? e : t).push(n.resourceLabel);
    const i = [];
    return e.length > 0 && i.push(p({ key: "externalRemoval", comment: ["{0} is a list of filenames"] }, "The following files have been closed and modified on disk: {0}.", e.join(", "))), t.length > 0 && i.push(p({ key: "noParallelUniverses", comment: ["{0} is a list of filenames"] }, "The following files have been modified in an incompatible way: {0}.", t.join(", "))), i.join(`
`);
  }
  get size() {
    return this.elements.size;
  }
  has(e) {
    return this.elements.has(e);
  }
  set(e, t) {
    this.elements.set(e, t);
  }
  delete(e) {
    return this.elements.delete(e);
  }
}
class bF {
  constructor(e, t, i, n, o, r, a) {
    this.id = ++fR, this.type = 1, this.actual = e, this.label = e.label, this.confirmBeforeUndo = e.confirmBeforeUndo || !1, this.resourceLabels = t, this.strResources = i, this.groupId = n, this.groupOrder = o, this.sourceId = r, this.sourceOrder = a, this.removedResources = null, this.invalidatedResources = null;
  }
  canSplit() {
    return typeof this.actual.split == "function";
  }
  removeResource(e, t, i) {
    this.removedResources || (this.removedResources = new OE()), this.removedResources.has(t) || this.removedResources.set(t, new PE(e, i));
  }
  setValid(e, t, i) {
    i ? this.invalidatedResources && (this.invalidatedResources.delete(t), this.invalidatedResources.size === 0 && (this.invalidatedResources = null)) : (this.invalidatedResources || (this.invalidatedResources = new OE()), this.invalidatedResources.has(t) || this.invalidatedResources.set(t, new PE(
      e,
      0
      /* RemovedResourceReason.ExternalRemoval */
    )));
  }
  toString() {
    return `[id:${this.id}] [group:${this.groupId}] [${this.invalidatedResources ? "INVALID" : "  VALID"}] ${this.actual.constructor.name} - ${this.actual}`;
  }
}
class gR {
  constructor(e, t) {
    this.resourceLabel = e, this.strResource = t, this._past = [], this._future = [], this.locked = !1, this.versionId = 1;
  }
  dispose() {
    for (const e of this._past)
      e.type === 1 && e.removeResource(
        this.resourceLabel,
        this.strResource,
        0
        /* RemovedResourceReason.ExternalRemoval */
      );
    for (const e of this._future)
      e.type === 1 && e.removeResource(
        this.resourceLabel,
        this.strResource,
        0
        /* RemovedResourceReason.ExternalRemoval */
      );
    this.versionId++;
  }
  toString() {
    const e = [];
    e.push(`* ${this.strResource}:`);
    for (let t = 0; t < this._past.length; t++)
      e.push(`   * [UNDO] ${this._past[t]}`);
    for (let t = this._future.length - 1; t >= 0; t--)
      e.push(`   * [REDO] ${this._future[t]}`);
    return e.join(`
`);
  }
  flushAllElements() {
    this._past = [], this._future = [], this.versionId++;
  }
  _setElementValidFlag(e, t) {
    e.type === 1 ? e.setValid(this.resourceLabel, this.strResource, t) : e.setValid(t);
  }
  setElementsValidFlag(e, t) {
    for (const i of this._past)
      t(i.actual) && this._setElementValidFlag(i, e);
    for (const i of this._future)
      t(i.actual) && this._setElementValidFlag(i, e);
  }
  pushElement(e) {
    for (const t of this._future)
      t.type === 1 && t.removeResource(
        this.resourceLabel,
        this.strResource,
        1
        /* RemovedResourceReason.NoParallelUniverses */
      );
    this._future = [], this._past.push(e), this.versionId++;
  }
  createSnapshot(e) {
    const t = [];
    for (let i = 0, n = this._past.length; i < n; i++)
      t.push(this._past[i].id);
    for (let i = this._future.length - 1; i >= 0; i--)
      t.push(this._future[i].id);
    return new uR(e, t);
  }
  restoreSnapshot(e) {
    const t = e.elements.length;
    let i = !0, n = 0, o = -1;
    for (let a = 0, l = this._past.length; a < l; a++, n++) {
      const c = this._past[a];
      i && (n >= t || c.id !== e.elements[n]) && (i = !1, o = 0), !i && c.type === 1 && c.removeResource(
        this.resourceLabel,
        this.strResource,
        0
        /* RemovedResourceReason.ExternalRemoval */
      );
    }
    let r = -1;
    for (let a = this._future.length - 1; a >= 0; a--, n++) {
      const l = this._future[a];
      i && (n >= t || l.id !== e.elements[n]) && (i = !1, r = a), !i && l.type === 1 && l.removeResource(
        this.resourceLabel,
        this.strResource,
        0
        /* RemovedResourceReason.ExternalRemoval */
      );
    }
    o !== -1 && (this._past = this._past.slice(0, o)), r !== -1 && (this._future = this._future.slice(r + 1)), this.versionId++;
  }
  getElements() {
    const e = [], t = [];
    for (const i of this._past)
      e.push(i.actual);
    for (const i of this._future)
      t.push(i.actual);
    return { past: e, future: t };
  }
  getClosestPastElement() {
    return this._past.length === 0 ? null : this._past[this._past.length - 1];
  }
  getSecondClosestPastElement() {
    return this._past.length < 2 ? null : this._past[this._past.length - 2];
  }
  getClosestFutureElement() {
    return this._future.length === 0 ? null : this._future[this._future.length - 1];
  }
  hasPastElements() {
    return this._past.length > 0;
  }
  hasFutureElements() {
    return this._future.length > 0;
  }
  splitPastWorkspaceElement(e, t) {
    for (let i = this._past.length - 1; i >= 0; i--)
      if (this._past[i] === e) {
        t.has(this.strResource) ? this._past[i] = t.get(this.strResource) : this._past.splice(i, 1);
        break;
      }
    this.versionId++;
  }
  splitFutureWorkspaceElement(e, t) {
    for (let i = this._future.length - 1; i >= 0; i--)
      if (this._future[i] === e) {
        t.has(this.strResource) ? this._future[i] = t.get(this.strResource) : this._future.splice(i, 1);
        break;
      }
    this.versionId++;
  }
  moveBackward(e) {
    this._past.pop(), this._future.push(e), this.versionId++;
  }
  moveForward(e) {
    this._future.pop(), this._past.push(e), this.versionId++;
  }
}
class P0 {
  constructor(e) {
    this.editStacks = e, this._versionIds = [];
    for (let t = 0, i = this.editStacks.length; t < i; t++)
      this._versionIds[t] = this.editStacks[t].versionId;
  }
  isValid() {
    for (let e = 0, t = this.editStacks.length; e < t; e++)
      if (this._versionIds[e] !== this.editStacks[e].versionId)
        return !1;
    return !0;
  }
}
const mR = new gR("", "");
mR.locked = !0;
let Lv = class {
  constructor(e, t) {
    this._dialogService = e, this._notificationService = t, this._editStacks = /* @__PURE__ */ new Map(), this._uriComparisonKeyComputers = [];
  }
  getUriComparisonKey(e) {
    for (const t of this._uriComparisonKeyComputers)
      if (t[0] === e.scheme)
        return t[1].getComparisonKey(e);
    return e.toString();
  }
  _print(e) {
    console.log("------------------------------------"), console.log(`AFTER ${e}: `);
    const t = [];
    for (const i of this._editStacks)
      t.push(i[1].toString());
    console.log(t.join(`
`));
  }
  pushElement(e, t = Sv.None, i = Dl.None) {
    if (e.type === 0) {
      const n = lm(e.resource), o = this.getUriComparisonKey(e.resource);
      this._pushElement(new cm(e, n, o, t.id, t.nextOrder(), i.id, i.nextOrder()));
    } else {
      const n = /* @__PURE__ */ new Set(), o = [], r = [];
      for (const a of e.resources) {
        const l = lm(a), c = this.getUriComparisonKey(a);
        n.has(c) || (n.add(c), o.push(l), r.push(c));
      }
      o.length === 1 ? this._pushElement(new cm(e, o[0], r[0], t.id, t.nextOrder(), i.id, i.nextOrder())) : this._pushElement(new bF(e, o, r, t.id, t.nextOrder(), i.id, i.nextOrder()));
    }
  }
  _pushElement(e) {
    for (let t = 0, i = e.strResources.length; t < i; t++) {
      const n = e.resourceLabels[t], o = e.strResources[t];
      let r;
      this._editStacks.has(o) ? r = this._editStacks.get(o) : (r = new gR(n, o), this._editStacks.set(o, r)), r.pushElement(e);
    }
  }
  getLastElement(e) {
    const t = this.getUriComparisonKey(e);
    if (this._editStacks.has(t)) {
      const i = this._editStacks.get(t);
      if (i.hasFutureElements())
        return null;
      const n = i.getClosestPastElement();
      return n ? n.actual : null;
    }
    return null;
  }
  _splitPastWorkspaceElement(e, t) {
    const i = e.actual.split(), n = /* @__PURE__ */ new Map();
    for (const o of i) {
      const r = lm(o.resource), a = this.getUriComparisonKey(o.resource), l = new cm(o, r, a, 0, 0, 0, 0);
      n.set(l.strResource, l);
    }
    for (const o of e.strResources) {
      if (t && t.has(o))
        continue;
      this._editStacks.get(o).splitPastWorkspaceElement(e, n);
    }
  }
  _splitFutureWorkspaceElement(e, t) {
    const i = e.actual.split(), n = /* @__PURE__ */ new Map();
    for (const o of i) {
      const r = lm(o.resource), a = this.getUriComparisonKey(o.resource), l = new cm(o, r, a, 0, 0, 0, 0);
      n.set(l.strResource, l);
    }
    for (const o of e.strResources) {
      if (t && t.has(o))
        continue;
      this._editStacks.get(o).splitFutureWorkspaceElement(e, n);
    }
  }
  removeElements(e) {
    const t = typeof e == "string" ? e : this.getUriComparisonKey(e);
    this._editStacks.has(t) && (this._editStacks.get(t).dispose(), this._editStacks.delete(t));
  }
  setElementsValidFlag(e, t, i) {
    const n = this.getUriComparisonKey(e);
    this._editStacks.has(n) && this._editStacks.get(n).setElementsValidFlag(t, i);
  }
  createSnapshot(e) {
    const t = this.getUriComparisonKey(e);
    return this._editStacks.has(t) ? this._editStacks.get(t).createSnapshot(e) : new uR(e, []);
  }
  restoreSnapshot(e) {
    const t = this.getUriComparisonKey(e.resource);
    if (this._editStacks.has(t)) {
      const i = this._editStacks.get(t);
      i.restoreSnapshot(e), !i.hasPastElements() && !i.hasFutureElements() && (i.dispose(), this._editStacks.delete(t));
    }
  }
  getElements(e) {
    const t = this.getUriComparisonKey(e);
    return this._editStacks.has(t) ? this._editStacks.get(t).getElements() : { past: [], future: [] };
  }
  _findClosestUndoElementWithSource(e) {
    if (!e)
      return [null, null];
    let t = null, i = null;
    for (const [n, o] of this._editStacks) {
      const r = o.getClosestPastElement();
      r && r.sourceId === e && (!t || r.sourceOrder > t.sourceOrder) && (t = r, i = n);
    }
    return [t, i];
  }
  canUndo(e) {
    if (e instanceof Dl) {
      const [, i] = this._findClosestUndoElementWithSource(e.id);
      return !!i;
    }
    const t = this.getUriComparisonKey(e);
    return this._editStacks.has(t) ? this._editStacks.get(t).hasPastElements() : !1;
  }
  _onError(e, t) {
    ht(e);
    for (const i of t.strResources)
      this.removeElements(i);
    this._notificationService.error(e);
  }
  _acquireLocks(e) {
    for (const t of e.editStacks)
      if (t.locked)
        throw new Error("Cannot acquire edit stack lock");
    for (const t of e.editStacks)
      t.locked = !0;
    return () => {
      for (const t of e.editStacks)
        t.locked = !1;
    };
  }
  _safeInvokeWithLocks(e, t, i, n, o) {
    const r = this._acquireLocks(i);
    let a;
    try {
      a = t();
    } catch (l) {
      return r(), n.dispose(), this._onError(l, e);
    }
    return a ? a.then(() => (r(), n.dispose(), o()), (l) => (r(), n.dispose(), this._onError(l, e))) : (r(), n.dispose(), o());
  }
  async _invokeWorkspacePrepare(e) {
    if (typeof e.actual.prepareUndoRedo > "u")
      return q.None;
    const t = e.actual.prepareUndoRedo();
    return typeof t > "u" ? q.None : t;
  }
  _invokeResourcePrepare(e, t) {
    if (e.actual.type !== 1 || typeof e.actual.prepareUndoRedo > "u")
      return t(q.None);
    const i = e.actual.prepareUndoRedo();
    return i ? A2(i) ? t(i) : i.then((n) => t(n)) : t(q.None);
  }
  _getAffectedEditStacks(e) {
    const t = [];
    for (const i of e.strResources)
      t.push(this._editStacks.get(i) || mR);
    return new P0(t);
  }
  _tryToSplitAndUndo(e, t, i, n) {
    if (t.canSplit())
      return this._splitPastWorkspaceElement(t, i), this._notificationService.warn(n), new hm(this._undo(e, 0, !0));
    for (const o of t.strResources)
      this.removeElements(o);
    return this._notificationService.warn(n), new hm();
  }
  _checkWorkspaceUndo(e, t, i, n) {
    if (t.removedResources)
      return this._tryToSplitAndUndo(e, t, t.removedResources, p({ key: "cannotWorkspaceUndo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not undo '{0}' across all files. {1}", t.label, t.removedResources.createMessage()));
    if (n && t.invalidatedResources)
      return this._tryToSplitAndUndo(e, t, t.invalidatedResources, p({ key: "cannotWorkspaceUndo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not undo '{0}' across all files. {1}", t.label, t.invalidatedResources.createMessage()));
    const o = [];
    for (const a of i.editStacks)
      a.getClosestPastElement() !== t && o.push(a.resourceLabel);
    if (o.length > 0)
      return this._tryToSplitAndUndo(e, t, null, p({ key: "cannotWorkspaceUndoDueToChanges", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not undo '{0}' across all files because changes were made to {1}", t.label, o.join(", ")));
    const r = [];
    for (const a of i.editStacks)
      a.locked && r.push(a.resourceLabel);
    return r.length > 0 ? this._tryToSplitAndUndo(e, t, null, p({ key: "cannotWorkspaceUndoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not undo '{0}' across all files because there is already an undo or redo operation running on {1}", t.label, r.join(", "))) : i.isValid() ? null : this._tryToSplitAndUndo(e, t, null, p({ key: "cannotWorkspaceUndoDueToInMeantimeUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not undo '{0}' across all files because an undo or redo operation occurred in the meantime", t.label));
  }
  _workspaceUndo(e, t, i) {
    const n = this._getAffectedEditStacks(t), o = this._checkWorkspaceUndo(
      e,
      t,
      n,
      /*invalidated resources will be checked after the prepare call*/
      !1
    );
    return o ? o.returnValue : this._confirmAndExecuteWorkspaceUndo(e, t, n, i);
  }
  _isPartOfUndoGroup(e) {
    if (!e.groupId)
      return !1;
    for (const [, t] of this._editStacks) {
      const i = t.getClosestPastElement();
      if (i) {
        if (i === e) {
          const n = t.getSecondClosestPastElement();
          if (n && n.groupId === e.groupId)
            return !0;
        }
        if (i.groupId === e.groupId)
          return !0;
      }
    }
    return !1;
  }
  async _confirmAndExecuteWorkspaceUndo(e, t, i, n) {
    if (t.canSplit() && !this._isPartOfUndoGroup(t)) {
      let a;
      (function(h) {
        h[h.All = 0] = "All", h[h.This = 1] = "This", h[h.Cancel = 2] = "Cancel";
      })(a || (a = {}));
      const { result: l } = await this._dialogService.prompt({
        type: Jt.Info,
        message: p("confirmWorkspace", "Would you like to undo '{0}' across all files?", t.label),
        buttons: [
          {
            label: p({ key: "ok", comment: ["{0} denotes a number that is > 1, && denotes a mnemonic"] }, "&&Undo in {0} Files", i.editStacks.length),
            run: () => a.All
          },
          {
            label: p({ key: "nok", comment: ["&& denotes a mnemonic"] }, "Undo this &&File"),
            run: () => a.This
          }
        ],
        cancelButton: {
          run: () => a.Cancel
        }
      });
      if (l === a.Cancel)
        return;
      if (l === a.This)
        return this._splitPastWorkspaceElement(t, null), this._undo(e, 0, !0);
      const c = this._checkWorkspaceUndo(
        e,
        t,
        i,
        /*invalidated resources will be checked after the prepare call*/
        !1
      );
      if (c)
        return c.returnValue;
      n = !0;
    }
    let o;
    try {
      o = await this._invokeWorkspacePrepare(t);
    } catch (a) {
      return this._onError(a, t);
    }
    const r = this._checkWorkspaceUndo(
      e,
      t,
      i,
      /*now also check that there are no more invalidated resources*/
      !0
    );
    if (r)
      return o.dispose(), r.returnValue;
    for (const a of i.editStacks)
      a.moveBackward(t);
    return this._safeInvokeWithLocks(t, () => t.actual.undo(), i, o, () => this._continueUndoInGroup(t.groupId, n));
  }
  _resourceUndo(e, t, i) {
    if (!t.isValid) {
      e.flushAllElements();
      return;
    }
    if (e.locked) {
      const n = p({ key: "cannotResourceUndoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation."] }, "Could not undo '{0}' because there is already an undo or redo operation running.", t.label);
      this._notificationService.warn(n);
      return;
    }
    return this._invokeResourcePrepare(t, (n) => (e.moveBackward(t), this._safeInvokeWithLocks(t, () => t.actual.undo(), new P0([e]), n, () => this._continueUndoInGroup(t.groupId, i))));
  }
  _findClosestUndoElementInGroup(e) {
    if (!e)
      return [null, null];
    let t = null, i = null;
    for (const [n, o] of this._editStacks) {
      const r = o.getClosestPastElement();
      r && r.groupId === e && (!t || r.groupOrder > t.groupOrder) && (t = r, i = n);
    }
    return [t, i];
  }
  _continueUndoInGroup(e, t) {
    if (!e)
      return;
    const [, i] = this._findClosestUndoElementInGroup(e);
    if (i)
      return this._undo(i, 0, t);
  }
  undo(e) {
    if (e instanceof Dl) {
      const [, t] = this._findClosestUndoElementWithSource(e.id);
      return t ? this._undo(t, e.id, !1) : void 0;
    }
    return typeof e == "string" ? this._undo(e, 0, !1) : this._undo(this.getUriComparisonKey(e), 0, !1);
  }
  _undo(e, t = 0, i) {
    if (!this._editStacks.has(e))
      return;
    const n = this._editStacks.get(e), o = n.getClosestPastElement();
    if (!o)
      return;
    if (o.groupId) {
      const [a, l] = this._findClosestUndoElementInGroup(o.groupId);
      if (o !== a && l)
        return this._undo(l, t, i);
    }
    if ((o.sourceId !== t || o.confirmBeforeUndo) && !i)
      return this._confirmAndContinueUndo(e, t, o);
    try {
      return o.type === 1 ? this._workspaceUndo(e, o, i) : this._resourceUndo(n, o, i);
    } finally {
    }
  }
  async _confirmAndContinueUndo(e, t, i) {
    if ((await this._dialogService.confirm({
      message: p("confirmDifferentSource", "Would you like to undo '{0}'?", i.label),
      primaryButton: p({ key: "confirmDifferentSource.yes", comment: ["&& denotes a mnemonic"] }, "&&Yes"),
      cancelButton: p("confirmDifferentSource.no", "No")
    })).confirmed)
      return this._undo(e, t, !0);
  }
  _findClosestRedoElementWithSource(e) {
    if (!e)
      return [null, null];
    let t = null, i = null;
    for (const [n, o] of this._editStacks) {
      const r = o.getClosestFutureElement();
      r && r.sourceId === e && (!t || r.sourceOrder < t.sourceOrder) && (t = r, i = n);
    }
    return [t, i];
  }
  canRedo(e) {
    if (e instanceof Dl) {
      const [, i] = this._findClosestRedoElementWithSource(e.id);
      return !!i;
    }
    const t = this.getUriComparisonKey(e);
    return this._editStacks.has(t) ? this._editStacks.get(t).hasFutureElements() : !1;
  }
  _tryToSplitAndRedo(e, t, i, n) {
    if (t.canSplit())
      return this._splitFutureWorkspaceElement(t, i), this._notificationService.warn(n), new hm(this._redo(e));
    for (const o of t.strResources)
      this.removeElements(o);
    return this._notificationService.warn(n), new hm();
  }
  _checkWorkspaceRedo(e, t, i, n) {
    if (t.removedResources)
      return this._tryToSplitAndRedo(e, t, t.removedResources, p({ key: "cannotWorkspaceRedo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not redo '{0}' across all files. {1}", t.label, t.removedResources.createMessage()));
    if (n && t.invalidatedResources)
      return this._tryToSplitAndRedo(e, t, t.invalidatedResources, p({ key: "cannotWorkspaceRedo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not redo '{0}' across all files. {1}", t.label, t.invalidatedResources.createMessage()));
    const o = [];
    for (const a of i.editStacks)
      a.getClosestFutureElement() !== t && o.push(a.resourceLabel);
    if (o.length > 0)
      return this._tryToSplitAndRedo(e, t, null, p({ key: "cannotWorkspaceRedoDueToChanges", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not redo '{0}' across all files because changes were made to {1}", t.label, o.join(", ")));
    const r = [];
    for (const a of i.editStacks)
      a.locked && r.push(a.resourceLabel);
    return r.length > 0 ? this._tryToSplitAndRedo(e, t, null, p({ key: "cannotWorkspaceRedoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not redo '{0}' across all files because there is already an undo or redo operation running on {1}", t.label, r.join(", "))) : i.isValid() ? null : this._tryToSplitAndRedo(e, t, null, p({ key: "cannotWorkspaceRedoDueToInMeantimeUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not redo '{0}' across all files because an undo or redo operation occurred in the meantime", t.label));
  }
  _workspaceRedo(e, t) {
    const i = this._getAffectedEditStacks(t), n = this._checkWorkspaceRedo(
      e,
      t,
      i,
      /*invalidated resources will be checked after the prepare call*/
      !1
    );
    return n ? n.returnValue : this._executeWorkspaceRedo(e, t, i);
  }
  async _executeWorkspaceRedo(e, t, i) {
    let n;
    try {
      n = await this._invokeWorkspacePrepare(t);
    } catch (r) {
      return this._onError(r, t);
    }
    const o = this._checkWorkspaceRedo(
      e,
      t,
      i,
      /*now also check that there are no more invalidated resources*/
      !0
    );
    if (o)
      return n.dispose(), o.returnValue;
    for (const r of i.editStacks)
      r.moveForward(t);
    return this._safeInvokeWithLocks(t, () => t.actual.redo(), i, n, () => this._continueRedoInGroup(t.groupId));
  }
  _resourceRedo(e, t) {
    if (!t.isValid) {
      e.flushAllElements();
      return;
    }
    if (e.locked) {
      const i = p({ key: "cannotResourceRedoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation."] }, "Could not redo '{0}' because there is already an undo or redo operation running.", t.label);
      this._notificationService.warn(i);
      return;
    }
    return this._invokeResourcePrepare(t, (i) => (e.moveForward(t), this._safeInvokeWithLocks(t, () => t.actual.redo(), new P0([e]), i, () => this._continueRedoInGroup(t.groupId))));
  }
  _findClosestRedoElementInGroup(e) {
    if (!e)
      return [null, null];
    let t = null, i = null;
    for (const [n, o] of this._editStacks) {
      const r = o.getClosestFutureElement();
      r && r.groupId === e && (!t || r.groupOrder < t.groupOrder) && (t = r, i = n);
    }
    return [t, i];
  }
  _continueRedoInGroup(e) {
    if (!e)
      return;
    const [, t] = this._findClosestRedoElementInGroup(e);
    if (t)
      return this._redo(t);
  }
  redo(e) {
    if (e instanceof Dl) {
      const [, t] = this._findClosestRedoElementWithSource(e.id);
      return t ? this._redo(t) : void 0;
    }
    return typeof e == "string" ? this._redo(e) : this._redo(this.getUriComparisonKey(e));
  }
  _redo(e) {
    if (!this._editStacks.has(e))
      return;
    const t = this._editStacks.get(e), i = t.getClosestFutureElement();
    if (i) {
      if (i.groupId) {
        const [n, o] = this._findClosestRedoElementInGroup(i.groupId);
        if (i !== n && o)
          return this._redo(o);
      }
      try {
        return i.type === 1 ? this._workspaceRedo(e, i) : this._resourceRedo(t, i);
      } finally {
      }
    }
  }
};
Lv = _F([
  AE(0, dR),
  AE(1, fo)
], Lv);
class hm {
  constructor(e) {
    this.returnValue = e;
  }
}
Ge(
  sk,
  Lv,
  1
  /* InstantiationType.Delayed */
);
function gn(s, e, t) {
  return Math.min(Math.max(s, e), t);
}
class pR {
  constructor() {
    this._n = 1, this._val = 0;
  }
  update(e) {
    return this._val = this._val + (e - this._val) / this._n, this._n += 1, this._val;
  }
  get value() {
    return this._val;
  }
}
class CF {
  constructor(e) {
    this._n = 0, this._val = 0, this._values = [], this._index = 0, this._sum = 0, this._values = new Array(e), this._values.fill(0, 0, e);
  }
  update(e) {
    const t = this._values[this._index];
    return this._values[this._index] = e, this._index = (this._index + 1) % this._values.length, this._sum -= t, this._sum += e, this._n < this._values.length && (this._n += 1), this._val = this._sum / this._n, this._val;
  }
  get value() {
    return this._val;
  }
}
const _R = Ve("environmentService");
var wF = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, FE = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const vF = Ve("ILanguageFeatureDebounceService");
var Up;
(function(s) {
  const e = /* @__PURE__ */ new WeakMap();
  let t = 0;
  function i(n) {
    let o = e.get(n);
    return o === void 0 && (o = ++t, e.set(n, o)), o;
  }
  s.of = i;
})(Up || (Up = {}));
class yF {
  constructor(e) {
    this._default = e;
  }
  get(e) {
    return this._default;
  }
  update(e, t) {
    return this._default;
  }
  default() {
    return this._default;
  }
}
class SF {
  constructor(e, t, i, n, o, r) {
    this._logService = e, this._name = t, this._registry = i, this._default = n, this._min = o, this._max = r, this._cache = new Tg(50, 0.7);
  }
  _key(e) {
    return e.id + this._registry.all(e).reduce((t, i) => ob(Up.of(i), t), 0);
  }
  get(e) {
    const t = this._key(e), i = this._cache.get(t);
    return i ? gn(i.value, this._min, this._max) : this.default();
  }
  update(e, t) {
    const i = this._key(e);
    let n = this._cache.get(i);
    n || (n = new CF(6), this._cache.set(i, n));
    const o = gn(n.update(t), this._min, this._max);
    return OL(e.uri, "output") || this._logService.trace(`[DEBOUNCE: ${this._name}] for ${e.uri.toString()} is ${o}ms`), o;
  }
  _overall() {
    const e = new pR();
    for (const [, t] of this._cache)
      e.update(t.value);
    return e.value;
  }
  default() {
    const e = this._overall() | 0 || this._default;
    return gn(e, this._min, this._max);
  }
}
let kv = class {
  constructor(e, t) {
    this._logService = e, this._data = /* @__PURE__ */ new Map(), this._isDev = t.isExtensionDevelopment || !t.isBuilt;
  }
  for(e, t, i) {
    const n = (i == null ? void 0 : i.min) ?? 50, o = (i == null ? void 0 : i.max) ?? n ** 2, r = (i == null ? void 0 : i.key) ?? void 0, a = `${Up.of(e)},${n}${r ? "," + r : ""}`;
    let l = this._data.get(a);
    return l || (this._isDev ? (this._logService.debug(`[DEBOUNCE: ${t}] is disabled in developed mode`), l = new yF(n * 1.5)) : l = new SF(
      this._logService,
      t,
      e,
      this._overallAverage() | 0 || n * 1.5,
      // default is overall default or derived from min-value
      n,
      o
    ), this._data.set(a, l)), l;
  }
  _overallAverage() {
    const e = new pR();
    for (const t of this._data.values())
      e.update(t.default());
    return e.value;
  }
};
kv = wF([
  FE(0, uo),
  FE(1, _R)
], kv);
Ge(
  vF,
  kv,
  1
  /* InstantiationType.Delayed */
);
class Xs {
  static getLanguageId(e) {
    return (e & 255) >>> 0;
  }
  static getTokenType(e) {
    return (e & 768) >>> 8;
  }
  static containsBalancedBrackets(e) {
    return (e & 1024) !== 0;
  }
  static getFontStyle(e) {
    return (e & 30720) >>> 11;
  }
  static getForeground(e) {
    return (e & 16744448) >>> 15;
  }
  static getBackground(e) {
    return (e & 4278190080) >>> 24;
  }
  static getClassNameFromMetadata(e) {
    let i = "mtk" + this.getForeground(e);
    const n = this.getFontStyle(e);
    return n & 1 && (i += " mtki"), n & 2 && (i += " mtkb"), n & 4 && (i += " mtku"), n & 8 && (i += " mtks"), i;
  }
  static getInlineStyleFromMetadata(e, t) {
    const i = this.getForeground(e), n = this.getFontStyle(e);
    let o = `color: ${t[i]};`;
    n & 1 && (o += "font-style: italic;"), n & 2 && (o += "font-weight: bold;");
    let r = "";
    return n & 4 && (r += " underline"), n & 8 && (r += " line-through"), r && (o += `text-decoration:${r};`), o;
  }
  static getPresentationFromMetadata(e) {
    const t = this.getForeground(e), i = this.getFontStyle(e);
    return {
      foreground: t,
      italic: !!(i & 1),
      bold: !!(i & 2),
      underline: !!(i & 4),
      strikethrough: !!(i & 8)
    };
  }
}
function Ld(s) {
  let e = 0, t = 0, i = 0, n = 0;
  for (let o = 0, r = s.length; o < r; o++) {
    const a = s.charCodeAt(o);
    a === 13 ? (e === 0 && (t = o), e++, o + 1 < r && s.charCodeAt(o + 1) === 10 ? (n |= 2, o++) : n |= 3, i = o + 1) : a === 10 && (n |= 1, e === 0 && (t = o), e++, i = o + 1);
  }
  return e === 0 && (t = s.length), [e, t, s.length - i, n];
}
var LF = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, O0 = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let xv = class {
  constructor(e, t, i, n) {
    this._legend = e, this._themeService = t, this._languageService = i, this._logService = n, this._hasWarnedOverlappingTokens = !1, this._hasWarnedInvalidLengthTokens = !1, this._hasWarnedInvalidEditStart = !1, this._hashTable = new Dv();
  }
  getMetadata(e, t, i) {
    const n = this._languageService.languageIdCodec.encodeLanguageId(i), o = this._hashTable.get(e, t, n);
    let r;
    if (o)
      r = o.metadata;
    else {
      let a = this._legend.tokenTypes[e];
      const l = [];
      if (a) {
        let c = t;
        for (let d = 0; c > 0 && d < this._legend.tokenModifiers.length; d++)
          c & 1 && l.push(this._legend.tokenModifiers[d]), c = c >> 1;
        const h = this._themeService.getColorTheme().getTokenStyleMetadata(a, l, i);
        if (typeof h > "u")
          r = 2147483647;
        else {
          if (r = 0, typeof h.italic < "u") {
            const d = (h.italic ? 1 : 0) << 11;
            r |= d | 1;
          }
          if (typeof h.bold < "u") {
            const d = (h.bold ? 2 : 0) << 11;
            r |= d | 2;
          }
          if (typeof h.underline < "u") {
            const d = (h.underline ? 4 : 0) << 11;
            r |= d | 4;
          }
          if (typeof h.strikethrough < "u") {
            const d = (h.strikethrough ? 8 : 0) << 11;
            r |= d | 8;
          }
          if (h.foreground) {
            const d = h.foreground << 15;
            r |= d | 16;
          }
          r === 0 && (r = 2147483647);
        }
      } else
        r = 2147483647, a = "not-in-legend";
      this._hashTable.add(e, t, n, r);
    }
    return r;
  }
  warnOverlappingSemanticTokens(e, t) {
    this._hasWarnedOverlappingTokens || (this._hasWarnedOverlappingTokens = !0, this._logService.warn(`Overlapping semantic tokens detected at lineNumber ${e}, column ${t}`));
  }
  warnInvalidLengthSemanticTokens(e, t) {
    this._hasWarnedInvalidLengthTokens || (this._hasWarnedInvalidLengthTokens = !0, this._logService.warn(`Semantic token with invalid length detected at lineNumber ${e}, column ${t}`));
  }
  warnInvalidEditStart(e, t, i, n, o) {
    this._hasWarnedInvalidEditStart || (this._hasWarnedInvalidEditStart = !0, this._logService.warn(`Invalid semantic tokens edit detected (previousResultId: ${e}, resultId: ${t}) at edit #${i}: The provided start offset ${n} is outside the previous data (length ${o}).`));
  }
};
xv = LF([
  O0(1, Ws),
  O0(2, gi),
  O0(3, uo)
], xv);
class kF {
  constructor(e, t, i, n) {
    this.tokenTypeIndex = e, this.tokenModifierSet = t, this.languageId = i, this.metadata = n, this.next = null;
  }
}
const _r = class _r {
  constructor() {
    this._elementsCount = 0, this._currentLengthIndex = 0, this._currentLength = _r._SIZES[this._currentLengthIndex], this._growCount = Math.round(this._currentLengthIndex + 1 < _r._SIZES.length ? 2 / 3 * this._currentLength : 0), this._elements = [], _r._nullOutEntries(this._elements, this._currentLength);
  }
  static _nullOutEntries(e, t) {
    for (let i = 0; i < t; i++)
      e[i] = null;
  }
  _hash2(e, t) {
    return (e << 5) - e + t | 0;
  }
  _hashFunc(e, t, i) {
    return this._hash2(this._hash2(e, t), i) % this._currentLength;
  }
  get(e, t, i) {
    const n = this._hashFunc(e, t, i);
    let o = this._elements[n];
    for (; o; ) {
      if (o.tokenTypeIndex === e && o.tokenModifierSet === t && o.languageId === i)
        return o;
      o = o.next;
    }
    return null;
  }
  add(e, t, i, n) {
    if (this._elementsCount++, this._growCount !== 0 && this._elementsCount >= this._growCount) {
      const o = this._elements;
      this._currentLengthIndex++, this._currentLength = _r._SIZES[this._currentLengthIndex], this._growCount = Math.round(this._currentLengthIndex + 1 < _r._SIZES.length ? 2 / 3 * this._currentLength : 0), this._elements = [], _r._nullOutEntries(this._elements, this._currentLength);
      for (const r of o) {
        let a = r;
        for (; a; ) {
          const l = a.next;
          a.next = null, this._add(a), a = l;
        }
      }
    }
    this._add(new kF(e, t, i, n));
  }
  _add(e) {
    const t = this._hashFunc(e.tokenTypeIndex, e.tokenModifierSet, e.languageId);
    e.next = this._elements[t], this._elements[t] = e;
  }
};
_r._SIZES = [3, 7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381, 32749, 65521, 131071, 262139, 524287, 1048573, 2097143];
let Dv = _r;
const xF = Ve("semanticTokensStylingService");
var DF = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, F0 = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let Ev = class extends q {
  constructor(e, t, i) {
    super(), this._themeService = e, this._logService = t, this._languageService = i, this._caches = /* @__PURE__ */ new WeakMap(), this._register(this._themeService.onDidColorThemeChange(() => {
      this._caches = /* @__PURE__ */ new WeakMap();
    }));
  }
  getStyling(e) {
    return this._caches.has(e) || this._caches.set(e, new xv(e.getLegend(), this._themeService, this._languageService, this._logService)), this._caches.get(e);
  }
};
Ev = DF([
  F0(0, Ws),
  F0(1, uo),
  F0(2, gi)
], Ev);
Ge(
  xF,
  Ev,
  1
  /* InstantiationType.Delayed */
);
function ca(s) {
  return s === 47 || s === 92;
}
function bR(s) {
  return s.replace(/[\\/]/g, Kt.sep);
}
function EF(s) {
  return s.indexOf("/") === -1 && (s = bR(s)), /^[a-zA-Z]:(\/|$)/.test(s) && (s = "/" + s), s;
}
function BE(s, e = Kt.sep) {
  if (!s)
    return "";
  const t = s.length, i = s.charCodeAt(0);
  if (ca(i)) {
    if (ca(s.charCodeAt(1)) && !ca(s.charCodeAt(2))) {
      let o = 3;
      const r = o;
      for (; o < t && !ca(s.charCodeAt(o)); o++)
        ;
      if (r !== o && !ca(s.charCodeAt(o + 1))) {
        for (o += 1; o < t; o++)
          if (ca(s.charCodeAt(o)))
            return s.slice(0, o + 1).replace(/[\\/]/g, e);
      }
    }
    return e;
  } else if (IF(i) && s.charCodeAt(1) === 58)
    return ca(s.charCodeAt(2)) ? s.slice(0, 2) + e : s.slice(0, 2);
  let n = s.indexOf("://");
  if (n !== -1) {
    for (n += 3; n < t; n++)
      if (ca(s.charCodeAt(n)))
        return s.slice(0, n + 1);
  }
  return "";
}
function Iv(s, e, t, i = Fa) {
  if (s === e)
    return !0;
  if (!s || !e || e.length > s.length)
    return !1;
  if (t) {
    if (!EL(s, e))
      return !1;
    if (e.length === s.length)
      return !0;
    let o = e.length;
    return e.charAt(e.length - 1) === i && o--, s.charAt(o) === i;
  }
  return e.charAt(e.length - 1) !== i && (e += i), s.indexOf(e) === 0;
}
function IF(s) {
  return s >= 65 && s <= 90 || s >= 97 && s <= 122;
}
const dm = "**", WE = "/", Qm = "[/\\\\]", Xm = "[^/\\\\]", NF = /\//g;
function VE(s, e) {
  switch (s) {
    case 0:
      return "";
    case 1:
      return `${Xm}*?`;
    // 1 star matches any number of characters except path separator (/ and \) - non greedy (?)
    default:
      return `(?:${Qm}|${Xm}+${Qm}${e ? `|${Qm}${Xm}+` : ""})*?`;
  }
}
function HE(s, e) {
  if (!s)
    return [];
  const t = [];
  let i = !1, n = !1, o = "";
  for (const r of s) {
    switch (r) {
      case e:
        if (!i && !n) {
          t.push(o), o = "";
          continue;
        }
        break;
      case "{":
        i = !0;
        break;
      case "}":
        i = !1;
        break;
      case "[":
        n = !0;
        break;
      case "]":
        n = !1;
        break;
    }
    o += r;
  }
  return o && t.push(o), t;
}
function CR(s) {
  if (!s)
    return "";
  let e = "";
  const t = HE(s, WE);
  if (t.every((i) => i === dm))
    e = ".*";
  else {
    let i = !1;
    t.forEach((n, o) => {
      if (n === dm) {
        if (i)
          return;
        e += VE(2, o === t.length - 1);
      } else {
        let r = !1, a = "", l = !1, c = "";
        for (const h of n) {
          if (h !== "}" && r) {
            a += h;
            continue;
          }
          if (l && (h !== "]" || !c)) {
            let d;
            h === "-" ? d = h : (h === "^" || h === "!") && !c ? d = "^" : h === WE ? d = "" : d = Yr(h), c += d;
            continue;
          }
          switch (h) {
            case "{":
              r = !0;
              continue;
            case "[":
              l = !0;
              continue;
            case "}": {
              const u = `(?:${HE(a, ",").map((f) => CR(f)).join("|")})`;
              e += u, r = !1, a = "";
              break;
            }
            case "]": {
              e += "[" + c + "]", l = !1, c = "";
              break;
            }
            case "?":
              e += Xm;
              continue;
            case "*":
              e += VE(1);
              continue;
            default:
              e += Yr(h);
          }
        }
        o < t.length - 1 && // more segments to come after this
        (t[o + 1] !== dm || // next segment is not **, or...
        o + 2 < t.length) && (e += Qm);
      }
      i = n === dm;
    });
  }
  return e;
}
const TF = /^\*\*\/\*\.[\w\.-]+$/, MF = /^\*\*\/([\w\.-]+)\/?$/, RF = /^{\*\*\/\*?[\w\.-]+\/?(,\*\*\/\*?[\w\.-]+\/?)*}$/, AF = /^{\*\*\/\*?[\w\.-]+(\/(\*\*)?)?(,\*\*\/\*?[\w\.-]+(\/(\*\*)?)?)*}$/, PF = /^\*\*((\/[\w\.-]+)+)\/?$/, OF = /^([\w\.-]+(\/[\w\.-]+)*)\/?$/, zE = new Tg(1e4), UE = function() {
  return !1;
}, Vo = function() {
  return null;
};
function ok(s, e) {
  if (!s)
    return Vo;
  let t;
  typeof s != "string" ? t = s.pattern : t = s, t = t.trim();
  const i = `${t}_${!!e.trimForExclusions}`;
  let n = zE.get(i);
  if (n)
    return $E(n, s);
  let o;
  return TF.test(t) ? n = FF(t.substr(4), t) : (o = MF.exec(B0(t, e))) ? n = BF(o[1], t) : (e.trimForExclusions ? AF : RF).test(t) ? n = WF(t, e) : (o = PF.exec(B0(t, e))) ? n = KE(o[1].substr(1), t, !0) : (o = OF.exec(B0(t, e))) ? n = KE(o[1], t, !1) : n = VF(t), zE.set(i, n), $E(n, s);
}
function $E(s, e) {
  if (typeof e == "string")
    return s;
  const t = function(i, n) {
    return Iv(i, e.base, !wn) ? s(ib(i.substr(e.base.length), Fa), n) : null;
  };
  return t.allBasenames = s.allBasenames, t.allPaths = s.allPaths, t.basenames = s.basenames, t.patterns = s.patterns, t;
}
function B0(s, e) {
  return e.trimForExclusions && s.endsWith("/**") ? s.substr(0, s.length - 2) : s;
}
function FF(s, e) {
  return function(t, i) {
    return typeof t == "string" && t.endsWith(s) ? e : null;
  };
}
function BF(s, e) {
  const t = `/${s}`, i = `\\${s}`, n = function(r, a) {
    return typeof r != "string" ? null : a ? a === s ? e : null : r === s || r.endsWith(t) || r.endsWith(i) ? e : null;
  }, o = [s];
  return n.basenames = o, n.patterns = [e], n.allBasenames = o, n;
}
function WF(s, e) {
  const t = vR(s.slice(1, -1).split(",").map((a) => ok(a, e)).filter((a) => a !== Vo), s), i = t.length;
  if (!i)
    return Vo;
  if (i === 1)
    return t[0];
  const n = function(a, l) {
    for (let c = 0, h = t.length; c < h; c++)
      if (t[c](a, l))
        return s;
    return null;
  }, o = t.find((a) => !!a.allBasenames);
  o && (n.allBasenames = o.allBasenames);
  const r = t.reduce((a, l) => l.allPaths ? a.concat(l.allPaths) : a, []);
  return r.length && (n.allPaths = r), n;
}
function KE(s, e, t) {
  const i = Fa === Kt.sep, n = i ? s : s.replace(NF, Fa), o = Fa + n, r = Kt.sep + s;
  let a;
  return t ? a = function(l, c) {
    return typeof l == "string" && (l === n || l.endsWith(o) || !i && (l === s || l.endsWith(r))) ? e : null;
  } : a = function(l, c) {
    return typeof l == "string" && (l === n || !i && l === s) ? e : null;
  }, a.allPaths = [(t ? "*/" : "./") + s], a;
}
function VF(s) {
  try {
    const e = new RegExp(`^${CR(s)}$`);
    return function(t) {
      return e.lastIndex = 0, typeof t == "string" && e.test(t) ? s : null;
    };
  } catch {
    return Vo;
  }
}
function HF(s, e, t) {
  return !s || typeof e != "string" ? !1 : wR(s)(e, void 0, t);
}
function wR(s, e = {}) {
  if (!s)
    return UE;
  if (typeof s == "string" || zF(s)) {
    const t = ok(s, e);
    if (t === Vo)
      return UE;
    const i = function(n, o) {
      return !!t(n, o);
    };
    return t.allBasenames && (i.allBasenames = t.allBasenames), t.allPaths && (i.allPaths = t.allPaths), i;
  }
  return UF(s, e);
}
function zF(s) {
  const e = s;
  return e ? typeof e.base == "string" && typeof e.pattern == "string" : !1;
}
function UF(s, e) {
  const t = vR(Object.getOwnPropertyNames(s).map((a) => $F(a, s[a], e)).filter((a) => a !== Vo)), i = t.length;
  if (!i)
    return Vo;
  if (!t.some((a) => !!a.requiresSiblings)) {
    if (i === 1)
      return t[0];
    const a = function(h, d) {
      let u;
      for (let f = 0, g = t.length; f < g; f++) {
        const m = t[f](h, d);
        if (typeof m == "string")
          return m;
        Hw(m) && (u || (u = []), u.push(m));
      }
      return u ? (async () => {
        for (const f of u) {
          const g = await f;
          if (typeof g == "string")
            return g;
        }
        return null;
      })() : null;
    }, l = t.find((h) => !!h.allBasenames);
    l && (a.allBasenames = l.allBasenames);
    const c = t.reduce((h, d) => d.allPaths ? h.concat(d.allPaths) : h, []);
    return c.length && (a.allPaths = c), a;
  }
  const n = function(a, l, c) {
    let h, d;
    for (let u = 0, f = t.length; u < f; u++) {
      const g = t[u];
      g.requiresSiblings && c && (l || (l = z2(a)), h || (h = l.substr(0, l.length - IO(a).length)));
      const m = g(a, l, h, c);
      if (typeof m == "string")
        return m;
      Hw(m) && (d || (d = []), d.push(m));
    }
    return d ? (async () => {
      for (const u of d) {
        const f = await u;
        if (typeof f == "string")
          return f;
      }
      return null;
    })() : null;
  }, o = t.find((a) => !!a.allBasenames);
  o && (n.allBasenames = o.allBasenames);
  const r = t.reduce((a, l) => l.allPaths ? a.concat(l.allPaths) : a, []);
  return r.length && (n.allPaths = r), n;
}
function $F(s, e, t) {
  if (e === !1)
    return Vo;
  const i = ok(s, t);
  if (i === Vo)
    return Vo;
  if (typeof e == "boolean")
    return i;
  if (e) {
    const n = e.when;
    if (typeof n == "string") {
      const o = (r, a, l, c) => {
        if (!c || !i(r, a))
          return null;
        const h = n.replace("$(basename)", () => l), d = c(h);
        return Hw(d) ? d.then((u) => u ? s : null) : d ? s : null;
      };
      return o.requiresSiblings = !0, o;
    }
  }
  return i;
}
function vR(s, e) {
  const t = s.filter((a) => !!a.basenames);
  if (t.length < 2)
    return s;
  const i = t.reduce((a, l) => {
    const c = l.basenames;
    return c ? a.concat(c) : a;
  }, []);
  let n;
  if (e) {
    n = [];
    for (let a = 0, l = i.length; a < l; a++)
      n.push(e);
  } else
    n = t.reduce((a, l) => {
      const c = l.patterns;
      return c ? a.concat(c) : a;
    }, []);
  const o = function(a, l) {
    if (typeof a != "string")
      return null;
    if (!l) {
      let h;
      for (h = a.length; h > 0; h--) {
        const d = a.charCodeAt(h - 1);
        if (d === 47 || d === 92)
          break;
      }
      l = a.substr(h);
    }
    const c = i.indexOf(l);
    return c !== -1 ? n[c] : null;
  };
  o.basenames = i, o.patterns = n, o.allBasenames = i;
  const r = s.filter((a) => !a.basenames);
  return r.push(o), r;
}
function yR(s, e, t, i, n, o) {
  if (Array.isArray(s)) {
    let r = 0;
    for (const a of s) {
      const l = yR(a, e, t, i, n, o);
      if (l === 10)
        return l;
      l > r && (r = l);
    }
    return r;
  } else {
    if (typeof s == "string")
      return i ? s === "*" ? 5 : s === t ? 10 : 0 : 0;
    if (s) {
      const { language: r, pattern: a, scheme: l, hasAccessToAllModels: c, notebookType: h } = s;
      if (!i && !c)
        return 0;
      h && n && (e = n);
      let d = 0;
      if (l)
        if (l === e.scheme)
          d = 10;
        else if (l === "*")
          d = 5;
        else
          return 0;
      if (r)
        if (r === t)
          d = 10;
        else if (r === "*")
          d = Math.max(d, 5);
        else
          return 0;
      if (h)
        if (h === o)
          d = 10;
        else if (h === "*" && o !== void 0)
          d = Math.max(d, 5);
        else
          return 0;
      if (a) {
        let u;
        if (typeof a == "string" ? u = a : u = { ...a, base: H2(a.base) }, u === e.fsPath || HF(u, e.fsPath))
          d = 10;
        else
          return 0;
      }
      return d;
    } else
      return 0;
  }
}
function SR(s) {
  return typeof s == "string" ? !1 : Array.isArray(s) ? s.every(SR) : !!s.exclusive;
}
class qE {
  constructor(e, t, i, n, o) {
    this.uri = e, this.languageId = t, this.notebookUri = i, this.notebookType = n, this.recursive = o;
  }
  equals(e) {
    var t, i;
    return this.notebookType === e.notebookType && this.languageId === e.languageId && this.uri.toString() === e.uri.toString() && ((t = this.notebookUri) == null ? void 0 : t.toString()) === ((i = e.notebookUri) == null ? void 0 : i.toString()) && this.recursive === e.recursive;
  }
}
class It {
  constructor(e) {
    this._notebookInfoResolver = e, this._clock = 0, this._entries = [], this._onDidChange = new O(), this.onDidChange = this._onDidChange.event;
  }
  register(e, t) {
    let i = {
      selector: e,
      provider: t,
      _score: -1,
      _time: this._clock++
    };
    return this._entries.push(i), this._lastCandidate = void 0, this._onDidChange.fire(this._entries.length), ke(() => {
      if (i) {
        const n = this._entries.indexOf(i);
        n >= 0 && (this._entries.splice(n, 1), this._lastCandidate = void 0, this._onDidChange.fire(this._entries.length), i = void 0);
      }
    });
  }
  has(e) {
    return this.all(e).length > 0;
  }
  all(e) {
    if (!e)
      return [];
    this._updateScores(e, !1);
    const t = [];
    for (const i of this._entries)
      i._score > 0 && t.push(i.provider);
    return t;
  }
  ordered(e, t = !1) {
    const i = [];
    return this._orderedForEach(e, t, (n) => i.push(n.provider)), i;
  }
  orderedGroups(e) {
    const t = [];
    let i, n;
    return this._orderedForEach(e, !1, (o) => {
      i && n === o._score ? i.push(o.provider) : (n = o._score, i = [o.provider], t.push(i));
    }), t;
  }
  _orderedForEach(e, t, i) {
    this._updateScores(e, t);
    for (const n of this._entries)
      n._score > 0 && i(n);
  }
  _updateScores(e, t) {
    var o, r;
    const i = (o = this._notebookInfoResolver) == null ? void 0 : o.call(this, e.uri), n = i ? new qE(e.uri, e.getLanguageId(), i.uri, i.type, t) : new qE(e.uri, e.getLanguageId(), void 0, void 0, t);
    if (!((r = this._lastCandidate) != null && r.equals(n))) {
      this._lastCandidate = n;
      for (const a of this._entries)
        if (a._score = yR(a.selector, n.uri, n.languageId, l9(e), n.notebookUri, n.notebookType), SR(a.selector) && a._score > 0)
          if (t)
            a._score = 0;
          else {
            for (const l of this._entries)
              l._score = 0;
            a._score = 1e3;
            break;
          }
      this._entries.sort(It._compareByScoreAndTime);
    }
  }
  static _compareByScoreAndTime(e, t) {
    return e._score < t._score ? 1 : e._score > t._score ? -1 : ku(e.selector) && !ku(t.selector) ? 1 : !ku(e.selector) && ku(t.selector) ? -1 : e._time < t._time ? 1 : e._time > t._time ? -1 : 0;
  }
}
function ku(s) {
  return typeof s == "string" ? !1 : Array.isArray(s) ? s.some(ku) : !!s.isBuiltin;
}
class KF {
  constructor() {
    this.referenceProvider = new It(this._score.bind(this)), this.renameProvider = new It(this._score.bind(this)), this.newSymbolNamesProvider = new It(this._score.bind(this)), this.codeActionProvider = new It(this._score.bind(this)), this.definitionProvider = new It(this._score.bind(this)), this.typeDefinitionProvider = new It(this._score.bind(this)), this.declarationProvider = new It(this._score.bind(this)), this.implementationProvider = new It(this._score.bind(this)), this.documentSymbolProvider = new It(this._score.bind(this)), this.inlayHintsProvider = new It(this._score.bind(this)), this.colorProvider = new It(this._score.bind(this)), this.codeLensProvider = new It(this._score.bind(this)), this.documentFormattingEditProvider = new It(this._score.bind(this)), this.documentRangeFormattingEditProvider = new It(this._score.bind(this)), this.onTypeFormattingEditProvider = new It(this._score.bind(this)), this.signatureHelpProvider = new It(this._score.bind(this)), this.hoverProvider = new It(this._score.bind(this)), this.documentHighlightProvider = new It(this._score.bind(this)), this.multiDocumentHighlightProvider = new It(this._score.bind(this)), this.selectionRangeProvider = new It(this._score.bind(this)), this.foldingRangeProvider = new It(this._score.bind(this)), this.linkProvider = new It(this._score.bind(this)), this.inlineCompletionsProvider = new It(this._score.bind(this)), this.inlineEditProvider = new It(this._score.bind(this)), this.completionProvider = new It(this._score.bind(this)), this.linkedEditingRangeProvider = new It(this._score.bind(this)), this.documentRangeSemanticTokensProvider = new It(this._score.bind(this)), this.documentSemanticTokensProvider = new It(this._score.bind(this)), this.documentDropEditProvider = new It(this._score.bind(this)), this.documentPasteEditProvider = new It(this._score.bind(this));
  }
  _score(e) {
    var t;
    return (t = this._notebookTypeResolver) == null ? void 0 : t.call(this, e);
  }
}
Ge(
  gt,
  KF,
  1
  /* InstantiationType.Delayed */
);
function rk(s) {
  return `--vscode-${s.replace(/\./g, "-")}`;
}
function te(s) {
  return `var(${rk(s)})`;
}
function qF(s, e) {
  return `var(${rk(s)}, ${e})`;
}
function jF(s) {
  return s !== null && typeof s == "object" && "light" in s && "dark" in s;
}
const LR = {
  ColorContribution: "base.contributions.colors"
}, GF = "default";
class ZF {
  constructor() {
    this._onDidChangeSchema = new O(), this.onDidChangeSchema = this._onDidChangeSchema.event, this.colorSchema = { type: "object", properties: {} }, this.colorReferenceSchema = { type: "string", enum: [], enumDescriptions: [] }, this.colorsById = {};
  }
  registerColor(e, t, i, n = !1, o) {
    const r = { id: e, description: i, defaults: t, needsTransparency: n, deprecationMessage: o };
    this.colorsById[e] = r;
    const a = { type: "string", format: "color-hex", defaultSnippets: [{ body: "${1:#ff0000}" }] };
    return o && (a.deprecationMessage = o), n && (a.pattern = "^#(?:(?<rgba>[0-9a-fA-f]{3}[0-9a-eA-E])|(?:[0-9a-fA-F]{6}(?:(?![fF]{2})(?:[0-9a-fA-F]{2}))))?$", a.patternErrorMessage = p("transparecyRequired", "This color must be transparent or it will obscure content")), this.colorSchema.properties[e] = {
      description: i,
      oneOf: [
        a,
        { type: "string", const: GF, description: p("useDefault", "Use the default color.") }
      ]
    }, this.colorReferenceSchema.enum.push(e), this.colorReferenceSchema.enumDescriptions.push(i), this._onDidChangeSchema.fire(), e;
  }
  getColors() {
    return Object.keys(this.colorsById).map((e) => this.colorsById[e]);
  }
  resolveDefaultColor(e, t) {
    const i = this.colorsById[e];
    if (i != null && i.defaults) {
      const n = jF(i.defaults) ? i.defaults[t.type] : i.defaults;
      return Ks(n, t);
    }
  }
  getColorSchema() {
    return this.colorSchema;
  }
  toString() {
    const e = (t, i) => {
      const n = t.indexOf(".") === -1 ? 0 : 1, o = i.indexOf(".") === -1 ? 0 : 1;
      return n !== o ? n - o : t.localeCompare(i);
    };
    return Object.keys(this.colorsById).sort(e).map((t) => `- \`${t}\`: ${this.colorsById[t].description}`).join(`
`);
  }
}
const yb = new ZF();
Li.add(LR.ColorContribution, yb);
function N(s, e, t, i, n) {
  return yb.registerColor(s, e, t, i, n);
}
function YF(s, e) {
  var t, i, n, o;
  switch (s.op) {
    case 0:
      return (t = Ks(s.value, e)) == null ? void 0 : t.darken(s.factor);
    case 1:
      return (i = Ks(s.value, e)) == null ? void 0 : i.lighten(s.factor);
    case 2:
      return (n = Ks(s.value, e)) == null ? void 0 : n.transparent(s.factor);
    case 3: {
      const r = Ks(s.background, e);
      return r ? (o = Ks(s.value, e)) == null ? void 0 : o.makeOpaque(r) : Ks(s.value, e);
    }
    case 4:
      for (const r of s.values) {
        const a = Ks(r, e);
        if (a)
          return a;
      }
      return;
    case 6:
      return Ks(e.defines(s.if) ? s.then : s.else, e);
    case 5: {
      const r = Ks(s.value, e);
      if (!r)
        return;
      const a = Ks(s.background, e);
      return a ? r.isDarkerThan(a) ? Z.getLighterColor(r, a, s.factor).transparent(s.transparency) : Z.getDarkerColor(r, a, s.factor).transparent(s.transparency) : r.transparent(s.factor * s.transparency);
    }
    default:
      throw jL();
  }
}
function Fc(s, e) {
  return { op: 0, value: s, factor: e };
}
function no(s, e) {
  return { op: 1, value: s, factor: e };
}
function Ae(s, e) {
  return { op: 2, value: s, factor: e };
}
function jE(...s) {
  return { op: 4, values: s };
}
function QF(s, e, t) {
  return { op: 6, if: s, then: e, else: t };
}
function GE(s, e, t, i) {
  return { op: 5, value: s, background: e, factor: t, transparency: i };
}
function Ks(s, e) {
  if (s !== null) {
    if (typeof s == "string")
      return s[0] === "#" ? Z.fromHex(s) : e.getColor(s);
    if (s instanceof Z)
      return s;
    if (typeof s == "object")
      return YF(s, e);
  }
}
const kR = "vscode://schemas/workbench-colors", xR = Li.as(wb.JSONContribution);
xR.registerSchema(kR, yb.getColorSchema());
const ZE = new sn(() => xR.notifySchemaChanged(kR), 200);
yb.onDidChangeSchema(() => {
  ZE.isScheduled() || ZE.schedule();
});
const ct = N("foreground", { dark: "#CCCCCC", light: "#616161", hcDark: "#FFFFFF", hcLight: "#292929" }, p("foreground", "Overall foreground color. This color is only used if not overridden by a component."));
N("disabledForeground", { dark: "#CCCCCC80", light: "#61616180", hcDark: "#A5A5A5", hcLight: "#7F7F7F" }, p("disabledForeground", "Overall foreground for disabled elements. This color is only used if not overridden by a component."));
N("errorForeground", { dark: "#F48771", light: "#A1260D", hcDark: "#F48771", hcLight: "#B5200D" }, p("errorForeground", "Overall foreground color for error messages. This color is only used if not overridden by a component."));
N("descriptionForeground", { light: "#717171", dark: Ae(ct, 0.7), hcDark: Ae(ct, 0.7), hcLight: Ae(ct, 0.7) }, p("descriptionForeground", "Foreground color for description text providing additional information, for example for a label."));
const Nv = N("icon.foreground", { dark: "#C5C5C5", light: "#424242", hcDark: "#FFFFFF", hcLight: "#292929" }, p("iconForeground", "The default color for icons in the workbench.")), Uo = N("focusBorder", { dark: "#007FD4", light: "#0090F1", hcDark: "#F38518", hcLight: "#006BBD" }, p("focusBorder", "Overall border color for focused elements. This color is only used if not overridden by a component.")), Xe = N("contrastBorder", { light: null, dark: null, hcDark: "#6FC3DF", hcLight: "#0F4A85" }, p("contrastBorder", "An extra border around elements to separate them from others for greater contrast.")), jt = N("contrastActiveBorder", { light: null, dark: null, hcDark: Uo, hcLight: Uo }, p("activeContrastBorder", "An extra border around active elements to separate them from others for greater contrast."));
N("selection.background", null, p("selectionBackground", "The background color of text selections in the workbench (e.g. for input fields or text areas). Note that this does not apply to selections within the editor."));
const XF = N("textLink.foreground", { light: "#006AB1", dark: "#3794FF", hcDark: "#21A6FF", hcLight: "#0F4A85" }, p("textLinkForeground", "Foreground color for links in text."));
N("textLink.activeForeground", { light: "#006AB1", dark: "#3794FF", hcDark: "#21A6FF", hcLight: "#0F4A85" }, p("textLinkActiveForeground", "Foreground color for links in text when clicked on and on mouse hover."));
N("textSeparator.foreground", { light: "#0000002e", dark: "#ffffff2e", hcDark: Z.black, hcLight: "#292929" }, p("textSeparatorForeground", "Color for text separators."));
N("textPreformat.foreground", { light: "#A31515", dark: "#D7BA7D", hcDark: "#000000", hcLight: "#FFFFFF" }, p("textPreformatForeground", "Foreground color for preformatted text segments."));
N("textPreformat.background", { light: "#0000001A", dark: "#FFFFFF1A", hcDark: "#FFFFFF", hcLight: "#09345f" }, p("textPreformatBackground", "Background color for preformatted text segments."));
N("textBlockQuote.background", { light: "#f2f2f2", dark: "#222222", hcDark: null, hcLight: "#F2F2F2" }, p("textBlockQuoteBackground", "Background color for block quotes in text."));
N("textBlockQuote.border", { light: "#007acc80", dark: "#007acc80", hcDark: Z.white, hcLight: "#292929" }, p("textBlockQuoteBorder", "Border color for block quotes in text."));
N("textCodeBlock.background", { light: "#dcdcdc66", dark: "#0a0a0a66", hcDark: Z.black, hcLight: "#F2F2F2" }, p("textCodeBlockBackground", "Background color for code blocks in text."));
N("sash.hoverBorder", Uo, p("sashActiveBorder", "Border color of active sashes."));
const Jm = N("badge.background", { dark: "#4D4D4D", light: "#C4C4C4", hcDark: Z.black, hcLight: "#0F4A85" }, p("badgeBackground", "Badge background color. Badges are small information labels, e.g. for search results count.")), JF = N("badge.foreground", { dark: Z.white, light: "#333", hcDark: Z.white, hcLight: Z.white }, p("badgeForeground", "Badge foreground color. Badges are small information labels, e.g. for search results count.")), ak = N("scrollbar.shadow", { dark: "#000000", light: "#DDDDDD", hcDark: null, hcLight: null }, p("scrollbarShadow", "Scrollbar shadow to indicate that the view is scrolled.")), DR = N("scrollbarSlider.background", { dark: Z.fromHex("#797979").transparent(0.4), light: Z.fromHex("#646464").transparent(0.4), hcDark: Ae(Xe, 0.6), hcLight: Ae(Xe, 0.4) }, p("scrollbarSliderBackground", "Scrollbar slider background color.")), ER = N("scrollbarSlider.hoverBackground", { dark: Z.fromHex("#646464").transparent(0.7), light: Z.fromHex("#646464").transparent(0.7), hcDark: Ae(Xe, 0.8), hcLight: Ae(Xe, 0.8) }, p("scrollbarSliderHoverBackground", "Scrollbar slider background color when hovering.")), IR = N("scrollbarSlider.activeBackground", { dark: Z.fromHex("#BFBFBF").transparent(0.4), light: Z.fromHex("#000000").transparent(0.6), hcDark: Xe, hcLight: Xe }, p("scrollbarSliderActiveBackground", "Scrollbar slider background color when clicked on.")), e8 = N("progressBar.background", { dark: Z.fromHex("#0E70C0"), light: Z.fromHex("#0E70C0"), hcDark: Xe, hcLight: Xe }, p("progressBarBackground", "Background color of the progress bar that can show for long running operations.")), ro = N("editor.background", { light: "#ffffff", dark: "#1E1E1E", hcDark: Z.black, hcLight: Z.white }, p("editorBackground", "Editor background color.")), Mg = N("editor.foreground", { light: "#333333", dark: "#BBBBBB", hcDark: Z.white, hcLight: ct }, p("editorForeground", "Editor default foreground color."));
N("editorStickyScroll.background", ro, p("editorStickyScrollBackground", "Background color of sticky scroll in the editor"));
N("editorStickyScrollHover.background", { dark: "#2A2D2E", light: "#F0F0F0", hcDark: null, hcLight: Z.fromHex("#0F4A85").transparent(0.1) }, p("editorStickyScrollHoverBackground", "Background color of sticky scroll on hover in the editor"));
N("editorStickyScroll.border", { dark: null, light: null, hcDark: Xe, hcLight: Xe }, p("editorStickyScrollBorder", "Border color of sticky scroll in the editor"));
N("editorStickyScroll.shadow", ak, p("editorStickyScrollShadow", " Shadow color of sticky scroll in the editor"));
const Is = N("editorWidget.background", { dark: "#252526", light: "#F3F3F3", hcDark: "#0C141F", hcLight: Z.white }, p("editorWidgetBackground", "Background color of editor widgets, such as find/replace.")), Sb = N("editorWidget.foreground", ct, p("editorWidgetForeground", "Foreground color of editor widgets, such as find/replace.")), NR = N("editorWidget.border", { dark: "#454545", light: "#C8C8C8", hcDark: Xe, hcLight: Xe }, p("editorWidgetBorder", "Border color of editor widgets. The color is only used if the widget chooses to have a border and if the color is not overridden by a widget."));
N("editorWidget.resizeBorder", null, p("editorWidgetResizeBorder", "Border color of the resize bar of editor widgets. The color is only used if the widget chooses to have a resize border and if the color is not overridden by a widget."));
N("editorError.background", null, p("editorError.background", "Background color of error text in the editor. The color must not be opaque so as not to hide underlying decorations."), !0);
const lk = N("editorError.foreground", { dark: "#F14C4C", light: "#E51400", hcDark: "#F48771", hcLight: "#B5200D" }, p("editorError.foreground", "Foreground color of error squigglies in the editor."));
N("editorError.border", { dark: null, light: null, hcDark: Z.fromHex("#E47777").transparent(0.8), hcLight: "#B5200D" }, p("errorBorder", "If set, color of double underlines for errors in the editor."));
const t8 = N("editorWarning.background", null, p("editorWarning.background", "Background color of warning text in the editor. The color must not be opaque so as not to hide underlying decorations."), !0), ja = N("editorWarning.foreground", { dark: "#CCA700", light: "#BF8803", hcDark: "#FFD370", hcLight: "#895503" }, p("editorWarning.foreground", "Foreground color of warning squigglies in the editor.")), $p = N("editorWarning.border", { dark: null, light: null, hcDark: Z.fromHex("#FFCC00").transparent(0.8), hcLight: Z.fromHex("#FFCC00").transparent(0.8) }, p("warningBorder", "If set, color of double underlines for warnings in the editor."));
N("editorInfo.background", null, p("editorInfo.background", "Background color of info text in the editor. The color must not be opaque so as not to hide underlying decorations."), !0);
const wc = N("editorInfo.foreground", { dark: "#3794FF", light: "#1a85ff", hcDark: "#3794FF", hcLight: "#1a85ff" }, p("editorInfo.foreground", "Foreground color of info squigglies in the editor.")), Kp = N("editorInfo.border", { dark: null, light: null, hcDark: Z.fromHex("#3794FF").transparent(0.8), hcLight: "#292929" }, p("infoBorder", "If set, color of double underlines for infos in the editor.")), i8 = N("editorHint.foreground", { dark: Z.fromHex("#eeeeee").transparent(0.7), light: "#6c6c6c", hcDark: null, hcLight: null }, p("editorHint.foreground", "Foreground color of hint squigglies in the editor."));
N("editorHint.border", { dark: null, light: null, hcDark: Z.fromHex("#eeeeee").transparent(0.8), hcLight: "#292929" }, p("hintBorder", "If set, color of double underlines for hints in the editor."));
N("editorLink.activeForeground", { dark: "#4E94CE", light: Z.blue, hcDark: Z.cyan, hcLight: "#292929" }, p("activeLinkForeground", "Color of active links."));
const ph = N("editor.selectionBackground", { light: "#ADD6FF", dark: "#264F78", hcDark: "#f3f518", hcLight: "#0F4A85" }, p("editorSelectionBackground", "Color of the editor selection.")), n8 = N("editor.selectionForeground", { light: null, dark: null, hcDark: "#000000", hcLight: Z.white }, p("editorSelectionForeground", "Color of the selected text for high contrast.")), TR = N("editor.inactiveSelectionBackground", { light: Ae(ph, 0.5), dark: Ae(ph, 0.5), hcDark: Ae(ph, 0.7), hcLight: Ae(ph, 0.5) }, p("editorInactiveSelection", "Color of the selection in an inactive editor. The color must not be opaque so as not to hide underlying decorations."), !0), MR = N("editor.selectionHighlightBackground", { light: GE(ph, ro, 0.3, 0.6), dark: GE(ph, ro, 0.3, 0.6), hcDark: null, hcLight: null }, p("editorSelectionHighlight", "Color for regions with the same content as the selection. The color must not be opaque so as not to hide underlying decorations."), !0);
N("editor.selectionHighlightBorder", { light: null, dark: null, hcDark: jt, hcLight: jt }, p("editorSelectionHighlightBorder", "Border color for regions with the same content as the selection."));
N("editor.findMatchBackground", { light: "#A8AC94", dark: "#515C6A", hcDark: null, hcLight: null }, p("editorFindMatch", "Color of the current search match."));
N("editor.findMatchForeground", null, p("editorFindMatchForeground", "Text color of the current search match."));
const xa = N("editor.findMatchHighlightBackground", { light: "#EA5C0055", dark: "#EA5C0055", hcDark: null, hcLight: null }, p("findMatchHighlight", "Color of the other search matches. The color must not be opaque so as not to hide underlying decorations."), !0);
N("editor.findMatchHighlightForeground", null, p("findMatchHighlightForeground", "Foreground color of the other search matches."), !0);
N("editor.findRangeHighlightBackground", { dark: "#3a3d4166", light: "#b4b4b44d", hcDark: null, hcLight: null }, p("findRangeHighlight", "Color of the range limiting the search. The color must not be opaque so as not to hide underlying decorations."), !0);
N("editor.findMatchBorder", { light: null, dark: null, hcDark: jt, hcLight: jt }, p("editorFindMatchBorder", "Border color of the current search match."));
const _h = N("editor.findMatchHighlightBorder", { light: null, dark: null, hcDark: jt, hcLight: jt }, p("findMatchHighlightBorder", "Border color of the other search matches."));
N("editor.findRangeHighlightBorder", { dark: null, light: null, hcDark: Ae(jt, 0.4), hcLight: Ae(jt, 0.4) }, p("findRangeHighlightBorder", "Border color of the range limiting the search. The color must not be opaque so as not to hide underlying decorations."), !0);
N("editor.hoverHighlightBackground", { light: "#ADD6FF26", dark: "#264f7840", hcDark: "#ADD6FF26", hcLight: null }, p("hoverHighlight", "Highlight below the word for which a hover is shown. The color must not be opaque so as not to hide underlying decorations."), !0);
const YE = N("editorHoverWidget.background", Is, p("hoverBackground", "Background color of the editor hover."));
N("editorHoverWidget.foreground", Sb, p("hoverForeground", "Foreground color of the editor hover."));
const s8 = N("editorHoverWidget.border", NR, p("hoverBorder", "Border color of the editor hover."));
N("editorHoverWidget.statusBarBackground", { dark: no(YE, 0.2), light: Fc(YE, 0.05), hcDark: Is, hcLight: Is }, p("statusBarBackground", "Background color of the editor hover status bar."));
const RR = N("editorInlayHint.foreground", { dark: "#969696", light: "#969696", hcDark: Z.white, hcLight: Z.black }, p("editorInlayHintForeground", "Foreground color of inline hints")), AR = N("editorInlayHint.background", { dark: Ae(Jm, 0.1), light: Ae(Jm, 0.1), hcDark: Ae(Z.white, 0.1), hcLight: Ae(Jm, 0.1) }, p("editorInlayHintBackground", "Background color of inline hints"));
N("editorInlayHint.typeForeground", RR, p("editorInlayHintForegroundTypes", "Foreground color of inline hints for types"));
N("editorInlayHint.typeBackground", AR, p("editorInlayHintBackgroundTypes", "Background color of inline hints for types"));
N("editorInlayHint.parameterForeground", RR, p("editorInlayHintForegroundParameter", "Foreground color of inline hints for parameters"));
N("editorInlayHint.parameterBackground", AR, p("editorInlayHintBackgroundParameter", "Background color of inline hints for parameters"));
const o8 = N("editorLightBulb.foreground", { dark: "#FFCC00", light: "#DDB100", hcDark: "#FFCC00", hcLight: "#007ACC" }, p("editorLightBulbForeground", "The color used for the lightbulb actions icon."));
N("editorLightBulbAutoFix.foreground", { dark: "#75BEFF", light: "#007ACC", hcDark: "#75BEFF", hcLight: "#007ACC" }, p("editorLightBulbAutoFixForeground", "The color used for the lightbulb auto fix actions icon."));
N("editorLightBulbAi.foreground", o8, p("editorLightBulbAiForeground", "The color used for the lightbulb AI icon."));
N("editor.snippetTabstopHighlightBackground", { dark: new Z(new qe(124, 124, 124, 0.3)), light: new Z(new qe(10, 50, 100, 0.2)), hcDark: new Z(new qe(124, 124, 124, 0.3)), hcLight: new Z(new qe(10, 50, 100, 0.2)) }, p("snippetTabstopHighlightBackground", "Highlight background color of a snippet tabstop."));
N("editor.snippetTabstopHighlightBorder", null, p("snippetTabstopHighlightBorder", "Highlight border color of a snippet tabstop."));
N("editor.snippetFinalTabstopHighlightBackground", null, p("snippetFinalTabstopHighlightBackground", "Highlight background color of the final tabstop of a snippet."));
N("editor.snippetFinalTabstopHighlightBorder", { dark: "#525252", light: new Z(new qe(10, 50, 100, 0.5)), hcDark: "#525252", hcLight: "#292929" }, p("snippetFinalTabstopHighlightBorder", "Highlight border color of the final tabstop of a snippet."));
const Tv = new Z(new qe(155, 185, 85, 0.2)), Mv = new Z(new qe(255, 0, 0, 0.2)), r8 = N("diffEditor.insertedTextBackground", { dark: "#9ccc2c33", light: "#9ccc2c40", hcDark: null, hcLight: null }, p("diffEditorInserted", "Background color for text that got inserted. The color must not be opaque so as not to hide underlying decorations."), !0), a8 = N("diffEditor.removedTextBackground", { dark: "#ff000033", light: "#ff000033", hcDark: null, hcLight: null }, p("diffEditorRemoved", "Background color for text that got removed. The color must not be opaque so as not to hide underlying decorations."), !0);
N("diffEditor.insertedLineBackground", { dark: Tv, light: Tv, hcDark: null, hcLight: null }, p("diffEditorInsertedLines", "Background color for lines that got inserted. The color must not be opaque so as not to hide underlying decorations."), !0);
N("diffEditor.removedLineBackground", { dark: Mv, light: Mv, hcDark: null, hcLight: null }, p("diffEditorRemovedLines", "Background color for lines that got removed. The color must not be opaque so as not to hide underlying decorations."), !0);
N("diffEditorGutter.insertedLineBackground", null, p("diffEditorInsertedLineGutter", "Background color for the margin where lines got inserted."));
N("diffEditorGutter.removedLineBackground", null, p("diffEditorRemovedLineGutter", "Background color for the margin where lines got removed."));
const l8 = N("diffEditorOverview.insertedForeground", null, p("diffEditorOverviewInserted", "Diff overview ruler foreground for inserted content.")), c8 = N("diffEditorOverview.removedForeground", null, p("diffEditorOverviewRemoved", "Diff overview ruler foreground for removed content."));
N("diffEditor.insertedTextBorder", { dark: null, light: null, hcDark: "#33ff2eff", hcLight: "#374E06" }, p("diffEditorInsertedOutline", "Outline color for the text that got inserted."));
N("diffEditor.removedTextBorder", { dark: null, light: null, hcDark: "#FF008F", hcLight: "#AD0707" }, p("diffEditorRemovedOutline", "Outline color for text that got removed."));
N("diffEditor.border", { dark: null, light: null, hcDark: Xe, hcLight: Xe }, p("diffEditorBorder", "Border color between the two text editors."));
N("diffEditor.diagonalFill", { dark: "#cccccc33", light: "#22222233", hcDark: null, hcLight: null }, p("diffDiagonalFill", "Color of the diff editor's diagonal fill. The diagonal fill is used in side-by-side diff views."));
N("diffEditor.unchangedRegionBackground", "sideBar.background", p("diffEditor.unchangedRegionBackground", "The background color of unchanged blocks in the diff editor."));
N("diffEditor.unchangedRegionForeground", "foreground", p("diffEditor.unchangedRegionForeground", "The foreground color of unchanged blocks in the diff editor."));
N("diffEditor.unchangedCodeBackground", { dark: "#74747429", light: "#b8b8b829", hcDark: null, hcLight: null }, p("diffEditor.unchangedCodeBackground", "The background color of unchanged code in the diff editor."));
const Rg = N("widget.shadow", { dark: Ae(Z.black, 0.36), light: Ae(Z.black, 0.16), hcDark: null, hcLight: null }, p("widgetShadow", "Shadow color of widgets such as find/replace inside the editor.")), h8 = N("widget.border", { dark: null, light: null, hcDark: Xe, hcLight: Xe }, p("widgetBorder", "Border color of widgets such as find/replace inside the editor.")), QE = N("toolbar.hoverBackground", { dark: "#5a5d5e50", light: "#b8b8b850", hcDark: null, hcLight: null }, p("toolbarHoverBackground", "Toolbar background when hovering over actions using the mouse"));
N("toolbar.hoverOutline", { dark: null, light: null, hcDark: jt, hcLight: jt }, p("toolbarHoverOutline", "Toolbar outline when hovering over actions using the mouse"));
N("toolbar.activeBackground", { dark: no(QE, 0.1), light: Fc(QE, 0.1), hcDark: null, hcLight: null }, p("toolbarActiveBackground", "Toolbar background when holding the mouse over actions"));
const d8 = N("breadcrumb.foreground", Ae(ct, 0.8), p("breadcrumbsFocusForeground", "Color of focused breadcrumb items.")), u8 = N("breadcrumb.background", ro, p("breadcrumbsBackground", "Background color of breadcrumb items.")), XE = N("breadcrumb.focusForeground", { light: Fc(ct, 0.2), dark: no(ct, 0.1), hcDark: no(ct, 0.1), hcLight: no(ct, 0.1) }, p("breadcrumbsFocusForeground", "Color of focused breadcrumb items.")), f8 = N("breadcrumb.activeSelectionForeground", { light: Fc(ct, 0.2), dark: no(ct, 0.1), hcDark: no(ct, 0.1), hcLight: no(ct, 0.1) }, p("breadcrumbsSelectedForeground", "Color of selected breadcrumb items."));
N("breadcrumbPicker.background", Is, p("breadcrumbsSelectedBackground", "Background color of breadcrumb item picker."));
const PR = 0.5, JE = Z.fromHex("#40C8AE").transparent(PR), eI = Z.fromHex("#40A6FF").transparent(PR), tI = Z.fromHex("#606060").transparent(0.4), ck = 0.4, kd = 1, Rv = N("merge.currentHeaderBackground", { dark: JE, light: JE, hcDark: null, hcLight: null }, p("mergeCurrentHeaderBackground", "Current header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), !0);
N("merge.currentContentBackground", Ae(Rv, ck), p("mergeCurrentContentBackground", "Current content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), !0);
const Av = N("merge.incomingHeaderBackground", { dark: eI, light: eI, hcDark: null, hcLight: null }, p("mergeIncomingHeaderBackground", "Incoming header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), !0);
N("merge.incomingContentBackground", Ae(Av, ck), p("mergeIncomingContentBackground", "Incoming content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), !0);
const Pv = N("merge.commonHeaderBackground", { dark: tI, light: tI, hcDark: null, hcLight: null }, p("mergeCommonHeaderBackground", "Common ancestor header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), !0);
N("merge.commonContentBackground", Ae(Pv, ck), p("mergeCommonContentBackground", "Common ancestor content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), !0);
const xd = N("merge.border", { dark: null, light: null, hcDark: "#C3DF6F", hcLight: "#007ACC" }, p("mergeBorder", "Border color on headers and the splitter in inline merge-conflicts."));
N("editorOverviewRuler.currentContentForeground", { dark: Ae(Rv, kd), light: Ae(Rv, kd), hcDark: xd, hcLight: xd }, p("overviewRulerCurrentContentForeground", "Current overview ruler foreground for inline merge-conflicts."));
N("editorOverviewRuler.incomingContentForeground", { dark: Ae(Av, kd), light: Ae(Av, kd), hcDark: xd, hcLight: xd }, p("overviewRulerIncomingContentForeground", "Incoming overview ruler foreground for inline merge-conflicts."));
N("editorOverviewRuler.commonContentForeground", { dark: Ae(Pv, kd), light: Ae(Pv, kd), hcDark: xd, hcLight: xd }, p("overviewRulerCommonContentForeground", "Common ancestor overview ruler foreground for inline merge-conflicts."));
N("editorOverviewRuler.findMatchForeground", { dark: "#d186167e", light: "#d186167e", hcDark: "#AB5A00", hcLight: "#AB5A00" }, p("overviewRulerFindMatchForeground", "Overview ruler marker color for find matches. The color must not be opaque so as not to hide underlying decorations."), !0);
N("editorOverviewRuler.selectionHighlightForeground", "#A0A0A0CC", p("overviewRulerSelectionHighlightForeground", "Overview ruler marker color for selection highlights. The color must not be opaque so as not to hide underlying decorations."), !0);
const g8 = N("problemsErrorIcon.foreground", lk, p("problemsErrorIconForeground", "The color used for the problems error icon.")), m8 = N("problemsWarningIcon.foreground", ja, p("problemsWarningIconForeground", "The color used for the problems warning icon.")), p8 = N("problemsInfoIcon.foreground", wc, p("problemsInfoIconForeground", "The color used for the problems info icon.")), _8 = N("minimap.findMatchHighlight", { light: "#d18616", dark: "#d18616", hcDark: "#AB5A00", hcLight: "#0F4A85" }, p("minimapFindMatchHighlight", "Minimap marker color for find matches."), !0);
N("minimap.selectionOccurrenceHighlight", { light: "#c9c9c9", dark: "#676767", hcDark: "#ffffff", hcLight: "#0F4A85" }, p("minimapSelectionOccurrenceHighlight", "Minimap marker color for repeating editor selections."), !0);
const iI = N("minimap.selectionHighlight", { light: "#ADD6FF", dark: "#264F78", hcDark: "#ffffff", hcLight: "#0F4A85" }, p("minimapSelectionHighlight", "Minimap marker color for the editor selection."), !0), b8 = N("minimap.infoHighlight", { dark: wc, light: wc, hcDark: Kp, hcLight: Kp }, p("minimapInfo", "Minimap marker color for infos.")), C8 = N("minimap.warningHighlight", { dark: ja, light: ja, hcDark: $p, hcLight: $p }, p("overviewRuleWarning", "Minimap marker color for warnings.")), w8 = N("minimap.errorHighlight", { dark: new Z(new qe(255, 18, 18, 0.7)), light: new Z(new qe(255, 18, 18, 0.7)), hcDark: new Z(new qe(255, 50, 50, 1)), hcLight: "#B5200D" }, p("minimapError", "Minimap marker color for errors.")), v8 = N("minimap.background", null, p("minimapBackground", "Minimap background color.")), y8 = N("minimap.foregroundOpacity", Z.fromHex("#000f"), p("minimapForegroundOpacity", 'Opacity of foreground elements rendered in the minimap. For example, "#000000c0" will render the elements with 75% opacity.'));
N("minimapSlider.background", Ae(DR, 0.5), p("minimapSliderBackground", "Minimap slider background color."));
N("minimapSlider.hoverBackground", Ae(ER, 0.5), p("minimapSliderHoverBackground", "Minimap slider background color when hovering."));
N("minimapSlider.activeBackground", Ae(IR, 0.5), p("minimapSliderActiveBackground", "Minimap slider background color when clicked on."));
N("charts.foreground", ct, p("chartsForeground", "The foreground color used in charts."));
N("charts.lines", Ae(ct, 0.5), p("chartsLines", "The color used for horizontal lines in charts."));
N("charts.red", lk, p("chartsRed", "The red color used in chart visualizations."));
N("charts.blue", wc, p("chartsBlue", "The blue color used in chart visualizations."));
N("charts.yellow", ja, p("chartsYellow", "The yellow color used in chart visualizations."));
N("charts.orange", _8, p("chartsOrange", "The orange color used in chart visualizations."));
N("charts.green", { dark: "#89D185", light: "#388A34", hcDark: "#89D185", hcLight: "#374e06" }, p("chartsGreen", "The green color used in chart visualizations."));
N("charts.purple", { dark: "#B180D7", light: "#652D90", hcDark: "#B180D7", hcLight: "#652D90" }, p("chartsPurple", "The purple color used in chart visualizations."));
const S8 = N("input.background", { dark: "#3C3C3C", light: Z.white, hcDark: Z.black, hcLight: Z.white }, p("inputBoxBackground", "Input box background.")), L8 = N("input.foreground", ct, p("inputBoxForeground", "Input box foreground.")), k8 = N("input.border", { dark: null, light: null, hcDark: Xe, hcLight: Xe }, p("inputBoxBorder", "Input box border.")), OR = N("inputOption.activeBorder", { dark: "#007ACC", light: "#007ACC", hcDark: Xe, hcLight: Xe }, p("inputBoxActiveOptionBorder", "Border color of activated options in input fields.")), x8 = N("inputOption.hoverBackground", { dark: "#5a5d5e80", light: "#b8b8b850", hcDark: null, hcLight: null }, p("inputOption.hoverBackground", "Background color of activated options in input fields.")), FR = N("inputOption.activeBackground", { dark: Ae(Uo, 0.4), light: Ae(Uo, 0.2), hcDark: Z.transparent, hcLight: Z.transparent }, p("inputOption.activeBackground", "Background hover color of options in input fields.")), BR = N("inputOption.activeForeground", { dark: Z.white, light: Z.black, hcDark: ct, hcLight: ct }, p("inputOption.activeForeground", "Foreground color of activated options in input fields."));
N("input.placeholderForeground", { light: Ae(ct, 0.5), dark: Ae(ct, 0.5), hcDark: Ae(ct, 0.7), hcLight: Ae(ct, 0.7) }, p("inputPlaceholderForeground", "Input box foreground color for placeholder text."));
const D8 = N("inputValidation.infoBackground", { dark: "#063B49", light: "#D6ECF2", hcDark: Z.black, hcLight: Z.white }, p("inputValidationInfoBackground", "Input validation background color for information severity.")), E8 = N("inputValidation.infoForeground", { dark: null, light: null, hcDark: null, hcLight: ct }, p("inputValidationInfoForeground", "Input validation foreground color for information severity.")), I8 = N("inputValidation.infoBorder", { dark: "#007acc", light: "#007acc", hcDark: Xe, hcLight: Xe }, p("inputValidationInfoBorder", "Input validation border color for information severity.")), N8 = N("inputValidation.warningBackground", { dark: "#352A05", light: "#F6F5D2", hcDark: Z.black, hcLight: Z.white }, p("inputValidationWarningBackground", "Input validation background color for warning severity.")), T8 = N("inputValidation.warningForeground", { dark: null, light: null, hcDark: null, hcLight: ct }, p("inputValidationWarningForeground", "Input validation foreground color for warning severity.")), M8 = N("inputValidation.warningBorder", { dark: "#B89500", light: "#B89500", hcDark: Xe, hcLight: Xe }, p("inputValidationWarningBorder", "Input validation border color for warning severity.")), R8 = N("inputValidation.errorBackground", { dark: "#5A1D1D", light: "#F2DEDE", hcDark: Z.black, hcLight: Z.white }, p("inputValidationErrorBackground", "Input validation background color for error severity.")), A8 = N("inputValidation.errorForeground", { dark: null, light: null, hcDark: null, hcLight: ct }, p("inputValidationErrorForeground", "Input validation foreground color for error severity.")), P8 = N("inputValidation.errorBorder", { dark: "#BE1100", light: "#BE1100", hcDark: Xe, hcLight: Xe }, p("inputValidationErrorBorder", "Input validation border color for error severity.")), Lb = N("dropdown.background", { dark: "#3C3C3C", light: Z.white, hcDark: Z.black, hcLight: Z.white }, p("dropdownBackground", "Dropdown background.")), O8 = N("dropdown.listBackground", { dark: null, light: null, hcDark: Z.black, hcLight: Z.white }, p("dropdownListBackground", "Dropdown list background.")), hk = N("dropdown.foreground", { dark: "#F0F0F0", light: ct, hcDark: Z.white, hcLight: ct }, p("dropdownForeground", "Dropdown foreground.")), dk = N("dropdown.border", { dark: Lb, light: "#CECECE", hcDark: Xe, hcLight: Xe }, p("dropdownBorder", "Dropdown border.")), WR = N("button.foreground", Z.white, p("buttonForeground", "Button foreground color.")), F8 = N("button.separator", Ae(WR, 0.4), p("buttonSeparator", "Button separator color.")), xu = N("button.background", { dark: "#0E639C", light: "#007ACC", hcDark: null, hcLight: "#0F4A85" }, p("buttonBackground", "Button background color.")), B8 = N("button.hoverBackground", { dark: no(xu, 0.2), light: Fc(xu, 0.2), hcDark: xu, hcLight: xu }, p("buttonHoverBackground", "Button background color when hovering.")), W8 = N("button.border", Xe, p("buttonBorder", "Button border color.")), V8 = N("button.secondaryForeground", { dark: Z.white, light: Z.white, hcDark: Z.white, hcLight: ct }, p("buttonSecondaryForeground", "Secondary button foreground color.")), Ov = N("button.secondaryBackground", { dark: "#3A3D41", light: "#5F6A79", hcDark: null, hcLight: Z.white }, p("buttonSecondaryBackground", "Secondary button background color.")), H8 = N("button.secondaryHoverBackground", { dark: no(Ov, 0.2), light: Fc(Ov, 0.2), hcDark: null, hcLight: null }, p("buttonSecondaryHoverBackground", "Secondary button background color when hovering.")), Du = N("radio.activeForeground", BR, p("radioActiveForeground", "Foreground color of active radio option.")), z8 = N("radio.activeBackground", FR, p("radioBackground", "Background color of active radio option.")), U8 = N("radio.activeBorder", OR, p("radioActiveBorder", "Border color of the active radio option.")), $8 = N("radio.inactiveForeground", null, p("radioInactiveForeground", "Foreground color of inactive radio option.")), K8 = N("radio.inactiveBackground", null, p("radioInactiveBackground", "Background color of inactive radio option.")), q8 = N("radio.inactiveBorder", { light: Ae(Du, 0.2), dark: Ae(Du, 0.2), hcDark: Ae(Du, 0.4), hcLight: Ae(Du, 0.2) }, p("radioInactiveBorder", "Border color of the inactive radio option.")), j8 = N("radio.inactiveHoverBackground", x8, p("radioHoverBackground", "Background color of inactive active radio option when hovering.")), G8 = N("checkbox.background", Lb, p("checkbox.background", "Background color of checkbox widget."));
N("checkbox.selectBackground", Is, p("checkbox.select.background", "Background color of checkbox widget when the element it's in is selected."));
const Z8 = N("checkbox.foreground", hk, p("checkbox.foreground", "Foreground color of checkbox widget.")), Y8 = N("checkbox.border", dk, p("checkbox.border", "Border color of checkbox widget."));
N("checkbox.selectBorder", Nv, p("checkbox.select.border", "Border color of checkbox widget when the element it's in is selected."));
const Q8 = N("keybindingLabel.background", { dark: new Z(new qe(128, 128, 128, 0.17)), light: new Z(new qe(221, 221, 221, 0.4)), hcDark: Z.transparent, hcLight: Z.transparent }, p("keybindingLabelBackground", "Keybinding label background color. The keybinding label is used to represent a keyboard shortcut.")), X8 = N("keybindingLabel.foreground", { dark: Z.fromHex("#CCCCCC"), light: Z.fromHex("#555555"), hcDark: Z.white, hcLight: ct }, p("keybindingLabelForeground", "Keybinding label foreground color. The keybinding label is used to represent a keyboard shortcut.")), J8 = N("keybindingLabel.border", { dark: new Z(new qe(51, 51, 51, 0.6)), light: new Z(new qe(204, 204, 204, 0.4)), hcDark: new Z(new qe(111, 195, 223)), hcLight: Xe }, p("keybindingLabelBorder", "Keybinding label border color. The keybinding label is used to represent a keyboard shortcut.")), eB = N("keybindingLabel.bottomBorder", { dark: new Z(new qe(68, 68, 68, 0.6)), light: new Z(new qe(187, 187, 187, 0.4)), hcDark: new Z(new qe(111, 195, 223)), hcLight: ct }, p("keybindingLabelBottomBorder", "Keybinding label border bottom color. The keybinding label is used to represent a keyboard shortcut.")), tB = N("list.focusBackground", null, p("listFocusBackground", "List/Tree background color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), iB = N("list.focusForeground", null, p("listFocusForeground", "List/Tree foreground color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), nB = N("list.focusOutline", { dark: Uo, light: Uo, hcDark: jt, hcLight: jt }, p("listFocusOutline", "List/Tree outline color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), sB = N("list.focusAndSelectionOutline", null, p("listFocusAndSelectionOutline", "List/Tree outline color for the focused item when the list/tree is active and selected. An active list/tree has keyboard focus, an inactive does not.")), vc = N("list.activeSelectionBackground", { dark: "#04395E", light: "#0060C0", hcDark: null, hcLight: Z.fromHex("#0F4A85").transparent(0.1) }, p("listActiveSelectionBackground", "List/Tree background color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), $f = N("list.activeSelectionForeground", { dark: Z.white, light: Z.white, hcDark: null, hcLight: null }, p("listActiveSelectionForeground", "List/Tree foreground color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), VR = N("list.activeSelectionIconForeground", null, p("listActiveSelectionIconForeground", "List/Tree icon foreground color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), oB = N("list.inactiveSelectionBackground", { dark: "#37373D", light: "#E4E6F1", hcDark: null, hcLight: Z.fromHex("#0F4A85").transparent(0.1) }, p("listInactiveSelectionBackground", "List/Tree background color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), rB = N("list.inactiveSelectionForeground", null, p("listInactiveSelectionForeground", "List/Tree foreground color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), aB = N("list.inactiveSelectionIconForeground", null, p("listInactiveSelectionIconForeground", "List/Tree icon foreground color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), lB = N("list.inactiveFocusBackground", null, p("listInactiveFocusBackground", "List/Tree background color for the focused item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), cB = N("list.inactiveFocusOutline", null, p("listInactiveFocusOutline", "List/Tree outline color for the focused item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), HR = N("list.hoverBackground", { dark: "#2A2D2E", light: "#F0F0F0", hcDark: Z.white.transparent(0.1), hcLight: Z.fromHex("#0F4A85").transparent(0.1) }, p("listHoverBackground", "List/Tree background when hovering over items using the mouse.")), zR = N("list.hoverForeground", null, p("listHoverForeground", "List/Tree foreground when hovering over items using the mouse.")), hB = N("list.dropBackground", { dark: "#062F4A", light: "#D6EBFF", hcDark: null, hcLight: null }, p("listDropBackground", "List/Tree drag and drop background when moving items over other items when using the mouse.")), dB = N("list.dropBetweenBackground", { dark: Nv, light: Nv, hcDark: null, hcLight: null }, p("listDropBetweenBackground", "List/Tree drag and drop border color when moving items between items when using the mouse.")), um = N("list.highlightForeground", { dark: "#2AAAFF", light: "#0066BF", hcDark: Uo, hcLight: Uo }, p("highlight", "List/Tree foreground color of the match highlights when searching inside the list/tree."));
N("list.focusHighlightForeground", { dark: um, light: QF(vc, um, "#BBE7FF"), hcDark: um, hcLight: um }, p("listFocusHighlightForeground", "List/Tree foreground color of the match highlights on actively focused items when searching inside the list/tree."));
N("list.invalidItemForeground", { dark: "#B89500", light: "#B89500", hcDark: "#B89500", hcLight: "#B5200D" }, p("invalidItemForeground", "List/Tree foreground color for invalid items, for example an unresolved root in explorer."));
N("list.errorForeground", { dark: "#F88070", light: "#B01011", hcDark: null, hcLight: null }, p("listErrorForeground", "Foreground color of list items containing errors."));
N("list.warningForeground", { dark: "#CCA700", light: "#855F00", hcDark: null, hcLight: null }, p("listWarningForeground", "Foreground color of list items containing warnings."));
const uB = N("listFilterWidget.background", { light: Fc(Is, 0), dark: no(Is, 0), hcDark: Is, hcLight: Is }, p("listFilterWidgetBackground", "Background color of the type filter widget in lists and trees.")), fB = N("listFilterWidget.outline", { dark: Z.transparent, light: Z.transparent, hcDark: "#f38518", hcLight: "#007ACC" }, p("listFilterWidgetOutline", "Outline color of the type filter widget in lists and trees.")), gB = N("listFilterWidget.noMatchesOutline", { dark: "#BE1100", light: "#BE1100", hcDark: Xe, hcLight: Xe }, p("listFilterWidgetNoMatchesOutline", "Outline color of the type filter widget in lists and trees, when there are no matches.")), mB = N("listFilterWidget.shadow", Rg, p("listFilterWidgetShadow", "Shadow color of the type filter widget in lists and trees."));
N("list.filterMatchBackground", { dark: xa, light: xa, hcDark: null, hcLight: null }, p("listFilterMatchHighlight", "Background color of the filtered match."));
N("list.filterMatchBorder", { dark: _h, light: _h, hcDark: Xe, hcLight: jt }, p("listFilterMatchHighlightBorder", "Border color of the filtered match."));
N("list.deemphasizedForeground", { dark: "#8C8C8C", light: "#8E8E90", hcDark: "#A7A8A9", hcLight: "#666666" }, p("listDeemphasizedForeground", "List/Tree foreground color for items that are deemphasized."));
const UR = N("tree.indentGuidesStroke", { dark: "#585858", light: "#a9a9a9", hcDark: "#a9a9a9", hcLight: "#a5a5a5" }, p("treeIndentGuidesStroke", "Tree stroke color for the indentation guides.")), pB = N("tree.inactiveIndentGuidesStroke", Ae(UR, 0.4), p("treeInactiveIndentGuidesStroke", "Tree stroke color for the indentation guides that are not active.")), _B = N("tree.tableColumnsBorder", { dark: "#CCCCCC20", light: "#61616120", hcDark: null, hcLight: null }, p("tableColumnsBorder", "Table border color between columns.")), bB = N("tree.tableOddRowsBackground", { dark: Ae(ct, 0.04), light: Ae(ct, 0.04), hcDark: null, hcLight: null }, p("tableOddRowsBackgroundColor", "Background color for odd table rows."));
N("editorActionList.background", Is, p("editorActionListBackground", "Action List background color."));
N("editorActionList.foreground", Sb, p("editorActionListForeground", "Action List foreground color."));
N("editorActionList.focusForeground", $f, p("editorActionListFocusForeground", "Action List foreground color for the focused item."));
N("editorActionList.focusBackground", vc, p("editorActionListFocusBackground", "Action List background color for the focused item."));
const CB = N("menu.border", { dark: null, light: null, hcDark: Xe, hcLight: Xe }, p("menuBorder", "Border color of menus.")), wB = N("menu.foreground", hk, p("menuForeground", "Foreground color of menu items.")), vB = N("menu.background", Lb, p("menuBackground", "Background color of menu items.")), yB = N("menu.selectionForeground", $f, p("menuSelectionForeground", "Foreground color of the selected menu item in menus.")), SB = N("menu.selectionBackground", vc, p("menuSelectionBackground", "Background color of the selected menu item in menus.")), LB = N("menu.selectionBorder", { dark: null, light: null, hcDark: jt, hcLight: jt }, p("menuSelectionBorder", "Border color of the selected menu item in menus.")), kB = N("menu.separatorBackground", { dark: "#606060", light: "#D4D4D4", hcDark: Xe, hcLight: Xe }, p("menuSeparatorBackground", "Color of a separator menu item in menus.")), nI = N("quickInput.background", Is, p("pickerBackground", "Quick picker background color. The quick picker widget is the container for pickers like the command palette.")), xB = N("quickInput.foreground", Sb, p("pickerForeground", "Quick picker foreground color. The quick picker widget is the container for pickers like the command palette.")), DB = N("quickInputTitle.background", { dark: new Z(new qe(255, 255, 255, 0.105)), light: new Z(new qe(0, 0, 0, 0.06)), hcDark: "#000000", hcLight: Z.white }, p("pickerTitleBackground", "Quick picker title background color. The quick picker widget is the container for pickers like the command palette.")), $R = N("pickerGroup.foreground", { dark: "#3794FF", light: "#0066BF", hcDark: Z.white, hcLight: "#0F4A85" }, p("pickerGroupForeground", "Quick picker color for grouping labels.")), EB = N("pickerGroup.border", { dark: "#3F3F46", light: "#CCCEDB", hcDark: Z.white, hcLight: "#0F4A85" }, p("pickerGroupBorder", "Quick picker color for grouping borders.")), sI = N("quickInput.list.focusBackground", null, "", void 0, p("quickInput.list.focusBackground deprecation", "Please use quickInputList.focusBackground instead")), Fv = N("quickInputList.focusForeground", $f, p("quickInput.listFocusForeground", "Quick picker foreground color for the focused item.")), KR = N("quickInputList.focusIconForeground", VR, p("quickInput.listFocusIconForeground", "Quick picker icon foreground color for the focused item.")), Bv = N("quickInputList.focusBackground", { dark: jE(sI, vc), light: jE(sI, vc), hcDark: null, hcLight: null }, p("quickInput.listFocusBackground", "Quick picker background color for the focused item."));
N("search.resultsInfoForeground", { light: ct, dark: Ae(ct, 0.65), hcDark: ct, hcLight: ct }, p("search.resultsInfoForeground", "Color of the text in the search viewlet's completion message."));
N("searchEditor.findMatchBackground", { light: Ae(xa, 0.66), dark: Ae(xa, 0.66), hcDark: xa, hcLight: xa }, p("searchEditor.queryMatch", "Color of the Search Editor query matches."));
N("searchEditor.findMatchBorder", { light: Ae(_h, 0.66), dark: Ae(_h, 0.66), hcDark: _h, hcLight: _h }, p("searchEditor.editorFindMatchBorder", "Border color of the Search Editor query matches."));
var IB = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, oI = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const Ag = Ve("hoverService");
let Kf = class extends q {
  get delay() {
    return this.isInstantlyHovering() ? 0 : this._delay;
  }
  constructor(e, t, i = {}, n, o) {
    super(), this.placement = e, this.instantHover = t, this.overrideOptions = i, this.configurationService = n, this.hoverService = o, this.lastHoverHideTime = 0, this.timeLimit = 200, this.hoverDisposables = this._register(new he()), this._delay = this.configurationService.getValue("workbench.hover.delay"), this._register(this.configurationService.onDidChangeConfiguration((r) => {
      r.affectsConfiguration("workbench.hover.delay") && (this._delay = this.configurationService.getValue("workbench.hover.delay"));
    }));
  }
  showHover(e, t) {
    const i = typeof this.overrideOptions == "function" ? this.overrideOptions(e, t) : this.overrideOptions;
    this.hoverDisposables.clear();
    const n = yi(e.target) ? [e.target] : e.target.targetElements;
    for (const r of n)
      this.hoverDisposables.add(fi(r, "keydown", (a) => {
        a.equals(
          9
          /* KeyCode.Escape */
        ) && this.hoverService.hideHover();
      }));
    const o = yi(e.content) ? void 0 : e.content.toString();
    return this.hoverService.showHover({
      ...e,
      ...i,
      persistence: {
        hideOnKeyDown: !0,
        ...i.persistence
      },
      id: o,
      appearance: {
        ...e.appearance,
        compact: !0,
        skipFadeInAnimation: this.isInstantlyHovering(),
        ...i.appearance
      }
    }, t);
  }
  isInstantlyHovering() {
    return this.instantHover && Date.now() - this.lastHoverHideTime < this.timeLimit;
  }
  onDidHideHover() {
    this.hoverDisposables.clear(), this.instantHover && (this.lastHoverHideTime = Date.now());
  }
};
Kf = IB([
  oI(3, Vt),
  oI(4, Ag)
], Kf);
const Pg = Ve("contextViewService"), ea = Ve("contextMenuService"), Ai = Ve("keybindingService");
class kb {
  constructor() {
    this._hooks = new he(), this._pointerMoveCallback = null, this._onStopCallback = null;
  }
  dispose() {
    this.stopMonitoring(!1), this._hooks.dispose();
  }
  stopMonitoring(e, t) {
    if (!this.isMonitoring())
      return;
    this._hooks.clear(), this._pointerMoveCallback = null;
    const i = this._onStopCallback;
    this._onStopCallback = null, e && i && i(t);
  }
  isMonitoring() {
    return !!this._pointerMoveCallback;
  }
  startMonitoring(e, t, i, n, o) {
    this.isMonitoring() && this.stopMonitoring(!1), this._pointerMoveCallback = n, this._onStopCallback = o;
    let r = e;
    try {
      e.setPointerCapture(t), this._hooks.add(ke(() => {
        try {
          e.releasePointerCapture(t);
        } catch {
        }
      }));
    } catch {
      r = ue(e);
    }
    this._hooks.add($(r, ee.POINTER_MOVE, (a) => {
      if (a.buttons !== i) {
        this.stopMonitoring(!0);
        return;
      }
      a.preventDefault(), this._pointerMoveCallback(a);
    })), this._hooks.add($(r, ee.POINTER_UP, (a) => this.stopMonitoring(!0)));
  }
}
function Ht(s, e, t) {
  let i = null, n = null;
  if (typeof t.value == "function" ? (i = "value", n = t.value, n.length !== 0 && console.warn("Memoize should only be used in functions with zero parameters")) : typeof t.get == "function" && (i = "get", n = t.get), !n)
    throw new Error("not supported");
  const o = `$memoize$${e}`;
  t[i] = function(...r) {
    return this.hasOwnProperty(o) || Object.defineProperty(this, o, {
      configurable: !1,
      enumerable: !1,
      writable: !1,
      value: n.apply(this, r)
    }), this[o];
  };
}
var NB = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, bt;
(function(s) {
  s.Tap = "-monaco-gesturetap", s.Change = "-monaco-gesturechange", s.Start = "-monaco-gesturestart", s.End = "-monaco-gesturesend", s.Contextmenu = "-monaco-gesturecontextmenu";
})(bt || (bt = {}));
const Ii = class Ii extends q {
  // ms
  constructor() {
    super(), this.dispatched = !1, this.targets = new An(), this.ignoreTargets = new An(), this.activeTouches = {}, this.handle = null, this._lastSetTapCountTime = 0, this._register(J.runAndSubscribe(rb, ({ window: e, disposables: t }) => {
      t.add($(e.document, "touchstart", (i) => this.onTouchStart(i), { passive: !1 })), t.add($(e.document, "touchend", (i) => this.onTouchEnd(e, i))), t.add($(e.document, "touchmove", (i) => this.onTouchMove(i), { passive: !1 }));
    }, { window: ut, disposables: this._store }));
  }
  static addTarget(e) {
    if (!Ii.isTouchDevice())
      return q.None;
    Ii.INSTANCE || (Ii.INSTANCE = new Ii());
    const t = Ii.INSTANCE.targets.push(e);
    return ke(t);
  }
  static ignoreTarget(e) {
    if (!Ii.isTouchDevice())
      return q.None;
    Ii.INSTANCE || (Ii.INSTANCE = new Ii());
    const t = Ii.INSTANCE.ignoreTargets.push(e);
    return ke(t);
  }
  static isTouchDevice() {
    return "ontouchstart" in ut || navigator.maxTouchPoints > 0;
  }
  dispose() {
    this.handle && (this.handle.dispose(), this.handle = null), super.dispose();
  }
  onTouchStart(e) {
    const t = Date.now();
    this.handle && (this.handle.dispose(), this.handle = null);
    for (let i = 0, n = e.targetTouches.length; i < n; i++) {
      const o = e.targetTouches.item(i);
      this.activeTouches[o.identifier] = {
        id: o.identifier,
        initialTarget: o.target,
        initialTimeStamp: t,
        initialPageX: o.pageX,
        initialPageY: o.pageY,
        rollingTimestamps: [t],
        rollingPageX: [o.pageX],
        rollingPageY: [o.pageY]
      };
      const r = this.newGestureEvent(bt.Start, o.target);
      r.pageX = o.pageX, r.pageY = o.pageY, this.dispatchEvent(r);
    }
    this.dispatched && (e.preventDefault(), e.stopPropagation(), this.dispatched = !1);
  }
  onTouchEnd(e, t) {
    const i = Date.now(), n = Object.keys(this.activeTouches).length;
    for (let o = 0, r = t.changedTouches.length; o < r; o++) {
      const a = t.changedTouches.item(o);
      if (!this.activeTouches.hasOwnProperty(String(a.identifier))) {
        console.warn("move of an UNKNOWN touch", a);
        continue;
      }
      const l = this.activeTouches[a.identifier], c = Date.now() - l.initialTimeStamp;
      if (c < Ii.HOLD_DELAY && Math.abs(l.initialPageX - as(l.rollingPageX)) < 30 && Math.abs(l.initialPageY - as(l.rollingPageY)) < 30) {
        const h = this.newGestureEvent(bt.Tap, l.initialTarget);
        h.pageX = as(l.rollingPageX), h.pageY = as(l.rollingPageY), this.dispatchEvent(h);
      } else if (c >= Ii.HOLD_DELAY && Math.abs(l.initialPageX - as(l.rollingPageX)) < 30 && Math.abs(l.initialPageY - as(l.rollingPageY)) < 30) {
        const h = this.newGestureEvent(bt.Contextmenu, l.initialTarget);
        h.pageX = as(l.rollingPageX), h.pageY = as(l.rollingPageY), this.dispatchEvent(h);
      } else if (n === 1) {
        const h = as(l.rollingPageX), d = as(l.rollingPageY), u = as(l.rollingTimestamps) - l.rollingTimestamps[0], f = h - l.rollingPageX[0], g = d - l.rollingPageY[0], m = [...this.targets].filter((_) => l.initialTarget instanceof Node && _.contains(l.initialTarget));
        this.inertia(
          e,
          m,
          i,
          // time now
          Math.abs(f) / u,
          // speed
          f > 0 ? 1 : -1,
          // x direction
          h,
          // x now
          Math.abs(g) / u,
          // y speed
          g > 0 ? 1 : -1,
          // y direction
          d
          // y now
        );
      }
      this.dispatchEvent(this.newGestureEvent(bt.End, l.initialTarget)), delete this.activeTouches[a.identifier];
    }
    this.dispatched && (t.preventDefault(), t.stopPropagation(), this.dispatched = !1);
  }
  newGestureEvent(e, t) {
    const i = document.createEvent("CustomEvent");
    return i.initEvent(e, !1, !0), i.initialTarget = t, i.tapCount = 0, i;
  }
  dispatchEvent(e) {
    if (e.type === bt.Tap) {
      const t = (/* @__PURE__ */ new Date()).getTime();
      let i = 0;
      t - this._lastSetTapCountTime > Ii.CLEAR_TAP_COUNT_TIME ? i = 1 : i = 2, this._lastSetTapCountTime = t, e.tapCount = i;
    } else (e.type === bt.Change || e.type === bt.Contextmenu) && (this._lastSetTapCountTime = 0);
    if (e.initialTarget instanceof Node) {
      for (const i of this.ignoreTargets)
        if (i.contains(e.initialTarget))
          return;
      const t = [];
      for (const i of this.targets)
        if (i.contains(e.initialTarget)) {
          let n = 0, o = e.initialTarget;
          for (; o && o !== i; )
            n++, o = o.parentElement;
          t.push([n, i]);
        }
      t.sort((i, n) => i[0] - n[0]);
      for (const [i, n] of t)
        n.dispatchEvent(e), this.dispatched = !0;
    }
  }
  inertia(e, t, i, n, o, r, a, l, c) {
    this.handle = Wn(e, () => {
      const h = Date.now(), d = h - i;
      let u = 0, f = 0, g = !0;
      n += Ii.SCROLL_FRICTION * d, a += Ii.SCROLL_FRICTION * d, n > 0 && (g = !1, u = o * n * d), a > 0 && (g = !1, f = l * a * d);
      const m = this.newGestureEvent(bt.Change);
      m.translationX = u, m.translationY = f, t.forEach((_) => _.dispatchEvent(m)), g || this.inertia(e, t, h, n, o, r + u, a, l, c + f);
    });
  }
  onTouchMove(e) {
    const t = Date.now();
    for (let i = 0, n = e.changedTouches.length; i < n; i++) {
      const o = e.changedTouches.item(i);
      if (!this.activeTouches.hasOwnProperty(String(o.identifier))) {
        console.warn("end of an UNKNOWN touch", o);
        continue;
      }
      const r = this.activeTouches[o.identifier], a = this.newGestureEvent(bt.Change, r.initialTarget);
      a.translationX = o.pageX - as(r.rollingPageX), a.translationY = o.pageY - as(r.rollingPageY), a.pageX = o.pageX, a.pageY = o.pageY, this.dispatchEvent(a), r.rollingPageX.length > 3 && (r.rollingPageX.shift(), r.rollingPageY.shift(), r.rollingTimestamps.shift()), r.rollingPageX.push(o.pageX), r.rollingPageY.push(o.pageY), r.rollingTimestamps.push(t);
    }
    this.dispatched && (e.preventDefault(), e.stopPropagation(), this.dispatched = !1);
  }
};
Ii.SCROLL_FRICTION = -5e-3, Ii.HOLD_DELAY = 700, Ii.CLEAR_TAP_COUNT_TIME = 400;
let an = Ii;
NB([
  Ht
], an, "isTouchDevice", null);
let ta = class extends q {
  onclick(e, t) {
    this._register($(e, ee.CLICK, (i) => t(new to(ue(e), i))));
  }
  onmousedown(e, t) {
    this._register($(e, ee.MOUSE_DOWN, (i) => t(new to(ue(e), i))));
  }
  onmouseover(e, t) {
    this._register($(e, ee.MOUSE_OVER, (i) => t(new to(ue(e), i))));
  }
  onmouseleave(e, t) {
    this._register($(e, ee.MOUSE_LEAVE, (i) => t(new to(ue(e), i))));
  }
  onkeydown(e, t) {
    this._register($(e, ee.KEY_DOWN, (i) => t(new Lt(i))));
  }
  onkeyup(e, t) {
    this._register($(e, ee.KEY_UP, (i) => t(new Lt(i))));
  }
  oninput(e, t) {
    this._register($(e, ee.INPUT, t));
  }
  onblur(e, t) {
    this._register($(e, ee.BLUR, t));
  }
  onfocus(e, t) {
    this._register($(e, ee.FOCUS, t));
  }
  ignoreGesture(e) {
    return an.ignoreTarget(e);
  }
};
const Dd = 11;
class TB extends ta {
  constructor(e) {
    super(), this._onActivate = e.onActivate, this.bgDomNode = document.createElement("div"), this.bgDomNode.className = "arrow-background", this.bgDomNode.style.position = "absolute", this.bgDomNode.style.width = e.bgWidth + "px", this.bgDomNode.style.height = e.bgHeight + "px", typeof e.top < "u" && (this.bgDomNode.style.top = "0px"), typeof e.left < "u" && (this.bgDomNode.style.left = "0px"), typeof e.bottom < "u" && (this.bgDomNode.style.bottom = "0px"), typeof e.right < "u" && (this.bgDomNode.style.right = "0px"), this.domNode = document.createElement("div"), this.domNode.className = e.className, this.domNode.classList.add(...Ke.asClassNameArray(e.icon)), this.domNode.style.position = "absolute", this.domNode.style.width = Dd + "px", this.domNode.style.height = Dd + "px", typeof e.top < "u" && (this.domNode.style.top = e.top + "px"), typeof e.left < "u" && (this.domNode.style.left = e.left + "px"), typeof e.bottom < "u" && (this.domNode.style.bottom = e.bottom + "px"), typeof e.right < "u" && (this.domNode.style.right = e.right + "px"), this._pointerMoveMonitor = this._register(new kb()), this._register(fi(this.bgDomNode, ee.POINTER_DOWN, (t) => this._arrowPointerDown(t))), this._register(fi(this.domNode, ee.POINTER_DOWN, (t) => this._arrowPointerDown(t))), this._pointerdownRepeatTimer = this._register(new BL()), this._pointerdownScheduleRepeatTimer = this._register(new Ic());
  }
  _arrowPointerDown(e) {
    if (!e.target || !(e.target instanceof Element))
      return;
    const t = () => {
      this._pointerdownRepeatTimer.cancelAndSet(() => this._onActivate(), 1e3 / 24, ue(e));
    };
    this._onActivate(), this._pointerdownRepeatTimer.cancel(), this._pointerdownScheduleRepeatTimer.cancelAndSet(t, 200), this._pointerMoveMonitor.startMonitoring(e.target, e.pointerId, e.buttons, (i) => {
    }, () => {
      this._pointerdownRepeatTimer.cancel(), this._pointerdownScheduleRepeatTimer.cancel();
    }), e.preventDefault();
  }
}
class MB extends q {
  constructor(e, t, i) {
    super(), this._visibility = e, this._visibleClassName = t, this._invisibleClassName = i, this._domNode = null, this._isVisible = !1, this._isNeeded = !1, this._rawShouldBeVisible = !1, this._shouldBeVisible = !1, this._revealTimer = this._register(new Ic());
  }
  setVisibility(e) {
    this._visibility !== e && (this._visibility = e, this._updateShouldBeVisible());
  }
  // ----------------- Hide / Reveal
  setShouldBeVisible(e) {
    this._rawShouldBeVisible = e, this._updateShouldBeVisible();
  }
  _applyVisibilitySetting() {
    return this._visibility === 2 ? !1 : this._visibility === 3 ? !0 : this._rawShouldBeVisible;
  }
  _updateShouldBeVisible() {
    const e = this._applyVisibilitySetting();
    this._shouldBeVisible !== e && (this._shouldBeVisible = e, this.ensureVisibility());
  }
  setIsNeeded(e) {
    this._isNeeded !== e && (this._isNeeded = e, this.ensureVisibility());
  }
  setDomNode(e) {
    this._domNode = e, this._domNode.setClassName(this._invisibleClassName), this.setShouldBeVisible(!1);
  }
  ensureVisibility() {
    if (!this._isNeeded) {
      this._hide(!1);
      return;
    }
    this._shouldBeVisible ? this._reveal() : this._hide(!0);
  }
  _reveal() {
    this._isVisible || (this._isVisible = !0, this._revealTimer.setIfNotSet(() => {
      var e;
      (e = this._domNode) == null || e.setClassName(this._visibleClassName);
    }, 0));
  }
  _hide(e) {
    var t;
    this._revealTimer.cancel(), this._isVisible && (this._isVisible = !1, (t = this._domNode) == null || t.setClassName(this._invisibleClassName + (e ? " fade" : "")));
  }
}
const RB = 140;
class qR extends ta {
  constructor(e) {
    super(), this._lazyRender = e.lazyRender, this._host = e.host, this._scrollable = e.scrollable, this._scrollByPage = e.scrollByPage, this._scrollbarState = e.scrollbarState, this._visibilityController = this._register(new MB(e.visibility, "visible scrollbar " + e.extraScrollbarClassName, "invisible scrollbar " + e.extraScrollbarClassName)), this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()), this._pointerMoveMonitor = this._register(new kb()), this._shouldRender = !0, this.domNode = je(document.createElement("div")), this.domNode.setAttribute("role", "presentation"), this.domNode.setAttribute("aria-hidden", "true"), this._visibilityController.setDomNode(this.domNode), this.domNode.setPosition("absolute"), this._register($(this.domNode.domNode, ee.POINTER_DOWN, (t) => this._domNodePointerDown(t)));
  }
  // ----------------- creation
  /**
   * Creates the dom node for an arrow & adds it to the container
   */
  _createArrow(e) {
    const t = this._register(new TB(e));
    this.domNode.domNode.appendChild(t.bgDomNode), this.domNode.domNode.appendChild(t.domNode);
  }
  /**
   * Creates the slider dom node, adds it to the container & hooks up the events
   */
  _createSlider(e, t, i, n) {
    this.slider = je(document.createElement("div")), this.slider.setClassName("slider"), this.slider.setPosition("absolute"), this.slider.setTop(e), this.slider.setLeft(t), typeof i == "number" && this.slider.setWidth(i), typeof n == "number" && this.slider.setHeight(n), this.slider.setLayerHinting(!0), this.slider.setContain("strict"), this.domNode.domNode.appendChild(this.slider.domNode), this._register($(this.slider.domNode, ee.POINTER_DOWN, (o) => {
      o.button === 0 && (o.preventDefault(), this._sliderPointerDown(o));
    })), this.onclick(this.slider.domNode, (o) => {
      o.leftButton && o.stopPropagation();
    });
  }
  // ----------------- Update state
  _onElementSize(e) {
    return this._scrollbarState.setVisibleSize(e) && (this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()), this._shouldRender = !0, this._lazyRender || this.render()), this._shouldRender;
  }
  _onElementScrollSize(e) {
    return this._scrollbarState.setScrollSize(e) && (this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()), this._shouldRender = !0, this._lazyRender || this.render()), this._shouldRender;
  }
  _onElementScrollPosition(e) {
    return this._scrollbarState.setScrollPosition(e) && (this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()), this._shouldRender = !0, this._lazyRender || this.render()), this._shouldRender;
  }
  // ----------------- rendering
  beginReveal() {
    this._visibilityController.setShouldBeVisible(!0);
  }
  beginHide() {
    this._visibilityController.setShouldBeVisible(!1);
  }
  render() {
    this._shouldRender && (this._shouldRender = !1, this._renderDomNode(this._scrollbarState.getRectangleLargeSize(), this._scrollbarState.getRectangleSmallSize()), this._updateSlider(this._scrollbarState.getSliderSize(), this._scrollbarState.getArrowSize() + this._scrollbarState.getSliderPosition()));
  }
  // ----------------- DOM events
  _domNodePointerDown(e) {
    e.target === this.domNode.domNode && this._onPointerDown(e);
  }
  delegatePointerDown(e) {
    const t = this.domNode.domNode.getClientRects()[0].top, i = t + this._scrollbarState.getSliderPosition(), n = t + this._scrollbarState.getSliderPosition() + this._scrollbarState.getSliderSize(), o = this._sliderPointerPosition(e);
    i <= o && o <= n ? e.button === 0 && (e.preventDefault(), this._sliderPointerDown(e)) : this._onPointerDown(e);
  }
  _onPointerDown(e) {
    let t, i;
    if (e.target === this.domNode.domNode && typeof e.offsetX == "number" && typeof e.offsetY == "number")
      t = e.offsetX, i = e.offsetY;
    else {
      const o = gs(this.domNode.domNode);
      t = e.pageX - o.left, i = e.pageY - o.top;
    }
    const n = this._pointerDownRelativePosition(t, i);
    this._setDesiredScrollPositionNow(this._scrollByPage ? this._scrollbarState.getDesiredScrollPositionFromOffsetPaged(n) : this._scrollbarState.getDesiredScrollPositionFromOffset(n)), e.button === 0 && (e.preventDefault(), this._sliderPointerDown(e));
  }
  _sliderPointerDown(e) {
    if (!e.target || !(e.target instanceof Element))
      return;
    const t = this._sliderPointerPosition(e), i = this._sliderOrthogonalPointerPosition(e), n = this._scrollbarState.clone();
    this.slider.toggleClassName("active", !0), this._pointerMoveMonitor.startMonitoring(e.target, e.pointerId, e.buttons, (o) => {
      const r = this._sliderOrthogonalPointerPosition(o), a = Math.abs(r - i);
      if (Fn && a > RB) {
        this._setDesiredScrollPositionNow(n.getScrollPosition());
        return;
      }
      const c = this._sliderPointerPosition(o) - t;
      this._setDesiredScrollPositionNow(n.getDesiredScrollPositionFromDelta(c));
    }, () => {
      this.slider.toggleClassName("active", !1), this._host.onDragEnd();
    }), this._host.onDragStart();
  }
  _setDesiredScrollPositionNow(e) {
    const t = {};
    this.writeScrollPosition(t, e), this._scrollable.setScrollPositionNow(t);
  }
  updateScrollbarSize(e) {
    this._updateScrollbarSize(e), this._scrollbarState.setScrollbarSize(e), this._shouldRender = !0, this._lazyRender || this.render();
  }
  isNeeded() {
    return this._scrollbarState.isNeeded();
  }
}
const AB = 20;
class Ed {
  constructor(e, t, i, n, o, r) {
    this._scrollbarSize = Math.round(t), this._oppositeScrollbarSize = Math.round(i), this._arrowSize = Math.round(e), this._visibleSize = n, this._scrollSize = o, this._scrollPosition = r, this._computedAvailableSize = 0, this._computedIsNeeded = !1, this._computedSliderSize = 0, this._computedSliderRatio = 0, this._computedSliderPosition = 0, this._refreshComputedValues();
  }
  clone() {
    return new Ed(this._arrowSize, this._scrollbarSize, this._oppositeScrollbarSize, this._visibleSize, this._scrollSize, this._scrollPosition);
  }
  setVisibleSize(e) {
    const t = Math.round(e);
    return this._visibleSize !== t ? (this._visibleSize = t, this._refreshComputedValues(), !0) : !1;
  }
  setScrollSize(e) {
    const t = Math.round(e);
    return this._scrollSize !== t ? (this._scrollSize = t, this._refreshComputedValues(), !0) : !1;
  }
  setScrollPosition(e) {
    const t = Math.round(e);
    return this._scrollPosition !== t ? (this._scrollPosition = t, this._refreshComputedValues(), !0) : !1;
  }
  setScrollbarSize(e) {
    this._scrollbarSize = Math.round(e);
  }
  setOppositeScrollbarSize(e) {
    this._oppositeScrollbarSize = Math.round(e);
  }
  static _computeValues(e, t, i, n, o) {
    const r = Math.max(0, i - e), a = Math.max(0, r - 2 * t), l = n > 0 && n > i;
    if (!l)
      return {
        computedAvailableSize: Math.round(r),
        computedIsNeeded: l,
        computedSliderSize: Math.round(a),
        computedSliderRatio: 0,
        computedSliderPosition: 0
      };
    const c = Math.round(Math.max(AB, Math.floor(i * a / n))), h = (a - c) / (n - i), d = o * h;
    return {
      computedAvailableSize: Math.round(r),
      computedIsNeeded: l,
      computedSliderSize: Math.round(c),
      computedSliderRatio: h,
      computedSliderPosition: Math.round(d)
    };
  }
  _refreshComputedValues() {
    const e = Ed._computeValues(this._oppositeScrollbarSize, this._arrowSize, this._visibleSize, this._scrollSize, this._scrollPosition);
    this._computedAvailableSize = e.computedAvailableSize, this._computedIsNeeded = e.computedIsNeeded, this._computedSliderSize = e.computedSliderSize, this._computedSliderRatio = e.computedSliderRatio, this._computedSliderPosition = e.computedSliderPosition;
  }
  getArrowSize() {
    return this._arrowSize;
  }
  getScrollPosition() {
    return this._scrollPosition;
  }
  getRectangleLargeSize() {
    return this._computedAvailableSize;
  }
  getRectangleSmallSize() {
    return this._scrollbarSize;
  }
  isNeeded() {
    return this._computedIsNeeded;
  }
  getSliderSize() {
    return this._computedSliderSize;
  }
  getSliderPosition() {
    return this._computedSliderPosition;
  }
  /**
   * Compute a desired `scrollPosition` such that `offset` ends up in the center of the slider.
   * `offset` is based on the same coordinate system as the `sliderPosition`.
   */
  getDesiredScrollPositionFromOffset(e) {
    if (!this._computedIsNeeded)
      return 0;
    const t = e - this._arrowSize - this._computedSliderSize / 2;
    return Math.round(t / this._computedSliderRatio);
  }
  /**
   * Compute a desired `scrollPosition` from if offset is before or after the slider position.
   * If offset is before slider, treat as a page up (or left).  If after, page down (or right).
   * `offset` and `_computedSliderPosition` are based on the same coordinate system.
   * `_visibleSize` corresponds to a "page" of lines in the returned coordinate system.
   */
  getDesiredScrollPositionFromOffsetPaged(e) {
    if (!this._computedIsNeeded)
      return 0;
    const t = e - this._arrowSize;
    let i = this._scrollPosition;
    return t < this._computedSliderPosition ? i -= this._visibleSize : i += this._visibleSize, i;
  }
  /**
   * Compute a desired `scrollPosition` such that the slider moves by `delta`.
   */
  getDesiredScrollPositionFromDelta(e) {
    if (!this._computedIsNeeded)
      return 0;
    const t = this._computedSliderPosition + e;
    return Math.round(t / this._computedSliderRatio);
  }
}
class PB extends qR {
  constructor(e, t, i) {
    const n = e.getScrollDimensions(), o = e.getCurrentScrollPosition();
    if (super({
      lazyRender: t.lazyRender,
      host: i,
      scrollbarState: new Ed(t.horizontalHasArrows ? t.arrowSize : 0, t.horizontal === 2 ? 0 : t.horizontalScrollbarSize, t.vertical === 2 ? 0 : t.verticalScrollbarSize, n.width, n.scrollWidth, o.scrollLeft),
      visibility: t.horizontal,
      extraScrollbarClassName: "horizontal",
      scrollable: e,
      scrollByPage: t.scrollByPage
    }), t.horizontalHasArrows) {
      const r = (t.arrowSize - Dd) / 2, a = (t.horizontalScrollbarSize - Dd) / 2;
      this._createArrow({
        className: "scra",
        icon: re.scrollbarButtonLeft,
        top: a,
        left: r,
        bottom: void 0,
        right: void 0,
        bgWidth: t.arrowSize,
        bgHeight: t.horizontalScrollbarSize,
        onActivate: () => this._host.onMouseWheel(new pc(null, 1, 0))
      }), this._createArrow({
        className: "scra",
        icon: re.scrollbarButtonRight,
        top: a,
        left: void 0,
        bottom: void 0,
        right: r,
        bgWidth: t.arrowSize,
        bgHeight: t.horizontalScrollbarSize,
        onActivate: () => this._host.onMouseWheel(new pc(null, -1, 0))
      });
    }
    this._createSlider(Math.floor((t.horizontalScrollbarSize - t.horizontalSliderSize) / 2), 0, void 0, t.horizontalSliderSize);
  }
  _updateSlider(e, t) {
    this.slider.setWidth(e), this.slider.setLeft(t);
  }
  _renderDomNode(e, t) {
    this.domNode.setWidth(e), this.domNode.setHeight(t), this.domNode.setLeft(0), this.domNode.setBottom(0);
  }
  onDidScroll(e) {
    return this._shouldRender = this._onElementScrollSize(e.scrollWidth) || this._shouldRender, this._shouldRender = this._onElementScrollPosition(e.scrollLeft) || this._shouldRender, this._shouldRender = this._onElementSize(e.width) || this._shouldRender, this._shouldRender;
  }
  _pointerDownRelativePosition(e, t) {
    return e;
  }
  _sliderPointerPosition(e) {
    return e.pageX;
  }
  _sliderOrthogonalPointerPosition(e) {
    return e.pageY;
  }
  _updateScrollbarSize(e) {
    this.slider.setHeight(e);
  }
  writeScrollPosition(e, t) {
    e.scrollLeft = t;
  }
  updateOptions(e) {
    this.updateScrollbarSize(e.horizontal === 2 ? 0 : e.horizontalScrollbarSize), this._scrollbarState.setOppositeScrollbarSize(e.vertical === 2 ? 0 : e.verticalScrollbarSize), this._visibilityController.setVisibility(e.horizontal), this._scrollByPage = e.scrollByPage;
  }
}
class OB extends qR {
  constructor(e, t, i) {
    const n = e.getScrollDimensions(), o = e.getCurrentScrollPosition();
    if (super({
      lazyRender: t.lazyRender,
      host: i,
      scrollbarState: new Ed(
        t.verticalHasArrows ? t.arrowSize : 0,
        t.vertical === 2 ? 0 : t.verticalScrollbarSize,
        // give priority to vertical scroll bar over horizontal and let it scroll all the way to the bottom
        0,
        n.height,
        n.scrollHeight,
        o.scrollTop
      ),
      visibility: t.vertical,
      extraScrollbarClassName: "vertical",
      scrollable: e,
      scrollByPage: t.scrollByPage
    }), t.verticalHasArrows) {
      const r = (t.arrowSize - Dd) / 2, a = (t.verticalScrollbarSize - Dd) / 2;
      this._createArrow({
        className: "scra",
        icon: re.scrollbarButtonUp,
        top: r,
        left: a,
        bottom: void 0,
        right: void 0,
        bgWidth: t.verticalScrollbarSize,
        bgHeight: t.arrowSize,
        onActivate: () => this._host.onMouseWheel(new pc(null, 0, 1))
      }), this._createArrow({
        className: "scra",
        icon: re.scrollbarButtonDown,
        top: void 0,
        left: a,
        bottom: r,
        right: void 0,
        bgWidth: t.verticalScrollbarSize,
        bgHeight: t.arrowSize,
        onActivate: () => this._host.onMouseWheel(new pc(null, 0, -1))
      });
    }
    this._createSlider(0, Math.floor((t.verticalScrollbarSize - t.verticalSliderSize) / 2), t.verticalSliderSize, void 0);
  }
  _updateSlider(e, t) {
    this.slider.setHeight(e), this.slider.setTop(t);
  }
  _renderDomNode(e, t) {
    this.domNode.setWidth(t), this.domNode.setHeight(e), this.domNode.setRight(0), this.domNode.setTop(0);
  }
  onDidScroll(e) {
    return this._shouldRender = this._onElementScrollSize(e.scrollHeight) || this._shouldRender, this._shouldRender = this._onElementScrollPosition(e.scrollTop) || this._shouldRender, this._shouldRender = this._onElementSize(e.height) || this._shouldRender, this._shouldRender;
  }
  _pointerDownRelativePosition(e, t) {
    return t;
  }
  _sliderPointerPosition(e) {
    return e.pageY;
  }
  _sliderOrthogonalPointerPosition(e) {
    return e.pageX;
  }
  _updateScrollbarSize(e) {
    this.slider.setWidth(e);
  }
  writeScrollPosition(e, t) {
    e.scrollTop = t;
  }
  updateOptions(e) {
    this.updateScrollbarSize(e.vertical === 2 ? 0 : e.verticalScrollbarSize), this._scrollbarState.setOppositeScrollbarSize(0), this._visibilityController.setVisibility(e.vertical), this._scrollByPage = e.scrollByPage;
  }
}
class qp {
  constructor(e, t, i, n, o, r, a) {
    this._forceIntegerValues = e, this._scrollStateBrand = void 0, this._forceIntegerValues && (t = t | 0, i = i | 0, n = n | 0, o = o | 0, r = r | 0, a = a | 0), this.rawScrollLeft = n, this.rawScrollTop = a, t < 0 && (t = 0), n + t > i && (n = i - t), n < 0 && (n = 0), o < 0 && (o = 0), a + o > r && (a = r - o), a < 0 && (a = 0), this.width = t, this.scrollWidth = i, this.scrollLeft = n, this.height = o, this.scrollHeight = r, this.scrollTop = a;
  }
  equals(e) {
    return this.rawScrollLeft === e.rawScrollLeft && this.rawScrollTop === e.rawScrollTop && this.width === e.width && this.scrollWidth === e.scrollWidth && this.scrollLeft === e.scrollLeft && this.height === e.height && this.scrollHeight === e.scrollHeight && this.scrollTop === e.scrollTop;
  }
  withScrollDimensions(e, t) {
    return new qp(this._forceIntegerValues, typeof e.width < "u" ? e.width : this.width, typeof e.scrollWidth < "u" ? e.scrollWidth : this.scrollWidth, t ? this.rawScrollLeft : this.scrollLeft, typeof e.height < "u" ? e.height : this.height, typeof e.scrollHeight < "u" ? e.scrollHeight : this.scrollHeight, t ? this.rawScrollTop : this.scrollTop);
  }
  withScrollPosition(e) {
    return new qp(this._forceIntegerValues, this.width, this.scrollWidth, typeof e.scrollLeft < "u" ? e.scrollLeft : this.rawScrollLeft, this.height, this.scrollHeight, typeof e.scrollTop < "u" ? e.scrollTop : this.rawScrollTop);
  }
  createScrollEvent(e, t) {
    const i = this.width !== e.width, n = this.scrollWidth !== e.scrollWidth, o = this.scrollLeft !== e.scrollLeft, r = this.height !== e.height, a = this.scrollHeight !== e.scrollHeight, l = this.scrollTop !== e.scrollTop;
    return {
      inSmoothScrolling: t,
      oldWidth: e.width,
      oldScrollWidth: e.scrollWidth,
      oldScrollLeft: e.scrollLeft,
      width: this.width,
      scrollWidth: this.scrollWidth,
      scrollLeft: this.scrollLeft,
      oldHeight: e.height,
      oldScrollHeight: e.scrollHeight,
      oldScrollTop: e.scrollTop,
      height: this.height,
      scrollHeight: this.scrollHeight,
      scrollTop: this.scrollTop,
      widthChanged: i,
      scrollWidthChanged: n,
      scrollLeftChanged: o,
      heightChanged: r,
      scrollHeightChanged: a,
      scrollTopChanged: l
    };
  }
}
class zd extends q {
  constructor(e) {
    super(), this._scrollableBrand = void 0, this._onScroll = this._register(new O()), this.onScroll = this._onScroll.event, this._smoothScrollDuration = e.smoothScrollDuration, this._scheduleAtNextAnimationFrame = e.scheduleAtNextAnimationFrame, this._state = new qp(e.forceIntegerValues, 0, 0, 0, 0, 0, 0), this._smoothScrolling = null;
  }
  dispose() {
    this._smoothScrolling && (this._smoothScrolling.dispose(), this._smoothScrolling = null), super.dispose();
  }
  setSmoothScrollDuration(e) {
    this._smoothScrollDuration = e;
  }
  validateScrollPosition(e) {
    return this._state.withScrollPosition(e);
  }
  getScrollDimensions() {
    return this._state;
  }
  setScrollDimensions(e, t) {
    var n;
    const i = this._state.withScrollDimensions(e, t);
    this._setState(i, !!this._smoothScrolling), (n = this._smoothScrolling) == null || n.acceptScrollDimensions(this._state);
  }
  /**
   * Returns the final scroll position that the instance will have once the smooth scroll animation concludes.
   * If no scroll animation is occurring, it will return the current scroll position instead.
   */
  getFutureScrollPosition() {
    return this._smoothScrolling ? this._smoothScrolling.to : this._state;
  }
  /**
   * Returns the current scroll position.
   * Note: This result might be an intermediate scroll position, as there might be an ongoing smooth scroll animation.
   */
  getCurrentScrollPosition() {
    return this._state;
  }
  setScrollPositionNow(e) {
    const t = this._state.withScrollPosition(e);
    this._smoothScrolling && (this._smoothScrolling.dispose(), this._smoothScrolling = null), this._setState(t, !1);
  }
  setScrollPositionSmooth(e, t) {
    if (this._smoothScrollDuration === 0)
      return this.setScrollPositionNow(e);
    if (this._smoothScrolling) {
      e = {
        scrollLeft: typeof e.scrollLeft > "u" ? this._smoothScrolling.to.scrollLeft : e.scrollLeft,
        scrollTop: typeof e.scrollTop > "u" ? this._smoothScrolling.to.scrollTop : e.scrollTop
      };
      const i = this._state.withScrollPosition(e);
      if (this._smoothScrolling.to.scrollLeft === i.scrollLeft && this._smoothScrolling.to.scrollTop === i.scrollTop)
        return;
      let n;
      t ? n = new qf(this._smoothScrolling.from, i, this._smoothScrolling.startTime, this._smoothScrolling.duration) : n = this._smoothScrolling.combine(this._state, i, this._smoothScrollDuration), this._smoothScrolling.dispose(), this._smoothScrolling = n;
    } else {
      const i = this._state.withScrollPosition(e);
      this._smoothScrolling = qf.start(this._state, i, this._smoothScrollDuration);
    }
    this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(() => {
      this._smoothScrolling && (this._smoothScrolling.animationFrameDisposable = null, this._performSmoothScrolling());
    });
  }
  hasPendingScrollAnimation() {
    return !!this._smoothScrolling;
  }
  _performSmoothScrolling() {
    if (!this._smoothScrolling)
      return;
    const e = this._smoothScrolling.tick(), t = this._state.withScrollPosition(e);
    if (this._setState(t, !0), !!this._smoothScrolling) {
      if (e.isDone) {
        this._smoothScrolling.dispose(), this._smoothScrolling = null;
        return;
      }
      this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(() => {
        this._smoothScrolling && (this._smoothScrolling.animationFrameDisposable = null, this._performSmoothScrolling());
      });
    }
  }
  _setState(e, t) {
    const i = this._state;
    i.equals(e) || (this._state = e, this._onScroll.fire(this._state.createScrollEvent(i, t)));
  }
}
class rI {
  constructor(e, t, i) {
    this.scrollLeft = e, this.scrollTop = t, this.isDone = i;
  }
}
function W0(s, e) {
  const t = e - s;
  return function(i) {
    return s + t * WB(i);
  };
}
function FB(s, e, t) {
  return function(i) {
    return i < t ? s(i / t) : e((i - t) / (1 - t));
  };
}
class qf {
  constructor(e, t, i, n) {
    this.from = e, this.to = t, this.duration = n, this.startTime = i, this.animationFrameDisposable = null, this._initAnimations();
  }
  _initAnimations() {
    this.scrollLeft = this._initAnimation(this.from.scrollLeft, this.to.scrollLeft, this.to.width), this.scrollTop = this._initAnimation(this.from.scrollTop, this.to.scrollTop, this.to.height);
  }
  _initAnimation(e, t, i) {
    if (Math.abs(e - t) > 2.5 * i) {
      let o, r;
      return e < t ? (o = e + 0.75 * i, r = t - 0.75 * i) : (o = e - 0.75 * i, r = t + 0.75 * i), FB(W0(e, o), W0(r, t), 0.33);
    }
    return W0(e, t);
  }
  dispose() {
    this.animationFrameDisposable !== null && (this.animationFrameDisposable.dispose(), this.animationFrameDisposable = null);
  }
  acceptScrollDimensions(e) {
    this.to = e.withScrollPosition(this.to), this._initAnimations();
  }
  tick() {
    return this._tick(Date.now());
  }
  _tick(e) {
    const t = (e - this.startTime) / this.duration;
    if (t < 1) {
      const i = this.scrollLeft(t), n = this.scrollTop(t);
      return new rI(i, n, !1);
    }
    return new rI(this.to.scrollLeft, this.to.scrollTop, !0);
  }
  combine(e, t, i) {
    return qf.start(e, t, i);
  }
  static start(e, t, i) {
    i = i + 10;
    const n = Date.now() - 10;
    return new qf(e, t, n, i);
  }
}
function BB(s) {
  return Math.pow(s, 3);
}
function WB(s) {
  return 1 - BB(1 - s);
}
const VB = 500, aI = 50;
class HB {
  constructor(e, t, i) {
    this.timestamp = e, this.deltaX = t, this.deltaY = i, this.score = 0;
  }
}
const b1 = class b1 {
  constructor() {
    this._capacity = 5, this._memory = [], this._front = -1, this._rear = -1;
  }
  isPhysicalMouseWheel() {
    if (this._front === -1 && this._rear === -1)
      return !1;
    let e = 1, t = 0, i = 1, n = this._rear;
    do {
      const o = n === this._front ? e : Math.pow(2, -i);
      if (e -= o, t += this._memory[n].score * o, n === this._front)
        break;
      n = (this._capacity + n - 1) % this._capacity, i++;
    } while (!0);
    return t <= 0.5;
  }
  acceptStandardWheelEvent(e) {
    if (Lg) {
      const t = ue(e.browserEvent), i = a6(t);
      this.accept(Date.now(), e.deltaX * i, e.deltaY * i);
    } else
      this.accept(Date.now(), e.deltaX, e.deltaY);
  }
  accept(e, t, i) {
    let n = null;
    const o = new HB(e, t, i);
    this._front === -1 && this._rear === -1 ? (this._memory[0] = o, this._front = 0, this._rear = 0) : (n = this._memory[this._rear], this._rear = (this._rear + 1) % this._capacity, this._rear === this._front && (this._front = (this._front + 1) % this._capacity), this._memory[this._rear] = o), o.score = this._computeScore(o, n);
  }
  /**
   * A score between 0 and 1 for `item`.
   *  - a score towards 0 indicates that the source appears to be a physical mouse wheel
   *  - a score towards 1 indicates that the source appears to be a touchpad or magic mouse, etc.
   */
  _computeScore(e, t) {
    if (Math.abs(e.deltaX) > 0 && Math.abs(e.deltaY) > 0)
      return 1;
    let i = 0.5;
    if ((!this._isAlmostInt(e.deltaX) || !this._isAlmostInt(e.deltaY)) && (i += 0.25), t) {
      const n = Math.abs(e.deltaX), o = Math.abs(e.deltaY), r = Math.abs(t.deltaX), a = Math.abs(t.deltaY), l = Math.max(Math.min(n, r), 1), c = Math.max(Math.min(o, a), 1), h = Math.max(n, r), d = Math.max(o, a);
      h % l === 0 && d % c === 0 && (i -= 0.5);
    }
    return Math.min(Math.max(i, 0), 1);
  }
  _isAlmostInt(e) {
    return Math.abs(Math.round(e) - e) < 0.01;
  }
};
b1.INSTANCE = new b1();
let jp = b1;
class uk extends ta {
  get options() {
    return this._options;
  }
  constructor(e, t, i) {
    super(), this._onScroll = this._register(new O()), this.onScroll = this._onScroll.event, this._onWillScroll = this._register(new O()), e.style.overflow = "hidden", this._options = UB(t), this._scrollable = i, this._register(this._scrollable.onScroll((o) => {
      this._onWillScroll.fire(o), this._onDidScroll(o), this._onScroll.fire(o);
    }));
    const n = {
      onMouseWheel: (o) => this._onMouseWheel(o),
      onDragStart: () => this._onDragStart(),
      onDragEnd: () => this._onDragEnd()
    };
    this._verticalScrollbar = this._register(new OB(this._scrollable, this._options, n)), this._horizontalScrollbar = this._register(new PB(this._scrollable, this._options, n)), this._domNode = document.createElement("div"), this._domNode.className = "monaco-scrollable-element " + this._options.className, this._domNode.setAttribute("role", "presentation"), this._domNode.style.position = "relative", this._domNode.style.overflow = "hidden", this._domNode.appendChild(e), this._domNode.appendChild(this._horizontalScrollbar.domNode.domNode), this._domNode.appendChild(this._verticalScrollbar.domNode.domNode), this._options.useShadows ? (this._leftShadowDomNode = je(document.createElement("div")), this._leftShadowDomNode.setClassName("shadow"), this._domNode.appendChild(this._leftShadowDomNode.domNode), this._topShadowDomNode = je(document.createElement("div")), this._topShadowDomNode.setClassName("shadow"), this._domNode.appendChild(this._topShadowDomNode.domNode), this._topLeftShadowDomNode = je(document.createElement("div")), this._topLeftShadowDomNode.setClassName("shadow"), this._domNode.appendChild(this._topLeftShadowDomNode.domNode)) : (this._leftShadowDomNode = null, this._topShadowDomNode = null, this._topLeftShadowDomNode = null), this._listenOnDomNode = this._options.listenOnDomNode || this._domNode, this._mouseWheelToDispose = [], this._setListeningToMouseWheel(this._options.handleMouseWheel), this.onmouseover(this._listenOnDomNode, (o) => this._onMouseOver(o)), this.onmouseleave(this._listenOnDomNode, (o) => this._onMouseLeave(o)), this._hideTimeout = this._register(new Ic()), this._isDragging = !1, this._mouseIsOver = !1, this._shouldRender = !0, this._revealOnScroll = !0;
  }
  dispose() {
    this._mouseWheelToDispose = Ri(this._mouseWheelToDispose), super.dispose();
  }
  /**
   * Get the generated 'scrollable' dom node
   */
  getDomNode() {
    return this._domNode;
  }
  getOverviewRulerLayoutInfo() {
    return {
      parent: this._domNode,
      insertBefore: this._verticalScrollbar.domNode.domNode
    };
  }
  /**
   * Delegate a pointer down event to the vertical scrollbar.
   * This is to help with clicking somewhere else and having the scrollbar react.
   */
  delegateVerticalScrollbarPointerDown(e) {
    this._verticalScrollbar.delegatePointerDown(e);
  }
  getScrollDimensions() {
    return this._scrollable.getScrollDimensions();
  }
  setScrollDimensions(e) {
    this._scrollable.setScrollDimensions(e, !1);
  }
  /**
   * Update the class name of the scrollable element.
   */
  updateClassName(e) {
    this._options.className = e, He && (this._options.className += " mac"), this._domNode.className = "monaco-scrollable-element " + this._options.className;
  }
  /**
   * Update configuration options for the scrollbar.
   */
  updateOptions(e) {
    typeof e.handleMouseWheel < "u" && (this._options.handleMouseWheel = e.handleMouseWheel, this._setListeningToMouseWheel(this._options.handleMouseWheel)), typeof e.mouseWheelScrollSensitivity < "u" && (this._options.mouseWheelScrollSensitivity = e.mouseWheelScrollSensitivity), typeof e.fastScrollSensitivity < "u" && (this._options.fastScrollSensitivity = e.fastScrollSensitivity), typeof e.scrollPredominantAxis < "u" && (this._options.scrollPredominantAxis = e.scrollPredominantAxis), typeof e.horizontal < "u" && (this._options.horizontal = e.horizontal), typeof e.vertical < "u" && (this._options.vertical = e.vertical), typeof e.horizontalScrollbarSize < "u" && (this._options.horizontalScrollbarSize = e.horizontalScrollbarSize), typeof e.verticalScrollbarSize < "u" && (this._options.verticalScrollbarSize = e.verticalScrollbarSize), typeof e.scrollByPage < "u" && (this._options.scrollByPage = e.scrollByPage), this._horizontalScrollbar.updateOptions(this._options), this._verticalScrollbar.updateOptions(this._options), this._options.lazyRender || this._render();
  }
  delegateScrollFromMouseWheelEvent(e) {
    this._onMouseWheel(new pc(e));
  }
  // -------------------- mouse wheel scrolling --------------------
  _setListeningToMouseWheel(e) {
    if (this._mouseWheelToDispose.length > 0 !== e && (this._mouseWheelToDispose = Ri(this._mouseWheelToDispose), e)) {
      const i = (n) => {
        this._onMouseWheel(new pc(n));
      };
      this._mouseWheelToDispose.push($(this._listenOnDomNode, ee.MOUSE_WHEEL, i, { passive: !1 }));
    }
  }
  _onMouseWheel(e) {
    var o;
    if ((o = e.browserEvent) != null && o.defaultPrevented)
      return;
    const t = jp.INSTANCE;
    t.acceptStandardWheelEvent(e);
    let i = !1;
    if (e.deltaY || e.deltaX) {
      let r = e.deltaY * this._options.mouseWheelScrollSensitivity, a = e.deltaX * this._options.mouseWheelScrollSensitivity;
      this._options.scrollPredominantAxis && (this._options.scrollYToX && a + r === 0 ? a = r = 0 : Math.abs(r) >= Math.abs(a) ? a = 0 : r = 0), this._options.flipAxes && ([r, a] = [a, r]);
      const l = !He && e.browserEvent && e.browserEvent.shiftKey;
      (this._options.scrollYToX || l) && !a && (a = r, r = 0), e.browserEvent && e.browserEvent.altKey && (a = a * this._options.fastScrollSensitivity, r = r * this._options.fastScrollSensitivity);
      const c = this._scrollable.getFutureScrollPosition();
      let h = {};
      if (r) {
        const d = aI * r, u = c.scrollTop - (d < 0 ? Math.floor(d) : Math.ceil(d));
        this._verticalScrollbar.writeScrollPosition(h, u);
      }
      if (a) {
        const d = aI * a, u = c.scrollLeft - (d < 0 ? Math.floor(d) : Math.ceil(d));
        this._horizontalScrollbar.writeScrollPosition(h, u);
      }
      h = this._scrollable.validateScrollPosition(h), (c.scrollLeft !== h.scrollLeft || c.scrollTop !== h.scrollTop) && (this._options.mouseWheelSmoothScroll && t.isPhysicalMouseWheel() ? this._scrollable.setScrollPositionSmooth(h) : this._scrollable.setScrollPositionNow(h), i = !0);
    }
    let n = i;
    !n && this._options.alwaysConsumeMouseWheel && (n = !0), !n && this._options.consumeMouseWheelIfScrollbarIsNeeded && (this._verticalScrollbar.isNeeded() || this._horizontalScrollbar.isNeeded()) && (n = !0), n && (e.preventDefault(), e.stopPropagation());
  }
  _onDidScroll(e) {
    this._shouldRender = this._horizontalScrollbar.onDidScroll(e) || this._shouldRender, this._shouldRender = this._verticalScrollbar.onDidScroll(e) || this._shouldRender, this._options.useShadows && (this._shouldRender = !0), this._revealOnScroll && this._reveal(), this._options.lazyRender || this._render();
  }
  /**
   * Render / mutate the DOM now.
   * Should be used together with the ctor option `lazyRender`.
   */
  renderNow() {
    if (!this._options.lazyRender)
      throw new Error("Please use `lazyRender` together with `renderNow`!");
    this._render();
  }
  _render() {
    if (this._shouldRender && (this._shouldRender = !1, this._horizontalScrollbar.render(), this._verticalScrollbar.render(), this._options.useShadows)) {
      const e = this._scrollable.getCurrentScrollPosition(), t = e.scrollTop > 0, i = e.scrollLeft > 0, n = i ? " left" : "", o = t ? " top" : "", r = i || t ? " top-left-corner" : "";
      this._leftShadowDomNode.setClassName(`shadow${n}`), this._topShadowDomNode.setClassName(`shadow${o}`), this._topLeftShadowDomNode.setClassName(`shadow${r}${o}${n}`);
    }
  }
  // -------------------- fade in / fade out --------------------
  _onDragStart() {
    this._isDragging = !0, this._reveal();
  }
  _onDragEnd() {
    this._isDragging = !1, this._hide();
  }
  _onMouseLeave(e) {
    this._mouseIsOver = !1, this._hide();
  }
  _onMouseOver(e) {
    this._mouseIsOver = !0, this._reveal();
  }
  _reveal() {
    this._verticalScrollbar.beginReveal(), this._horizontalScrollbar.beginReveal(), this._scheduleHide();
  }
  _hide() {
    !this._mouseIsOver && !this._isDragging && (this._verticalScrollbar.beginHide(), this._horizontalScrollbar.beginHide());
  }
  _scheduleHide() {
    !this._mouseIsOver && !this._isDragging && this._hideTimeout.cancelAndSet(() => this._hide(), VB);
  }
}
class zB extends uk {
  constructor(e, t) {
    t = t || {}, t.mouseWheelSmoothScroll = !1;
    const i = new zd({
      forceIntegerValues: !0,
      smoothScrollDuration: 0,
      scheduleAtNextAnimationFrame: (n) => Wn(ue(e), n)
    });
    super(e, t, i), this._register(i);
  }
  setScrollPosition(e) {
    this._scrollable.setScrollPositionNow(e);
  }
}
class xb extends uk {
  constructor(e, t, i) {
    super(e, t, i);
  }
  setScrollPosition(e) {
    e.reuseAnimation ? this._scrollable.setScrollPositionSmooth(e, e.reuseAnimation) : this._scrollable.setScrollPositionNow(e);
  }
  getScrollPosition() {
    return this._scrollable.getCurrentScrollPosition();
  }
}
class fk extends uk {
  constructor(e, t) {
    t = t || {}, t.mouseWheelSmoothScroll = !1;
    const i = new zd({
      forceIntegerValues: !1,
      // See https://github.com/microsoft/vscode/issues/139877
      smoothScrollDuration: 0,
      scheduleAtNextAnimationFrame: (n) => Wn(ue(e), n)
    });
    super(e, t, i), this._register(i), this._element = e, this._register(this.onScroll((n) => {
      n.scrollTopChanged && (this._element.scrollTop = n.scrollTop), n.scrollLeftChanged && (this._element.scrollLeft = n.scrollLeft);
    })), this.scanDomNode();
  }
  setScrollPosition(e) {
    this._scrollable.setScrollPositionNow(e);
  }
  getScrollPosition() {
    return this._scrollable.getCurrentScrollPosition();
  }
  scanDomNode() {
    this.setScrollDimensions({
      width: this._element.clientWidth,
      scrollWidth: this._element.scrollWidth,
      height: this._element.clientHeight,
      scrollHeight: this._element.scrollHeight
    }), this.setScrollPosition({
      scrollLeft: this._element.scrollLeft,
      scrollTop: this._element.scrollTop
    });
  }
}
function UB(s) {
  const e = {
    lazyRender: typeof s.lazyRender < "u" ? s.lazyRender : !1,
    className: typeof s.className < "u" ? s.className : "",
    useShadows: typeof s.useShadows < "u" ? s.useShadows : !0,
    handleMouseWheel: typeof s.handleMouseWheel < "u" ? s.handleMouseWheel : !0,
    flipAxes: typeof s.flipAxes < "u" ? s.flipAxes : !1,
    consumeMouseWheelIfScrollbarIsNeeded: typeof s.consumeMouseWheelIfScrollbarIsNeeded < "u" ? s.consumeMouseWheelIfScrollbarIsNeeded : !1,
    alwaysConsumeMouseWheel: typeof s.alwaysConsumeMouseWheel < "u" ? s.alwaysConsumeMouseWheel : !1,
    scrollYToX: typeof s.scrollYToX < "u" ? s.scrollYToX : !1,
    mouseWheelScrollSensitivity: typeof s.mouseWheelScrollSensitivity < "u" ? s.mouseWheelScrollSensitivity : 1,
    fastScrollSensitivity: typeof s.fastScrollSensitivity < "u" ? s.fastScrollSensitivity : 5,
    scrollPredominantAxis: typeof s.scrollPredominantAxis < "u" ? s.scrollPredominantAxis : !0,
    mouseWheelSmoothScroll: typeof s.mouseWheelSmoothScroll < "u" ? s.mouseWheelSmoothScroll : !0,
    arrowSize: typeof s.arrowSize < "u" ? s.arrowSize : 11,
    listenOnDomNode: typeof s.listenOnDomNode < "u" ? s.listenOnDomNode : null,
    horizontal: typeof s.horizontal < "u" ? s.horizontal : 1,
    horizontalScrollbarSize: typeof s.horizontalScrollbarSize < "u" ? s.horizontalScrollbarSize : 10,
    horizontalSliderSize: typeof s.horizontalSliderSize < "u" ? s.horizontalSliderSize : 0,
    horizontalHasArrows: typeof s.horizontalHasArrows < "u" ? s.horizontalHasArrows : !1,
    vertical: typeof s.vertical < "u" ? s.vertical : 1,
    verticalScrollbarSize: typeof s.verticalScrollbarSize < "u" ? s.verticalScrollbarSize : 10,
    verticalHasArrows: typeof s.verticalHasArrows < "u" ? s.verticalHasArrows : !1,
    verticalSliderSize: typeof s.verticalSliderSize < "u" ? s.verticalSliderSize : 0,
    scrollByPage: typeof s.scrollByPage < "u" ? s.scrollByPage : !1
  };
  return e.horizontalSliderSize = typeof s.horizontalSliderSize < "u" ? s.horizontalSliderSize : e.horizontalScrollbarSize, e.verticalSliderSize = typeof s.verticalSliderSize < "u" ? s.verticalSliderSize : e.verticalScrollbarSize, He && (e.className += " mac"), e;
}
const fm = pe;
let $B = class extends q {
  constructor() {
    super(), this.containerDomNode = document.createElement("div"), this.containerDomNode.className = "monaco-hover", this.containerDomNode.tabIndex = 0, this.containerDomNode.setAttribute("role", "tooltip"), this.contentsDomNode = document.createElement("div"), this.contentsDomNode.className = "monaco-hover-content", this.scrollbar = this._register(new fk(this.contentsDomNode, {
      consumeMouseWheelIfScrollbarIsNeeded: !0
    })), this.containerDomNode.appendChild(this.scrollbar.getDomNode());
  }
  onContentsChanged() {
    this.scrollbar.scanDomNode();
  }
};
class gk extends q {
  static render(e, t, i) {
    return new gk(e, t, i);
  }
  constructor(e, t, i) {
    super(), this.actionLabel = t.label, this.actionKeybindingLabel = i, this.actionContainer = ae(e, fm("div.action-container")), this.actionContainer.setAttribute("tabindex", "0"), this.action = ae(this.actionContainer, fm("a.action")), this.action.setAttribute("role", "button"), t.iconClass && ae(this.action, fm(`span.icon.${t.iconClass}`));
    const n = ae(this.action, fm("span"));
    n.textContent = i ? `${t.label} (${i})` : t.label, this._store.add(new qB(this.actionContainer, t.run)), this._store.add(new jB(this.actionContainer, t.run, [
      3,
      10
      /* KeyCode.Space */
    ])), this.setEnabled(!0);
  }
  setEnabled(e) {
    e ? (this.actionContainer.classList.remove("disabled"), this.actionContainer.removeAttribute("aria-disabled")) : (this.actionContainer.classList.add("disabled"), this.actionContainer.setAttribute("aria-disabled", "true"));
  }
}
function KB(s, e) {
  return s && e ? p("acessibleViewHint", "Inspect this in the accessible view with {0}.", e) : s ? p("acessibleViewHintNoKbOpen", "Inspect this in the accessible view via the command Open Accessible View which is currently not triggerable via keybinding.") : "";
}
class qB extends q {
  constructor(e, t) {
    super(), this._register($(e, ee.CLICK, (i) => {
      i.stopPropagation(), i.preventDefault(), t(e);
    }));
  }
}
class jB extends q {
  constructor(e, t, i) {
    super(), this._register($(e, ee.KEY_DOWN, (n) => {
      const o = new Lt(n);
      i.some((r) => o.equals(r)) && (n.stopPropagation(), n.preventDefault(), t(e));
    }));
  }
}
const Og = Ve("openerService");
function GB(s) {
  let e;
  const t = /^L?(\d+)(?:,(\d+))?(-L?(\d+)(?:,(\d+))?)?/.exec(s.fragment);
  return t && (e = {
    startLineNumber: parseInt(t[1]),
    startColumn: t[2] ? parseInt(t[2]) : 1,
    endLineNumber: t[4] ? parseInt(t[4]) : void 0,
    endColumn: t[4] ? t[5] ? parseInt(t[5]) : 1 : void 0
  }, s = s.with({ fragment: "" })), { selection: e, uri: s };
}
class Re {
  get event() {
    return this.emitter.event;
  }
  constructor(e, t, i) {
    const n = (o) => this.emitter.fire(o);
    this.emitter = new O({
      onWillAddFirstListener: () => e.addEventListener(t, n, i),
      onDidRemoveLastListener: () => e.removeEventListener(t, n, i)
    });
  }
  dispose() {
    this.emitter.dispose();
  }
}
function ZB(s, e = {}) {
  const t = mk(e);
  return t.textContent = s, t;
}
function YB(s, e = {}) {
  const t = mk(e);
  return jR(t, XB(s, !!e.renderCodeSegments), e.actionHandler, e.renderCodeSegments), t;
}
function mk(s) {
  const e = s.inline ? "span" : "div", t = document.createElement(e);
  return s.className && (t.className = s.className), t;
}
class QB {
  constructor(e) {
    this.source = e, this.index = 0;
  }
  eos() {
    return this.index >= this.source.length;
  }
  next() {
    const e = this.peek();
    return this.advance(), e;
  }
  peek() {
    return this.source[this.index];
  }
  advance() {
    this.index++;
  }
}
function jR(s, e, t, i) {
  let n;
  if (e.type === 2)
    n = document.createTextNode(e.content || "");
  else if (e.type === 3)
    n = document.createElement("b");
  else if (e.type === 4)
    n = document.createElement("i");
  else if (e.type === 7 && i)
    n = document.createElement("code");
  else if (e.type === 5 && t) {
    const o = document.createElement("a");
    t.disposables.add(fi(o, "click", (r) => {
      t.callback(String(e.index), r);
    })), n = o;
  } else e.type === 8 ? n = document.createElement("br") : e.type === 1 && (n = s);
  n && s !== n && s.appendChild(n), n && Array.isArray(e.children) && e.children.forEach((o) => {
    jR(n, o, t, i);
  });
}
function XB(s, e) {
  const t = {
    type: 1,
    children: []
  };
  let i = 0, n = t;
  const o = [], r = new QB(s);
  for (; !r.eos(); ) {
    let a = r.next();
    const l = a === "\\" && Wv(r.peek(), e) !== 0;
    if (l && (a = r.next()), !l && JB(a, e) && a === r.peek()) {
      r.advance(), n.type === 2 && (n = o.pop());
      const c = Wv(a, e);
      if (n.type === c || n.type === 5 && c === 6)
        n = o.pop();
      else {
        const h = {
          type: c,
          children: []
        };
        c === 5 && (h.index = i, i++), n.children.push(h), o.push(n), n = h;
      }
    } else if (a === `
`)
      n.type === 2 && (n = o.pop()), n.children.push({
        type: 8
        /* FormatType.NewLine */
      });
    else if (n.type !== 2) {
      const c = {
        type: 2,
        content: a
      };
      n.children.push(c), o.push(n), n = c;
    } else
      n.content += a;
  }
  return n.type === 2 && (n = o.pop()), t;
}
function JB(s, e) {
  return Wv(s, e) !== 0;
}
function Wv(s, e) {
  switch (s) {
    case "*":
      return 3;
    case "_":
      return 4;
    case "[":
      return 5;
    case "]":
      return 6;
    case "`":
      return e ? 7 : 0;
    default:
      return 0;
  }
}
const eW = new RegExp(`(\\\\)?\\$\\((${Ke.iconNameExpression}(?:${Ke.iconModifierExpression})?)\\)`, "g");
function Yl(s) {
  const e = new Array();
  let t, i = 0, n = 0;
  for (; (t = eW.exec(s)) !== null; ) {
    n = t.index || 0, i < n && e.push(s.substring(i, n)), i = (t.index || 0) + t[0].length;
    const [, o, r] = t;
    e.push(o ? `$(${r})` : Gp({ id: r }));
  }
  return i < s.length && e.push(s.substring(i)), e;
}
function Gp(s) {
  const e = pe("span");
  return e.classList.add(...Ke.asClassNameArray(s)), e;
}
function GR(...s) {
  return function(e, t) {
    for (let i = 0, n = s.length; i < n; i++) {
      const o = s[i](e, t);
      if (o)
        return o;
    }
    return null;
  };
}
ZR.bind(void 0, !1);
const Zp = ZR.bind(void 0, !0);
function ZR(s, e, t) {
  if (!t || t.length < e.length)
    return null;
  let i;
  return s ? i = EL(t, e) : i = t.indexOf(e) === 0, i ? e.length > 0 ? [{ start: 0, end: e.length }] : [] : null;
}
function tW(s, e) {
  const t = e.toLowerCase().indexOf(s.toLowerCase());
  return t === -1 ? null : [{ start: t, end: t + s.length }];
}
function iW(s, e) {
  return Vv(s.toLowerCase(), e.toLowerCase(), 0, 0);
}
function Vv(s, e, t, i) {
  if (t === s.length)
    return [];
  if (i === e.length)
    return null;
  if (s[t] === e[i]) {
    let n = null;
    return (n = Vv(s, e, t + 1, i + 1)) ? QR({ start: i, end: i + 1 }, n) : null;
  }
  return Vv(s, e, t, i + 1);
}
function pk(s) {
  return 97 <= s && s <= 122;
}
function Db(s) {
  return 65 <= s && s <= 90;
}
function _k(s) {
  return 48 <= s && s <= 57;
}
function nW(s) {
  return s === 32 || s === 9 || s === 10 || s === 13;
}
const sW = /* @__PURE__ */ new Set();
"()[]{}<>`'\"-/;:,.?!".split("").forEach((s) => sW.add(s.charCodeAt(0)));
function YR(s) {
  return pk(s) || Db(s) || _k(s);
}
function QR(s, e) {
  return e.length === 0 ? e = [s] : s.end === e[0].start ? e[0].start = s.start : e.unshift(s), e;
}
function XR(s, e) {
  for (let t = e; t < s.length; t++) {
    const i = s.charCodeAt(t);
    if (Db(i) || _k(i) || t > 0 && !YR(s.charCodeAt(t - 1)))
      return t;
  }
  return s.length;
}
function Hv(s, e, t, i) {
  if (t === s.length)
    return [];
  if (i === e.length)
    return null;
  if (s[t] !== e[i].toLowerCase())
    return null;
  {
    let n = null, o = i + 1;
    for (n = Hv(s, e, t + 1, i + 1); !n && (o = XR(e, o)) < e.length; )
      n = Hv(s, e, t + 1, o), o++;
    return n === null ? null : QR({ start: i, end: i + 1 }, n);
  }
}
function oW(s) {
  let e = 0, t = 0, i = 0, n = 0, o = 0;
  for (let h = 0; h < s.length; h++)
    o = s.charCodeAt(h), Db(o) && e++, pk(o) && t++, YR(o) && i++, _k(o) && n++;
  const r = e / s.length, a = t / s.length, l = i / s.length, c = n / s.length;
  return { upperPercent: r, lowerPercent: a, alphaPercent: l, numericPercent: c };
}
function rW(s) {
  const { upperPercent: e, lowerPercent: t } = s;
  return t === 0 && e > 0.6;
}
function aW(s) {
  const { upperPercent: e, lowerPercent: t, alphaPercent: i, numericPercent: n } = s;
  return t > 0.2 && e < 0.8 && i > 0.6 && n < 0.2;
}
function lW(s) {
  let e = 0, t = 0, i = 0, n = 0;
  for (let o = 0; o < s.length; o++)
    i = s.charCodeAt(o), Db(i) && e++, pk(i) && t++, nW(i) && n++;
  return (e === 0 || t === 0) && n === 0 ? s.length <= 30 : e <= 5;
}
function JR(s, e) {
  if (!e || (e = e.trim(), e.length === 0) || !lW(s))
    return null;
  e.length > 60 && (e = e.substring(0, 60));
  const t = oW(e);
  if (!aW(t)) {
    if (!rW(t))
      return null;
    e = e.toLowerCase();
  }
  let i = null, n = 0;
  for (s = s.toLowerCase(); n < e.length && (i = Hv(s, e, 0, n)) === null; )
    n = XR(e, n + 1);
  return i;
}
const cW = GR(Zp, JR, tW), hW = GR(Zp, JR, iW), lI = new Tg(1e4);
function cI(s, e, t = !1) {
  if (typeof s != "string" || typeof e != "string")
    return null;
  let i = lI.get(s);
  i || (i = new RegExp(YO(s), "i"), lI.set(s, i));
  const n = i.exec(e);
  return n ? [{ start: n.index, end: n.index + n[0].length }] : t ? hW(s, e) : cW(s, e);
}
function dW(s, e) {
  const t = iA(s, s.toLowerCase(), 0, e, e.toLowerCase(), 0, { firstMatchCanBeWeak: !0, boostFullMatch: !0 });
  return t ? uW(t) : null;
}
function uW(s) {
  if (typeof s > "u")
    return [];
  const e = [], t = s[1];
  for (let i = s.length - 1; i > 1; i--) {
    const n = s[i] + t, o = e[e.length - 1];
    o && o.end === n ? o.end = n + 1 : e.push({ start: n, end: n + 1 });
  }
  return e;
}
const Da = 128;
function bk() {
  const s = [], e = [];
  for (let t = 0; t <= Da; t++)
    e[t] = 0;
  for (let t = 0; t <= Da; t++)
    s.push(e.slice(0));
  return s;
}
function eA(s) {
  const e = [];
  for (let t = 0; t <= s; t++)
    e[t] = 0;
  return e;
}
const tA = eA(2 * Da), zv = eA(2 * Da), nr = bk(), al = bk(), gm = bk();
function mm(s, e) {
  if (e < 0 || e >= s.length)
    return !1;
  const t = s.codePointAt(e);
  switch (t) {
    case 95:
    case 45:
    case 46:
    case 32:
    case 47:
    case 92:
    case 39:
    case 34:
    case 58:
    case 36:
    case 60:
    case 62:
    case 40:
    case 41:
    case 91:
    case 93:
    case 123:
    case 125:
      return !0;
    case void 0:
      return !1;
    default:
      return !!RL(t);
  }
}
function hI(s, e) {
  if (e < 0 || e >= s.length)
    return !1;
  switch (s.charCodeAt(e)) {
    case 32:
    case 9:
      return !0;
    default:
      return !1;
  }
}
function ep(s, e, t) {
  return e[s] !== t[s];
}
function fW(s, e, t, i, n, o, r = !1) {
  for (; e < t && n < o; )
    s[e] === i[n] && (r && (tA[e] = n), e += 1), n += 1;
  return e === t;
}
var Zh;
(function(s) {
  s.Default = [-100, 0];
  function e(t) {
    return !t || t.length === 2 && t[0] === -100 && t[1] === 0;
  }
  s.isDefault = e;
})(Zh || (Zh = {}));
const jx = class jx {
  constructor(e, t) {
    this.firstMatchCanBeWeak = e, this.boostFullMatch = t;
  }
};
jx.default = { boostFullMatch: !0, firstMatchCanBeWeak: !1 };
let Uv = jx;
function iA(s, e, t, i, n, o, r = Uv.default) {
  const a = s.length > Da ? Da : s.length, l = i.length > Da ? Da : i.length;
  if (t >= a || o >= l || a - t > l - o || !fW(e, t, a, n, o, l, !0))
    return;
  gW(a, l, t, o, e, n);
  let c = 1, h = 1, d = t, u = o;
  const f = [!1];
  for (c = 1, d = t; d < a; c++, d++) {
    const C = tA[d], v = zv[d], w = d + 1 < a ? zv[d + 1] : l;
    for (h = C - o + 1, u = C; u < w; h++, u++) {
      let S = Number.MIN_SAFE_INTEGER, L = !1;
      u <= v && (S = mW(s, e, d, t, i, n, u, l, o, nr[c - 1][h - 1] === 0, f));
      let k = 0;
      S !== Number.MAX_SAFE_INTEGER && (L = !0, k = S + al[c - 1][h - 1]);
      const D = u > C, E = D ? al[c][h - 1] + (nr[c][h - 1] > 0 ? -5 : 0) : 0, U = u > C + 1 && nr[c][h - 1] > 0, P = U ? al[c][h - 2] + (nr[c][h - 2] > 0 ? -5 : 0) : 0;
      if (U && (!D || P >= E) && (!L || P >= k))
        al[c][h] = P, gm[c][h] = 3, nr[c][h] = 0;
      else if (D && (!L || E >= k))
        al[c][h] = E, gm[c][h] = 2, nr[c][h] = 0;
      else if (L)
        al[c][h] = k, gm[c][h] = 1, nr[c][h] = nr[c - 1][h - 1] + 1;
      else
        throw new Error("not possible");
    }
  }
  if (!f[0] && !r.firstMatchCanBeWeak)
    return;
  c--, h--;
  const g = [al[c][h], o];
  let m = 0, _ = 0;
  for (; c >= 1; ) {
    let C = h;
    do {
      const v = gm[c][C];
      if (v === 3)
        C = C - 2;
      else if (v === 2)
        C = C - 1;
      else
        break;
    } while (C >= 1);
    m > 1 && e[t + c - 1] === n[o + h - 1] && !ep(C + o - 1, i, n) && m + 1 > nr[c][C] && (C = h), C === h ? m++ : m = 1, _ || (_ = C), c--, h = C - 1, g.push(h);
  }
  l - o === a && r.boostFullMatch && (g[0] += 2);
  const b = _ - a;
  return g[0] -= b, g;
}
function gW(s, e, t, i, n, o) {
  let r = s - 1, a = e - 1;
  for (; r >= t && a >= i; )
    n[r] === o[a] && (zv[r] = a, r--), a--;
}
function mW(s, e, t, i, n, o, r, a, l, c, h) {
  if (e[t] !== o[r])
    return Number.MIN_SAFE_INTEGER;
  let d = 1, u = !1;
  return r === t - i ? d = s[t] === n[r] ? 7 : 5 : ep(r, n, o) && (r === 0 || !ep(r - 1, n, o)) ? (d = s[t] === n[r] ? 7 : 5, u = !0) : mm(o, r) && (r === 0 || !mm(o, r - 1)) ? d = 5 : (mm(o, r - 1) || hI(o, r - 1)) && (d = 5, u = !0), d > 1 && t === i && (h[0] = !0), u || (u = ep(r, n, o) || mm(o, r - 1) || hI(o, r - 1)), t === i ? r > l && (d -= u ? 3 : 5) : c ? d += u ? 2 : 0 : d += u ? 0 : 1, r + 1 === a && (d -= u ? 3 : 5), d;
}
const pW = "$(", Ck = new RegExp(`\\$\\(${Ke.iconNameExpression}(?:${Ke.iconModifierExpression})?\\)`, "g"), _W = new RegExp(`(\\\\)?${Ck.source}`, "g");
function bW(s) {
  return s.replace(_W, (e, t) => t ? e : `\\${e}`);
}
const CW = new RegExp(`\\\\${Ck.source}`, "g");
function wW(s) {
  return s.replace(CW, (e) => `\\${e}`);
}
const vW = new RegExp(`(\\s)?(\\\\)?${Ck.source}(\\s)?`, "g");
function nA(s) {
  return s.indexOf(pW) === -1 ? s : s.replace(vW, (e, t, i, n) => i ? e : t || n || "");
}
function yW(s) {
  return s ? s.replace(/\$\((.*?)\)/g, (e, t) => ` ${t} `).trim() : "";
}
const V0 = new RegExp(`\\$\\(${Ke.iconNameCharacter}+\\)`, "g");
function Eu(s) {
  V0.lastIndex = 0;
  let e = "";
  const t = [];
  let i = 0;
  for (; ; ) {
    const n = V0.lastIndex, o = V0.exec(s), r = s.substring(n, o == null ? void 0 : o.index);
    if (r.length > 0) {
      e += r;
      for (let a = 0; a < r.length; a++)
        t.push(i);
    }
    if (!o)
      break;
    i += o[0].length;
  }
  return { text: e, iconOffsets: t };
}
function H0(s, e, t = !1) {
  const { text: i, iconOffsets: n } = e;
  if (!n || n.length === 0)
    return cI(s, i, t);
  const o = ib(i, " "), r = i.length - o.length, a = cI(s, o, t);
  if (a)
    for (const l of a) {
      const c = n[l.start + r] + r;
      l.start += c, l.end += c;
    }
  return a;
}
function sr(s) {
  return Lp(s, !0);
}
class SW {
  constructor(e) {
    this._ignorePathCasing = e;
  }
  compare(e, t, i = !1) {
    return e === t ? 0 : Ow(this.getComparisonKey(e, i), this.getComparisonKey(t, i));
  }
  isEqual(e, t, i = !1) {
    return e === t ? !0 : !e || !t ? !1 : this.getComparisonKey(e, i) === this.getComparisonKey(t, i);
  }
  getComparisonKey(e, t = !1) {
    return e.with({
      path: this._ignorePathCasing(e) ? e.path.toLowerCase() : void 0,
      fragment: t ? null : void 0
    }).toString();
  }
  isEqualOrParent(e, t, i = !1) {
    if (e.scheme === t.scheme) {
      if (e.scheme === Ne.file)
        return Iv(sr(e), sr(t), this._ignorePathCasing(e)) && e.query === t.query && (i || e.fragment === t.fragment);
      if (uI(e.authority, t.authority))
        return Iv(e.path, t.path, this._ignorePathCasing(e), "/") && e.query === t.query && (i || e.fragment === t.fragment);
    }
    return !1;
  }
  // --- path math
  joinPath(e, ...t) {
    return Te.joinPath(e, ...t);
  }
  basenameOrAuthority(e) {
    return wk(e) || e.authority;
  }
  basename(e) {
    return Kt.basename(e.path);
  }
  extname(e) {
    return Kt.extname(e.path);
  }
  dirname(e) {
    if (e.path.length === 0)
      return e;
    let t;
    return e.scheme === Ne.file ? t = Te.file(EO(sr(e))).path : (t = Kt.dirname(e.path), e.authority && t.length && t.charCodeAt(0) !== 47 && (console.error(`dirname("${e.toString})) resulted in a relative path`), t = "/")), e.with({
      path: t
    });
  }
  normalizePath(e) {
    if (!e.path.length)
      return e;
    let t;
    return e.scheme === Ne.file ? t = Te.file(H2(sr(e))).path : t = Kt.normalize(e.path), e.with({
      path: t
    });
  }
  relativePath(e, t) {
    if (e.scheme !== t.scheme || !uI(e.authority, t.authority))
      return;
    if (e.scheme === Ne.file) {
      const o = DO(sr(e), sr(t));
      return Fn ? bR(o) : o;
    }
    let i = e.path || "/";
    const n = t.path || "/";
    if (this._ignorePathCasing(e)) {
      let o = 0;
      for (const r = Math.min(i.length, n.length); o < r && !(i.charCodeAt(o) !== n.charCodeAt(o) && i.charAt(o).toLowerCase() !== n.charAt(o).toLowerCase()); o++)
        ;
      i = n.substr(0, o) + i.substr(o);
    }
    return Kt.relative(i, n);
  }
  resolvePath(e, t) {
    if (e.scheme === Ne.file) {
      const i = Te.file(xO(sr(e), t));
      return e.with({
        authority: i.authority,
        path: i.path
      });
    }
    return t = EF(t), e.with({
      path: Kt.resolve(e.path, t)
    });
  }
  // --- misc
  isAbsolutePath(e) {
    return !!e.path && e.path[0] === "/";
  }
  isEqualAuthority(e, t) {
    return e === t || e !== void 0 && t !== void 0 && dh(e, t);
  }
  hasTrailingPathSeparator(e, t = Fa) {
    if (e.scheme === Ne.file) {
      const i = sr(e);
      return i.length > BE(i).length && i[i.length - 1] === t;
    } else {
      const i = e.path;
      return i.length > 1 && i.charCodeAt(i.length - 1) === 47 && !/^[a-zA-Z]:(\/$|\\$)/.test(e.fsPath);
    }
  }
  removeTrailingPathSeparator(e, t = Fa) {
    return fI(e, t) ? e.with({ path: e.path.substr(0, e.path.length - 1) }) : e;
  }
  addTrailingPathSeparator(e, t = Fa) {
    let i = !1;
    if (e.scheme === Ne.file) {
      const n = sr(e);
      i = n !== void 0 && n.length === BE(n).length && n[n.length - 1] === t;
    } else {
      t = "/";
      const n = e.path;
      i = n.length === 1 && n.charCodeAt(n.length - 1) === 47;
    }
    return !i && !fI(e, t) ? e.with({ path: e.path + "/" }) : e;
  }
}
const Nt = new SW(() => !1), LW = Nt.isEqual.bind(Nt);
Nt.isEqualOrParent.bind(Nt);
Nt.getComparisonKey.bind(Nt);
Nt.basenameOrAuthority.bind(Nt);
const wk = Nt.basename.bind(Nt);
Nt.extname.bind(Nt);
const kW = Nt.dirname.bind(Nt);
Nt.joinPath.bind(Nt);
const xW = Nt.normalizePath.bind(Nt);
Nt.relativePath.bind(Nt);
const dI = Nt.resolvePath.bind(Nt);
Nt.isAbsolutePath.bind(Nt);
const uI = Nt.isEqualAuthority.bind(Nt), fI = Nt.hasTrailingPathSeparator.bind(Nt);
Nt.removeTrailingPathSeparator.bind(Nt);
Nt.addTrailingPathSeparator.bind(Nt);
var Yp;
(function(s) {
  s.META_DATA_LABEL = "label", s.META_DATA_DESCRIPTION = "description", s.META_DATA_SIZE = "size", s.META_DATA_MIME = "mime";
  function e(t) {
    const i = /* @__PURE__ */ new Map();
    t.path.substring(t.path.indexOf(";") + 1, t.path.lastIndexOf(";")).split(";").forEach((r) => {
      const [a, l] = r.split(":");
      a && l && i.set(a, l);
    });
    const o = t.path.substring(0, t.path.indexOf(";"));
    return o && i.set(s.META_DATA_MIME, o), i;
  }
  s.parseMetaData = e;
})(Yp || (Yp = {}));
class sA {
  constructor(e = "", t = !1) {
    if (this.value = e, typeof this.value != "string")
      throw eb("value");
    typeof t == "boolean" ? (this.isTrusted = t, this.supportThemeIcons = !1, this.supportHtml = !1) : (this.isTrusted = t.isTrusted ?? void 0, this.supportThemeIcons = t.supportThemeIcons ?? !1, this.supportHtml = t.supportHtml ?? !1);
  }
  appendText(e, t = 0) {
    return this.value += EW(this.supportThemeIcons ? bW(e) : e).replace(/([ \t]+)/g, (i, n) => "&nbsp;".repeat(n.length)).replace(/\>/gm, "\\>").replace(/\n/g, t === 1 ? `\\
` : `

`), this;
  }
  appendMarkdown(e) {
    return this.value += e, this;
  }
  appendCodeblock(e, t) {
    return this.value += `
${IW(t, e)}
`, this;
  }
  appendLink(e, t, i) {
    return this.value += "[", this.value += this._escape(t, "]"), this.value += "](", this.value += this._escape(String(e), ")"), i && (this.value += ` "${this._escape(this._escape(i, '"'), ")")}"`), this.value += ")", this;
  }
  _escape(e, t) {
    const i = new RegExp(Yr(t), "g");
    return e.replace(i, (n, o) => e.charAt(o - 1) !== "\\" ? `\\${n}` : n);
  }
}
function Yh(s) {
  return s instanceof sA ? !0 : s && typeof s == "object" ? typeof s.value == "string" && (typeof s.isTrusted == "boolean" || typeof s.isTrusted == "object" || s.isTrusted === void 0) && (typeof s.supportThemeIcons == "boolean" || s.supportThemeIcons === void 0) : !1;
}
function DW(s, e) {
  return s === e ? !0 : !s || !e ? !1 : s.value === e.value && s.isTrusted === e.isTrusted && s.supportThemeIcons === e.supportThemeIcons && s.supportHtml === e.supportHtml && (s.baseUri === e.baseUri || !!s.baseUri && !!e.baseUri && LW(Te.from(s.baseUri), Te.from(e.baseUri)));
}
function EW(s) {
  return s.replace(/[\\`*_{}[\]()#+\-!~]/g, "\\$&");
}
function IW(s, e) {
  var n;
  const t = ((n = s.match(/^`+/gm)) == null ? void 0 : n.reduce((o, r) => o.length > r.length ? o : r).length) ?? 0, i = t >= 3 ? t + 1 : 3;
  return [
    `${"`".repeat(i)}${e}`,
    s,
    `${"`".repeat(i)}`
  ].join(`
`);
}
function pm(s) {
  return s.replace(/"/g, "&quot;");
}
function z0(s) {
  return s && s.replace(/\\([\\`*_{}[\]()#+\-.!~])/g, "$1");
}
function NW(s) {
  const e = [], t = s.split("|").map((n) => n.trim());
  s = t[0];
  const i = t[1];
  if (i) {
    const n = /height=(\d+)/.exec(i), o = /width=(\d+)/.exec(i), r = n ? n[1] : "", a = o ? o[1] : "", l = isFinite(parseInt(a)), c = isFinite(parseInt(r));
    l && e.push(`width="${a}"`), c && e.push(`height="${r}"`);
  }
  return { href: s, dimensions: e };
}
class oA {
  constructor(e) {
    this._prefix = e, this._lastId = 0;
  }
  nextId() {
    return this._prefix + ++this._lastId;
  }
}
const gI = new oA("id#");
let Wi = {};
(function() {
  function s(e, t) {
    t(Wi);
  }
  s.amd = !0, (function(e, t) {
    typeof s == "function" && s.amd ? s(["exports"], t) : typeof exports == "object" && typeof module < "u" ? t(exports) : (e = typeof globalThis < "u" ? globalThis : e || self, t(e.marked = {}));
  })(this, (function(e) {
    function t() {
      return {
        async: !1,
        breaks: !1,
        extensions: null,
        gfm: !0,
        hooks: null,
        pedantic: !1,
        renderer: null,
        silent: !1,
        tokenizer: null,
        walkTokens: null
      };
    }
    e.defaults = t();
    function i(Oe) {
      e.defaults = Oe;
    }
    const n = /[&<>"']/, o = new RegExp(n.source, "g"), r = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, a = new RegExp(r.source, "g"), l = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, c = (Oe) => l[Oe];
    function h(Oe, I) {
      if (I) {
        if (n.test(Oe))
          return Oe.replace(o, c);
      } else if (r.test(Oe))
        return Oe.replace(a, c);
      return Oe;
    }
    const d = /(^|[^\[])\^/g;
    function u(Oe, I) {
      let T = typeof Oe == "string" ? Oe : Oe.source;
      I = I || "";
      const M = {
        replace: (F, H) => {
          let j = typeof H == "string" ? H : H.source;
          return j = j.replace(d, "$1"), T = T.replace(F, j), M;
        },
        getRegex: () => new RegExp(T, I)
      };
      return M;
    }
    function f(Oe) {
      try {
        Oe = encodeURI(Oe).replace(/%25/g, "%");
      } catch {
        return null;
      }
      return Oe;
    }
    const g = { exec: () => null };
    function m(Oe, I) {
      const T = Oe.replace(/\|/g, (H, j, X) => {
        let ce = !1, ge = j;
        for (; --ge >= 0 && X[ge] === "\\"; )
          ce = !ce;
        return ce ? "|" : " |";
      }), M = T.split(/ \|/);
      let F = 0;
      if (M[0].trim() || M.shift(), M.length > 0 && !M[M.length - 1].trim() && M.pop(), I)
        if (M.length > I)
          M.splice(I);
        else
          for (; M.length < I; )
            M.push("");
      for (; F < M.length; F++)
        M[F] = M[F].trim().replace(/\\\|/g, "|");
      return M;
    }
    function _(Oe, I, T) {
      const M = Oe.length;
      if (M === 0)
        return "";
      let F = 0;
      for (; F < M && Oe.charAt(M - F - 1) === I; )
        F++;
      return Oe.slice(0, M - F);
    }
    function b(Oe, I) {
      if (Oe.indexOf(I[1]) === -1)
        return -1;
      let T = 0;
      for (let M = 0; M < Oe.length; M++)
        if (Oe[M] === "\\")
          M++;
        else if (Oe[M] === I[0])
          T++;
        else if (Oe[M] === I[1] && (T--, T < 0))
          return M;
      return -1;
    }
    function C(Oe, I, T, M) {
      const F = I.href, H = I.title ? h(I.title) : null, j = Oe[1].replace(/\\([\[\]])/g, "$1");
      if (Oe[0].charAt(0) !== "!") {
        M.state.inLink = !0;
        const X = {
          type: "link",
          raw: T,
          href: F,
          title: H,
          text: j,
          tokens: M.inlineTokens(j)
        };
        return M.state.inLink = !1, X;
      }
      return {
        type: "image",
        raw: T,
        href: F,
        title: H,
        text: h(j)
      };
    }
    function v(Oe, I) {
      const T = Oe.match(/^(\s+)(?:```)/);
      if (T === null)
        return I;
      const M = T[1];
      return I.split(`
`).map((F) => {
        const H = F.match(/^\s+/);
        if (H === null)
          return F;
        const [j] = H;
        return j.length >= M.length ? F.slice(M.length) : F;
      }).join(`
`);
    }
    class w {
      // set by the lexer
      constructor(I) {
        Zt(this, "options");
        Zt(this, "rules");
        // set by the lexer
        Zt(this, "lexer");
        this.options = I || e.defaults;
      }
      space(I) {
        const T = this.rules.block.newline.exec(I);
        if (T && T[0].length > 0)
          return {
            type: "space",
            raw: T[0]
          };
      }
      code(I) {
        const T = this.rules.block.code.exec(I);
        if (T) {
          const M = T[0].replace(/^ {1,4}/gm, "");
          return {
            type: "code",
            raw: T[0],
            codeBlockStyle: "indented",
            text: this.options.pedantic ? M : _(M, `
`)
          };
        }
      }
      fences(I) {
        const T = this.rules.block.fences.exec(I);
        if (T) {
          const M = T[0], F = v(M, T[3] || "");
          return {
            type: "code",
            raw: M,
            lang: T[2] ? T[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : T[2],
            text: F
          };
        }
      }
      heading(I) {
        const T = this.rules.block.heading.exec(I);
        if (T) {
          let M = T[2].trim();
          if (/#$/.test(M)) {
            const F = _(M, "#");
            (this.options.pedantic || !F || / $/.test(F)) && (M = F.trim());
          }
          return {
            type: "heading",
            raw: T[0],
            depth: T[1].length,
            text: M,
            tokens: this.lexer.inline(M)
          };
        }
      }
      hr(I) {
        const T = this.rules.block.hr.exec(I);
        if (T)
          return {
            type: "hr",
            raw: _(T[0], `
`)
          };
      }
      blockquote(I) {
        const T = this.rules.block.blockquote.exec(I);
        if (T) {
          let M = _(T[0], `
`).split(`
`), F = "", H = "";
          const j = [];
          for (; M.length > 0; ) {
            let X = !1;
            const ce = [];
            let ge;
            for (ge = 0; ge < M.length; ge++)
              if (/^ {0,3}>/.test(M[ge]))
                ce.push(M[ge]), X = !0;
              else if (!X)
                ce.push(M[ge]);
              else
                break;
            M = M.slice(ge);
            const Me = ce.join(`
`), rt = Me.replace(/\n {0,3}((?:=+|-+) *)(?=\n|$)/g, `
    $1`).replace(/^ {0,3}>[ \t]?/gm, "");
            F = F ? `${F}
${Me}` : Me, H = H ? `${H}
${rt}` : rt;
            const dt = this.lexer.state.top;
            if (this.lexer.state.top = !0, this.lexer.blockTokens(rt, j, !0), this.lexer.state.top = dt, M.length === 0)
              break;
            const Pt = j[j.length - 1];
            if ((Pt == null ? void 0 : Pt.type) === "code")
              break;
            if ((Pt == null ? void 0 : Pt.type) === "blockquote") {
              const Ot = Pt, Ln = Ot.raw + `
` + M.join(`
`), rs = this.blockquote(Ln);
              j[j.length - 1] = rs, F = F.substring(0, F.length - Ot.raw.length) + rs.raw, H = H.substring(0, H.length - Ot.text.length) + rs.text;
              break;
            } else if ((Pt == null ? void 0 : Pt.type) === "list") {
              const Ot = Pt, Ln = Ot.raw + `
` + M.join(`
`), rs = this.list(Ln);
              j[j.length - 1] = rs, F = F.substring(0, F.length - Pt.raw.length) + rs.raw, H = H.substring(0, H.length - Ot.raw.length) + rs.raw, M = Ln.substring(j[j.length - 1].raw.length).split(`
`);
              continue;
            }
          }
          return {
            type: "blockquote",
            raw: F,
            tokens: j,
            text: H
          };
        }
      }
      list(I) {
        let T = this.rules.block.list.exec(I);
        if (T) {
          let M = T[1].trim();
          const F = M.length > 1, H = {
            type: "list",
            raw: "",
            ordered: F,
            start: F ? +M.slice(0, -1) : "",
            loose: !1,
            items: []
          };
          M = F ? `\\d{1,9}\\${M.slice(-1)}` : `\\${M}`, this.options.pedantic && (M = F ? M : "[*+-]");
          const j = new RegExp(`^( {0,3}${M})((?:[	 ][^\\n]*)?(?:\\n|$))`);
          let X = !1;
          for (; I; ) {
            let ce = !1, ge = "", Me = "";
            if (!(T = j.exec(I)) || this.rules.block.hr.test(I))
              break;
            ge = T[0], I = I.substring(ge.length);
            let rt = T[2].split(`
`, 1)[0].replace(/^\t+/, (Jd) => " ".repeat(3 * Jd.length)), dt = I.split(`
`, 1)[0], Pt = !rt.trim(), Ot = 0;
            if (this.options.pedantic ? (Ot = 2, Me = rt.trimStart()) : Pt ? Ot = T[1].length + 1 : (Ot = T[2].search(/[^ ]/), Ot = Ot > 4 ? 1 : Ot, Me = rt.slice(Ot), Ot += T[1].length), Pt && /^ *$/.test(dt) && (ge += dt + `
`, I = I.substring(dt.length + 1), ce = !0), !ce) {
              const Jd = new RegExp(`^ {0,${Math.min(3, Ot - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), Ee = new RegExp(`^ {0,${Math.min(3, Ot - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), z = new RegExp(`^ {0,${Math.min(3, Ot - 1)}}(?:\`\`\`|~~~)`), le = new RegExp(`^ {0,${Math.min(3, Ot - 1)}}#`);
              for (; I; ) {
                const ve = I.split(`
`, 1)[0];
                if (dt = ve, this.options.pedantic && (dt = dt.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")), z.test(dt) || le.test(dt) || Jd.test(dt) || Ee.test(I))
                  break;
                if (dt.search(/[^ ]/) >= Ot || !dt.trim())
                  Me += `
` + dt.slice(Ot);
                else {
                  if (Pt || rt.search(/[^ ]/) >= 4 || z.test(rt) || le.test(rt) || Ee.test(rt))
                    break;
                  Me += `
` + dt;
                }
                !Pt && !dt.trim() && (Pt = !0), ge += ve + `
`, I = I.substring(ve.length + 1), rt = dt.slice(Ot);
              }
            }
            H.loose || (X ? H.loose = !0 : /\n *\n *$/.test(ge) && (X = !0));
            let Ln = null, rs;
            this.options.gfm && (Ln = /^\[[ xX]\] /.exec(Me), Ln && (rs = Ln[0] !== "[ ] ", Me = Me.replace(/^\[[ xX]\] +/, ""))), H.items.push({
              type: "list_item",
              raw: ge,
              task: !!Ln,
              checked: rs,
              loose: !1,
              text: Me,
              tokens: []
            }), H.raw += ge;
          }
          H.items[H.items.length - 1].raw = H.items[H.items.length - 1].raw.trimEnd(), H.items[H.items.length - 1].text = H.items[H.items.length - 1].text.trimEnd(), H.raw = H.raw.trimEnd();
          for (let ce = 0; ce < H.items.length; ce++)
            if (this.lexer.state.top = !1, H.items[ce].tokens = this.lexer.blockTokens(H.items[ce].text, []), !H.loose) {
              const ge = H.items[ce].tokens.filter((rt) => rt.type === "space"), Me = ge.length > 0 && ge.some((rt) => /\n.*\n/.test(rt.raw));
              H.loose = Me;
            }
          if (H.loose)
            for (let ce = 0; ce < H.items.length; ce++)
              H.items[ce].loose = !0;
          return H;
        }
      }
      html(I) {
        const T = this.rules.block.html.exec(I);
        if (T)
          return {
            type: "html",
            block: !0,
            raw: T[0],
            pre: T[1] === "pre" || T[1] === "script" || T[1] === "style",
            text: T[0]
          };
      }
      def(I) {
        const T = this.rules.block.def.exec(I);
        if (T) {
          const M = T[1].toLowerCase().replace(/\s+/g, " "), F = T[2] ? T[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", H = T[3] ? T[3].substring(1, T[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : T[3];
          return {
            type: "def",
            tag: M,
            raw: T[0],
            href: F,
            title: H
          };
        }
      }
      table(I) {
        const T = this.rules.block.table.exec(I);
        if (!T || !/[:|]/.test(T[2]))
          return;
        const M = m(T[1]), F = T[2].replace(/^\||\| *$/g, "").split("|"), H = T[3] && T[3].trim() ? T[3].replace(/\n[ \t]*$/, "").split(`
`) : [], j = {
          type: "table",
          raw: T[0],
          header: [],
          align: [],
          rows: []
        };
        if (M.length === F.length) {
          for (const X of F)
            /^ *-+: *$/.test(X) ? j.align.push("right") : /^ *:-+: *$/.test(X) ? j.align.push("center") : /^ *:-+ *$/.test(X) ? j.align.push("left") : j.align.push(null);
          for (let X = 0; X < M.length; X++)
            j.header.push({
              text: M[X],
              tokens: this.lexer.inline(M[X]),
              header: !0,
              align: j.align[X]
            });
          for (const X of H)
            j.rows.push(m(X, j.header.length).map((ce, ge) => ({
              text: ce,
              tokens: this.lexer.inline(ce),
              header: !1,
              align: j.align[ge]
            })));
          return j;
        }
      }
      lheading(I) {
        const T = this.rules.block.lheading.exec(I);
        if (T)
          return {
            type: "heading",
            raw: T[0],
            depth: T[2].charAt(0) === "=" ? 1 : 2,
            text: T[1],
            tokens: this.lexer.inline(T[1])
          };
      }
      paragraph(I) {
        const T = this.rules.block.paragraph.exec(I);
        if (T) {
          const M = T[1].charAt(T[1].length - 1) === `
` ? T[1].slice(0, -1) : T[1];
          return {
            type: "paragraph",
            raw: T[0],
            text: M,
            tokens: this.lexer.inline(M)
          };
        }
      }
      text(I) {
        const T = this.rules.block.text.exec(I);
        if (T)
          return {
            type: "text",
            raw: T[0],
            text: T[0],
            tokens: this.lexer.inline(T[0])
          };
      }
      escape(I) {
        const T = this.rules.inline.escape.exec(I);
        if (T)
          return {
            type: "escape",
            raw: T[0],
            text: h(T[1])
          };
      }
      tag(I) {
        const T = this.rules.inline.tag.exec(I);
        if (T)
          return !this.lexer.state.inLink && /^<a /i.test(T[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && /^<\/a>/i.test(T[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(T[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(T[0]) && (this.lexer.state.inRawBlock = !1), {
            type: "html",
            raw: T[0],
            inLink: this.lexer.state.inLink,
            inRawBlock: this.lexer.state.inRawBlock,
            block: !1,
            text: T[0]
          };
      }
      link(I) {
        const T = this.rules.inline.link.exec(I);
        if (T) {
          const M = T[2].trim();
          if (!this.options.pedantic && /^</.test(M)) {
            if (!/>$/.test(M))
              return;
            const j = _(M.slice(0, -1), "\\");
            if ((M.length - j.length) % 2 === 0)
              return;
          } else {
            const j = b(T[2], "()");
            if (j > -1) {
              const ce = (T[0].indexOf("!") === 0 ? 5 : 4) + T[1].length + j;
              T[2] = T[2].substring(0, j), T[0] = T[0].substring(0, ce).trim(), T[3] = "";
            }
          }
          let F = T[2], H = "";
          if (this.options.pedantic) {
            const j = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(F);
            j && (F = j[1], H = j[3]);
          } else
            H = T[3] ? T[3].slice(1, -1) : "";
          return F = F.trim(), /^</.test(F) && (this.options.pedantic && !/>$/.test(M) ? F = F.slice(1) : F = F.slice(1, -1)), C(T, {
            href: F && F.replace(this.rules.inline.anyPunctuation, "$1"),
            title: H && H.replace(this.rules.inline.anyPunctuation, "$1")
          }, T[0], this.lexer);
        }
      }
      reflink(I, T) {
        let M;
        if ((M = this.rules.inline.reflink.exec(I)) || (M = this.rules.inline.nolink.exec(I))) {
          const F = (M[2] || M[1]).replace(/\s+/g, " "), H = T[F.toLowerCase()];
          if (!H) {
            const j = M[0].charAt(0);
            return {
              type: "text",
              raw: j,
              text: j
            };
          }
          return C(M, H, M[0], this.lexer);
        }
      }
      emStrong(I, T, M = "") {
        let F = this.rules.inline.emStrongLDelim.exec(I);
        if (!F || F[3] && M.match(/[\p{L}\p{N}]/u))
          return;
        if (!(F[1] || F[2] || "") || !M || this.rules.inline.punctuation.exec(M)) {
          const j = [...F[0]].length - 1;
          let X, ce, ge = j, Me = 0;
          const rt = F[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
          for (rt.lastIndex = 0, T = T.slice(-1 * I.length + j); (F = rt.exec(T)) != null; ) {
            if (X = F[1] || F[2] || F[3] || F[4] || F[5] || F[6], !X)
              continue;
            if (ce = [...X].length, F[3] || F[4]) {
              ge += ce;
              continue;
            } else if ((F[5] || F[6]) && j % 3 && !((j + ce) % 3)) {
              Me += ce;
              continue;
            }
            if (ge -= ce, ge > 0)
              continue;
            ce = Math.min(ce, ce + ge + Me);
            const dt = [...F[0]][0].length, Pt = I.slice(0, j + F.index + dt + ce);
            if (Math.min(j, ce) % 2) {
              const Ln = Pt.slice(1, -1);
              return {
                type: "em",
                raw: Pt,
                text: Ln,
                tokens: this.lexer.inlineTokens(Ln)
              };
            }
            const Ot = Pt.slice(2, -2);
            return {
              type: "strong",
              raw: Pt,
              text: Ot,
              tokens: this.lexer.inlineTokens(Ot)
            };
          }
        }
      }
      codespan(I) {
        const T = this.rules.inline.code.exec(I);
        if (T) {
          let M = T[2].replace(/\n/g, " ");
          const F = /[^ ]/.test(M), H = /^ /.test(M) && / $/.test(M);
          return F && H && (M = M.substring(1, M.length - 1)), M = h(M, !0), {
            type: "codespan",
            raw: T[0],
            text: M
          };
        }
      }
      br(I) {
        const T = this.rules.inline.br.exec(I);
        if (T)
          return {
            type: "br",
            raw: T[0]
          };
      }
      del(I) {
        const T = this.rules.inline.del.exec(I);
        if (T)
          return {
            type: "del",
            raw: T[0],
            text: T[2],
            tokens: this.lexer.inlineTokens(T[2])
          };
      }
      autolink(I) {
        const T = this.rules.inline.autolink.exec(I);
        if (T) {
          let M, F;
          return T[2] === "@" ? (M = h(T[1]), F = "mailto:" + M) : (M = h(T[1]), F = M), {
            type: "link",
            raw: T[0],
            text: M,
            href: F,
            tokens: [
              {
                type: "text",
                raw: M,
                text: M
              }
            ]
          };
        }
      }
      url(I) {
        var M;
        let T;
        if (T = this.rules.inline.url.exec(I)) {
          let F, H;
          if (T[2] === "@")
            F = h(T[0]), H = "mailto:" + F;
          else {
            let j;
            do
              j = T[0], T[0] = ((M = this.rules.inline._backpedal.exec(T[0])) == null ? void 0 : M[0]) ?? "";
            while (j !== T[0]);
            F = h(T[0]), T[1] === "www." ? H = "http://" + T[0] : H = T[0];
          }
          return {
            type: "link",
            raw: T[0],
            text: F,
            href: H,
            tokens: [
              {
                type: "text",
                raw: F,
                text: F
              }
            ]
          };
        }
      }
      inlineText(I) {
        const T = this.rules.inline.text.exec(I);
        if (T) {
          let M;
          return this.lexer.state.inRawBlock ? M = T[0] : M = h(T[0]), {
            type: "text",
            raw: T[0],
            text: M
          };
        }
      }
    }
    const S = /^(?: *(?:\n|$))+/, L = /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/, k = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/, D = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, E = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, U = /(?:[*+-]|\d{1,9}[.)])/, P = u(/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html))+?)\n {0,3}(=+|-+) *(?:\n+|$)/).replace(/bull/g, U).replace(/blockCode/g, / {4}/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).getRegex(), B = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, W = /^[^\n]+/, A = /(?!\s*\])(?:\\.|[^\[\]\\])+/, K = u(/^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/).replace("label", A).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(), Y = u(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, U).getRegex(), Q = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", ne = /<!--(?:-?>|[\s\S]*?(?:-->|$))/, ie = u("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))", "i").replace("comment", ne).replace("tag", Q).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), me = u(B).replace("hr", D).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Q).getRegex(), vt = {
      blockquote: u(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", me).getRegex(),
      code: L,
      def: K,
      fences: k,
      heading: E,
      hr: D,
      html: ie,
      lheading: P,
      list: Y,
      newline: S,
      paragraph: me,
      table: g,
      text: W
    }, be = u("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", D).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Q).getRegex(), Ze = {
      ...vt,
      table: be,
      paragraph: u(B).replace("hr", D).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", be).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Q).getRegex()
    }, De = {
      ...vt,
      html: u(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", ne).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
      def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
      heading: /^(#{1,6})(.*)(?:\n+|$)/,
      fences: g,
      // fences not supported
      lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
      paragraph: u(B).replace("hr", D).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", P).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
    }, mt = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, Je = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, xt = /^( {2,}|\\)\n(?!\s*$)/, mi = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, pi = "\\p{P}\\p{S}", ws = u(/^((?![*_])[\spunctuation])/, "u").replace(/punctuation/g, pi).getRegex(), Xt = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g, vs = u(/^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/, "u").replace(/punct/g, pi).getRegex(), Jo = u("^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)[punct](\\*+)(?=[\\s]|$)|[^punct\\s](\\*+)(?!\\*)(?=[punct\\s]|$)|(?!\\*)[punct\\s](\\*+)(?=[^punct\\s])|[\\s](\\*+)(?!\\*)(?=[punct])|(?!\\*)[punct](\\*+)(?!\\*)(?=[punct])|[^punct\\s](\\*+)(?=[^punct\\s])", "gu").replace(/punct/g, pi).getRegex(), Yd = u("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\\s]|$)|[^punct\\s](_+)(?!_)(?=[punct\\s]|$)|(?!_)[punct\\s](_+)(?=[^punct\\s])|[\\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])", "gu").replace(/punct/g, pi).getRegex(), Qd = u(/\\([punct])/, "gu").replace(/punct/g, pi).getRegex(), sa = u(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(), Uc = u(ne).replace("(?:-->|$)", "-->").getRegex(), $c = u("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", Uc).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(), il = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/, qg = u(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/).replace("label", il).replace("href", /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(), jg = u(/^!?\[(label)\]\[(ref)\]/).replace("label", il).replace("ref", A).getRegex(), Kc = u(/^!?\[(ref)\](?:\[\])?/).replace("ref", A).getRegex(), nl = u("reflink|nolink(?!\\()", "g").replace("reflink", jg).replace("nolink", Kc).getRegex(), _o = {
      _backpedal: g,
      // only used for GFM url
      anyPunctuation: Qd,
      autolink: sa,
      blockSkip: Xt,
      br: xt,
      code: Je,
      del: g,
      emStrongLDelim: vs,
      emStrongRDelimAst: Jo,
      emStrongRDelimUnd: Yd,
      escape: mt,
      link: qg,
      nolink: Kc,
      punctuation: ws,
      reflink: jg,
      reflinkSearch: nl,
      tag: $c,
      text: mi,
      url: g
    }, oa = {
      ..._o,
      link: u(/^!?\[(label)\]\((.*?)\)/).replace("label", il).getRegex(),
      reflink: u(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", il).getRegex()
    }, qc = {
      ..._o,
      escape: u(mt).replace("])", "~|])").getRegex(),
      url: u(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),
      _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
      del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
      text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
    }, Gg = {
      ...qc,
      br: u(xt).replace("{2,}", "*").getRegex(),
      text: u(qc.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
    }, sl = {
      normal: vt,
      gfm: Ze,
      pedantic: De
    }, er = {
      normal: _o,
      gfm: qc,
      breaks: Gg,
      pedantic: oa
    };
    class zn {
      constructor(I) {
        Zt(this, "tokens");
        Zt(this, "options");
        Zt(this, "state");
        Zt(this, "tokenizer");
        Zt(this, "inlineQueue");
        this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = I || e.defaults, this.options.tokenizer = this.options.tokenizer || new w(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = {
          inLink: !1,
          inRawBlock: !1,
          top: !0
        };
        const T = {
          block: sl.normal,
          inline: er.normal
        };
        this.options.pedantic ? (T.block = sl.pedantic, T.inline = er.pedantic) : this.options.gfm && (T.block = sl.gfm, this.options.breaks ? T.inline = er.breaks : T.inline = er.gfm), this.tokenizer.rules = T;
      }
      /**
       * Expose Rules
       */
      static get rules() {
        return {
          block: sl,
          inline: er
        };
      }
      /**
       * Static Lex Method
       */
      static lex(I, T) {
        return new zn(T).lex(I);
      }
      /**
       * Static Lex Inline Method
       */
      static lexInline(I, T) {
        return new zn(T).inlineTokens(I);
      }
      /**
       * Preprocessing
       */
      lex(I) {
        I = I.replace(/\r\n|\r/g, `
`), this.blockTokens(I, this.tokens);
        for (let T = 0; T < this.inlineQueue.length; T++) {
          const M = this.inlineQueue[T];
          this.inlineTokens(M.src, M.tokens);
        }
        return this.inlineQueue = [], this.tokens;
      }
      blockTokens(I, T = [], M = !1) {
        this.options.pedantic ? I = I.replace(/\t/g, "    ").replace(/^ +$/gm, "") : I = I.replace(/^( *)(\t+)/gm, (X, ce, ge) => ce + "    ".repeat(ge.length));
        let F, H, j;
        for (; I; )
          if (!(this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((X) => (F = X.call({ lexer: this }, I, T)) ? (I = I.substring(F.raw.length), T.push(F), !0) : !1))) {
            if (F = this.tokenizer.space(I)) {
              I = I.substring(F.raw.length), F.raw.length === 1 && T.length > 0 ? T[T.length - 1].raw += `
` : T.push(F);
              continue;
            }
            if (F = this.tokenizer.code(I)) {
              I = I.substring(F.raw.length), H = T[T.length - 1], H && (H.type === "paragraph" || H.type === "text") ? (H.raw += `
` + F.raw, H.text += `
` + F.text, this.inlineQueue[this.inlineQueue.length - 1].src = H.text) : T.push(F);
              continue;
            }
            if (F = this.tokenizer.fences(I)) {
              I = I.substring(F.raw.length), T.push(F);
              continue;
            }
            if (F = this.tokenizer.heading(I)) {
              I = I.substring(F.raw.length), T.push(F);
              continue;
            }
            if (F = this.tokenizer.hr(I)) {
              I = I.substring(F.raw.length), T.push(F);
              continue;
            }
            if (F = this.tokenizer.blockquote(I)) {
              I = I.substring(F.raw.length), T.push(F);
              continue;
            }
            if (F = this.tokenizer.list(I)) {
              I = I.substring(F.raw.length), T.push(F);
              continue;
            }
            if (F = this.tokenizer.html(I)) {
              I = I.substring(F.raw.length), T.push(F);
              continue;
            }
            if (F = this.tokenizer.def(I)) {
              I = I.substring(F.raw.length), H = T[T.length - 1], H && (H.type === "paragraph" || H.type === "text") ? (H.raw += `
` + F.raw, H.text += `
` + F.raw, this.inlineQueue[this.inlineQueue.length - 1].src = H.text) : this.tokens.links[F.tag] || (this.tokens.links[F.tag] = {
                href: F.href,
                title: F.title
              });
              continue;
            }
            if (F = this.tokenizer.table(I)) {
              I = I.substring(F.raw.length), T.push(F);
              continue;
            }
            if (F = this.tokenizer.lheading(I)) {
              I = I.substring(F.raw.length), T.push(F);
              continue;
            }
            if (j = I, this.options.extensions && this.options.extensions.startBlock) {
              let X = 1 / 0;
              const ce = I.slice(1);
              let ge;
              this.options.extensions.startBlock.forEach((Me) => {
                ge = Me.call({ lexer: this }, ce), typeof ge == "number" && ge >= 0 && (X = Math.min(X, ge));
              }), X < 1 / 0 && X >= 0 && (j = I.substring(0, X + 1));
            }
            if (this.state.top && (F = this.tokenizer.paragraph(j))) {
              H = T[T.length - 1], M && (H == null ? void 0 : H.type) === "paragraph" ? (H.raw += `
` + F.raw, H.text += `
` + F.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = H.text) : T.push(F), M = j.length !== I.length, I = I.substring(F.raw.length);
              continue;
            }
            if (F = this.tokenizer.text(I)) {
              I = I.substring(F.raw.length), H = T[T.length - 1], H && H.type === "text" ? (H.raw += `
` + F.raw, H.text += `
` + F.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = H.text) : T.push(F);
              continue;
            }
            if (I) {
              const X = "Infinite loop on byte: " + I.charCodeAt(0);
              if (this.options.silent) {
                console.error(X);
                break;
              } else
                throw new Error(X);
            }
          }
        return this.state.top = !0, T;
      }
      inline(I, T = []) {
        return this.inlineQueue.push({ src: I, tokens: T }), T;
      }
      /**
       * Lexing/Compiling
       */
      inlineTokens(I, T = []) {
        let M, F, H, j = I, X, ce, ge;
        if (this.tokens.links) {
          const Me = Object.keys(this.tokens.links);
          if (Me.length > 0)
            for (; (X = this.tokenizer.rules.inline.reflinkSearch.exec(j)) != null; )
              Me.includes(X[0].slice(X[0].lastIndexOf("[") + 1, -1)) && (j = j.slice(0, X.index) + "[" + "a".repeat(X[0].length - 2) + "]" + j.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
        }
        for (; (X = this.tokenizer.rules.inline.blockSkip.exec(j)) != null; )
          j = j.slice(0, X.index) + "[" + "a".repeat(X[0].length - 2) + "]" + j.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
        for (; (X = this.tokenizer.rules.inline.anyPunctuation.exec(j)) != null; )
          j = j.slice(0, X.index) + "++" + j.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
        for (; I; )
          if (ce || (ge = ""), ce = !1, !(this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((Me) => (M = Me.call({ lexer: this }, I, T)) ? (I = I.substring(M.raw.length), T.push(M), !0) : !1))) {
            if (M = this.tokenizer.escape(I)) {
              I = I.substring(M.raw.length), T.push(M);
              continue;
            }
            if (M = this.tokenizer.tag(I)) {
              I = I.substring(M.raw.length), F = T[T.length - 1], F && M.type === "text" && F.type === "text" ? (F.raw += M.raw, F.text += M.text) : T.push(M);
              continue;
            }
            if (M = this.tokenizer.link(I)) {
              I = I.substring(M.raw.length), T.push(M);
              continue;
            }
            if (M = this.tokenizer.reflink(I, this.tokens.links)) {
              I = I.substring(M.raw.length), F = T[T.length - 1], F && M.type === "text" && F.type === "text" ? (F.raw += M.raw, F.text += M.text) : T.push(M);
              continue;
            }
            if (M = this.tokenizer.emStrong(I, j, ge)) {
              I = I.substring(M.raw.length), T.push(M);
              continue;
            }
            if (M = this.tokenizer.codespan(I)) {
              I = I.substring(M.raw.length), T.push(M);
              continue;
            }
            if (M = this.tokenizer.br(I)) {
              I = I.substring(M.raw.length), T.push(M);
              continue;
            }
            if (M = this.tokenizer.del(I)) {
              I = I.substring(M.raw.length), T.push(M);
              continue;
            }
            if (M = this.tokenizer.autolink(I)) {
              I = I.substring(M.raw.length), T.push(M);
              continue;
            }
            if (!this.state.inLink && (M = this.tokenizer.url(I))) {
              I = I.substring(M.raw.length), T.push(M);
              continue;
            }
            if (H = I, this.options.extensions && this.options.extensions.startInline) {
              let Me = 1 / 0;
              const rt = I.slice(1);
              let dt;
              this.options.extensions.startInline.forEach((Pt) => {
                dt = Pt.call({ lexer: this }, rt), typeof dt == "number" && dt >= 0 && (Me = Math.min(Me, dt));
              }), Me < 1 / 0 && Me >= 0 && (H = I.substring(0, Me + 1));
            }
            if (M = this.tokenizer.inlineText(H)) {
              I = I.substring(M.raw.length), M.raw.slice(-1) !== "_" && (ge = M.raw.slice(-1)), ce = !0, F = T[T.length - 1], F && F.type === "text" ? (F.raw += M.raw, F.text += M.text) : T.push(M);
              continue;
            }
            if (I) {
              const Me = "Infinite loop on byte: " + I.charCodeAt(0);
              if (this.options.silent) {
                console.error(Me);
                break;
              } else
                throw new Error(Me);
            }
          }
        return T;
      }
    }
    class bo {
      // set by the parser
      constructor(I) {
        Zt(this, "options");
        Zt(this, "parser");
        this.options = I || e.defaults;
      }
      space(I) {
        return "";
      }
      code({ text: I, lang: T, escaped: M }) {
        var j;
        const F = (j = (T || "").match(/^\S*/)) == null ? void 0 : j[0], H = I.replace(/\n$/, "") + `
`;
        return F ? '<pre><code class="language-' + h(F) + '">' + (M ? H : h(H, !0)) + `</code></pre>
` : "<pre><code>" + (M ? H : h(H, !0)) + `</code></pre>
`;
      }
      blockquote({ tokens: I }) {
        return `<blockquote>
${this.parser.parse(I)}</blockquote>
`;
      }
      html({ text: I }) {
        return I;
      }
      heading({ tokens: I, depth: T }) {
        return `<h${T}>${this.parser.parseInline(I)}</h${T}>
`;
      }
      hr(I) {
        return `<hr>
`;
      }
      list(I) {
        const T = I.ordered, M = I.start;
        let F = "";
        for (let X = 0; X < I.items.length; X++) {
          const ce = I.items[X];
          F += this.listitem(ce);
        }
        const H = T ? "ol" : "ul", j = T && M !== 1 ? ' start="' + M + '"' : "";
        return "<" + H + j + `>
` + F + "</" + H + `>
`;
      }
      listitem(I) {
        let T = "";
        if (I.task) {
          const M = this.checkbox({ checked: !!I.checked });
          I.loose ? I.tokens.length > 0 && I.tokens[0].type === "paragraph" ? (I.tokens[0].text = M + " " + I.tokens[0].text, I.tokens[0].tokens && I.tokens[0].tokens.length > 0 && I.tokens[0].tokens[0].type === "text" && (I.tokens[0].tokens[0].text = M + " " + I.tokens[0].tokens[0].text)) : I.tokens.unshift({
            type: "text",
            raw: M + " ",
            text: M + " "
          }) : T += M + " ";
        }
        return T += this.parser.parse(I.tokens, !!I.loose), `<li>${T}</li>
`;
      }
      checkbox({ checked: I }) {
        return "<input " + (I ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
      }
      paragraph({ tokens: I }) {
        return `<p>${this.parser.parseInline(I)}</p>
`;
      }
      table(I) {
        let T = "", M = "";
        for (let H = 0; H < I.header.length; H++)
          M += this.tablecell(I.header[H]);
        T += this.tablerow({ text: M });
        let F = "";
        for (let H = 0; H < I.rows.length; H++) {
          const j = I.rows[H];
          M = "";
          for (let X = 0; X < j.length; X++)
            M += this.tablecell(j[X]);
          F += this.tablerow({ text: M });
        }
        return F && (F = `<tbody>${F}</tbody>`), `<table>
<thead>
` + T + `</thead>
` + F + `</table>
`;
      }
      tablerow({ text: I }) {
        return `<tr>
${I}</tr>
`;
      }
      tablecell(I) {
        const T = this.parser.parseInline(I.tokens), M = I.header ? "th" : "td";
        return (I.align ? `<${M} align="${I.align}">` : `<${M}>`) + T + `</${M}>
`;
      }
      /**
       * span level renderer
       */
      strong({ tokens: I }) {
        return `<strong>${this.parser.parseInline(I)}</strong>`;
      }
      em({ tokens: I }) {
        return `<em>${this.parser.parseInline(I)}</em>`;
      }
      codespan({ text: I }) {
        return `<code>${I}</code>`;
      }
      br(I) {
        return "<br>";
      }
      del({ tokens: I }) {
        return `<del>${this.parser.parseInline(I)}</del>`;
      }
      link({ href: I, title: T, tokens: M }) {
        const F = this.parser.parseInline(M), H = f(I);
        if (H === null)
          return F;
        I = H;
        let j = '<a href="' + I + '"';
        return T && (j += ' title="' + T + '"'), j += ">" + F + "</a>", j;
      }
      image({ href: I, title: T, text: M }) {
        const F = f(I);
        if (F === null)
          return M;
        I = F;
        let H = `<img src="${I}" alt="${M}"`;
        return T && (H += ` title="${T}"`), H += ">", H;
      }
      text(I) {
        return "tokens" in I && I.tokens ? this.parser.parseInline(I.tokens) : I.text;
      }
    }
    class tr {
      // no need for block level renderers
      strong({ text: I }) {
        return I;
      }
      em({ text: I }) {
        return I;
      }
      codespan({ text: I }) {
        return I;
      }
      del({ text: I }) {
        return I;
      }
      html({ text: I }) {
        return I;
      }
      text({ text: I }) {
        return I;
      }
      link({ text: I }) {
        return "" + I;
      }
      image({ text: I }) {
        return "" + I;
      }
      br() {
        return "";
      }
    }
    class _i {
      constructor(I) {
        Zt(this, "options");
        Zt(this, "renderer");
        Zt(this, "textRenderer");
        this.options = I || e.defaults, this.options.renderer = this.options.renderer || new bo(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.renderer.parser = this, this.textRenderer = new tr();
      }
      /**
       * Static Parse Method
       */
      static parse(I, T) {
        return new _i(T).parse(I);
      }
      /**
       * Static Parse Inline Method
       */
      static parseInline(I, T) {
        return new _i(T).parseInline(I);
      }
      /**
       * Parse Loop
       */
      parse(I, T = !0) {
        let M = "";
        for (let F = 0; F < I.length; F++) {
          const H = I[F];
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[H.type]) {
            const X = H, ce = this.options.extensions.renderers[X.type].call({ parser: this }, X);
            if (ce !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(X.type)) {
              M += ce || "";
              continue;
            }
          }
          const j = H;
          switch (j.type) {
            case "space": {
              M += this.renderer.space(j);
              continue;
            }
            case "hr": {
              M += this.renderer.hr(j);
              continue;
            }
            case "heading": {
              M += this.renderer.heading(j);
              continue;
            }
            case "code": {
              M += this.renderer.code(j);
              continue;
            }
            case "table": {
              M += this.renderer.table(j);
              continue;
            }
            case "blockquote": {
              M += this.renderer.blockquote(j);
              continue;
            }
            case "list": {
              M += this.renderer.list(j);
              continue;
            }
            case "html": {
              M += this.renderer.html(j);
              continue;
            }
            case "paragraph": {
              M += this.renderer.paragraph(j);
              continue;
            }
            case "text": {
              let X = j, ce = this.renderer.text(X);
              for (; F + 1 < I.length && I[F + 1].type === "text"; )
                X = I[++F], ce += `
` + this.renderer.text(X);
              T ? M += this.renderer.paragraph({
                type: "paragraph",
                raw: ce,
                text: ce,
                tokens: [{ type: "text", raw: ce, text: ce }]
              }) : M += ce;
              continue;
            }
            default: {
              const X = 'Token with "' + j.type + '" type was not found.';
              if (this.options.silent)
                return console.error(X), "";
              throw new Error(X);
            }
          }
        }
        return M;
      }
      /**
       * Parse Inline Tokens
       */
      parseInline(I, T) {
        T = T || this.renderer;
        let M = "";
        for (let F = 0; F < I.length; F++) {
          const H = I[F];
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[H.type]) {
            const X = this.options.extensions.renderers[H.type].call({ parser: this }, H);
            if (X !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(H.type)) {
              M += X || "";
              continue;
            }
          }
          const j = H;
          switch (j.type) {
            case "escape": {
              M += T.text(j);
              break;
            }
            case "html": {
              M += T.html(j);
              break;
            }
            case "link": {
              M += T.link(j);
              break;
            }
            case "image": {
              M += T.image(j);
              break;
            }
            case "strong": {
              M += T.strong(j);
              break;
            }
            case "em": {
              M += T.em(j);
              break;
            }
            case "codespan": {
              M += T.codespan(j);
              break;
            }
            case "br": {
              M += T.br(j);
              break;
            }
            case "del": {
              M += T.del(j);
              break;
            }
            case "text": {
              M += T.text(j);
              break;
            }
            default: {
              const X = 'Token with "' + j.type + '" type was not found.';
              if (this.options.silent)
                return console.error(X), "";
              throw new Error(X);
            }
          }
        }
        return M;
      }
    }
    class os {
      constructor(I) {
        Zt(this, "options");
        this.options = I || e.defaults;
      }
      /**
       * Process markdown before marked
       */
      preprocess(I) {
        return I;
      }
      /**
       * Process HTML after marked is finished
       */
      postprocess(I) {
        return I;
      }
      /**
       * Process all tokens before walk tokens
       */
      processAllTokens(I) {
        return I;
      }
    }
    Zt(os, "passThroughHooks", /* @__PURE__ */ new Set([
      "preprocess",
      "postprocess",
      "processAllTokens"
    ]));
    class jc {
      constructor(...I) {
        Zt(this, "defaults", t());
        Zt(this, "options", this.setOptions);
        Zt(this, "parse", this.parseMarkdown(zn.lex, _i.parse));
        Zt(this, "parseInline", this.parseMarkdown(zn.lexInline, _i.parseInline));
        Zt(this, "Parser", _i);
        Zt(this, "Renderer", bo);
        Zt(this, "TextRenderer", tr);
        Zt(this, "Lexer", zn);
        Zt(this, "Tokenizer", w);
        Zt(this, "Hooks", os);
        this.use(...I);
      }
      /**
       * Run callback for every token
       */
      walkTokens(I, T) {
        var F, H;
        let M = [];
        for (const j of I)
          switch (M = M.concat(T.call(this, j)), j.type) {
            case "table": {
              const X = j;
              for (const ce of X.header)
                M = M.concat(this.walkTokens(ce.tokens, T));
              for (const ce of X.rows)
                for (const ge of ce)
                  M = M.concat(this.walkTokens(ge.tokens, T));
              break;
            }
            case "list": {
              const X = j;
              M = M.concat(this.walkTokens(X.items, T));
              break;
            }
            default: {
              const X = j;
              (H = (F = this.defaults.extensions) == null ? void 0 : F.childTokens) != null && H[X.type] ? this.defaults.extensions.childTokens[X.type].forEach((ce) => {
                const ge = X[ce].flat(1 / 0);
                M = M.concat(this.walkTokens(ge, T));
              }) : X.tokens && (M = M.concat(this.walkTokens(X.tokens, T)));
            }
          }
        return M;
      }
      use(...I) {
        const T = this.defaults.extensions || { renderers: {}, childTokens: {} };
        return I.forEach((M) => {
          const F = { ...M };
          if (F.async = this.defaults.async || F.async || !1, M.extensions && (M.extensions.forEach((H) => {
            if (!H.name)
              throw new Error("extension name required");
            if ("renderer" in H) {
              const j = T.renderers[H.name];
              j ? T.renderers[H.name] = function(...X) {
                let ce = H.renderer.apply(this, X);
                return ce === !1 && (ce = j.apply(this, X)), ce;
              } : T.renderers[H.name] = H.renderer;
            }
            if ("tokenizer" in H) {
              if (!H.level || H.level !== "block" && H.level !== "inline")
                throw new Error("extension level must be 'block' or 'inline'");
              const j = T[H.level];
              j ? j.unshift(H.tokenizer) : T[H.level] = [H.tokenizer], H.start && (H.level === "block" ? T.startBlock ? T.startBlock.push(H.start) : T.startBlock = [H.start] : H.level === "inline" && (T.startInline ? T.startInline.push(H.start) : T.startInline = [H.start]));
            }
            "childTokens" in H && H.childTokens && (T.childTokens[H.name] = H.childTokens);
          }), F.extensions = T), M.renderer) {
            const H = this.defaults.renderer || new bo(this.defaults);
            for (const j in M.renderer) {
              if (!(j in H))
                throw new Error(`renderer '${j}' does not exist`);
              if (["options", "parser"].includes(j))
                continue;
              const X = j, ce = M.renderer[X], ge = H[X];
              H[X] = (...Me) => {
                let rt = ce.apply(H, Me);
                return rt === !1 && (rt = ge.apply(H, Me)), rt || "";
              };
            }
            F.renderer = H;
          }
          if (M.tokenizer) {
            const H = this.defaults.tokenizer || new w(this.defaults);
            for (const j in M.tokenizer) {
              if (!(j in H))
                throw new Error(`tokenizer '${j}' does not exist`);
              if (["options", "rules", "lexer"].includes(j))
                continue;
              const X = j, ce = M.tokenizer[X], ge = H[X];
              H[X] = (...Me) => {
                let rt = ce.apply(H, Me);
                return rt === !1 && (rt = ge.apply(H, Me)), rt;
              };
            }
            F.tokenizer = H;
          }
          if (M.hooks) {
            const H = this.defaults.hooks || new os();
            for (const j in M.hooks) {
              if (!(j in H))
                throw new Error(`hook '${j}' does not exist`);
              if (j === "options")
                continue;
              const X = j, ce = M.hooks[X], ge = H[X];
              os.passThroughHooks.has(j) ? H[X] = (Me) => {
                if (this.defaults.async)
                  return Promise.resolve(ce.call(H, Me)).then((dt) => ge.call(H, dt));
                const rt = ce.call(H, Me);
                return ge.call(H, rt);
              } : H[X] = (...Me) => {
                let rt = ce.apply(H, Me);
                return rt === !1 && (rt = ge.apply(H, Me)), rt;
              };
            }
            F.hooks = H;
          }
          if (M.walkTokens) {
            const H = this.defaults.walkTokens, j = M.walkTokens;
            F.walkTokens = function(X) {
              let ce = [];
              return ce.push(j.call(this, X)), H && (ce = ce.concat(H.call(this, X))), ce;
            };
          }
          this.defaults = { ...this.defaults, ...F };
        }), this;
      }
      setOptions(I) {
        return this.defaults = { ...this.defaults, ...I }, this;
      }
      lexer(I, T) {
        return zn.lex(I, T ?? this.defaults);
      }
      parser(I, T) {
        return _i.parse(I, T ?? this.defaults);
      }
      parseMarkdown(I, T) {
        return (F, H) => {
          const j = { ...H }, X = { ...this.defaults, ...j }, ce = this.onError(!!X.silent, !!X.async);
          if (this.defaults.async === !0 && j.async === !1)
            return ce(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
          if (typeof F > "u" || F === null)
            return ce(new Error("marked(): input parameter is undefined or null"));
          if (typeof F != "string")
            return ce(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(F) + ", string expected"));
          if (X.hooks && (X.hooks.options = X), X.async)
            return Promise.resolve(X.hooks ? X.hooks.preprocess(F) : F).then((ge) => I(ge, X)).then((ge) => X.hooks ? X.hooks.processAllTokens(ge) : ge).then((ge) => X.walkTokens ? Promise.all(this.walkTokens(ge, X.walkTokens)).then(() => ge) : ge).then((ge) => T(ge, X)).then((ge) => X.hooks ? X.hooks.postprocess(ge) : ge).catch(ce);
          try {
            X.hooks && (F = X.hooks.preprocess(F));
            let ge = I(F, X);
            X.hooks && (ge = X.hooks.processAllTokens(ge)), X.walkTokens && this.walkTokens(ge, X.walkTokens);
            let Me = T(ge, X);
            return X.hooks && (Me = X.hooks.postprocess(Me)), Me;
          } catch (ge) {
            return ce(ge);
          }
        };
      }
      onError(I, T) {
        return (M) => {
          if (M.message += `
Please report this to https://github.com/markedjs/marked.`, I) {
            const F = "<p>An error occurred:</p><pre>" + h(M.message + "", !0) + "</pre>";
            return T ? Promise.resolve(F) : F;
          }
          if (T)
            return Promise.reject(M);
          throw M;
        };
      }
    }
    const Hs = new jc();
    function Et(Oe, I) {
      return Hs.parse(Oe, I);
    }
    Et.options = Et.setOptions = function(Oe) {
      return Hs.setOptions(Oe), Et.defaults = Hs.defaults, i(Et.defaults), Et;
    }, Et.getDefaults = t, Et.defaults = e.defaults, Et.use = function(...Oe) {
      return Hs.use(...Oe), Et.defaults = Hs.defaults, i(Et.defaults), Et;
    }, Et.walkTokens = function(Oe, I) {
      return Hs.walkTokens(Oe, I);
    }, Et.parseInline = Hs.parseInline, Et.Parser = _i, Et.parser = _i.parse, Et.Renderer = bo, Et.TextRenderer = tr, Et.Lexer = zn, Et.lexer = zn.lex, Et.Tokenizer = w, Et.Hooks = os, Et.parse = Et;
    const ol = Et.options, t0 = Et.setOptions, i0 = Et.use, ki = Et.walkTokens, ra = Et.parseInline, n0 = Et, Zg = _i.parse, Xd = zn.lex;
    e.Hooks = os, e.Lexer = zn, e.Marked = jc, e.Parser = _i, e.Renderer = bo, e.TextRenderer = tr, e.Tokenizer = w, e.getDefaults = t, e.lexer = Xd, e.marked = Et, e.options = ol, e.parse = n0, e.parseInline = ra, e.parser = Zg, e.setOptions = t0, e.use = i0, e.walkTokens = ki;
  }));
})();
Wi.Hooks || exports.Hooks;
Wi.Lexer || exports.Lexer;
Wi.Marked || exports.Marked;
Wi.Parser || exports.Parser;
var rA = Wi.Renderer || exports.Renderer;
Wi.TextRenderer || exports.TextRenderer;
Wi.Tokenizer || exports.Tokenizer;
var TW = Wi.defaults || exports.defaults;
Wi.getDefaults || exports.getDefaults;
var Eb = Wi.lexer || exports.lexer;
Wi.marked || exports.marked;
Wi.options || exports.options;
var aA = Wi.parse || exports.parse;
Wi.parseInline || exports.parseInline;
var MW = Wi.parser || exports.parser;
Wi.setOptions || exports.setOptions;
Wi.use || exports.use;
Wi.walkTokens || exports.walkTokens;
function RW(s) {
  return JSON.stringify(s, AW);
}
function $v(s) {
  let e = JSON.parse(s);
  return e = Kv(e), e;
}
function AW(s, e) {
  return e instanceof RegExp ? {
    $mid: 2,
    source: e.source,
    flags: e.flags
  } : e;
}
function Kv(s, e = 0) {
  if (!s || e > 200)
    return s;
  if (typeof s == "object") {
    switch (s.$mid) {
      case 1:
        return Te.revive(s);
      case 2:
        return new RegExp(s.source, s.flags);
      case 17:
        return new Date(s.source);
    }
    if (s instanceof QL || s instanceof Uint8Array)
      return s;
    if (Array.isArray(s))
      for (let t = 0; t < s.length; ++t)
        s[t] = Kv(s[t], e + 1);
    else
      for (const t in s)
        Object.hasOwnProperty.call(s, t) && (s[t] = Kv(s[t], e + 1));
  }
  return s;
}
const U0 = Object.freeze({
  image: ({ href: s, title: e, text: t }) => {
    let i = [], n = [];
    return s && ({ href: s, dimensions: i } = NW(s), n.push(`src="${pm(s)}"`)), t && n.push(`alt="${pm(t)}"`), e && n.push(`title="${pm(e)}"`), i.length && (n = n.concat(i)), "<img " + n.join(" ") + ">";
  },
  paragraph({ tokens: s }) {
    return `<p>${this.parser.parseInline(s)}</p>`;
  },
  link({ href: s, title: e, tokens: t }) {
    let i = this.parser.parseInline(t);
    return typeof s != "string" ? "" : (s === i && (i = z0(i)), e = typeof e == "string" ? pm(z0(e)) : "", s = z0(s), s = s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;"), `<a href="${s}" title="${e || s}" draggable="false">${i}</a>`);
  }
});
function vk(s, e = {}, t = {}) {
  const i = new he();
  let n = !1;
  const o = mk(e), r = function(m) {
    let _;
    try {
      _ = $v(decodeURIComponent(m));
    } catch {
    }
    return _ ? (_ = y2(_, (b) => {
      if (s.uris && s.uris[b])
        return Te.revive(s.uris[b]);
    }), encodeURIComponent(JSON.stringify(_))) : m;
  }, a = function(m, _) {
    const b = s.uris && s.uris[m];
    let C = Te.revive(b);
    return _ ? m.startsWith(Ne.data + ":") ? m : (C || (C = Te.parse(m)), sb.uriToBrowserUri(C).toString(!0)) : !C || Te.parse(m).toString() === C.toString() ? m : (C.query && (C = C.with({ query: r(C.query) })), C.toString());
  }, l = new rA();
  l.image = U0.image, l.link = U0.link, l.paragraph = U0.paragraph;
  const c = [], h = [];
  if (e.codeBlockRendererSync ? l.code = ({ text: m, lang: _ }) => {
    const b = gI.nextId(), C = e.codeBlockRendererSync(mI(_), m);
    return h.push([b, C]), `<div class="code" data-code="${b}">${Fu(m)}</div>`;
  } : e.codeBlockRenderer && (l.code = ({ text: m, lang: _ }) => {
    const b = gI.nextId(), C = e.codeBlockRenderer(mI(_), m);
    return c.push(C.then((v) => [b, v])), `<div class="code" data-code="${b}">${Fu(m)}</div>`;
  }), e.actionHandler) {
    const m = function(C) {
      let v = C.target;
      if (!(v.tagName !== "A" && (v = v.parentElement, !v || v.tagName !== "A")))
        try {
          let w = v.dataset.href;
          w && (s.baseUri && (w = $0(Te.from(s.baseUri), w)), e.actionHandler.callback(w, C));
        } catch (w) {
          ht(w);
        } finally {
          C.preventDefault();
        }
    }, _ = e.actionHandler.disposables.add(new Re(o, "click")), b = e.actionHandler.disposables.add(new Re(o, "auxclick"));
    e.actionHandler.disposables.add(J.any(_.event, b.event)((C) => {
      const v = new to(ue(o), C);
      !v.leftButton && !v.middleButton || m(v);
    })), e.actionHandler.disposables.add($(o, "keydown", (C) => {
      const v = new Lt(C);
      !v.equals(
        10
        /* KeyCode.Space */
      ) && !v.equals(
        3
        /* KeyCode.Enter */
      ) || m(v);
    }));
  }
  s.supportHtml || (l.html = ({ text: m }) => {
    var b;
    return (b = e.sanitizerOptions) != null && b.replaceWithPlaintext ? Fu(m) : (s.isTrusted ? m.match(/^(<span[^>]+>)|(<\/\s*span>)$/) : void 0) ? m : "";
  }), t.renderer = l;
  let d = s.value ?? "";
  d.length > 1e5 && (d = `${d.substr(0, 1e5)}…`), s.supportThemeIcons && (d = wW(d));
  let u;
  if (e.fillInIncompleteTokens) {
    const m = {
      ...TW,
      ...t
    }, _ = Eb(d, m), b = jW(_);
    u = MW(b, m);
  } else
    u = aA(d, { ...t, async: !1 });
  s.supportThemeIcons && (u = Yl(u).map((_) => typeof _ == "string" ? _ : _.outerHTML).join(""));
  const g = new DOMParser().parseFromString(qv({ isTrusted: s.isTrusted, ...e.sanitizerOptions }, u), "text/html");
  if (g.body.querySelectorAll("img, audio, video, source").forEach((m) => {
    const _ = m.getAttribute("src");
    if (_) {
      let b = _;
      try {
        s.baseUri && (b = $0(Te.from(s.baseUri), b));
      } catch {
      }
      if (m.setAttribute("src", a(b, !0)), e.remoteImageIsAllowed) {
        const C = Te.parse(b);
        C.scheme !== Ne.file && C.scheme !== Ne.data && !e.remoteImageIsAllowed(C) && m.replaceWith(pe("", void 0, m.outerHTML));
      }
    }
  }), g.body.querySelectorAll("a").forEach((m) => {
    const _ = m.getAttribute("href");
    if (m.setAttribute("href", ""), !_ || /^data:|javascript:/i.test(_) || /^command:/i.test(_) && !s.isTrusted || /^command:(\/\/\/)?_workbench\.downloadResource/i.test(_))
      m.replaceWith(...m.childNodes);
    else {
      let b = a(_, !1);
      s.baseUri && (b = $0(Te.from(s.baseUri), _)), m.dataset.href = b;
    }
  }), o.innerHTML = qv({ isTrusted: s.isTrusted, ...e.sanitizerOptions }, g.body.innerHTML), c.length > 0)
    Promise.all(c).then((m) => {
      var C;
      if (n)
        return;
      const _ = new Map(m), b = o.querySelectorAll("div[data-code]");
      for (const v of b) {
        const w = _.get(v.dataset.code ?? "");
        w && on(v, w);
      }
      (C = e.asyncRenderCallback) == null || C.call(e);
    });
  else if (h.length > 0) {
    const m = new Map(h), _ = o.querySelectorAll("div[data-code]");
    for (const b of _) {
      const C = m.get(b.dataset.code ?? "");
      C && on(b, C);
    }
  }
  if (e.asyncRenderCallback)
    for (const m of o.getElementsByTagName("img")) {
      const _ = i.add($(m, "load", () => {
        _.dispose(), e.asyncRenderCallback();
      }));
    }
  return {
    element: o,
    dispose: () => {
      n = !0, i.dispose();
    }
  };
}
function mI(s) {
  if (!s)
    return "";
  const e = s.split(/[\s+|:|,|\{|\?]/, 1);
  return e.length ? e[0] : s;
}
function $0(s, e) {
  return /^\w[\w\d+.-]*:/.test(e) ? e : s.path.endsWith("/") ? dI(s, e).toString() : dI(kW(s), e).toString();
}
const PW = ["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"];
function qv(s, e) {
  const { config: t, allowedSchemes: i } = FW(s), n = new he();
  n.add(pI("uponSanitizeAttribute", (o, r) => {
    var a;
    if (r.attrName === "style" || r.attrName === "class") {
      if (o.tagName === "SPAN") {
        if (r.attrName === "style") {
          r.keepAttr = /^(color\:(#[0-9a-fA-F]+|var\(--vscode(-[a-zA-Z]+)+\));)?(background-color\:(#[0-9a-fA-F]+|var\(--vscode(-[a-zA-Z]+)+\));)?(border-radius:[0-9]+px;)?$/.test(r.attrValue);
          return;
        } else if (r.attrName === "class") {
          r.keepAttr = /^codicon codicon-[a-z\-]+( codicon-modifier-[a-z\-]+)?$/.test(r.attrValue);
          return;
        }
      }
      r.keepAttr = !1;
      return;
    } else if (o.tagName === "INPUT" && ((a = o.attributes.getNamedItem("type")) == null ? void 0 : a.value) === "checkbox") {
      if (r.attrName === "type" && r.attrValue === "checkbox" || r.attrName === "disabled" || r.attrName === "checked") {
        r.keepAttr = !0;
        return;
      }
      r.keepAttr = !1;
    }
  })), n.add(pI("uponSanitizeElement", (o, r) => {
    var a;
    if (r.tagName === "input" && (((a = o.attributes.getNamedItem("type")) == null ? void 0 : a.value) === "checkbox" ? o.setAttribute("disabled", "") : s.replaceWithPlaintext || o.remove()), s.replaceWithPlaintext && !r.allowedTags[r.tagName] && r.tagName !== "body" && o.parentElement) {
      let l, c;
      if (r.tagName === "#comment")
        l = `<!--${o.textContent}-->`;
      else {
        const f = PW.includes(r.tagName), g = o.attributes.length ? " " + Array.from(o.attributes).map((m) => `${m.name}="${m.value}"`).join(" ") : "";
        l = `<${r.tagName}${g}>`, f || (c = `</${r.tagName}>`);
      }
      const h = document.createDocumentFragment(), d = o.parentElement.ownerDocument.createTextNode(l);
      h.appendChild(d);
      const u = c ? o.parentElement.ownerDocument.createTextNode(c) : void 0;
      for (; o.firstChild; )
        h.appendChild(o.firstChild);
      u && h.appendChild(u), o.nodeType === Node.COMMENT_NODE ? o.parentElement.insertBefore(h, o) : o.parentElement.replaceChild(h, o);
    }
  })), n.add(g7(i));
  try {
    return gM(e, { ...t, RETURN_TRUSTED_TYPE: !0 });
  } finally {
    n.dispose();
  }
}
const OW = [
  "align",
  "autoplay",
  "alt",
  "checked",
  "class",
  "colspan",
  "controls",
  "data-code",
  "data-href",
  "disabled",
  "draggable",
  "height",
  "href",
  "loop",
  "muted",
  "playsinline",
  "poster",
  "rowspan",
  "src",
  "style",
  "target",
  "title",
  "type",
  "width",
  "start"
];
function FW(s) {
  const e = [
    Ne.http,
    Ne.https,
    Ne.mailto,
    Ne.data,
    Ne.file,
    Ne.vscodeFileResource,
    Ne.vscodeRemote,
    Ne.vscodeRemoteResource
  ];
  return s.isTrusted && e.push(Ne.command), {
    config: {
      // allowedTags should included everything that markdown renders to.
      // Since we have our own sanitize function for marked, it's possible we missed some tag so let dompurify make sure.
      // HTML tags that can result from markdown are from reading https://spec.commonmark.org/0.29/
      // HTML table tags that can result from markdown are from https://github.github.com/gfm/#tables-extension-
      ALLOWED_TAGS: s.allowedTags ?? [...m7],
      ALLOWED_ATTR: OW,
      ALLOW_UNKNOWN_PROTOCOLS: !0
    },
    allowedSchemes: e
  };
}
function BW(s) {
  return typeof s == "string" ? s : WW(s);
}
function WW(s, e) {
  let t = s.value ?? "";
  t.length > 1e5 && (t = `${t.substr(0, 1e5)}…`);
  const i = aA(t, { async: !1, renderer: zW.value }).replace(/&(#\d+|[a-zA-Z]+);/g, (n) => VW.get(n) ?? n);
  return qv({ isTrusted: !1 }, i).toString();
}
const VW = /* @__PURE__ */ new Map([
  ["&quot;", '"'],
  ["&nbsp;", " "],
  ["&amp;", "&"],
  ["&#39;", "'"],
  ["&lt;", "<"],
  ["&gt;", ">"]
]);
function HW() {
  const s = new rA();
  return s.code = ({ text: e }) => e, s.blockquote = ({ text: e }) => e + `
`, s.html = (e) => "", s.heading = function({ tokens: e }) {
    return this.parser.parseInline(e) + `
`;
  }, s.hr = () => "", s.list = function({ items: e }) {
    return e.map((t) => this.listitem(t)).join(`
`) + `
`;
  }, s.listitem = ({ text: e }) => e + `
`, s.paragraph = function({ tokens: e }) {
    return this.parser.parseInline(e) + `
`;
  }, s.table = function({ header: e, rows: t }) {
    return e.map((i) => this.tablecell(i)).join(" ") + `
` + t.map((i) => i.map((n) => this.tablecell(n)).join(" ")).join(`
`) + `
`;
  }, s.tablerow = ({ text: e }) => e, s.tablecell = function({ tokens: e }) {
    return this.parser.parseInline(e);
  }, s.strong = ({ text: e }) => e, s.em = ({ text: e }) => e, s.codespan = ({ text: e }) => e, s.br = (e) => `
`, s.del = ({ text: e }) => e, s.image = (e) => "", s.text = ({ text: e }) => e, s.link = ({ text: e }) => e, s;
}
const zW = new Ha((s) => HW());
function Qp(s) {
  let e = "";
  return s.forEach((t) => {
    e += t.raw;
  }), e;
}
function lA(s) {
  var e, t;
  if (s.tokens)
    for (let i = s.tokens.length - 1; i >= 0; i--) {
      const n = s.tokens[i];
      if (n.type === "text") {
        const o = n.raw.split(`
`), r = o[o.length - 1];
        if (r.includes("`"))
          return ZW(s);
        if (r.includes("**"))
          return tV(s);
        if (r.match(/\*\w/))
          return YW(s);
        if (r.match(/(^|\s)__\w/))
          return iV(s);
        if (r.match(/(^|\s)_\w/))
          return QW(s);
        if (
          // Text with start of link target
          UW(r) || // This token doesn't have the link text, eg if it contains other markdown constructs that are in other subtokens.
          // But some preceding token does have an unbalanced [ at least
          $W(r) && s.tokens.slice(0, i).some((a) => a.type === "text" && a.raw.match(/\[[^\]]*$/))
        ) {
          const a = s.tokens.slice(i + 1);
          return (
            // If the link was parsed as a link, then look for a link token and a text token with a quote
            ((e = a[0]) == null ? void 0 : e.type) === "link" && ((t = a[1]) == null ? void 0 : t.type) === "text" && a[1].raw.match(/^ *"[^"]*$/) || // And if the link was not parsed as a link (eg command link), just look for a single quote in this token
            r.match(/^[^"]* +"[^"]*$/) ? JW(s) : XW(s)
          );
        } else if (r.match(/(^|\s)\[\w*/))
          return eV(s);
      }
    }
}
function UW(s) {
  return !!s.match(/(^|\s)\[.*\]\(\w*/);
}
function $W(s) {
  return !!s.match(/^[^\[]*\]\([^\)]*$/);
}
function KW(s) {
  var l;
  const e = s.items[s.items.length - 1], t = e.tokens ? e.tokens[e.tokens.length - 1] : void 0;
  let i;
  if ((t == null ? void 0 : t.type) === "text" && !("inRawBlock" in e) && (i = lA(t)), !i || i.type !== "paragraph")
    return;
  const n = Qp(s.items.slice(0, -1)), o = (l = e.raw.match(/^(\s*(-|\d+\.|\*) +)/)) == null ? void 0 : l[0];
  if (!o)
    return;
  const r = o + Qp(e.tokens.slice(0, -1)) + i.raw, a = Eb(n + r)[0];
  if (a.type === "list")
    return a;
}
const qW = 3;
function jW(s) {
  for (let e = 0; e < qW; e++) {
    const t = GW(s);
    if (t)
      s = t;
    else
      break;
  }
  return s;
}
function GW(s) {
  let e, t;
  for (e = 0; e < s.length; e++) {
    const i = s[e];
    if (i.type === "paragraph" && i.raw.match(/(\n|^)\|/)) {
      t = nV(s.slice(e));
      break;
    }
    if (e === s.length - 1 && i.type === "list") {
      const n = KW(i);
      if (n) {
        t = [n];
        break;
      }
    }
    if (e === s.length - 1 && i.type === "paragraph") {
      const n = lA(i);
      if (n) {
        t = [n];
        break;
      }
    }
  }
  if (t) {
    const i = [
      ...s.slice(0, e),
      ...t
    ];
    return i.links = s.links, i;
  }
  return null;
}
function ZW(s) {
  return Ja(s, "`");
}
function YW(s) {
  return Ja(s, "*");
}
function QW(s) {
  return Ja(s, "_");
}
function XW(s) {
  return Ja(s, ")");
}
function JW(s) {
  return Ja(s, '")');
}
function eV(s) {
  return Ja(s, "](https://microsoft.com)");
}
function tV(s) {
  return Ja(s, "**");
}
function iV(s) {
  return Ja(s, "__");
}
function Ja(s, e) {
  const t = Qp(Array.isArray(s) ? s : [s]);
  return Eb(t + e)[0];
}
function nV(s) {
  const e = Qp(s), t = e.split(`
`);
  let i, n = !1;
  for (let o = 0; o < t.length; o++) {
    const r = t[o].trim();
    if (typeof i > "u" && r.match(/^\s*\|/)) {
      const a = r.match(/(\|[^\|]+)(?=\||$)/g);
      a && (i = a.length);
    } else if (typeof i == "number")
      if (r.match(/^\s*\|/)) {
        if (o !== t.length - 1)
          return;
        n = !0;
      } else
        return;
  }
  if (typeof i == "number" && i > 0) {
    const o = n ? t.slice(0, -1).join(`
`) : e, r = !!o.match(/\|\s*$/), a = o + (r ? "" : "|") + `
|${" --- |".repeat(i)}`;
    return Eb(a);
  }
}
function pI(s, e) {
  return mM(s, e), ke(() => pM(s));
}
const br = class br {
  static createEmpty(e, t) {
    const i = br.defaultTokenMetadata, n = new Uint32Array(2);
    return n[0] = e.length, n[1] = i, new br(n, e, t);
  }
  static createFromTextAndMetadata(e, t) {
    let i = 0, n = "";
    const o = new Array();
    for (const { text: r, metadata: a } of e)
      o.push(i + r.length, a), i += r.length, n += r;
    return new br(new Uint32Array(o), n, t);
  }
  constructor(e, t, i) {
    this._lineTokensBrand = void 0, this._tokens = e, this._tokensCount = this._tokens.length >>> 1, this._text = t, this.languageIdCodec = i;
  }
  equals(e) {
    return e instanceof br ? this.slicedEquals(e, 0, this._tokensCount) : !1;
  }
  slicedEquals(e, t, i) {
    if (this._text !== e._text || this._tokensCount !== e._tokensCount)
      return !1;
    const n = t << 1, o = n + (i << 1);
    for (let r = n; r < o; r++)
      if (this._tokens[r] !== e._tokens[r])
        return !1;
    return !0;
  }
  getLineContent() {
    return this._text;
  }
  getCount() {
    return this._tokensCount;
  }
  getStartOffset(e) {
    return e > 0 ? this._tokens[e - 1 << 1] : 0;
  }
  getMetadata(e) {
    return this._tokens[(e << 1) + 1];
  }
  getLanguageId(e) {
    const t = this._tokens[(e << 1) + 1], i = Xs.getLanguageId(t);
    return this.languageIdCodec.decodeLanguageId(i);
  }
  getStandardTokenType(e) {
    const t = this._tokens[(e << 1) + 1];
    return Xs.getTokenType(t);
  }
  getForeground(e) {
    const t = this._tokens[(e << 1) + 1];
    return Xs.getForeground(t);
  }
  getClassName(e) {
    const t = this._tokens[(e << 1) + 1];
    return Xs.getClassNameFromMetadata(t);
  }
  getInlineStyle(e, t) {
    const i = this._tokens[(e << 1) + 1];
    return Xs.getInlineStyleFromMetadata(i, t);
  }
  getPresentation(e) {
    const t = this._tokens[(e << 1) + 1];
    return Xs.getPresentationFromMetadata(t);
  }
  getEndOffset(e) {
    return this._tokens[e << 1];
  }
  /**
   * Find the token containing offset `offset`.
   * @param offset The search offset
   * @return The index of the token containing the offset.
   */
  findTokenIndexAtOffset(e) {
    return br.findIndexInTokensArray(this._tokens, e);
  }
  inflate() {
    return this;
  }
  sliceAndInflate(e, t, i) {
    return new yk(this, e, t, i);
  }
  static convertToEndOffset(e, t) {
    const n = (e.length >>> 1) - 1;
    for (let o = 0; o < n; o++)
      e[o << 1] = e[o + 1 << 1];
    e[n << 1] = t;
  }
  static findIndexInTokensArray(e, t) {
    if (e.length <= 2)
      return 0;
    let i = 0, n = (e.length >>> 1) - 1;
    for (; i < n; ) {
      const o = i + Math.floor((n - i) / 2), r = e[o << 1];
      if (r === t)
        return o + 1;
      r < t ? i = o + 1 : r > t && (n = o);
    }
    return i;
  }
  /**
   * @pure
   * @param insertTokens Must be sorted by offset.
  */
  withInserted(e) {
    if (e.length === 0)
      return this;
    let t = 0, i = 0, n = "";
    const o = new Array();
    let r = 0;
    for (; ; ) {
      const a = t < this._tokensCount ? this._tokens[t << 1] : -1, l = i < e.length ? e[i] : null;
      if (a !== -1 && (l === null || a <= l.offset)) {
        n += this._text.substring(r, a);
        const c = this._tokens[(t << 1) + 1];
        o.push(n.length, c), t++, r = a;
      } else if (l) {
        if (l.offset > r) {
          n += this._text.substring(r, l.offset);
          const c = this._tokens[(t << 1) + 1];
          o.push(n.length, c), r = l.offset;
        }
        n += l.text, o.push(n.length, l.tokenMetadata), i++;
      } else
        break;
    }
    return new br(new Uint32Array(o), n, this.languageIdCodec);
  }
  getTokenText(e) {
    const t = this.getStartOffset(e), i = this.getEndOffset(e);
    return this._text.substring(t, i);
  }
  forEach(e) {
    const t = this.getCount();
    for (let i = 0; i < t; i++)
      e(i);
  }
};
br.defaultTokenMetadata = (32768 | 2 << 24) >>> 0;
let Si = br;
class yk {
  constructor(e, t, i, n) {
    this._source = e, this._startOffset = t, this._endOffset = i, this._deltaOffset = n, this._firstTokenIndex = e.findTokenIndexAtOffset(t), this.languageIdCodec = e.languageIdCodec, this._tokensCount = 0;
    for (let o = this._firstTokenIndex, r = e.getCount(); o < r && !(e.getStartOffset(o) >= i); o++)
      this._tokensCount++;
  }
  getMetadata(e) {
    return this._source.getMetadata(this._firstTokenIndex + e);
  }
  getLanguageId(e) {
    return this._source.getLanguageId(this._firstTokenIndex + e);
  }
  getLineContent() {
    return this._source.getLineContent().substring(this._startOffset, this._endOffset);
  }
  equals(e) {
    return e instanceof yk ? this._startOffset === e._startOffset && this._endOffset === e._endOffset && this._deltaOffset === e._deltaOffset && this._source.slicedEquals(e._source, this._firstTokenIndex, this._tokensCount) : !1;
  }
  getCount() {
    return this._tokensCount;
  }
  getStandardTokenType(e) {
    return this._source.getStandardTokenType(this._firstTokenIndex + e);
  }
  getForeground(e) {
    return this._source.getForeground(this._firstTokenIndex + e);
  }
  getEndOffset(e) {
    const t = this._source.getEndOffset(this._firstTokenIndex + e);
    return Math.min(this._endOffset, t) - this._startOffset + this._deltaOffset;
  }
  getClassName(e) {
    return this._source.getClassName(this._firstTokenIndex + e);
  }
  getInlineStyle(e, t) {
    return this._source.getInlineStyle(this._firstTokenIndex + e, t);
  }
  getPresentation(e) {
    return this._source.getPresentation(this._firstTokenIndex + e);
  }
  findTokenIndexAtOffset(e) {
    return this._source.findTokenIndexAtOffset(e + this._startOffset - this._deltaOffset) - this._firstTokenIndex;
  }
  getTokenText(e) {
    const t = this._firstTokenIndex + e, i = this._source.getStartOffset(t), n = this._source.getEndOffset(t);
    let o = this._source.getTokenText(t);
    return i < this._startOffset && (o = o.substring(this._startOffset - i)), n > this._endOffset && (o = o.substring(0, o.length - (n - this._endOffset))), o;
  }
  forEach(e) {
    for (let t = 0; t < this.getCount(); t++)
      e(t);
  }
}
const jf = new class {
  clone() {
    return this;
  }
  equals(s) {
    return this === s;
  }
}();
function cA(s, e) {
  return new xL([new Rf(0, "", s)], e);
}
function Sk(s, e) {
  const t = new Uint32Array(2);
  return t[0] = 0, t[1] = (s << 0 | 0 | 0 | 32768 | 2 << 24) >>> 0, new tb(t, e === null ? jf : e);
}
const _I = {
  getInitialState: () => jf,
  tokenizeEncoded: (s, e, t) => Sk(0, t)
};
async function sV(s, e, t) {
  if (!t)
    return bI(e, s.languageIdCodec, _I);
  const i = await Yt.getOrCreate(t);
  return bI(e, s.languageIdCodec, i || _I);
}
function oV(s, e, t, i, n, o, r) {
  let a = "<div>", l = i, c = 0, h = !0;
  for (let d = 0, u = e.getCount(); d < u; d++) {
    const f = e.getEndOffset(d);
    if (f <= i)
      continue;
    let g = "";
    for (; l < f && l < n; l++) {
      const m = s.charCodeAt(l);
      switch (m) {
        case 9: {
          let _ = o - (l + c) % o;
          for (c += _ - 1; _ > 0; )
            r && h ? (g += "&#160;", h = !1) : (g += " ", h = !0), _--;
          break;
        }
        case 60:
          g += "&lt;", h = !1;
          break;
        case 62:
          g += "&gt;", h = !1;
          break;
        case 38:
          g += "&amp;", h = !1;
          break;
        case 0:
          g += "&#00;", h = !1;
          break;
        case 65279:
        case 8232:
        case 8233:
        case 133:
          g += "�", h = !1;
          break;
        case 13:
          g += "&#8203", h = !1;
          break;
        case 32:
          r && h ? (g += "&#160;", h = !1) : (g += " ", h = !0);
          break;
        default:
          g += String.fromCharCode(m), h = !1;
      }
    }
    if (a += `<span style="${e.getInlineStyle(d, t)}">${g}</span>`, f > n || l >= n)
      break;
  }
  return a += "</div>", a;
}
function bI(s, e, t) {
  let i = '<div class="monaco-tokenized-source">';
  const n = Vd(s);
  let o = t.getInitialState();
  for (let r = 0, a = n.length; r < a; r++) {
    const l = n[r];
    r > 0 && (i += "<br/>");
    const c = t.tokenizeEncoded(l, !0, o);
    Si.convertToEndOffset(c.tokens, l.length);
    const d = new Si(c.tokens, l, e).inflate();
    let u = 0;
    for (let f = 0, g = d.getCount(); f < g; f++) {
      const m = d.getClassName(f), _ = d.getEndOffset(f);
      i += `<span class="${m}">${Fu(l.substring(u, _))}</span>`, u = _;
    }
    o = c.endState;
  }
  return i += "</div>", i;
}
var rV = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, CI = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, jv, nc;
let Gv = (nc = class {
  constructor(e, t, i) {
    this._options = e, this._languageService = t, this._openerService = i, this._onDidRenderAsync = new O(), this.onDidRenderAsync = this._onDidRenderAsync.event;
  }
  dispose() {
    this._onDidRenderAsync.dispose();
  }
  render(e, t, i) {
    if (!e)
      return { element: document.createElement("span"), dispose: () => {
      } };
    const n = new he(), o = n.add(vk(e, { ...this._getRenderOptions(e, n), ...t }, i));
    return o.element.classList.add("rendered-markdown"), {
      element: o.element,
      dispose: () => n.dispose()
    };
  }
  _getRenderOptions(e, t) {
    return {
      codeBlockRenderer: async (i, n) => {
        var l, c;
        let o;
        i ? o = this._languageService.getLanguageIdByLanguageName(i) : this._options.editor && (o = (l = this._options.editor.getModel()) == null ? void 0 : l.getLanguageId()), o || (o = Ms);
        const r = await sV(this._languageService, n, o), a = document.createElement("span");
        if (a.innerHTML = ((c = jv._ttpTokenizer) == null ? void 0 : c.createHTML(r)) ?? r, this._options.editor) {
          const h = this._options.editor.getOption(
            50
            /* EditorOption.fontInfo */
          );
          Fi(a, h);
        } else this._options.codeBlockFontFamily && (a.style.fontFamily = this._options.codeBlockFontFamily);
        return this._options.codeBlockFontSize !== void 0 && (a.style.fontSize = this._options.codeBlockFontSize), a;
      },
      asyncRenderCallback: () => this._onDidRenderAsync.fire(),
      actionHandler: {
        callback: (i) => hA(this._openerService, i, e.isTrusted),
        disposables: t
      }
    };
  }
}, jv = nc, nc._ttpTokenizer = Pc("tokenizeToString", {
  createHTML(e) {
    return e;
  }
}), nc);
Gv = jv = rV([
  CI(1, gi),
  CI(2, Og)
], Gv);
async function hA(s, e, t) {
  try {
    return await s.open(e, {
      fromUserGesture: !0,
      allowContributedOpeners: !0,
      allowCommands: aV(t)
    });
  } catch (i) {
    return ht(i), !1;
  }
}
function aV(s) {
  return s === !0 ? !0 : s && Array.isArray(s.enabledCommands) ? s.enabledCommands : !1;
}
const go = Ve("accessibilityService"), lV = new de("accessibilityModeEnabled", !1), wI = 2e4;
let El, tp, Zv, ip, Yv;
function cV(s) {
  El = document.createElement("div"), El.className = "monaco-aria-container";
  const e = () => {
    const i = document.createElement("div");
    return i.className = "monaco-alert", i.setAttribute("role", "alert"), i.setAttribute("aria-atomic", "true"), El.appendChild(i), i;
  };
  tp = e(), Zv = e();
  const t = () => {
    const i = document.createElement("div");
    return i.className = "monaco-status", i.setAttribute("aria-live", "polite"), i.setAttribute("aria-atomic", "true"), El.appendChild(i), i;
  };
  ip = t(), Yv = t(), s.appendChild(El);
}
function Gf(s) {
  El && (tp.textContent !== s ? (oo(Zv), Jp(tp, s)) : (oo(tp), Jp(Zv, s)));
}
function Xp(s) {
  El && (ip.textContent !== s ? (oo(Yv), Jp(ip, s)) : (oo(ip), Jp(Yv, s)));
}
function Jp(s, e) {
  oo(s), e.length > wI && (e = e.substr(0, wI)), s.textContent = e, s.style.visibility = "hidden", s.style.visibility = "visible";
}
var hV = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, uu = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const wo = pe;
let Qv = class extends ta {
  get _targetWindow() {
    return ue(this._target.targetElements[0]);
  }
  get _targetDocumentElement() {
    return ue(this._target.targetElements[0]).document.documentElement;
  }
  get isDisposed() {
    return this._isDisposed;
  }
  get isMouseIn() {
    return this._lockMouseTracker.isMouseIn;
  }
  get domNode() {
    return this._hover.containerDomNode;
  }
  get onDispose() {
    return this._onDispose.event;
  }
  get onRequestLayout() {
    return this._onRequestLayout.event;
  }
  get anchor() {
    return this._hoverPosition === 2 ? 0 : 1;
  }
  get x() {
    return this._x;
  }
  get y() {
    return this._y;
  }
  /**
   * Whether the hover is "locked" by holding the alt/option key. When locked, the hover will not
   * hide and can be hovered regardless of whether the `hideOnHover` hover option is set.
   */
  get isLocked() {
    return this._isLocked;
  }
  set isLocked(e) {
    this._isLocked !== e && (this._isLocked = e, this._hoverContainer.classList.toggle("locked", this._isLocked));
  }
  constructor(e, t, i, n, o, r) {
    var u, f, g, m, _, b, C;
    super(), this._keybindingService = t, this._configurationService = i, this._openerService = n, this._instantiationService = o, this._accessibilityService = r, this._messageListeners = new he(), this._isDisposed = !1, this._forcePosition = !1, this._x = 0, this._y = 0, this._isLocked = !1, this._enableFocusTraps = !1, this._addedFocusTrap = !1, this._onDispose = this._register(new O()), this._onRequestLayout = this._register(new O()), this._linkHandler = e.linkHandler || ((v) => hA(this._openerService, v, Yh(e.content) ? e.content.isTrusted : void 0)), this._target = "targetElements" in e.target ? e.target : new dV(e.target), this._hoverPointer = (u = e.appearance) != null && u.showPointer ? wo("div.workbench-hover-pointer") : void 0, this._hover = this._register(new $B()), this._hover.containerDomNode.classList.add("workbench-hover", "fadeIn"), (f = e.appearance) != null && f.compact && this._hover.containerDomNode.classList.add("workbench-hover", "compact"), (g = e.appearance) != null && g.skipFadeInAnimation && this._hover.containerDomNode.classList.add("skip-fade-in"), e.additionalClasses && this._hover.containerDomNode.classList.add(...e.additionalClasses), (m = e.position) != null && m.forcePosition && (this._forcePosition = !0), e.trapFocus && (this._enableFocusTraps = !0), this._hoverPosition = ((_ = e.position) == null ? void 0 : _.hoverPosition) ?? 3, this.onmousedown(this._hover.containerDomNode, (v) => v.stopPropagation()), this.onkeydown(this._hover.containerDomNode, (v) => {
      v.equals(
        9
        /* KeyCode.Escape */
      ) && this.dispose();
    }), this._register($(this._targetWindow, "blur", () => this.dispose()));
    const a = wo("div.hover-row.markdown-hover"), l = wo("div.hover-contents");
    if (typeof e.content == "string")
      l.textContent = e.content, l.style.whiteSpace = "pre-wrap";
    else if (yi(e.content))
      l.appendChild(e.content), l.classList.add("html-hover-contents");
    else {
      const v = e.content, w = this._instantiationService.createInstance(Gv, { codeBlockFontFamily: this._configurationService.getValue("editor").fontFamily || es.fontFamily }), { element: S } = w.render(v, {
        actionHandler: {
          callback: (L) => this._linkHandler(L),
          disposables: this._messageListeners
        },
        asyncRenderCallback: () => {
          l.classList.add("code-hover-contents"), this.layout(), this._onRequestLayout.fire();
        }
      });
      l.appendChild(S);
    }
    if (a.appendChild(l), this._hover.contentsDomNode.appendChild(a), e.actions && e.actions.length > 0) {
      const v = wo("div.hover-row.status-bar"), w = wo("div.actions");
      e.actions.forEach((S) => {
        const L = this._keybindingService.lookupKeybinding(S.commandId), k = L ? L.getLabel() : null;
        gk.render(w, {
          label: S.label,
          commandId: S.commandId,
          run: (D) => {
            S.run(D), this.dispose();
          },
          iconClass: S.iconClass
        }, k);
      }), v.appendChild(w), this._hover.containerDomNode.appendChild(v);
    }
    this._hoverContainer = wo("div.workbench-hover-container"), this._hoverPointer && this._hoverContainer.appendChild(this._hoverPointer), this._hoverContainer.appendChild(this._hover.containerDomNode);
    let c;
    if (e.actions && e.actions.length > 0 ? c = !1 : ((b = e.persistence) == null ? void 0 : b.hideOnHover) === void 0 ? c = typeof e.content == "string" || Yh(e.content) && !e.content.value.includes("](") && !e.content.value.includes("</a>") : c = e.persistence.hideOnHover, (C = e.appearance) != null && C.showHoverHint) {
      const v = wo("div.hover-row.status-bar"), w = wo("div.info");
      w.textContent = p("hoverhint", "Hold {0} key to mouse over", He ? "Option" : "Alt"), v.appendChild(w), this._hover.containerDomNode.appendChild(v);
    }
    const h = [...this._target.targetElements];
    c || h.push(this._hoverContainer);
    const d = this._register(new vI(h));
    if (this._register(d.onMouseOut(() => {
      this._isLocked || this.dispose();
    })), c) {
      const v = [...this._target.targetElements, this._hoverContainer];
      this._lockMouseTracker = this._register(new vI(v)), this._register(this._lockMouseTracker.onMouseOut(() => {
        this._isLocked || this.dispose();
      }));
    } else
      this._lockMouseTracker = d;
  }
  addFocusTrap() {
    if (!this._enableFocusTraps || this._addedFocusTrap)
      return;
    this._addedFocusTrap = !0;
    const e = this._hover.containerDomNode, t = this.findLastFocusableChild(this._hover.containerDomNode);
    if (t) {
      const i = $L(this._hoverContainer, wo("div")), n = ae(this._hoverContainer, wo("div"));
      i.tabIndex = 0, n.tabIndex = 0, this._register($(n, "focus", (o) => {
        e.focus(), o.preventDefault();
      })), this._register($(i, "focus", (o) => {
        t.focus(), o.preventDefault();
      }));
    }
  }
  findLastFocusableChild(e) {
    if (e.hasChildNodes())
      for (let t = 0; t < e.childNodes.length; t++) {
        const i = e.childNodes.item(e.childNodes.length - t - 1);
        if (i.nodeType === i.ELEMENT_NODE) {
          const o = i;
          if (typeof o.tabIndex == "number" && o.tabIndex >= 0)
            return o;
        }
        const n = this.findLastFocusableChild(i);
        if (n)
          return n;
      }
  }
  render(e) {
    var n;
    e.appendChild(this._hoverContainer);
    const i = this._hoverContainer.contains(this._hoverContainer.ownerDocument.activeElement) && KB(this._configurationService.getValue("accessibility.verbosity.hover") === !0 && this._accessibilityService.isScreenReaderOptimized(), (n = this._keybindingService.lookupKeybinding("editor.action.accessibleView")) == null ? void 0 : n.getAriaLabel());
    i && Xp(i), this.layout(), this.addFocusTrap();
  }
  layout() {
    this._hover.containerDomNode.classList.remove("right-aligned"), this._hover.contentsDomNode.style.maxHeight = "";
    const e = (h) => {
      const d = vM(h), u = h.getBoundingClientRect();
      return {
        top: u.top * d,
        bottom: u.bottom * d,
        right: u.right * d,
        left: u.left * d
      };
    }, t = this._target.targetElements.map((h) => e(h)), { top: i, right: n, bottom: o, left: r } = t[0], a = n - r, l = o - i, c = {
      top: i,
      right: n,
      bottom: o,
      left: r,
      width: a,
      height: l,
      center: {
        x: r + a / 2,
        y: i + l / 2
      }
    };
    if (this.adjustHorizontalHoverPosition(c), this.adjustVerticalHoverPosition(c), this.adjustHoverMaxHeight(c), this._hoverContainer.style.padding = "", this._hoverContainer.style.margin = "", this._hoverPointer) {
      switch (this._hoverPosition) {
        case 1:
          c.left += 3, c.right += 3, this._hoverContainer.style.paddingLeft = "3px", this._hoverContainer.style.marginLeft = "-3px";
          break;
        case 0:
          c.left -= 3, c.right -= 3, this._hoverContainer.style.paddingRight = "3px", this._hoverContainer.style.marginRight = "-3px";
          break;
        case 2:
          c.top += 3, c.bottom += 3, this._hoverContainer.style.paddingTop = "3px", this._hoverContainer.style.marginTop = "-3px";
          break;
        case 3:
          c.top -= 3, c.bottom -= 3, this._hoverContainer.style.paddingBottom = "3px", this._hoverContainer.style.marginBottom = "-3px";
          break;
      }
      c.center.x = c.left + a / 2, c.center.y = c.top + l / 2;
    }
    this.computeXCordinate(c), this.computeYCordinate(c), this._hoverPointer && (this._hoverPointer.classList.remove("top"), this._hoverPointer.classList.remove("left"), this._hoverPointer.classList.remove("right"), this._hoverPointer.classList.remove("bottom"), this.setHoverPointerPosition(c)), this._hover.onContentsChanged();
  }
  computeXCordinate(e) {
    const t = this._hover.containerDomNode.clientWidth + 2;
    this._target.x !== void 0 ? this._x = this._target.x : this._hoverPosition === 1 ? this._x = e.right : this._hoverPosition === 0 ? this._x = e.left - t : (this._hoverPointer ? this._x = e.center.x - this._hover.containerDomNode.clientWidth / 2 : this._x = e.left, this._x + t >= this._targetDocumentElement.clientWidth && (this._hover.containerDomNode.classList.add("right-aligned"), this._x = Math.max(this._targetDocumentElement.clientWidth - t - 2, this._targetDocumentElement.clientLeft))), this._x < this._targetDocumentElement.clientLeft && (this._x = e.left + 2);
  }
  computeYCordinate(e) {
    this._target.y !== void 0 ? this._y = this._target.y : this._hoverPosition === 3 ? this._y = e.top : this._hoverPosition === 2 ? this._y = e.bottom - 2 : this._hoverPointer ? this._y = e.center.y + this._hover.containerDomNode.clientHeight / 2 : this._y = e.bottom, this._y > this._targetWindow.innerHeight && (this._y = e.bottom);
  }
  adjustHorizontalHoverPosition(e) {
    if (this._target.x !== void 0)
      return;
    const t = this._hoverPointer ? 3 : 0;
    if (this._forcePosition) {
      const i = t + 2;
      this._hoverPosition === 1 ? this._hover.containerDomNode.style.maxWidth = `${this._targetDocumentElement.clientWidth - e.right - i}px` : this._hoverPosition === 0 && (this._hover.containerDomNode.style.maxWidth = `${e.left - i}px`);
      return;
    }
    this._hoverPosition === 1 ? this._targetDocumentElement.clientWidth - e.right < this._hover.containerDomNode.clientWidth + t && (e.left >= this._hover.containerDomNode.clientWidth + t ? this._hoverPosition = 0 : this._hoverPosition = 2) : this._hoverPosition === 0 && (e.left < this._hover.containerDomNode.clientWidth + t && (this._targetDocumentElement.clientWidth - e.right >= this._hover.containerDomNode.clientWidth + t ? this._hoverPosition = 1 : this._hoverPosition = 2), e.left - this._hover.containerDomNode.clientWidth - t <= this._targetDocumentElement.clientLeft && (this._hoverPosition = 1));
  }
  adjustVerticalHoverPosition(e) {
    if (this._target.y !== void 0 || this._forcePosition)
      return;
    const t = this._hoverPointer ? 3 : 0;
    this._hoverPosition === 3 ? e.top - this._hover.containerDomNode.clientHeight - t < 0 && (this._hoverPosition = 2) : this._hoverPosition === 2 && e.bottom + this._hover.containerDomNode.clientHeight + t > this._targetWindow.innerHeight && (this._hoverPosition = 3);
  }
  adjustHoverMaxHeight(e) {
    let t = this._targetWindow.innerHeight / 2;
    if (this._forcePosition) {
      const i = (this._hoverPointer ? 3 : 0) + 2;
      this._hoverPosition === 3 ? t = Math.min(t, e.top - i) : this._hoverPosition === 2 && (t = Math.min(t, this._targetWindow.innerHeight - e.bottom - i));
    }
    if (this._hover.containerDomNode.style.maxHeight = `${t}px`, this._hover.contentsDomNode.clientHeight < this._hover.contentsDomNode.scrollHeight) {
      const i = `${this._hover.scrollbar.options.verticalScrollbarSize}px`;
      this._hover.contentsDomNode.style.paddingRight !== i && (this._hover.contentsDomNode.style.paddingRight = i);
    }
  }
  setHoverPointerPosition(e) {
    if (this._hoverPointer)
      switch (this._hoverPosition) {
        case 0:
        case 1: {
          this._hoverPointer.classList.add(this._hoverPosition === 0 ? "right" : "left");
          const t = this._hover.containerDomNode.clientHeight;
          t > e.height ? this._hoverPointer.style.top = `${e.center.y - (this._y - t) - 3}px` : this._hoverPointer.style.top = `${Math.round(t / 2) - 3}px`;
          break;
        }
        case 3:
        case 2: {
          this._hoverPointer.classList.add(this._hoverPosition === 3 ? "bottom" : "top");
          const t = this._hover.containerDomNode.clientWidth;
          let i = Math.round(t / 2) - 3;
          const n = this._x + i;
          (n < e.left || n > e.right) && (i = e.center.x - this._x - 3), this._hoverPointer.style.left = `${i}px`;
          break;
        }
      }
  }
  focus() {
    this._hover.containerDomNode.focus();
  }
  dispose() {
    this._isDisposed || (this._onDispose.fire(), this._hoverContainer.remove(), this._messageListeners.dispose(), this._target.dispose(), super.dispose()), this._isDisposed = !0;
  }
};
Qv = hV([
  uu(1, Ai),
  uu(2, Vt),
  uu(3, Og),
  uu(4, ot),
  uu(5, go)
], Qv);
class vI extends ta {
  get onMouseOut() {
    return this._onMouseOut.event;
  }
  get isMouseIn() {
    return this._isMouseIn;
  }
  constructor(e) {
    super(), this._elements = e, this._isMouseIn = !0, this._onMouseOut = this._register(new O()), this._elements.forEach((t) => this.onmouseover(t, () => this._onTargetMouseOver(t))), this._elements.forEach((t) => this.onmouseleave(t, () => this._onTargetMouseLeave(t)));
  }
  _onTargetMouseOver(e) {
    this._isMouseIn = !0, this._clearEvaluateMouseStateTimeout(e);
  }
  _onTargetMouseLeave(e) {
    this._isMouseIn = !1, this._evaluateMouseState(e);
  }
  _evaluateMouseState(e) {
    this._clearEvaluateMouseStateTimeout(e), this._mouseTimeout = ue(e).setTimeout(() => this._fireIfMouseOutside(), 0);
  }
  _clearEvaluateMouseStateTimeout(e) {
    this._mouseTimeout && (ue(e).clearTimeout(this._mouseTimeout), this._mouseTimeout = void 0);
  }
  _fireIfMouseOutside() {
    this._isMouseIn || this._onMouseOut.fire();
  }
}
class dV {
  constructor(e) {
    this._element = e, this.targetElements = [this._element];
  }
  dispose() {
  }
}
var Pi;
(function(s) {
  function e(o, r) {
    if (o.start >= r.end || r.start >= o.end)
      return { start: 0, end: 0 };
    const a = Math.max(o.start, r.start), l = Math.min(o.end, r.end);
    return l - a <= 0 ? { start: 0, end: 0 } : { start: a, end: l };
  }
  s.intersect = e;
  function t(o) {
    return o.end - o.start <= 0;
  }
  s.isEmpty = t;
  function i(o, r) {
    return !t(e(o, r));
  }
  s.intersects = i;
  function n(o, r) {
    const a = [], l = { start: o.start, end: Math.min(r.start, o.end) }, c = { start: Math.max(r.end, o.start), end: o.end };
    return t(l) || a.push(l), t(c) || a.push(c), a;
  }
  s.relativeComplement = n;
})(Pi || (Pi = {}));
function uV(s) {
  const e = s;
  return !!e && typeof e.x == "number" && typeof e.y == "number";
}
var Ea;
(function(s) {
  s[s.AVOID = 0] = "AVOID", s[s.ALIGN = 1] = "ALIGN";
})(Ea || (Ea = {}));
function bh(s, e, t) {
  const i = t.mode === Ea.ALIGN ? t.offset : t.offset + t.size, n = t.mode === Ea.ALIGN ? t.offset + t.size : t.offset;
  return t.position === 0 ? e <= s - i ? i : e <= n ? n - e : Math.max(s - e, 0) : e <= n ? n - e : e <= s - i ? i : 0;
}
const Fh = class Fh extends q {
  constructor(e, t) {
    super(), this.container = null, this.useFixedPosition = !1, this.useShadowDOM = !1, this.delegate = null, this.toDisposeOnClean = q.None, this.toDisposeOnSetContainer = q.None, this.shadowRoot = null, this.shadowRootHostElement = null, this.view = pe(".context-view"), FD(this.view), this.setContainer(e, t), this._register(ke(() => this.setContainer(
      null,
      1
      /* ContextViewDOMPosition.ABSOLUTE */
    )));
  }
  setContainer(e, t) {
    var n;
    this.useFixedPosition = t !== 1;
    const i = this.useShadowDOM;
    if (this.useShadowDOM = t === 3, !(e === this.container && i === this.useShadowDOM) && (this.container && (this.toDisposeOnSetContainer.dispose(), this.view.remove(), this.shadowRoot && (this.shadowRoot = null, (n = this.shadowRootHostElement) == null || n.remove(), this.shadowRootHostElement = null), this.container = null), e)) {
      if (this.container = e, this.useShadowDOM) {
        this.shadowRootHostElement = pe(".shadow-root-host"), this.container.appendChild(this.shadowRootHostElement), this.shadowRoot = this.shadowRootHostElement.attachShadow({ mode: "open" });
        const r = document.createElement("style");
        r.textContent = fV, this.shadowRoot.appendChild(r), this.shadowRoot.appendChild(this.view), this.shadowRoot.appendChild(pe("slot"));
      } else
        this.container.appendChild(this.view);
      const o = new he();
      Fh.BUBBLE_UP_EVENTS.forEach((r) => {
        o.add(fi(this.container, r, (a) => {
          this.onDOMEvent(a, !1);
        }));
      }), Fh.BUBBLE_DOWN_EVENTS.forEach((r) => {
        o.add(fi(this.container, r, (a) => {
          this.onDOMEvent(a, !0);
        }, !0));
      }), this.toDisposeOnSetContainer = o;
    }
  }
  show(e) {
    var t, i;
    this.isVisible() && this.hide(), oo(this.view), this.view.className = "context-view monaco-component", this.view.style.top = "0px", this.view.style.left = "0px", this.view.style.zIndex = `${2575 + (e.layer ?? 0)}`, this.view.style.position = this.useFixedPosition ? "fixed" : "absolute", xM(this.view), this.toDisposeOnClean = e.render(this.view) || q.None, this.delegate = e, this.doLayout(), (i = (t = this.delegate).focus) == null || i.call(t);
  }
  getViewElement() {
    return this.view;
  }
  layout() {
    var e, t;
    if (this.isVisible()) {
      if (this.delegate.canRelayout === !1 && !(fc && nM.pointerEvents)) {
        this.hide();
        return;
      }
      (t = (e = this.delegate) == null ? void 0 : e.layout) == null || t.call(e), this.doLayout();
    }
  }
  doLayout() {
    if (!this.isVisible())
      return;
    const e = this.delegate.getAnchor();
    let t;
    if (yi(e)) {
      const u = gs(e), f = vM(e);
      t = {
        top: u.top * f,
        left: u.left * f,
        width: u.width * f,
        height: u.height * f
      };
    } else uV(e) ? t = {
      top: e.y,
      left: e.x,
      width: e.width || 1,
      height: e.height || 2
    } : t = {
      top: e.posy,
      left: e.posx,
      // We are about to position the context view where the mouse
      // cursor is. To prevent the view being exactly under the mouse
      // when showing and thus potentially triggering an action within,
      // we treat the mouse location like a small sized block element.
      width: 2,
      height: 2
    };
    const i = VL(this.view), n = Yw(this.view), o = this.delegate.anchorPosition || 0, r = this.delegate.anchorAlignment || 0, a = this.delegate.anchorAxisAlignment || 0;
    let l, c;
    const h = Lu();
    if (a === 0) {
      const u = {
        offset: t.top - h.pageYOffset,
        size: t.height,
        position: o === 0 ? 0 : 1
        /* LayoutAnchorPosition.After */
      }, f = { offset: t.left, size: t.width, position: r === 0 ? 0 : 1, mode: Ea.ALIGN };
      l = bh(h.innerHeight, n, u) + h.pageYOffset, Pi.intersects({ start: l, end: l + n }, { start: u.offset, end: u.offset + u.size }) && (f.mode = Ea.AVOID), c = bh(h.innerWidth, i, f);
    } else {
      const u = {
        offset: t.left,
        size: t.width,
        position: r === 0 ? 0 : 1
        /* LayoutAnchorPosition.After */
      }, f = { offset: t.top, size: t.height, position: o === 0 ? 0 : 1, mode: Ea.ALIGN };
      c = bh(h.innerWidth, i, u), Pi.intersects({ start: c, end: c + i }, { start: u.offset, end: u.offset + u.size }) && (f.mode = Ea.AVOID), l = bh(h.innerHeight, n, f) + h.pageYOffset;
    }
    this.view.classList.remove("top", "bottom", "left", "right"), this.view.classList.add(o === 0 ? "bottom" : "top"), this.view.classList.add(r === 0 ? "left" : "right"), this.view.classList.toggle("fixed", this.useFixedPosition);
    const d = gs(this.container);
    this.view.style.top = `${l - (this.useFixedPosition ? gs(this.view).top : d.top)}px`, this.view.style.left = `${c - (this.useFixedPosition ? gs(this.view).left : d.left)}px`, this.view.style.width = "initial";
  }
  hide(e) {
    const t = this.delegate;
    this.delegate = null, t != null && t.onHide && t.onHide(e), this.toDisposeOnClean.dispose(), FD(this.view);
  }
  isVisible() {
    return !!this.delegate;
  }
  onDOMEvent(e, t) {
    this.delegate && (this.delegate.onDOMEvent ? this.delegate.onDOMEvent(e, ue(e).document.activeElement) : t && !ui(e.target, this.container) && this.hide());
  }
  dispose() {
    this.hide(), super.dispose();
  }
};
Fh.BUBBLE_UP_EVENTS = ["click", "keydown", "focus", "blur"], Fh.BUBBLE_DOWN_EVENTS = ["click"];
let Xv = Fh;
const fV = (
  /* css */
  `
	:host {
		all: initial; /* 1st rule so subsequent properties are reset. */
	}

	.codicon[class*='codicon-'] {
		font: normal normal normal 16px/1 codicon;
		display: inline-block;
		text-decoration: none;
		text-rendering: auto;
		text-align: center;
		-webkit-font-smoothing: antialiased;
		-moz-osx-font-smoothing: grayscale;
		user-select: none;
		-webkit-user-select: none;
		-ms-user-select: none;
	}

	:host {
		font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "HelveticaNeue-Light", system-ui, "Ubuntu", "Droid Sans", sans-serif;
	}

	:host-context(.mac) { font-family: -apple-system, BlinkMacSystemFont, sans-serif; }
	:host-context(.mac:lang(zh-Hans)) { font-family: -apple-system, BlinkMacSystemFont, "PingFang SC", "Hiragino Sans GB", sans-serif; }
	:host-context(.mac:lang(zh-Hant)) { font-family: -apple-system, BlinkMacSystemFont, "PingFang TC", sans-serif; }
	:host-context(.mac:lang(ja)) { font-family: -apple-system, BlinkMacSystemFont, "Hiragino Kaku Gothic Pro", sans-serif; }
	:host-context(.mac:lang(ko)) { font-family: -apple-system, BlinkMacSystemFont, "Nanum Gothic", "Apple SD Gothic Neo", "AppleGothic", sans-serif; }

	:host-context(.windows) { font-family: "Segoe WPC", "Segoe UI", sans-serif; }
	:host-context(.windows:lang(zh-Hans)) { font-family: "Segoe WPC", "Segoe UI", "Microsoft YaHei", sans-serif; }
	:host-context(.windows:lang(zh-Hant)) { font-family: "Segoe WPC", "Segoe UI", "Microsoft Jhenghei", sans-serif; }
	:host-context(.windows:lang(ja)) { font-family: "Segoe WPC", "Segoe UI", "Yu Gothic UI", "Meiryo UI", sans-serif; }
	:host-context(.windows:lang(ko)) { font-family: "Segoe WPC", "Segoe UI", "Malgun Gothic", "Dotom", sans-serif; }

	:host-context(.linux) { font-family: system-ui, "Ubuntu", "Droid Sans", sans-serif; }
	:host-context(.linux:lang(zh-Hans)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans SC", "Source Han Sans CN", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(zh-Hant)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans TC", "Source Han Sans TW", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(ja)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans J", "Source Han Sans JP", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(ko)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans K", "Source Han Sans JR", "Source Han Sans", "UnDotum", "FBaekmuk Gulim", sans-serif; }
`
);
var gV = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, mV = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let e_ = class extends q {
  constructor(e) {
    super(), this.layoutService = e, this.contextView = this._register(new Xv(
      this.layoutService.mainContainer,
      1
      /* ContextViewDOMPosition.ABSOLUTE */
    )), this.layout(), this._register(e.onDidLayoutContainer(() => this.layout()));
  }
  // ContextView
  showContextView(e, t, i) {
    let n;
    t ? t === this.layoutService.getContainer(ue(t)) ? n = 1 : i ? n = 3 : n = 2 : n = 1, this.contextView.setContainer(t ?? this.layoutService.activeContainer, n), this.contextView.show(e);
    const o = {
      close: () => {
        this.openContextView === o && this.hideContextView();
      }
    };
    return this.openContextView = o, o;
  }
  layout() {
    this.contextView.layout();
  }
  hideContextView(e) {
    this.contextView.hide(e), this.openContextView = void 0;
  }
};
e_ = gV([
  mV(0, Xa)
], e_);
class pV extends e_ {
  getContextViewElement() {
    return this.contextView.getViewElement();
  }
}
class _V {
  constructor(e, t, i) {
    this.hoverDelegate = e, this.target = t, this.fadeInAnimation = i;
  }
  async update(e, t, i) {
    if (this._cancellationTokenSource && (this._cancellationTokenSource.dispose(!0), this._cancellationTokenSource = void 0), this.isDisposed)
      return;
    let n;
    if (e === void 0 || Jn(e) || yi(e))
      n = e;
    else if (!pp(e.markdown))
      n = e.markdown ?? e.markdownNotSupportedFallback;
    else {
      this._hoverWidget || this.show(p("iconLabel.loading", "Loading..."), t, i), this._cancellationTokenSource = new Wd();
      const o = this._cancellationTokenSource.token;
      if (n = await e.markdown(o), n === void 0 && (n = e.markdownNotSupportedFallback), this.isDisposed || o.isCancellationRequested)
        return;
    }
    this.show(n, t, i);
  }
  show(e, t, i) {
    var o;
    const n = this._hoverWidget;
    if (this.hasContent(e)) {
      const r = {
        content: e,
        target: this.target,
        actions: i == null ? void 0 : i.actions,
        linkHandler: i == null ? void 0 : i.linkHandler,
        trapFocus: i == null ? void 0 : i.trapFocus,
        appearance: {
          showPointer: this.hoverDelegate.placement === "element",
          skipFadeInAnimation: !this.fadeInAnimation || !!n,
          // do not fade in if the hover is already showing
          showHoverHint: (o = i == null ? void 0 : i.appearance) == null ? void 0 : o.showHoverHint
        },
        position: {
          hoverPosition: 2
        }
      };
      this._hoverWidget = this.hoverDelegate.showHover(r, t);
    }
    n == null || n.dispose();
  }
  hasContent(e) {
    return e ? Yh(e) ? !!e.value : !0 : !1;
  }
  get isDisposed() {
    var e;
    return (e = this._hoverWidget) == null ? void 0 : e.isDisposed;
  }
  dispose() {
    var e, t;
    (e = this._hoverWidget) == null || e.dispose(), (t = this._cancellationTokenSource) == null || t.dispose(!0), this._cancellationTokenSource = void 0;
  }
}
var bV = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, fu = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let Jv = class extends q {
  constructor(e, t, i, n, o) {
    super(), this._instantiationService = e, this._keybindingService = i, this._layoutService = n, this._accessibilityService = o, this._managedHovers = /* @__PURE__ */ new Map(), t.onDidShowContextMenu(() => this.hideHover()), this._contextViewHandler = this._register(new e_(this._layoutService));
  }
  showHover(e, t, i) {
    var l, c, h, d;
    if (yI(this._currentHoverOptions) === yI(e) || this._currentHover && ((c = (l = this._currentHoverOptions) == null ? void 0 : l.persistence) != null && c.sticky))
      return;
    this._currentHoverOptions = e, this._lastHoverOptions = e;
    const n = e.trapFocus || this._accessibilityService.isScreenReaderOptimized(), o = Gi();
    i || (n && o ? o.classList.contains("monaco-hover") || (this._lastFocusedElementBeforeOpen = o) : this._lastFocusedElementBeforeOpen = void 0);
    const r = new he(), a = this._instantiationService.createInstance(Qv, e);
    if ((h = e.persistence) != null && h.sticky && (a.isLocked = !0), a.onDispose(() => {
      var f, g;
      ((f = this._currentHover) == null ? void 0 : f.domNode) && SM(this._currentHover.domNode) && ((g = this._lastFocusedElementBeforeOpen) == null || g.focus()), this._currentHoverOptions === e && (this._currentHoverOptions = void 0), r.dispose();
    }, void 0, r), !e.container) {
      const u = yi(e.target) ? e.target : e.target.targetElements[0];
      e.container = this._layoutService.getContainer(ue(u));
    }
    if (this._contextViewHandler.showContextView(new CV(a, t), e.container), a.onRequestLayout(() => this._contextViewHandler.layout(), void 0, r), (d = e.persistence) != null && d.sticky)
      r.add($(ue(e.container).document, ee.MOUSE_DOWN, (u) => {
        ui(u.target, a.domNode) || this.doHideHover();
      }));
    else {
      if ("targetElements" in e.target)
        for (const f of e.target.targetElements)
          r.add($(f, ee.CLICK, () => this.hideHover()));
      else
        r.add($(e.target, ee.CLICK, () => this.hideHover()));
      const u = Gi();
      if (u) {
        const f = ue(u).document;
        r.add($(u, ee.KEY_DOWN, (g) => {
          var m;
          return this._keyDown(g, a, !!((m = e.persistence) != null && m.hideOnKeyDown));
        })), r.add($(f, ee.KEY_DOWN, (g) => {
          var m;
          return this._keyDown(g, a, !!((m = e.persistence) != null && m.hideOnKeyDown));
        })), r.add($(u, ee.KEY_UP, (g) => this._keyUp(g, a))), r.add($(f, ee.KEY_UP, (g) => this._keyUp(g, a)));
      }
    }
    if ("IntersectionObserver" in ut) {
      const u = new IntersectionObserver((g) => this._intersectionChange(g, a), { threshold: 0 }), f = "targetElements" in e.target ? e.target.targetElements[0] : e.target;
      u.observe(f), r.add(ke(() => u.disconnect()));
    }
    return this._currentHover = a, a;
  }
  hideHover() {
    var e;
    (e = this._currentHover) != null && e.isLocked || !this._currentHoverOptions || this.doHideHover();
  }
  doHideHover() {
    this._currentHover = void 0, this._currentHoverOptions = void 0, this._contextViewHandler.hideContextView();
  }
  _intersectionChange(e, t) {
    e[e.length - 1].isIntersecting || t.dispose();
  }
  showAndFocusLastHover() {
    this._lastHoverOptions && this.showHover(this._lastHoverOptions, !0, !0);
  }
  _keyDown(e, t, i) {
    var r, a;
    if (e.key === "Alt") {
      t.isLocked = !0;
      return;
    }
    const n = new Lt(e);
    this._keybindingService.resolveKeyboardEvent(n).getSingleModifierDispatchChords().some((l) => !!l) || this._keybindingService.softDispatch(n, n.target).kind !== 0 || i && (!((r = this._currentHoverOptions) != null && r.trapFocus) || e.key !== "Tab") && (this.hideHover(), (a = this._lastFocusedElementBeforeOpen) == null || a.focus());
  }
  _keyUp(e, t) {
    var i;
    e.key === "Alt" && (t.isLocked = !1, t.isMouseIn || (this.hideHover(), (i = this._lastFocusedElementBeforeOpen) == null || i.focus()));
  }
  // TODO: Investigate performance of this function. There seems to be a lot of content created
  //       and thrown away on start up
  setupManagedHover(e, t, i, n) {
    t.setAttribute("custom-hover", "true"), t.title !== "" && (console.warn("HTML element already has a title attribute, which will conflict with the custom hover. Please remove the title attribute."), console.trace("Stack trace:", t.title), t.title = "");
    let o, r;
    const a = (v, w) => {
      var L;
      const S = r !== void 0;
      v && (r == null || r.dispose(), r = void 0), w && (o == null || o.dispose(), o = void 0), S && ((L = e.onDidHideHover) == null || L.call(e), r = void 0);
    }, l = (v, w, S, L) => new Ic(async () => {
      (!r || r.isDisposed) && (r = new _V(e, S || t, v > 0), await r.update(typeof i == "function" ? i() : i, w, { ...n, trapFocus: L }));
    }, v);
    let c = !1;
    const h = $(t, ee.MOUSE_DOWN, () => {
      c = !0, a(!0, !0);
    }, !0), d = $(t, ee.MOUSE_UP, () => {
      c = !1;
    }, !0), u = $(t, ee.MOUSE_LEAVE, (v) => {
      c = !1, a(!1, v.fromElement === t);
    }, !0), f = (v) => {
      if (o)
        return;
      const w = new he(), S = {
        targetElements: [t],
        dispose: () => {
        }
      };
      if (e.placement === void 0 || e.placement === "mouse") {
        const L = (k) => {
          S.x = k.x + 10, yi(k.target) && SI(k.target, t) !== t && a(!0, !0);
        };
        w.add($(t, ee.MOUSE_MOVE, L, !0));
      }
      o = w, !(yi(v.target) && SI(v.target, t) !== t) && w.add(l(e.delay, !1, S));
    }, g = $(t, ee.MOUSE_OVER, f, !0), m = () => {
      if (c || o)
        return;
      const v = {
        targetElements: [t],
        dispose: () => {
        }
      }, w = new he(), S = () => a(!0, !0);
      w.add($(t, ee.BLUR, S, !0)), w.add(l(e.delay, !1, v)), o = w;
    };
    let _;
    const b = t.tagName.toLowerCase();
    b !== "input" && b !== "textarea" && (_ = $(t, ee.FOCUS, m, !0));
    const C = {
      show: (v) => {
        a(!1, !0), l(0, v, void 0, v);
      },
      hide: () => {
        a(!0, !0);
      },
      update: async (v, w) => {
        i = v, await (r == null ? void 0 : r.update(i, void 0, w));
      },
      dispose: () => {
        this._managedHovers.delete(t), g.dispose(), u.dispose(), h.dispose(), d.dispose(), _ == null || _.dispose(), a(!0, !0);
      }
    };
    return this._managedHovers.set(t, C), C;
  }
  showManagedHover(e) {
    const t = this._managedHovers.get(e);
    t && t.show(!0);
  }
  dispose() {
    this._managedHovers.forEach((e) => e.dispose()), super.dispose();
  }
};
Jv = bV([
  fu(0, ot),
  fu(1, ea),
  fu(2, Ai),
  fu(3, Xa),
  fu(4, go)
], Jv);
function yI(s) {
  if (s !== void 0)
    return (s == null ? void 0 : s.id) ?? s;
}
class CV {
  get anchorPosition() {
    return this._hover.anchor;
  }
  constructor(e, t = !1) {
    this._hover = e, this._focus = t, this.layer = 1;
  }
  render(e) {
    return this._hover.render(e), this._focus && this._hover.focus(), this._hover;
  }
  getAnchor() {
    return {
      x: this._hover.x,
      y: this._hover.y
    };
  }
  layout() {
    this._hover.layout();
  }
}
function SI(s, e) {
  for (e = e ?? ue(s).document.body; !s.hasAttribute("custom-hover") && s !== e; )
    s = s.parentElement;
  return s;
}
Ge(
  Ag,
  Jv,
  1
  /* InstantiationType.Delayed */
);
Jr((s, e) => {
  const t = s.getColor(s8);
  t && (e.addRule(`.monaco-workbench .workbench-hover .hover-row:not(:first-child):not(:empty) { border-top: 1px solid ${t.transparent(0.5)}; }`), e.addRule(`.monaco-workbench .workbench-hover hr { border-top: 1px solid ${t.transparent(0.5)}; }`));
});
const wV = Ve("IWorkspaceEditService");
class Lk {
  constructor(e) {
    this.metadata = e;
  }
  static convert(e) {
    return e.edits.map((t) => {
      if (Ql.is(t))
        return Ql.lift(t);
      if (Qh.is(t))
        return Qh.lift(t);
      throw new Error("Unsupported edit");
    });
  }
}
class Ql extends Lk {
  static is(e) {
    return e instanceof Ql ? !0 : _n(e) && Te.isUri(e.resource) && _n(e.textEdit);
  }
  static lift(e) {
    return e instanceof Ql ? e : new Ql(e.resource, e.textEdit, e.versionId, e.metadata);
  }
  constructor(e, t, i = void 0, n) {
    super(n), this.resource = e, this.textEdit = t, this.versionId = i;
  }
}
class Qh extends Lk {
  static is(e) {
    return e instanceof Qh ? !0 : _n(e) && (!!e.newResource || !!e.oldResource);
  }
  static lift(e) {
    return e instanceof Qh ? e : new Qh(e.oldResource, e.newResource, e.options, e.metadata);
  }
  constructor(e, t, i = {}, n) {
    super(n), this.oldResource = e, this.newResource = t, this.options = i;
  }
}
const xi = {
  enableSplitViewResizing: !0,
  renderSideBySide: !0,
  renderMarginRevertIcon: !0,
  renderGutterMenu: !0,
  maxComputationTime: 5e3,
  maxFileSize: 50,
  ignoreTrimWhitespace: !0,
  renderIndicators: !0,
  originalEditable: !1,
  diffCodeLens: !1,
  renderOverviewRuler: !0,
  diffWordWrap: "inherit",
  diffAlgorithm: "advanced",
  accessibilityVerbose: !1,
  experimental: {
    showMoves: !1,
    showEmptyDecorations: !0,
    useTrueInlineView: !1
  },
  hideUnchangedRegions: {
    enabled: !1,
    contextLineCount: 3,
    minimumLineCount: 3,
    revealLineCount: 20
  },
  isInEmbeddedEditor: !1,
  onlyShowAccessibleDiffViewer: !1,
  renderSideBySideInlineBreakpoint: 900,
  useInlineViewWhenSpaceIsLimited: !0,
  compactMode: !1
}, vV = Object.freeze({
  id: "editor",
  order: 5,
  type: "object",
  title: p("editorConfigurationTitle", "Editor"),
  scope: 5
}), t_ = {
  ...vV,
  properties: {
    "editor.tabSize": {
      type: "number",
      default: Oi.tabSize,
      minimum: 1,
      markdownDescription: p("tabSize", "The number of spaces a tab is equal to. This setting is overridden based on the file contents when {0} is on.", "`#editor.detectIndentation#`")
    },
    "editor.indentSize": {
      anyOf: [
        {
          type: "string",
          enum: ["tabSize"]
        },
        {
          type: "number",
          minimum: 1
        }
      ],
      default: "tabSize",
      markdownDescription: p("indentSize", 'The number of spaces used for indentation or `"tabSize"` to use the value from `#editor.tabSize#`. This setting is overridden based on the file contents when `#editor.detectIndentation#` is on.')
    },
    "editor.insertSpaces": {
      type: "boolean",
      default: Oi.insertSpaces,
      markdownDescription: p("insertSpaces", "Insert spaces when pressing `Tab`. This setting is overridden based on the file contents when {0} is on.", "`#editor.detectIndentation#`")
    },
    "editor.detectIndentation": {
      type: "boolean",
      default: Oi.detectIndentation,
      markdownDescription: p("detectIndentation", "Controls whether {0} and {1} will be automatically detected when a file is opened based on the file contents.", "`#editor.tabSize#`", "`#editor.insertSpaces#`")
    },
    "editor.trimAutoWhitespace": {
      type: "boolean",
      default: Oi.trimAutoWhitespace,
      description: p("trimAutoWhitespace", "Remove trailing auto inserted whitespace.")
    },
    "editor.largeFileOptimizations": {
      type: "boolean",
      default: Oi.largeFileOptimizations,
      description: p("largeFileOptimizations", "Special handling for large files to disable certain memory intensive features.")
    },
    "editor.wordBasedSuggestions": {
      enum: ["off", "currentDocument", "matchingDocuments", "allDocuments"],
      default: "matchingDocuments",
      enumDescriptions: [
        p("wordBasedSuggestions.off", "Turn off Word Based Suggestions."),
        p("wordBasedSuggestions.currentDocument", "Only suggest words from the active document."),
        p("wordBasedSuggestions.matchingDocuments", "Suggest words from all open documents of the same language."),
        p("wordBasedSuggestions.allDocuments", "Suggest words from all open documents.")
      ],
      description: p("wordBasedSuggestions", "Controls whether completions should be computed based on words in the document and from which documents they are computed.")
    },
    "editor.semanticHighlighting.enabled": {
      enum: [!0, !1, "configuredByTheme"],
      enumDescriptions: [
        p("semanticHighlighting.true", "Semantic highlighting enabled for all color themes."),
        p("semanticHighlighting.false", "Semantic highlighting disabled for all color themes."),
        p("semanticHighlighting.configuredByTheme", "Semantic highlighting is configured by the current color theme's `semanticHighlighting` setting.")
      ],
      default: "configuredByTheme",
      description: p("semanticHighlighting.enabled", "Controls whether the semanticHighlighting is shown for the languages that support it.")
    },
    "editor.stablePeek": {
      type: "boolean",
      default: !1,
      markdownDescription: p("stablePeek", "Keep peek editors open even when double-clicking their content or when hitting `Escape`.")
    },
    "editor.maxTokenizationLineLength": {
      type: "integer",
      default: 2e4,
      description: p("maxTokenizationLineLength", "Lines above this length will not be tokenized for performance reasons")
    },
    "editor.experimental.asyncTokenization": {
      type: "boolean",
      default: !0,
      description: p("editor.experimental.asyncTokenization", "Controls whether the tokenization should happen asynchronously on a web worker."),
      tags: ["experimental"]
    },
    "editor.experimental.asyncTokenizationLogging": {
      type: "boolean",
      default: !1,
      description: p("editor.experimental.asyncTokenizationLogging", "Controls whether async tokenization should be logged. For debugging only.")
    },
    "editor.experimental.asyncTokenizationVerification": {
      type: "boolean",
      default: !1,
      description: p("editor.experimental.asyncTokenizationVerification", "Controls whether async tokenization should be verified against legacy background tokenization. Might slow down tokenization. For debugging only."),
      tags: ["experimental"]
    },
    "editor.experimental.treeSitterTelemetry": {
      type: "boolean",
      default: !1,
      markdownDescription: p("editor.experimental.treeSitterTelemetry", "Controls whether tree sitter parsing should be turned on and telemetry collected. Setting `editor.experimental.preferTreeSitter` for specific languages will take precedence."),
      tags: ["experimental"]
    },
    "editor.language.brackets": {
      type: ["array", "null"],
      default: null,
      // We want to distinguish the empty array from not configured.
      description: p("schema.brackets", "Defines the bracket symbols that increase or decrease the indentation."),
      items: {
        type: "array",
        items: [
          {
            type: "string",
            description: p("schema.openBracket", "The opening bracket character or string sequence.")
          },
          {
            type: "string",
            description: p("schema.closeBracket", "The closing bracket character or string sequence.")
          }
        ]
      }
    },
    "editor.language.colorizedBracketPairs": {
      type: ["array", "null"],
      default: null,
      // We want to distinguish the empty array from not configured.
      description: p("schema.colorizedBracketPairs", "Defines the bracket pairs that are colorized by their nesting level if bracket pair colorization is enabled."),
      items: {
        type: "array",
        items: [
          {
            type: "string",
            description: p("schema.openBracket", "The opening bracket character or string sequence.")
          },
          {
            type: "string",
            description: p("schema.closeBracket", "The closing bracket character or string sequence.")
          }
        ]
      }
    },
    "diffEditor.maxComputationTime": {
      type: "number",
      default: xi.maxComputationTime,
      description: p("maxComputationTime", "Timeout in milliseconds after which diff computation is cancelled. Use 0 for no timeout.")
    },
    "diffEditor.maxFileSize": {
      type: "number",
      default: xi.maxFileSize,
      description: p("maxFileSize", "Maximum file size in MB for which to compute diffs. Use 0 for no limit.")
    },
    "diffEditor.renderSideBySide": {
      type: "boolean",
      default: xi.renderSideBySide,
      description: p("sideBySide", "Controls whether the diff editor shows the diff side by side or inline.")
    },
    "diffEditor.renderSideBySideInlineBreakpoint": {
      type: "number",
      default: xi.renderSideBySideInlineBreakpoint,
      description: p("renderSideBySideInlineBreakpoint", "If the diff editor width is smaller than this value, the inline view is used.")
    },
    "diffEditor.useInlineViewWhenSpaceIsLimited": {
      type: "boolean",
      default: xi.useInlineViewWhenSpaceIsLimited,
      description: p("useInlineViewWhenSpaceIsLimited", "If enabled and the editor width is too small, the inline view is used.")
    },
    "diffEditor.renderMarginRevertIcon": {
      type: "boolean",
      default: xi.renderMarginRevertIcon,
      description: p("renderMarginRevertIcon", "When enabled, the diff editor shows arrows in its glyph margin to revert changes.")
    },
    "diffEditor.renderGutterMenu": {
      type: "boolean",
      default: xi.renderGutterMenu,
      description: p("renderGutterMenu", "When enabled, the diff editor shows a special gutter for revert and stage actions.")
    },
    "diffEditor.ignoreTrimWhitespace": {
      type: "boolean",
      default: xi.ignoreTrimWhitespace,
      description: p("ignoreTrimWhitespace", "When enabled, the diff editor ignores changes in leading or trailing whitespace.")
    },
    "diffEditor.renderIndicators": {
      type: "boolean",
      default: xi.renderIndicators,
      description: p("renderIndicators", "Controls whether the diff editor shows +/- indicators for added/removed changes.")
    },
    "diffEditor.codeLens": {
      type: "boolean",
      default: xi.diffCodeLens,
      description: p("codeLens", "Controls whether the editor shows CodeLens.")
    },
    "diffEditor.wordWrap": {
      type: "string",
      enum: ["off", "on", "inherit"],
      default: xi.diffWordWrap,
      markdownEnumDescriptions: [
        p("wordWrap.off", "Lines will never wrap."),
        p("wordWrap.on", "Lines will wrap at the viewport width."),
        p("wordWrap.inherit", "Lines will wrap according to the {0} setting.", "`#editor.wordWrap#`")
      ]
    },
    "diffEditor.diffAlgorithm": {
      type: "string",
      enum: ["legacy", "advanced"],
      default: xi.diffAlgorithm,
      markdownEnumDescriptions: [
        p("diffAlgorithm.legacy", "Uses the legacy diffing algorithm."),
        p("diffAlgorithm.advanced", "Uses the advanced diffing algorithm.")
      ],
      tags: ["experimental"]
    },
    "diffEditor.hideUnchangedRegions.enabled": {
      type: "boolean",
      default: xi.hideUnchangedRegions.enabled,
      markdownDescription: p("hideUnchangedRegions.enabled", "Controls whether the diff editor shows unchanged regions.")
    },
    "diffEditor.hideUnchangedRegions.revealLineCount": {
      type: "integer",
      default: xi.hideUnchangedRegions.revealLineCount,
      markdownDescription: p("hideUnchangedRegions.revealLineCount", "Controls how many lines are used for unchanged regions."),
      minimum: 1
    },
    "diffEditor.hideUnchangedRegions.minimumLineCount": {
      type: "integer",
      default: xi.hideUnchangedRegions.minimumLineCount,
      markdownDescription: p("hideUnchangedRegions.minimumLineCount", "Controls how many lines are used as a minimum for unchanged regions."),
      minimum: 1
    },
    "diffEditor.hideUnchangedRegions.contextLineCount": {
      type: "integer",
      default: xi.hideUnchangedRegions.contextLineCount,
      markdownDescription: p("hideUnchangedRegions.contextLineCount", "Controls how many lines are used as context when comparing unchanged regions."),
      minimum: 1
    },
    "diffEditor.experimental.showMoves": {
      type: "boolean",
      default: xi.experimental.showMoves,
      markdownDescription: p("showMoves", "Controls whether the diff editor should show detected code moves.")
    },
    "diffEditor.experimental.showEmptyDecorations": {
      type: "boolean",
      default: xi.experimental.showEmptyDecorations,
      description: p("showEmptyDecorations", "Controls whether the diff editor shows empty decorations to see where characters got inserted or deleted.")
    },
    "diffEditor.experimental.useTrueInlineView": {
      type: "boolean",
      default: xi.experimental.useTrueInlineView,
      description: p("useTrueInlineView", "If enabled and the editor uses the inline view, word changes are rendered inline.")
    }
  }
};
function yV(s) {
  return typeof s.type < "u" || typeof s.anyOf < "u";
}
for (const s of ch) {
  const e = s.schema;
  if (typeof e < "u")
    if (yV(e))
      t_.properties[`editor.${s.name}`] = e;
    else
      for (const t in e)
        Object.hasOwnProperty.call(e, t) && (t_.properties[t] = e[t]);
}
let _m = null;
function dA() {
  return _m === null && (_m = /* @__PURE__ */ Object.create(null), Object.keys(t_.properties).forEach((s) => {
    _m[s] = !0;
  })), _m;
}
function SV(s) {
  return dA()[`editor.${s}`] || !1;
}
function LV(s) {
  return dA()[`diffEditor.${s}`] || !1;
}
const kV = Li.as(Oc.Configuration);
kV.registerConfiguration(t_);
class xV {
  static insert(e, t) {
    return {
      range: new R(e.lineNumber, e.column, e.lineNumber, e.column),
      text: t,
      forceMoveMarkers: !0
    };
  }
  static delete(e) {
    return {
      range: e,
      text: null
    };
  }
  static replace(e, t) {
    return {
      range: e,
      text: t
    };
  }
  static replaceMove(e, t) {
    return {
      range: e,
      text: t,
      forceMoveMarkers: !0
    };
  }
}
function bm(s) {
  return Object.isFrozen(s) ? s : q5(s);
}
class vi {
  static createEmptyModel(e) {
    return new vi({}, [], [], void 0, e);
  }
  constructor(e, t, i, n, o) {
    this._contents = e, this._keys = t, this._overrides = i, this.raw = n, this.logService = o, this.overrideConfigurations = /* @__PURE__ */ new Map();
  }
  get rawConfiguration() {
    var e;
    if (!this._rawConfiguration)
      if ((e = this.raw) != null && e.length) {
        const t = this.raw.map((i) => {
          if (i instanceof vi)
            return i;
          const n = new DV("", this.logService);
          return n.parseRaw(i), n.configurationModel;
        });
        this._rawConfiguration = t.reduce((i, n) => n === i ? n : i.merge(n), t[0]);
      } else
        this._rawConfiguration = this;
    return this._rawConfiguration;
  }
  get contents() {
    return this._contents;
  }
  get overrides() {
    return this._overrides;
  }
  get keys() {
    return this._keys;
  }
  isEmpty() {
    return this._keys.length === 0 && Object.keys(this._contents).length === 0 && this._overrides.length === 0;
  }
  getValue(e) {
    return e ? QD(this.contents, e) : this.contents;
  }
  inspect(e, t) {
    const i = this;
    return {
      get value() {
        return bm(i.rawConfiguration.getValue(e));
      },
      get override() {
        return t ? bm(i.rawConfiguration.getOverrideValue(e, t)) : void 0;
      },
      get merged() {
        return bm(t ? i.rawConfiguration.override(t).getValue(e) : i.rawConfiguration.getValue(e));
      },
      get overrides() {
        const n = [];
        for (const { contents: o, identifiers: r, keys: a } of i.rawConfiguration.overrides) {
          const l = new vi(o, a, [], void 0, i.logService).getValue(e);
          l !== void 0 && n.push({ identifiers: r, value: l });
        }
        return n.length ? bm(n) : void 0;
      }
    };
  }
  getOverrideValue(e, t) {
    const i = this.getContentsForOverrideIdentifer(t);
    return i ? e ? QD(i, e) : i : void 0;
  }
  override(e) {
    let t = this.overrideConfigurations.get(e);
    return t || (t = this.createOverrideConfigurationModel(e), this.overrideConfigurations.set(e, t)), t;
  }
  merge(...e) {
    var r, a;
    const t = fa(this.contents), i = fa(this.overrides), n = [...this.keys], o = (r = this.raw) != null && r.length ? [...this.raw] : [this];
    for (const l of e)
      if (o.push(...(a = l.raw) != null && a.length ? l.raw : [l]), !l.isEmpty()) {
        this.mergeContents(t, l.contents);
        for (const c of l.overrides) {
          const [h] = i.filter((d) => oi(d.identifiers, c.identifiers));
          h ? (this.mergeContents(h.contents, c.contents), h.keys.push(...c.keys), h.keys = uc(h.keys)) : i.push(fa(c));
        }
        for (const c of l.keys)
          n.indexOf(c) === -1 && n.push(c);
      }
    return new vi(t, n, i, o.every((l) => l instanceof vi) ? void 0 : o, this.logService);
  }
  createOverrideConfigurationModel(e) {
    const t = this.getContentsForOverrideIdentifer(e);
    if (!t || typeof t != "object" || !Object.keys(t).length)
      return this;
    const i = {};
    for (const n of uc([...Object.keys(this.contents), ...Object.keys(t)])) {
      let o = this.contents[n];
      const r = t[n];
      r && (typeof o == "object" && typeof r == "object" ? (o = fa(o), this.mergeContents(o, r)) : o = r), i[n] = o;
    }
    return new vi(i, this.keys, this.overrides, void 0, this.logService);
  }
  mergeContents(e, t) {
    for (const i of Object.keys(t)) {
      if (i in e && _n(e[i]) && _n(t[i])) {
        this.mergeContents(e[i], t[i]);
        continue;
      }
      e[i] = fa(t[i]);
    }
  }
  getContentsForOverrideIdentifer(e) {
    let t = null, i = null;
    const n = (o) => {
      o && (i ? this.mergeContents(i, o) : i = fa(o));
    };
    for (const o of this.overrides)
      o.identifiers.length === 1 && o.identifiers[0] === e ? t = o.contents : o.identifiers.includes(e) && n(o.contents);
    return n(t), i;
  }
  toJSON() {
    return {
      contents: this.contents,
      overrides: this.overrides,
      keys: this.keys
    };
  }
  setValue(e, t) {
    this.updateValue(e, t, !1);
  }
  removeValue(e) {
    const t = this.keys.indexOf(e);
    t !== -1 && (this.keys.splice(t, 1), D3(this.contents, e), $a.test(e) && this.overrides.splice(this.overrides.findIndex((i) => oi(i.identifiers, Mp(e))), 1));
  }
  updateValue(e, t, i) {
    if (UM(this.contents, e, t, (n) => this.logService.error(n)), i = i || this.keys.indexOf(e) === -1, i && this.keys.push(e), $a.test(e)) {
      const n = Mp(e), o = {
        identifiers: n,
        keys: Object.keys(this.contents[e]),
        contents: av(this.contents[e], (a) => this.logService.error(a))
      }, r = this.overrides.findIndex((a) => oi(a.identifiers, n));
      r !== -1 ? this.overrides[r] = o : this.overrides.push(o);
    }
  }
}
class DV {
  constructor(e, t) {
    this._name = e, this.logService = t, this._raw = null, this._configurationModel = null, this._restrictedConfigurations = [];
  }
  get configurationModel() {
    return this._configurationModel || vi.createEmptyModel(this.logService);
  }
  parseRaw(e, t) {
    this._raw = e;
    const { contents: i, keys: n, overrides: o, restricted: r, hasExcludedProperties: a } = this.doParseRaw(e, t);
    this._configurationModel = new vi(i, n, o, a ? [e] : void 0, this.logService), this._restrictedConfigurations = r || [];
  }
  doParseRaw(e, t) {
    const i = Li.as(Oc.Configuration).getConfigurationProperties(), n = this.filter(e, i, !0, t);
    e = n.raw;
    const o = av(e, (l) => this.logService.error(`Conflict in settings file ${this._name}: ${l}`)), r = Object.keys(e), a = this.toOverrides(e, (l) => this.logService.error(`Conflict in settings file ${this._name}: ${l}`));
    return { contents: o, keys: r, overrides: a, restricted: n.restricted, hasExcludedProperties: n.hasExcludedProperties };
  }
  filter(e, t, i, n) {
    var l, c, h;
    let o = !1;
    if (!(n != null && n.scopes) && !(n != null && n.skipRestricted) && !((l = n == null ? void 0 : n.exclude) != null && l.length))
      return { raw: e, restricted: [], hasExcludedProperties: o };
    const r = {}, a = [];
    for (const d in e)
      if ($a.test(d) && i) {
        const u = this.filter(e[d], t, !1, n);
        r[d] = u.raw, o = o || u.hasExcludedProperties, a.push(...u.restricted);
      } else {
        const u = t[d], f = u ? typeof u.scope < "u" ? u.scope : 3 : void 0;
        u != null && u.restricted && a.push(d), !((c = n.exclude) != null && c.includes(d)) && ((h = n.include) != null && h.includes(d) || (f === void 0 || n.scopes === void 0 || n.scopes.includes(f)) && !(n.skipRestricted && (u != null && u.restricted))) ? r[d] = e[d] : o = !0;
      }
    return { raw: r, restricted: a, hasExcludedProperties: o };
  }
  toOverrides(e, t) {
    const i = [];
    for (const n of Object.keys(e))
      if ($a.test(n)) {
        const o = {};
        for (const r in e[n])
          o[r] = e[n][r];
        i.push({
          identifiers: Mp(n),
          keys: Object.keys(o),
          contents: av(o, t)
        });
      }
    return i;
  }
}
class EV {
  constructor(e, t, i, n, o, r, a, l, c, h, d, u, f) {
    this.key = e, this.overrides = t, this._value = i, this.overrideIdentifiers = n, this.defaultConfiguration = o, this.policyConfiguration = r, this.applicationConfiguration = a, this.userConfiguration = l, this.localUserConfiguration = c, this.remoteUserConfiguration = h, this.workspaceConfiguration = d, this.folderConfigurationModel = u, this.memoryConfigurationModel = f;
  }
  toInspectValue(e) {
    return (e == null ? void 0 : e.value) !== void 0 || (e == null ? void 0 : e.override) !== void 0 || (e == null ? void 0 : e.overrides) !== void 0 ? e : void 0;
  }
  get userInspectValue() {
    return this._userInspectValue || (this._userInspectValue = this.userConfiguration.inspect(this.key, this.overrides.overrideIdentifier)), this._userInspectValue;
  }
  get user() {
    return this.toInspectValue(this.userInspectValue);
  }
}
class Ib {
  constructor(e, t, i, n, o, r, a, l, c, h) {
    this._defaultConfiguration = e, this._policyConfiguration = t, this._applicationConfiguration = i, this._localUserConfiguration = n, this._remoteUserConfiguration = o, this._workspaceConfiguration = r, this._folderConfigurations = a, this._memoryConfiguration = l, this._memoryConfigurationByResource = c, this.logService = h, this._workspaceConsolidatedConfiguration = null, this._foldersConsolidatedConfigurations = new ts(), this._userConfiguration = null;
  }
  getValue(e, t, i) {
    return this.getConsolidatedConfigurationModel(e, t, i).getValue(e);
  }
  updateValue(e, t, i = {}) {
    let n;
    i.resource ? (n = this._memoryConfigurationByResource.get(i.resource), n || (n = vi.createEmptyModel(this.logService), this._memoryConfigurationByResource.set(i.resource, n))) : n = this._memoryConfiguration, t === void 0 ? n.removeValue(e) : n.setValue(e, t), i.resource || (this._workspaceConsolidatedConfiguration = null);
  }
  inspect(e, t, i) {
    const n = this.getConsolidatedConfigurationModel(e, t, i), o = this.getFolderConfigurationModelForResource(t.resource, i), r = t.resource ? this._memoryConfigurationByResource.get(t.resource) || this._memoryConfiguration : this._memoryConfiguration, a = /* @__PURE__ */ new Set();
    for (const l of n.overrides)
      for (const c of l.identifiers)
        n.getOverrideValue(e, c) !== void 0 && a.add(c);
    return new EV(e, t, n.getValue(e), a.size ? [...a] : void 0, this._defaultConfiguration, this._policyConfiguration.isEmpty() ? void 0 : this._policyConfiguration, this.applicationConfiguration.isEmpty() ? void 0 : this.applicationConfiguration, this.userConfiguration, this.localUserConfiguration, this.remoteUserConfiguration, i ? this._workspaceConfiguration : void 0, o || void 0, r);
  }
  get applicationConfiguration() {
    return this._applicationConfiguration;
  }
  get userConfiguration() {
    return this._userConfiguration || (this._userConfiguration = this._remoteUserConfiguration.isEmpty() ? this._localUserConfiguration : this._localUserConfiguration.merge(this._remoteUserConfiguration)), this._userConfiguration;
  }
  get localUserConfiguration() {
    return this._localUserConfiguration;
  }
  get remoteUserConfiguration() {
    return this._remoteUserConfiguration;
  }
  getConsolidatedConfigurationModel(e, t, i) {
    let n = this.getConsolidatedConfigurationModelForResource(t, i);
    return t.overrideIdentifier && (n = n.override(t.overrideIdentifier)), !this._policyConfiguration.isEmpty() && this._policyConfiguration.getValue(e) !== void 0 && (n = n.merge(this._policyConfiguration)), n;
  }
  getConsolidatedConfigurationModelForResource({ resource: e }, t) {
    let i = this.getWorkspaceConsolidatedConfiguration();
    if (t && e) {
      const n = t.getFolder(e);
      n && (i = this.getFolderConsolidatedConfiguration(n.uri) || i);
      const o = this._memoryConfigurationByResource.get(e);
      o && (i = i.merge(o));
    }
    return i;
  }
  getWorkspaceConsolidatedConfiguration() {
    return this._workspaceConsolidatedConfiguration || (this._workspaceConsolidatedConfiguration = this._defaultConfiguration.merge(this.applicationConfiguration, this.userConfiguration, this._workspaceConfiguration, this._memoryConfiguration)), this._workspaceConsolidatedConfiguration;
  }
  getFolderConsolidatedConfiguration(e) {
    let t = this._foldersConsolidatedConfigurations.get(e);
    if (!t) {
      const i = this.getWorkspaceConsolidatedConfiguration(), n = this._folderConfigurations.get(e);
      n ? (t = i.merge(n), this._foldersConsolidatedConfigurations.set(e, t)) : t = i;
    }
    return t;
  }
  getFolderConfigurationModelForResource(e, t) {
    if (t && e) {
      const i = t.getFolder(e);
      if (i)
        return this._folderConfigurations.get(i.uri);
    }
  }
  toData() {
    return {
      defaults: {
        contents: this._defaultConfiguration.contents,
        overrides: this._defaultConfiguration.overrides,
        keys: this._defaultConfiguration.keys
      },
      policy: {
        contents: this._policyConfiguration.contents,
        overrides: this._policyConfiguration.overrides,
        keys: this._policyConfiguration.keys
      },
      application: {
        contents: this.applicationConfiguration.contents,
        overrides: this.applicationConfiguration.overrides,
        keys: this.applicationConfiguration.keys
      },
      user: {
        contents: this.userConfiguration.contents,
        overrides: this.userConfiguration.overrides,
        keys: this.userConfiguration.keys
      },
      workspace: {
        contents: this._workspaceConfiguration.contents,
        overrides: this._workspaceConfiguration.overrides,
        keys: this._workspaceConfiguration.keys
      },
      folders: [...this._folderConfigurations.keys()].reduce((e, t) => {
        const { contents: i, overrides: n, keys: o } = this._folderConfigurations.get(t);
        return e.push([t, { contents: i, overrides: n, keys: o }]), e;
      }, [])
    };
  }
  static parse(e, t) {
    const i = this.parseConfigurationModel(e.defaults, t), n = this.parseConfigurationModel(e.policy, t), o = this.parseConfigurationModel(e.application, t), r = this.parseConfigurationModel(e.user, t), a = this.parseConfigurationModel(e.workspace, t), l = e.folders.reduce((c, h) => (c.set(Te.revive(h[0]), this.parseConfigurationModel(h[1], t)), c), new ts());
    return new Ib(i, n, o, r, vi.createEmptyModel(t), a, l, vi.createEmptyModel(t), new ts(), t);
  }
  static parseConfigurationModel(e, t) {
    return new vi(e.contents, e.keys, e.overrides, void 0, t);
  }
}
class IV {
  constructor(e, t, i, n, o) {
    this.change = e, this.previous = t, this.currentConfiguraiton = i, this.currentWorkspace = n, this.logService = o, this._marker = `
`, this._markerCode1 = this._marker.charCodeAt(0), this._markerCode2 = 46, this.affectedKeys = /* @__PURE__ */ new Set(), this._previousConfiguration = void 0;
    for (const r of e.keys)
      this.affectedKeys.add(r);
    for (const [, r] of e.overrides)
      for (const a of r)
        this.affectedKeys.add(a);
    this._affectsConfigStr = this._marker;
    for (const r of this.affectedKeys)
      this._affectsConfigStr += r + this._marker;
  }
  get previousConfiguration() {
    return !this._previousConfiguration && this.previous && (this._previousConfiguration = Ib.parse(this.previous.data, this.logService)), this._previousConfiguration;
  }
  affectsConfiguration(e, t) {
    var a;
    const i = this._marker + e, n = this._affectsConfigStr.indexOf(i);
    if (n < 0)
      return !1;
    const o = n + i.length;
    if (o >= this._affectsConfigStr.length)
      return !1;
    const r = this._affectsConfigStr.charCodeAt(o);
    if (r !== this._markerCode1 && r !== this._markerCode2)
      return !1;
    if (t) {
      const l = this.previousConfiguration ? this.previousConfiguration.getValue(e, t, (a = this.previous) == null ? void 0 : a.workspace) : void 0, c = this.currentConfiguraiton.getValue(e, t, this.currentWorkspace);
      return !Pn(l, c);
    }
    return !0;
  }
}
class NV {
  constructor() {
    this._onDidChange = new O(), this.onDidChange = this._onDidChange.event, this._enabled = !0;
  }
  get enabled() {
    return this._enabled;
  }
  /**
   * Enable IME
   */
  enable() {
    this._enabled = !0, this._onDidChange.fire();
  }
  /**
   * Disable IME
   */
  disable() {
    this._enabled = !1, this._onDidChange.fire();
  }
}
const $u = new NV(), i_ = {
  kind: 0
  /* ResultKind.NoMatchingKb */
}, TV = {
  kind: 1
  /* ResultKind.MoreChordsNeeded */
};
function MV(s, e, t) {
  return { kind: 2, commandId: s, commandArgs: e, isBubble: t };
}
class Ku {
  constructor(e, t, i) {
    var n;
    this._log = i, this._defaultKeybindings = e, this._defaultBoundCommands = /* @__PURE__ */ new Map();
    for (const o of e) {
      const r = o.command;
      r && r.charAt(0) !== "-" && this._defaultBoundCommands.set(r, !0);
    }
    this._map = /* @__PURE__ */ new Map(), this._lookupMap = /* @__PURE__ */ new Map(), this._keybindings = Ku.handleRemovals([].concat(e).concat(t));
    for (let o = 0, r = this._keybindings.length; o < r; o++) {
      const a = this._keybindings[o];
      if (a.chords.length === 0)
        continue;
      const l = (n = a.when) == null ? void 0 : n.substituteConstants();
      l && l.type === 0 || this._addKeyPress(a.chords[0], a);
    }
  }
  static _isTargetedForRemoval(e, t, i) {
    if (t) {
      for (let n = 0; n < t.length; n++)
        if (t[n] !== e.chords[n])
          return !1;
    }
    return !(i && i.type !== 1 && (!e.when || !V7(i, e.when)));
  }
  /**
   * Looks for rules containing "-commandId" and removes them.
   */
  static handleRemovals(e) {
    const t = /* @__PURE__ */ new Map();
    for (let n = 0, o = e.length; n < o; n++) {
      const r = e[n];
      if (r.command && r.command.charAt(0) === "-") {
        const a = r.command.substring(1);
        t.has(a) ? t.get(a).push(r) : t.set(a, [r]);
      }
    }
    if (t.size === 0)
      return e;
    const i = [];
    for (let n = 0, o = e.length; n < o; n++) {
      const r = e[n];
      if (!r.command || r.command.length === 0) {
        i.push(r);
        continue;
      }
      if (r.command.charAt(0) === "-")
        continue;
      const a = t.get(r.command);
      if (!a || !r.isDefault) {
        i.push(r);
        continue;
      }
      let l = !1;
      for (const c of a) {
        const h = c.when;
        if (this._isTargetedForRemoval(r, c.chords, h)) {
          l = !0;
          break;
        }
      }
      if (!l) {
        i.push(r);
        continue;
      }
    }
    return i;
  }
  _addKeyPress(e, t) {
    const i = this._map.get(e);
    if (typeof i > "u") {
      this._map.set(e, [t]), this._addToLookupMap(t);
      return;
    }
    for (let n = i.length - 1; n >= 0; n--) {
      const o = i[n];
      if (o.command === t.command)
        continue;
      let r = !0;
      for (let a = 1; a < o.chords.length && a < t.chords.length; a++)
        if (o.chords[a] !== t.chords[a]) {
          r = !1;
          break;
        }
      r && Ku.whenIsEntirelyIncluded(o.when, t.when) && this._removeFromLookupMap(o);
    }
    i.push(t), this._addToLookupMap(t);
  }
  _addToLookupMap(e) {
    if (!e.command)
      return;
    let t = this._lookupMap.get(e.command);
    typeof t > "u" ? (t = [e], this._lookupMap.set(e.command, t)) : t.push(e);
  }
  _removeFromLookupMap(e) {
    if (!e.command)
      return;
    const t = this._lookupMap.get(e.command);
    if (!(typeof t > "u")) {
      for (let i = 0, n = t.length; i < n; i++)
        if (t[i] === e) {
          t.splice(i, 1);
          return;
        }
    }
  }
  /**
   * Returns true if it is provable `a` implies `b`.
   */
  static whenIsEntirelyIncluded(e, t) {
    return !t || t.type === 1 ? !0 : !e || e.type === 1 ? !1 : nv(e, t);
  }
  getKeybindings() {
    return this._keybindings;
  }
  lookupPrimaryKeybinding(e, t) {
    const i = this._lookupMap.get(e);
    if (typeof i > "u" || i.length === 0)
      return null;
    if (i.length === 1)
      return i[0];
    for (let n = i.length - 1; n >= 0; n--) {
      const o = i[n];
      if (t.contextMatchesRules(o.when))
        return o;
    }
    return i[i.length - 1];
  }
  /**
   * Looks up a keybinding trigged as a result of pressing a sequence of chords - `[...currentChords, keypress]`
   *
   * Example: resolving 3 chords pressed sequentially - `cmd+k cmd+p cmd+i`:
   * 	`currentChords = [ 'cmd+k' , 'cmd+p' ]` and `keypress = `cmd+i` - last pressed chord
   */
  resolve(e, t, i) {
    const n = [...t, i];
    this._log(`| Resolving ${n}`);
    const o = this._map.get(n[0]);
    if (o === void 0)
      return this._log("\\ No keybinding entries."), i_;
    let r = null;
    if (n.length < 2)
      r = o;
    else {
      r = [];
      for (let l = 0, c = o.length; l < c; l++) {
        const h = o[l];
        if (n.length > h.chords.length)
          continue;
        let d = !0;
        for (let u = 1; u < n.length; u++)
          if (h.chords[u] !== n[u]) {
            d = !1;
            break;
          }
        d && r.push(h);
      }
    }
    const a = this._findCommand(e, r);
    return a ? n.length < a.chords.length ? (this._log(`\\ From ${r.length} keybinding entries, awaiting ${a.chords.length - n.length} more chord(s), when: ${LI(a.when)}, source: ${kI(a)}.`), TV) : (this._log(`\\ From ${r.length} keybinding entries, matched ${a.command}, when: ${LI(a.when)}, source: ${kI(a)}.`), MV(a.command, a.commandArgs, a.bubble)) : (this._log(`\\ From ${r.length} keybinding entries, no when clauses matched the context.`), i_);
  }
  _findCommand(e, t) {
    for (let i = t.length - 1; i >= 0; i--) {
      const n = t[i];
      if (Ku._contextMatchesRules(e, n.when))
        return n;
    }
    return null;
  }
  static _contextMatchesRules(e, t) {
    return t ? t.evaluate(e) : !0;
  }
}
function LI(s) {
  return s ? `${s.serialize()}` : "no when condition";
}
function kI(s) {
  return s.extensionId ? s.isBuiltinExtension ? `built-in extension ${s.extensionId}` : `user extension ${s.extensionId}` : s.isDefault ? "built-in" : "user";
}
const RV = /^(cursor|delete|undo|redo|tab|editor\.action\.clipboard)/;
class AV extends q {
  get onDidUpdateKeybindings() {
    return this._onDidUpdateKeybindings ? this._onDidUpdateKeybindings.event : J.None;
  }
  get inChordMode() {
    return this._currentChords.length > 0;
  }
  constructor(e, t, i, n, o) {
    super(), this._contextKeyService = e, this._commandService = t, this._telemetryService = i, this._notificationService = n, this._logService = o, this._onDidUpdateKeybindings = this._register(new O()), this._currentChords = [], this._currentChordChecker = new PL(), this._currentChordStatusMessage = null, this._ignoreSingleModifiers = Ch.EMPTY, this._currentSingleModifier = null, this._currentSingleModifierClearTimeout = new Ic(), this._currentlyDispatchingCommandId = null, this._logging = !1;
  }
  dispose() {
    super.dispose();
  }
  _log(e) {
    this._logging && this._logService.info(`[KeybindingService]: ${e}`);
  }
  getKeybindings() {
    return this._getResolver().getKeybindings();
  }
  lookupKeybinding(e, t) {
    const i = this._getResolver().lookupPrimaryKeybinding(e, t || this._contextKeyService);
    if (i)
      return i.resolvedKeybinding;
  }
  dispatchEvent(e, t) {
    return this._dispatch(e, t);
  }
  // TODO@ulugbekna: update namings to align with `_doDispatch`
  // TODO@ulugbekna: this fn doesn't seem to take into account single-modifier keybindings, eg `shift shift`
  softDispatch(e, t) {
    this._log("/ Soft dispatching keyboard event");
    const i = this.resolveKeyboardEvent(e);
    if (i.hasMultipleChords())
      return console.warn("keyboard event should not be mapped to multiple chords"), i_;
    const [n] = i.getDispatchChords();
    if (n === null)
      return this._log("\\ Keyboard event cannot be dispatched"), i_;
    const o = this._contextKeyService.getContext(t), r = this._currentChords.map((({ keypress: a }) => a));
    return this._getResolver().resolve(o, r, n);
  }
  _scheduleLeaveChordMode() {
    const e = Date.now();
    this._currentChordChecker.cancelAndSet(() => {
      if (!this._documentHasFocus()) {
        this._leaveChordMode();
        return;
      }
      Date.now() - e > 5e3 && this._leaveChordMode();
    }, 500);
  }
  _expectAnotherChord(e, t) {
    switch (this._currentChords.push({ keypress: e, label: t }), this._currentChords.length) {
      case 0:
        throw vL("impossible");
      case 1:
        this._currentChordStatusMessage = this._notificationService.status(p("first.chord", "({0}) was pressed. Waiting for second key of chord...", t));
        break;
      default: {
        const i = this._currentChords.map(({ label: n }) => n).join(", ");
        this._currentChordStatusMessage = this._notificationService.status(p("next.chord", "({0}) was pressed. Waiting for next key of chord...", i));
      }
    }
    this._scheduleLeaveChordMode(), $u.enabled && $u.disable();
  }
  _leaveChordMode() {
    this._currentChordStatusMessage && (this._currentChordStatusMessage.dispose(), this._currentChordStatusMessage = null), this._currentChordChecker.cancel(), this._currentChords = [], $u.enable();
  }
  _dispatch(e, t) {
    return this._doDispatch(
      this.resolveKeyboardEvent(e),
      t,
      /*isSingleModiferChord*/
      !1
    );
  }
  _singleModifierDispatch(e, t) {
    const i = this.resolveKeyboardEvent(e), [n] = i.getSingleModifierDispatchChords();
    if (n)
      return this._ignoreSingleModifiers.has(n) ? (this._log(`+ Ignoring single modifier ${n} due to it being pressed together with other keys.`), this._ignoreSingleModifiers = Ch.EMPTY, this._currentSingleModifierClearTimeout.cancel(), this._currentSingleModifier = null, !1) : (this._ignoreSingleModifiers = Ch.EMPTY, this._currentSingleModifier === null ? (this._log(`+ Storing single modifier for possible chord ${n}.`), this._currentSingleModifier = n, this._currentSingleModifierClearTimeout.cancelAndSet(() => {
        this._log("+ Clearing single modifier due to 300ms elapsed."), this._currentSingleModifier = null;
      }, 300), !1) : n === this._currentSingleModifier ? (this._log(`/ Dispatching single modifier chord ${n} ${n}`), this._currentSingleModifierClearTimeout.cancel(), this._currentSingleModifier = null, this._doDispatch(
        i,
        t,
        /*isSingleModiferChord*/
        !0
      )) : (this._log(`+ Clearing single modifier due to modifier mismatch: ${this._currentSingleModifier} ${n}`), this._currentSingleModifierClearTimeout.cancel(), this._currentSingleModifier = null, !1));
    const [o] = i.getChords();
    return this._ignoreSingleModifiers = new Ch(o), this._currentSingleModifier !== null && this._log("+ Clearing single modifier due to other key up."), this._currentSingleModifierClearTimeout.cancel(), this._currentSingleModifier = null, !1;
  }
  _doDispatch(e, t, i = !1) {
    let n = !1;
    if (e.hasMultipleChords())
      return console.warn("Unexpected keyboard event mapped to multiple chords"), !1;
    let o = null, r = null;
    if (i) {
      const [h] = e.getSingleModifierDispatchChords();
      o = h, r = h ? [h] : [];
    } else
      [o] = e.getDispatchChords(), r = this._currentChords.map(({ keypress: h }) => h);
    if (o === null)
      return this._log("\\ Keyboard event cannot be dispatched in keydown phase."), n;
    const a = this._contextKeyService.getContext(t), l = e.getLabel(), c = this._getResolver().resolve(a, r, o);
    switch (c.kind) {
      case 0: {
        if (this._logService.trace("KeybindingService#dispatch", l, "[ No matching keybinding ]"), this.inChordMode) {
          const h = this._currentChords.map(({ label: d }) => d).join(", ");
          this._log(`+ Leaving multi-chord mode: Nothing bound to "${h}, ${l}".`), this._notificationService.status(p("missing.chord", "The key combination ({0}, {1}) is not a command.", h, l), {
            hideAfter: 10 * 1e3
            /* 10s */
          }), this._leaveChordMode(), n = !0;
        }
        return n;
      }
      case 1:
        return this._logService.trace("KeybindingService#dispatch", l, "[ Several keybindings match - more chords needed ]"), n = !0, this._expectAnotherChord(o, l), this._log(this._currentChords.length === 1 ? "+ Entering multi-chord mode..." : "+ Continuing multi-chord mode..."), n;
      case 2: {
        if (this._logService.trace("KeybindingService#dispatch", l, `[ Will dispatch command ${c.commandId} ]`), c.commandId === null || c.commandId === "") {
          if (this.inChordMode) {
            const h = this._currentChords.map(({ label: d }) => d).join(", ");
            this._log(`+ Leaving chord mode: Nothing bound to "${h}, ${l}".`), this._notificationService.status(p("missing.chord", "The key combination ({0}, {1}) is not a command.", h, l), {
              hideAfter: 10 * 1e3
              /* 10s */
            }), this._leaveChordMode(), n = !0;
          }
        } else {
          this.inChordMode && this._leaveChordMode(), c.isBubble || (n = !0), this._log(`+ Invoking command ${c.commandId}.`), this._currentlyDispatchingCommandId = c.commandId;
          try {
            typeof c.commandArgs > "u" ? this._commandService.executeCommand(c.commandId).then(void 0, (h) => this._notificationService.warn(h)) : this._commandService.executeCommand(c.commandId, c.commandArgs).then(void 0, (h) => this._notificationService.warn(h));
          } finally {
            this._currentlyDispatchingCommandId = null;
          }
          RV.test(c.commandId) || this._telemetryService.publicLog2("workbenchActionExecuted", { id: c.commandId, from: "keybinding", detail: e.getUserSettingsLabel() ?? void 0 });
        }
        return n;
      }
    }
  }
  mightProducePrintableCharacter(e) {
    return e.ctrlKey || e.metaKey ? !1 : e.keyCode >= 31 && e.keyCode <= 56 || e.keyCode >= 21 && e.keyCode <= 30;
  }
}
const C1 = class C1 {
  constructor(e) {
    this._ctrlKey = e ? e.ctrlKey : !1, this._shiftKey = e ? e.shiftKey : !1, this._altKey = e ? e.altKey : !1, this._metaKey = e ? e.metaKey : !1;
  }
  has(e) {
    switch (e) {
      case "ctrl":
        return this._ctrlKey;
      case "shift":
        return this._shiftKey;
      case "alt":
        return this._altKey;
      case "meta":
        return this._metaKey;
    }
  }
};
C1.EMPTY = new C1(null);
let Ch = C1;
class xI {
  constructor(e, t, i, n, o, r, a) {
    this._resolvedKeybindingItemBrand = void 0, this.resolvedKeybinding = e, this.chords = e ? ey(e.getDispatchChords()) : [], e && this.chords.length === 0 && (this.chords = ey(e.getSingleModifierDispatchChords())), this.bubble = t ? t.charCodeAt(0) === 94 : !1, this.command = this.bubble ? t.substr(1) : t, this.commandArgs = i, this.when = n, this.isDefault = o, this.extensionId = r, this.isBuiltinExtension = a;
  }
}
function ey(s) {
  const e = [];
  for (let t = 0, i = s.length; t < i; t++) {
    const n = s[t];
    if (!n)
      return [];
    e.push(n);
  }
  return e;
}
class Nb {
  constructor(e, t, i = t) {
    this.modifierLabels = [null], this.modifierLabels[
      2
      /* OperatingSystem.Macintosh */
    ] = e, this.modifierLabels[
      1
      /* OperatingSystem.Windows */
    ] = t, this.modifierLabels[
      3
      /* OperatingSystem.Linux */
    ] = i;
  }
  toLabel(e, t, i) {
    if (t.length === 0)
      return null;
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o], l = i(a);
      if (l === null)
        return null;
      n[o] = BV(a, l, this.modifierLabels[e]);
    }
    return n.join(" ");
  }
}
const kk = new Nb({
  ctrlKey: "⌃",
  shiftKey: "⇧",
  altKey: "⌥",
  metaKey: "⌘",
  separator: ""
}, {
  ctrlKey: p({ key: "ctrlKey", comment: ["This is the short form for the Control key on the keyboard"] }, "Ctrl"),
  shiftKey: p({ key: "shiftKey", comment: ["This is the short form for the Shift key on the keyboard"] }, "Shift"),
  altKey: p({ key: "altKey", comment: ["This is the short form for the Alt key on the keyboard"] }, "Alt"),
  metaKey: p({ key: "windowsKey", comment: ["This is the short form for the Windows key on the keyboard"] }, "Windows"),
  separator: "+"
}, {
  ctrlKey: p({ key: "ctrlKey", comment: ["This is the short form for the Control key on the keyboard"] }, "Ctrl"),
  shiftKey: p({ key: "shiftKey", comment: ["This is the short form for the Shift key on the keyboard"] }, "Shift"),
  altKey: p({ key: "altKey", comment: ["This is the short form for the Alt key on the keyboard"] }, "Alt"),
  metaKey: p({ key: "superKey", comment: ["This is the short form for the Super key on the keyboard"] }, "Super"),
  separator: "+"
}), PV = new Nb({
  ctrlKey: p({ key: "ctrlKey.long", comment: ["This is the long form for the Control key on the keyboard"] }, "Control"),
  shiftKey: p({ key: "shiftKey.long", comment: ["This is the long form for the Shift key on the keyboard"] }, "Shift"),
  altKey: p({ key: "optKey.long", comment: ["This is the long form for the Alt/Option key on the keyboard"] }, "Option"),
  metaKey: p({ key: "cmdKey.long", comment: ["This is the long form for the Command key on the keyboard"] }, "Command"),
  separator: "+"
}, {
  ctrlKey: p({ key: "ctrlKey.long", comment: ["This is the long form for the Control key on the keyboard"] }, "Control"),
  shiftKey: p({ key: "shiftKey.long", comment: ["This is the long form for the Shift key on the keyboard"] }, "Shift"),
  altKey: p({ key: "altKey.long", comment: ["This is the long form for the Alt key on the keyboard"] }, "Alt"),
  metaKey: p({ key: "windowsKey.long", comment: ["This is the long form for the Windows key on the keyboard"] }, "Windows"),
  separator: "+"
}, {
  ctrlKey: p({ key: "ctrlKey.long", comment: ["This is the long form for the Control key on the keyboard"] }, "Control"),
  shiftKey: p({ key: "shiftKey.long", comment: ["This is the long form for the Shift key on the keyboard"] }, "Shift"),
  altKey: p({ key: "altKey.long", comment: ["This is the long form for the Alt key on the keyboard"] }, "Alt"),
  metaKey: p({ key: "superKey.long", comment: ["This is the long form for the Super key on the keyboard"] }, "Super"),
  separator: "+"
}), OV = new Nb({
  ctrlKey: "Ctrl",
  shiftKey: "Shift",
  altKey: "Alt",
  metaKey: "Cmd",
  separator: "+"
}, {
  ctrlKey: "Ctrl",
  shiftKey: "Shift",
  altKey: "Alt",
  metaKey: "Super",
  separator: "+"
}), FV = new Nb({
  ctrlKey: "ctrl",
  shiftKey: "shift",
  altKey: "alt",
  metaKey: "cmd",
  separator: "+"
}, {
  ctrlKey: "ctrl",
  shiftKey: "shift",
  altKey: "alt",
  metaKey: "win",
  separator: "+"
}, {
  ctrlKey: "ctrl",
  shiftKey: "shift",
  altKey: "alt",
  metaKey: "meta",
  separator: "+"
});
function BV(s, e, t) {
  if (e === null)
    return "";
  const i = [];
  return s.ctrlKey && i.push(t.ctrlKey), s.shiftKey && i.push(t.shiftKey), s.altKey && i.push(t.altKey), s.metaKey && i.push(t.metaKey), e !== "" && i.push(e), i.join(t.separator);
}
class WV extends c6 {
  constructor(e, t) {
    if (super(), t.length === 0)
      throw eb("chords");
    this._os = e, this._chords = t;
  }
  getLabel() {
    return kk.toLabel(this._os, this._chords, (e) => this._getLabel(e));
  }
  getAriaLabel() {
    return PV.toLabel(this._os, this._chords, (e) => this._getAriaLabel(e));
  }
  getElectronAccelerator() {
    return this._chords.length > 1 || this._chords[0].isDuplicateModifierCase() ? null : OV.toLabel(this._os, this._chords, (e) => this._getElectronAccelerator(e));
  }
  getUserSettingsLabel() {
    return FV.toLabel(this._os, this._chords, (e) => this._getUserSettingsLabel(e));
  }
  hasMultipleChords() {
    return this._chords.length > 1;
  }
  getChords() {
    return this._chords.map((e) => this._getChord(e));
  }
  _getChord(e) {
    return new l6(e.ctrlKey, e.shiftKey, e.altKey, e.metaKey, this._getLabel(e), this._getAriaLabel(e));
  }
  getDispatchChords() {
    return this._chords.map((e) => this._getChordDispatch(e));
  }
  getSingleModifierDispatchChords() {
    return this._chords.map((e) => this._getSingleModifierChordDispatch(e));
  }
}
class Zf extends WV {
  constructor(e, t) {
    super(t, e);
  }
  _keyCodeToUILabel(e) {
    if (this._os === 2)
      switch (e) {
        case 15:
          return "←";
        case 16:
          return "↑";
        case 17:
          return "→";
        case 18:
          return "↓";
      }
    return Lr.toString(e);
  }
  _getLabel(e) {
    return e.isDuplicateModifierCase() ? "" : this._keyCodeToUILabel(e.keyCode);
  }
  _getAriaLabel(e) {
    return e.isDuplicateModifierCase() ? "" : Lr.toString(e.keyCode);
  }
  _getElectronAccelerator(e) {
    return Lr.toElectronAccelerator(e.keyCode);
  }
  _getUserSettingsLabel(e) {
    if (e.isDuplicateModifierCase())
      return "";
    const t = Lr.toUserSettingsUS(e.keyCode);
    return t && t.toLowerCase();
  }
  _getChordDispatch(e) {
    return Zf.getDispatchStr(e);
  }
  static getDispatchStr(e) {
    if (e.isModifierKey())
      return null;
    let t = "";
    return e.ctrlKey && (t += "ctrl+"), e.shiftKey && (t += "shift+"), e.altKey && (t += "alt+"), e.metaKey && (t += "meta+"), t += Lr.toString(e.keyCode), t;
  }
  _getSingleModifierChordDispatch(e) {
    return e.keyCode === 5 && !e.shiftKey && !e.altKey && !e.metaKey ? "ctrl" : e.keyCode === 4 && !e.ctrlKey && !e.altKey && !e.metaKey ? "shift" : e.keyCode === 6 && !e.ctrlKey && !e.shiftKey && !e.metaKey ? "alt" : e.keyCode === 57 && !e.ctrlKey && !e.shiftKey && !e.altKey ? "meta" : null;
  }
  /**
   * *NOTE*: Check return value for `KeyCode.Unknown`.
   */
  static _scanCodeToKeyCode(e) {
    const t = kL[e];
    if (t !== -1)
      return t;
    switch (e) {
      case 10:
        return 31;
      case 11:
        return 32;
      case 12:
        return 33;
      case 13:
        return 34;
      case 14:
        return 35;
      case 15:
        return 36;
      case 16:
        return 37;
      case 17:
        return 38;
      case 18:
        return 39;
      case 19:
        return 40;
      case 20:
        return 41;
      case 21:
        return 42;
      case 22:
        return 43;
      case 23:
        return 44;
      case 24:
        return 45;
      case 25:
        return 46;
      case 26:
        return 47;
      case 27:
        return 48;
      case 28:
        return 49;
      case 29:
        return 50;
      case 30:
        return 51;
      case 31:
        return 52;
      case 32:
        return 53;
      case 33:
        return 54;
      case 34:
        return 55;
      case 35:
        return 56;
      case 36:
        return 22;
      case 37:
        return 23;
      case 38:
        return 24;
      case 39:
        return 25;
      case 40:
        return 26;
      case 41:
        return 27;
      case 42:
        return 28;
      case 43:
        return 29;
      case 44:
        return 30;
      case 45:
        return 21;
      case 51:
        return 88;
      case 52:
        return 86;
      case 53:
        return 92;
      case 54:
        return 94;
      case 55:
        return 93;
      case 56:
        return 0;
      // missing
      case 57:
        return 85;
      case 58:
        return 95;
      case 59:
        return 91;
      case 60:
        return 87;
      case 61:
        return 89;
      case 62:
        return 90;
      case 106:
        return 97;
    }
    return 0;
  }
  static _toKeyCodeChord(e) {
    if (!e)
      return null;
    if (e instanceof mc)
      return e;
    const t = this._scanCodeToKeyCode(e.scanCode);
    return t === 0 ? null : new mc(e.ctrlKey, e.shiftKey, e.altKey, e.metaKey, t);
  }
  static resolveKeybinding(e, t) {
    const i = ey(e.chords.map((n) => this._toKeyCodeChord(n)));
    return i.length > 0 ? [new Zf(i, t)] : [];
  }
}
const VV = Ve("labelService"), HV = Ve("progressService"), xk = Ve("editorProgressService");
class zV {
  constructor() {
    this._value = "", this._pos = 0;
  }
  reset(e) {
    return this._value = e, this._pos = 0, this;
  }
  next() {
    return this._pos += 1, this;
  }
  hasNext() {
    return this._pos < this._value.length - 1;
  }
  cmp(e) {
    const t = e.charCodeAt(0), i = this._value.charCodeAt(this._pos);
    return t - i;
  }
  value() {
    return this._value[this._pos];
  }
}
class UV {
  constructor(e = !0) {
    this._caseSensitive = e;
  }
  reset(e) {
    return this._value = e, this._from = 0, this._to = 0, this.next();
  }
  hasNext() {
    return this._to < this._value.length;
  }
  next() {
    this._from = this._to;
    let e = !0;
    for (; this._to < this._value.length; this._to++)
      if (this._value.charCodeAt(this._to) === 46)
        if (e)
          this._from++;
        else
          break;
      else
        e = !1;
    return this;
  }
  cmp(e) {
    return this._caseSensitive ? DL(e, this._value, 0, e.length, this._from, this._to) : Sg(e, this._value, 0, e.length, this._from, this._to);
  }
  value() {
    return this._value.substring(this._from, this._to);
  }
}
class $V {
  constructor(e = !0, t = !0) {
    this._splitOnBackslash = e, this._caseSensitive = t;
  }
  reset(e) {
    this._from = 0, this._to = 0, this._value = e, this._valueLen = e.length;
    for (let t = e.length - 1; t >= 0; t--, this._valueLen--) {
      const i = this._value.charCodeAt(t);
      if (!(i === 47 || this._splitOnBackslash && i === 92))
        break;
    }
    return this.next();
  }
  hasNext() {
    return this._to < this._valueLen;
  }
  next() {
    this._from = this._to;
    let e = !0;
    for (; this._to < this._valueLen; this._to++) {
      const t = this._value.charCodeAt(this._to);
      if (t === 47 || this._splitOnBackslash && t === 92)
        if (e)
          this._from++;
        else
          break;
      else
        e = !1;
    }
    return this;
  }
  cmp(e) {
    return this._caseSensitive ? DL(e, this._value, 0, e.length, this._from, this._to) : Sg(e, this._value, 0, e.length, this._from, this._to);
  }
  value() {
    return this._value.substring(this._from, this._to);
  }
}
class KV {
  constructor(e, t) {
    this._ignorePathCasing = e, this._ignoreQueryAndFragment = t, this._states = [], this._stateIdx = 0;
  }
  reset(e) {
    return this._value = e, this._states = [], this._value.scheme && this._states.push(
      1
      /* UriIteratorState.Scheme */
    ), this._value.authority && this._states.push(
      2
      /* UriIteratorState.Authority */
    ), this._value.path && (this._pathIterator = new $V(!1, !this._ignorePathCasing(e)), this._pathIterator.reset(e.path), this._pathIterator.value() && this._states.push(
      3
      /* UriIteratorState.Path */
    )), this._ignoreQueryAndFragment(e) || (this._value.query && this._states.push(
      4
      /* UriIteratorState.Query */
    ), this._value.fragment && this._states.push(
      5
      /* UriIteratorState.Fragment */
    )), this._stateIdx = 0, this;
  }
  next() {
    return this._states[this._stateIdx] === 3 && this._pathIterator.hasNext() ? this._pathIterator.next() : this._stateIdx += 1, this;
  }
  hasNext() {
    return this._states[this._stateIdx] === 3 && this._pathIterator.hasNext() || this._stateIdx < this._states.length - 1;
  }
  cmp(e) {
    if (this._states[this._stateIdx] === 1)
      return wD(e, this._value.scheme);
    if (this._states[this._stateIdx] === 2)
      return wD(e, this._value.authority);
    if (this._states[this._stateIdx] === 3)
      return this._pathIterator.cmp(e);
    if (this._states[this._stateIdx] === 4)
      return Ow(e, this._value.query);
    if (this._states[this._stateIdx] === 5)
      return Ow(e, this._value.fragment);
    throw new Error();
  }
  value() {
    if (this._states[this._stateIdx] === 1)
      return this._value.scheme;
    if (this._states[this._stateIdx] === 2)
      return this._value.authority;
    if (this._states[this._stateIdx] === 3)
      return this._pathIterator.value();
    if (this._states[this._stateIdx] === 4)
      return this._value.query;
    if (this._states[this._stateIdx] === 5)
      return this._value.fragment;
    throw new Error();
  }
}
class Cm {
  constructor() {
    this.height = 1;
  }
  rotateLeft() {
    const e = this.right;
    return this.right = e.left, e.left = this, this.updateHeight(), e.updateHeight(), e;
  }
  rotateRight() {
    const e = this.left;
    return this.left = e.right, e.right = this, this.updateHeight(), e.updateHeight(), e;
  }
  updateHeight() {
    this.height = 1 + Math.max(this.heightLeft, this.heightRight);
  }
  balanceFactor() {
    return this.heightRight - this.heightLeft;
  }
  get heightLeft() {
    var e;
    return ((e = this.left) == null ? void 0 : e.height) ?? 0;
  }
  get heightRight() {
    var e;
    return ((e = this.right) == null ? void 0 : e.height) ?? 0;
  }
}
class qu {
  static forUris(e = () => !1, t = () => !1) {
    return new qu(new KV(e, t));
  }
  static forStrings() {
    return new qu(new zV());
  }
  static forConfigKeys() {
    return new qu(new UV());
  }
  constructor(e) {
    this._iter = e;
  }
  clear() {
    this._root = void 0;
  }
  set(e, t) {
    const i = this._iter.reset(e);
    let n;
    this._root || (this._root = new Cm(), this._root.segment = i.value());
    const o = [];
    for (n = this._root; ; ) {
      const a = i.cmp(n.segment);
      if (a > 0)
        n.left || (n.left = new Cm(), n.left.segment = i.value()), o.push([-1, n]), n = n.left;
      else if (a < 0)
        n.right || (n.right = new Cm(), n.right.segment = i.value()), o.push([1, n]), n = n.right;
      else if (i.hasNext())
        i.next(), n.mid || (n.mid = new Cm(), n.mid.segment = i.value()), o.push([0, n]), n = n.mid;
      else
        break;
    }
    const r = n.value;
    n.value = t, n.key = e;
    for (let a = o.length - 1; a >= 0; a--) {
      const l = o[a][1];
      l.updateHeight();
      const c = l.balanceFactor();
      if (c < -1 || c > 1) {
        const h = o[a][0], d = o[a + 1][0];
        if (h === 1 && d === 1)
          o[a][1] = l.rotateLeft();
        else if (h === -1 && d === -1)
          o[a][1] = l.rotateRight();
        else if (h === 1 && d === -1)
          l.right = o[a + 1][1] = o[a + 1][1].rotateRight(), o[a][1] = l.rotateLeft();
        else if (h === -1 && d === 1)
          l.left = o[a + 1][1] = o[a + 1][1].rotateLeft(), o[a][1] = l.rotateRight();
        else
          throw new Error();
        if (a > 0)
          switch (o[a - 1][0]) {
            case -1:
              o[a - 1][1].left = o[a][1];
              break;
            case 1:
              o[a - 1][1].right = o[a][1];
              break;
            case 0:
              o[a - 1][1].mid = o[a][1];
              break;
          }
        else
          this._root = o[0][1];
      }
    }
    return r;
  }
  get(e) {
    var t;
    return (t = this._getNode(e)) == null ? void 0 : t.value;
  }
  _getNode(e) {
    const t = this._iter.reset(e);
    let i = this._root;
    for (; i; ) {
      const n = t.cmp(i.segment);
      if (n > 0)
        i = i.left;
      else if (n < 0)
        i = i.right;
      else if (t.hasNext())
        t.next(), i = i.mid;
      else
        break;
    }
    return i;
  }
  has(e) {
    const t = this._getNode(e);
    return !((t == null ? void 0 : t.value) === void 0 && (t == null ? void 0 : t.mid) === void 0);
  }
  delete(e) {
    return this._delete(e, !1);
  }
  deleteSuperstr(e) {
    return this._delete(e, !0);
  }
  _delete(e, t) {
    const i = this._iter.reset(e), n = [];
    let o = this._root;
    for (; o; ) {
      const r = i.cmp(o.segment);
      if (r > 0)
        n.push([-1, o]), o = o.left;
      else if (r < 0)
        n.push([1, o]), o = o.right;
      else if (i.hasNext())
        i.next(), n.push([0, o]), o = o.mid;
      else
        break;
    }
    if (o) {
      if (t ? (o.left = void 0, o.mid = void 0, o.right = void 0, o.height = 1) : (o.key = void 0, o.value = void 0), !o.mid && !o.value)
        if (o.left && o.right) {
          const r = this._min(o.right);
          if (r.key) {
            const { key: a, value: l, segment: c } = r;
            this._delete(r.key, !1), o.key = a, o.value = l, o.segment = c;
          }
        } else {
          const r = o.left ?? o.right;
          if (n.length > 0) {
            const [a, l] = n[n.length - 1];
            switch (a) {
              case -1:
                l.left = r;
                break;
              case 0:
                l.mid = r;
                break;
              case 1:
                l.right = r;
                break;
            }
          } else
            this._root = r;
        }
      for (let r = n.length - 1; r >= 0; r--) {
        const a = n[r][1];
        a.updateHeight();
        const l = a.balanceFactor();
        if (l > 1 ? (a.right.balanceFactor() >= 0 || (a.right = a.right.rotateRight()), n[r][1] = a.rotateLeft()) : l < -1 && (a.left.balanceFactor() <= 0 || (a.left = a.left.rotateLeft()), n[r][1] = a.rotateRight()), r > 0)
          switch (n[r - 1][0]) {
            case -1:
              n[r - 1][1].left = n[r][1];
              break;
            case 1:
              n[r - 1][1].right = n[r][1];
              break;
            case 0:
              n[r - 1][1].mid = n[r][1];
              break;
          }
        else
          this._root = n[0][1];
      }
    }
  }
  _min(e) {
    for (; e.left; )
      e = e.left;
    return e;
  }
  findSubstr(e) {
    const t = this._iter.reset(e);
    let i = this._root, n;
    for (; i; ) {
      const o = t.cmp(i.segment);
      if (o > 0)
        i = i.left;
      else if (o < 0)
        i = i.right;
      else if (t.hasNext())
        t.next(), n = i.value || n, i = i.mid;
      else
        break;
    }
    return i && i.value || n;
  }
  findSuperstr(e) {
    return this._findSuperstrOrElement(e, !1);
  }
  _findSuperstrOrElement(e, t) {
    const i = this._iter.reset(e);
    let n = this._root;
    for (; n; ) {
      const o = i.cmp(n.segment);
      if (o > 0)
        n = n.left;
      else if (o < 0)
        n = n.right;
      else if (i.hasNext())
        i.next(), n = n.mid;
      else
        return n.mid ? this._entries(n.mid) : t ? n.value : void 0;
    }
  }
  forEach(e) {
    for (const [t, i] of this)
      e(i, t);
  }
  *[Symbol.iterator]() {
    yield* this._entries(this._root);
  }
  _entries(e) {
    const t = [];
    return this._dfsEntries(e, t), t[Symbol.iterator]();
  }
  _dfsEntries(e, t) {
    e && (e.left && this._dfsEntries(e.left, t), e.value && t.push([e.key, e.value]), e.mid && this._dfsEntries(e.mid, t), e.right && this._dfsEntries(e.right, t));
  }
}
const qV = Ve("contextService");
class jV {
  constructor(e, t) {
    this.raw = t, this.uri = e.uri, this.index = e.index, this.name = e.name;
  }
  toJSON() {
    return { uri: this.uri, name: this.name, index: this.index };
  }
}
const GV = "code-workspace";
p("codeWorkspace", "Code Workspace");
const ZV = "4064f6ec-cb38-4ad0-af64-ee6467e63c82";
var DI;
(function(s) {
  s.inspectTokensAction = p("inspectTokens", "Developer: Inspect Tokens");
})(DI || (DI = {}));
var EI;
(function(s) {
  s.gotoLineActionLabel = p("gotoLineActionLabel", "Go to Line/Column...");
})(EI || (EI = {}));
var II;
(function(s) {
  s.helpQuickAccessActionLabel = p("helpQuickAccess", "Show all Quick Access Providers");
})(II || (II = {}));
var NI;
(function(s) {
  s.quickCommandActionLabel = p("quickCommandActionLabel", "Command Palette"), s.quickCommandHelp = p("quickCommandActionHelp", "Show And Run Commands");
})(NI || (NI = {}));
var TI;
(function(s) {
  s.quickOutlineActionLabel = p("quickOutlineActionLabel", "Go to Symbol..."), s.quickOutlineByCategoryActionLabel = p("quickOutlineByCategoryActionLabel", "Go to Symbol by Category...");
})(TI || (TI = {}));
var ty;
(function(s) {
  s.editorViewAccessibleLabel = p("editorViewAccessibleLabel", "Editor content");
})(ty || (ty = {}));
var MI;
(function(s) {
  s.toggleHighContrast = p("toggleHighContrast", "Toggle High Contrast Theme");
})(MI || (MI = {}));
var iy;
(function(s) {
  s.bulkEditServiceSummary = p("bulkEditServiceSummary", "Made {0} edits in {1} files");
})(iy || (iy = {}));
const YV = Ve("workspaceTrustManagementService");
let Id = [], Dk = [], uA = [];
function wm(s, e = !1) {
  QV(s, !1, e);
}
function QV(s, e, t) {
  const i = XV(s, e);
  Id.push(i), i.userConfigured ? uA.push(i) : Dk.push(i), t && !i.userConfigured && Id.forEach((n) => {
    n.mime === i.mime || n.userConfigured || (i.extension && n.extension === i.extension && console.warn(`Overwriting extension <<${i.extension}>> to now point to mime <<${i.mime}>>`), i.filename && n.filename === i.filename && console.warn(`Overwriting filename <<${i.filename}>> to now point to mime <<${i.mime}>>`), i.filepattern && n.filepattern === i.filepattern && console.warn(`Overwriting filepattern <<${i.filepattern}>> to now point to mime <<${i.mime}>>`), i.firstline && n.firstline === i.firstline && console.warn(`Overwriting firstline <<${i.firstline}>> to now point to mime <<${i.mime}>>`));
  });
}
function XV(s, e) {
  return {
    id: s.id,
    mime: s.mime,
    filename: s.filename,
    extension: s.extension,
    filepattern: s.filepattern,
    firstline: s.firstline,
    userConfigured: e,
    filenameLowercase: s.filename ? s.filename.toLowerCase() : void 0,
    extensionLowercase: s.extension ? s.extension.toLowerCase() : void 0,
    filepatternLowercase: s.filepattern ? wR(s.filepattern.toLowerCase()) : void 0,
    filepatternOnPath: s.filepattern ? s.filepattern.indexOf(Kt.sep) >= 0 : !1
  };
}
function JV() {
  Id = Id.filter((s) => s.userConfigured), Dk = [];
}
function eH(s, e) {
  return tH(s, e).map((t) => t.id);
}
function tH(s, e) {
  let t;
  if (s)
    switch (s.scheme) {
      case Ne.file:
        t = s.fsPath;
        break;
      case Ne.data: {
        t = Yp.parseMetaData(s).get(Yp.META_DATA_LABEL);
        break;
      }
      case Ne.vscodeNotebookCell:
        t = void 0;
        break;
      default:
        t = s.path;
    }
  if (!t)
    return [{ id: "unknown", mime: Dr.unknown }];
  t = t.toLowerCase();
  const i = z2(t), n = RI(t, i, uA);
  if (n)
    return [n, { id: Ms, mime: Dr.text }];
  const o = RI(t, i, Dk);
  if (o)
    return [o, { id: Ms, mime: Dr.text }];
  if (e) {
    const r = iH(e);
    if (r)
      return [r, { id: Ms, mime: Dr.text }];
  }
  return [{ id: "unknown", mime: Dr.unknown }];
}
function RI(s, e, t) {
  var r;
  let i, n, o;
  for (let a = t.length - 1; a >= 0; a--) {
    const l = t[a];
    if (e === l.filenameLowercase) {
      i = l;
      break;
    }
    if (l.filepattern && (!n || l.filepattern.length > n.filepattern.length)) {
      const c = l.filepatternOnPath ? s : e;
      (r = l.filepatternLowercase) != null && r.call(l, c) && (n = l);
    }
    l.extension && (!o || l.extension.length > o.extension.length) && e.endsWith(l.extensionLowercase) && (o = l);
  }
  if (i)
    return i;
  if (n)
    return n;
  if (o)
    return o;
}
function iH(s) {
  if (AL(s) && (s = s.substr(1)), s.length > 0)
    for (let e = Id.length - 1; e >= 0; e--) {
      const t = Id[e];
      if (!t.firstline)
        continue;
      const i = s.match(t.firstline);
      if (i && i.length > 0)
        return t;
    }
}
const vm = Object.prototype.hasOwnProperty, AI = "vs.editor.nullLanguage";
class nH {
  constructor() {
    this._languageIdToLanguage = [], this._languageToLanguageId = /* @__PURE__ */ new Map(), this._register(
      AI,
      0
      /* LanguageId.Null */
    ), this._register(
      Ms,
      1
      /* LanguageId.PlainText */
    ), this._nextLanguageId = 2;
  }
  _register(e, t) {
    this._languageIdToLanguage[t] = e, this._languageToLanguageId.set(e, t);
  }
  register(e) {
    if (this._languageToLanguageId.has(e))
      return;
    const t = this._nextLanguageId++;
    this._register(e, t);
  }
  encodeLanguageId(e) {
    return this._languageToLanguageId.get(e) || 0;
  }
  decodeLanguageId(e) {
    return this._languageIdToLanguage[e] || AI;
  }
}
const wf = class wf extends q {
  constructor(e = !0, t = !1) {
    super(), this._onDidChange = this._register(new O()), this.onDidChange = this._onDidChange.event, wf.instanceCount++, this._warnOnOverwrite = t, this.languageIdCodec = new nH(), this._dynamicLanguages = [], this._languages = {}, this._mimeTypesMap = {}, this._nameMap = {}, this._lowercaseNameMap = {}, e && (this._initializeFromRegistry(), this._register(wd.onDidChangeLanguages((i) => {
      this._initializeFromRegistry();
    })));
  }
  dispose() {
    wf.instanceCount--, super.dispose();
  }
  _initializeFromRegistry() {
    this._languages = {}, this._mimeTypesMap = {}, this._nameMap = {}, this._lowercaseNameMap = {}, JV();
    const e = [].concat(wd.getLanguages()).concat(this._dynamicLanguages);
    this._registerLanguages(e);
  }
  _registerLanguages(e) {
    for (const t of e)
      this._registerLanguage(t);
    this._mimeTypesMap = {}, this._nameMap = {}, this._lowercaseNameMap = {}, Object.keys(this._languages).forEach((t) => {
      const i = this._languages[t];
      i.name && (this._nameMap[i.name] = i.identifier), i.aliases.forEach((n) => {
        this._lowercaseNameMap[n.toLowerCase()] = i.identifier;
      }), i.mimetypes.forEach((n) => {
        this._mimeTypesMap[n] = i.identifier;
      });
    }), Li.as(Oc.Configuration).registerOverrideIdentifiers(this.getRegisteredLanguageIds()), this._onDidChange.fire();
  }
  _registerLanguage(e) {
    const t = e.id;
    let i;
    vm.call(this._languages, t) ? i = this._languages[t] : (this.languageIdCodec.register(t), i = {
      identifier: t,
      name: null,
      mimetypes: [],
      aliases: [],
      extensions: [],
      filenames: [],
      configurationFiles: [],
      icons: []
    }, this._languages[t] = i), this._mergeLanguage(i, e);
  }
  _mergeLanguage(e, t) {
    const i = t.id;
    let n = null;
    if (Array.isArray(t.mimetypes) && t.mimetypes.length > 0 && (e.mimetypes.push(...t.mimetypes), n = t.mimetypes[0]), n || (n = `text/x-${i}`, e.mimetypes.push(n)), Array.isArray(t.extensions)) {
      t.configuration ? e.extensions = t.extensions.concat(e.extensions) : e.extensions = e.extensions.concat(t.extensions);
      for (const a of t.extensions)
        wm({ id: i, mime: n, extension: a }, this._warnOnOverwrite);
    }
    if (Array.isArray(t.filenames))
      for (const a of t.filenames)
        wm({ id: i, mime: n, filename: a }, this._warnOnOverwrite), e.filenames.push(a);
    if (Array.isArray(t.filenamePatterns))
      for (const a of t.filenamePatterns)
        wm({ id: i, mime: n, filepattern: a }, this._warnOnOverwrite);
    if (typeof t.firstLine == "string" && t.firstLine.length > 0) {
      let a = t.firstLine;
      a.charAt(0) !== "^" && (a = "^" + a);
      try {
        const l = new RegExp(a);
        QO(l) || wm({ id: i, mime: n, firstline: l }, this._warnOnOverwrite);
      } catch (l) {
        console.warn(`[${t.id}]: Invalid regular expression \`${a}\`: `, l);
      }
    }
    e.aliases.push(i);
    let o = null;
    if (typeof t.aliases < "u" && Array.isArray(t.aliases) && (t.aliases.length === 0 ? o = [null] : o = t.aliases), o !== null)
      for (const a of o)
        !a || a.length === 0 || e.aliases.push(a);
    const r = o !== null && o.length > 0;
    if (!(r && o[0] === null)) {
      const a = (r ? o[0] : null) || i;
      (r || !e.name) && (e.name = a);
    }
    t.configuration && e.configurationFiles.push(t.configuration), t.icon && e.icons.push(t.icon);
  }
  isRegisteredLanguageId(e) {
    return e ? vm.call(this._languages, e) : !1;
  }
  getRegisteredLanguageIds() {
    return Object.keys(this._languages);
  }
  getLanguageIdByLanguageName(e) {
    const t = e.toLowerCase();
    return vm.call(this._lowercaseNameMap, t) ? this._lowercaseNameMap[t] : null;
  }
  getLanguageIdByMimeType(e) {
    return e && vm.call(this._mimeTypesMap, e) ? this._mimeTypesMap[e] : null;
  }
  guessLanguageIdByFilepathOrFirstLine(e, t) {
    return !e && !t ? [] : eH(e, t);
  }
};
wf.instanceCount = 0;
let ny = wf;
const Fs = (s, e) => s === e;
function sH(s = Fs) {
  return (e, t) => oi(e, t, s);
}
function PI(s, e, t) {
  {
    const i = s;
    return (n, o) => n == null || o === void 0 || o === null ? o === n : i(n, o);
  }
}
class ln {
  constructor(e, t, i) {
    this.owner = e, this.debugNameSource = t, this.referenceFn = i;
  }
  getDebugName(e) {
    return oH(e, this);
  }
}
const OI = /* @__PURE__ */ new Map(), sy = /* @__PURE__ */ new WeakMap();
function oH(s, e) {
  const t = sy.get(s);
  if (t)
    return t;
  const i = rH(s, e);
  if (i) {
    let n = OI.get(i) ?? 0;
    n++, OI.set(i, n);
    const o = n === 1 ? i : `${i}#${n}`;
    return sy.set(s, o), o;
  }
}
function rH(s, e) {
  const t = sy.get(s);
  if (t)
    return t;
  const i = e.owner ? lH(e.owner) + "." : "";
  let n;
  const o = e.debugNameSource;
  if (o !== void 0)
    if (typeof o == "function") {
      if (n = o(), n !== void 0)
        return i + n;
    } else
      return i + o;
  const r = e.referenceFn;
  if (r !== void 0 && (n = Ek(r), n !== void 0))
    return i + n;
  if (e.owner !== void 0) {
    const a = aH(e.owner, s);
    if (a !== void 0)
      return i + a;
  }
}
function aH(s, e) {
  for (const t in s)
    if (s[t] === e)
      return t;
}
const FI = /* @__PURE__ */ new Map(), BI = /* @__PURE__ */ new WeakMap();
function lH(s) {
  const e = BI.get(s);
  if (e)
    return e;
  const t = cH(s);
  let i = FI.get(t) ?? 0;
  i++, FI.set(t, i);
  const n = i === 1 ? t : `${t}#${i}`;
  return BI.set(s, n), n;
}
function cH(s) {
  const e = s.constructor;
  return e ? e.name : "Object";
}
function Ek(s) {
  const e = s.toString(), i = /\/\*\*\s*@description\s*([^*]*)\*\//.exec(e), n = i ? i[1] : void 0;
  return n == null ? void 0 : n.trim();
}
let hH;
function fA() {
  return hH;
}
let gA;
function dH(s) {
  gA = s;
}
let mA;
function uH(s) {
  mA = s;
}
let oy;
function fH(s) {
  oy = s;
}
class pA {
  get TChange() {
    return null;
  }
  reportChanges() {
    this.get();
  }
  /** @sealed */
  read(e) {
    return e ? e.readObservable(this) : this.get();
  }
  map(e, t) {
    const i = t === void 0 ? void 0 : e, n = t === void 0 ? e : t;
    return oy({
      owner: i,
      debugName: () => {
        const o = Ek(n);
        if (o !== void 0)
          return o;
        const a = /^\s*\(?\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\s*\)?\s*=>\s*\1(?:\??)\.([a-zA-Z_$][a-zA-Z_$0-9]*)\s*$/.exec(n.toString());
        if (a)
          return `${this.debugName}.${a[2]}`;
        if (!i)
          return `${this.debugName} (mapped)`;
      },
      debugReferenceFn: n
    }, (o) => n(this.read(o), o));
  }
  /**
   * @sealed
   * Converts an observable of an observable value into a direct observable of the value.
  */
  flatten() {
    return oy({
      owner: void 0,
      debugName: () => `${this.debugName} (flattened)`
    }, (e) => this.read(e).read(e));
  }
  recomputeInitiallyAndOnChange(e, t) {
    return e.add(gA(this, t)), this;
  }
  /**
   * Ensures that this observable is observed. This keeps the cache alive.
   * However, in case of deriveds, it does not force eager evaluation (only when the value is read/get).
   * Use `recomputeInitiallyAndOnChange` for eager evaluation.
   */
  keepObserved(e) {
    return e.add(mA(this)), this;
  }
}
class Ud extends pA {
  constructor() {
    super(...arguments), this.observers = /* @__PURE__ */ new Set();
  }
  addObserver(e) {
    const t = this.observers.size;
    this.observers.add(e), t === 0 && this.onFirstObserverAdded();
  }
  removeObserver(e) {
    this.observers.delete(e) && this.observers.size === 0 && this.onLastObserverRemoved();
  }
  onFirstObserverAdded() {
  }
  onLastObserverRemoved() {
  }
}
function ni(s, e) {
  const t = new Fg(s, e);
  try {
    s(t);
  } finally {
    t.finish();
  }
}
let ym;
function Iu(s) {
  if (ym)
    s(ym);
  else {
    const e = new Fg(s, void 0);
    ym = e;
    try {
      s(e);
    } finally {
      e.finish(), ym = void 0;
    }
  }
}
function Ik(s, e, t) {
  s ? e(s) : ni(e, t);
}
class Fg {
  constructor(e, t) {
    this._fn = e, this._getDebugName = t, this.updatingObservers = [];
  }
  getDebugName() {
    return this._getDebugName ? this._getDebugName() : Ek(this._fn);
  }
  updateObserver(e, t) {
    this.updatingObservers.push({ observer: e, observable: t }), e.beginUpdate(t);
  }
  finish() {
    const e = this.updatingObservers;
    for (let t = 0; t < e.length; t++) {
      const { observer: i, observable: n } = e[t];
      i.endUpdate(n);
    }
    this.updatingObservers = null;
  }
}
function $e(s, e) {
  let t;
  return typeof s == "string" ? t = new ln(void 0, s, void 0) : t = new ln(s, void 0, void 0), new Nk(t, e, Fs);
}
class Nk extends Ud {
  get debugName() {
    return this._debugNameData.getDebugName(this) ?? "ObservableValue";
  }
  constructor(e, t, i) {
    super(), this._debugNameData = e, this._equalityComparator = i, this._value = t;
  }
  get() {
    return this._value;
  }
  set(e, t, i) {
    var o;
    if (i === void 0 && this._equalityComparator(this._value, e))
      return;
    let n;
    t || (t = n = new Fg(() => {
    }, () => `Setting ${this.debugName}`));
    try {
      const r = this._value;
      this._setValue(e), (o = fA()) == null || o.handleObservableChanged(this, { oldValue: r, newValue: e, change: i, didChange: !0, hadValue: !0 });
      for (const a of this.observers)
        t.updateObserver(a, this), a.handleChange(this, i);
    } finally {
      n && n.finish();
    }
  }
  toString() {
    return `${this.debugName}: ${this._value}`;
  }
  _setValue(e) {
    this._value = e;
  }
}
function _A(s, e) {
  let t;
  return typeof s == "string" ? t = new ln(void 0, s, void 0) : t = new ln(s, void 0, void 0), new gH(t, e, Fs);
}
class gH extends Nk {
  _setValue(e) {
    this._value !== e && (this._value && this._value.dispose(), this._value = e);
  }
  dispose() {
    var e;
    (e = this._value) == null || e.dispose();
  }
}
function Se(s, e) {
  return e !== void 0 ? new Nd(new ln(s, void 0, e), e, void 0, void 0, void 0, Fs) : new Nd(new ln(void 0, void 0, s), s, void 0, void 0, void 0, Fs);
}
function Tk(s, e, t) {
  return new mH(new ln(s, void 0, e), e, void 0, void 0, void 0, Fs, t);
}
function Tb(s, e) {
  return new Nd(new ln(s.owner, s.debugName, s.debugReferenceFn), e, void 0, void 0, s.onLastObserverRemoved, s.equalsFn ?? Fs);
}
fH(Tb);
function $d(s, e) {
  let t, i;
  e === void 0 ? (t = s, i = void 0) : (i = s, t = e);
  const n = new he();
  return new Nd(new ln(i, void 0, t), (o) => (n.clear(), t(o, n)), void 0, void 0, () => n.dispose(), Fs);
}
function ko(s, e) {
  let t, i;
  e === void 0 ? (t = s, i = void 0) : (i = s, t = e);
  let n;
  return new Nd(new ln(i, void 0, t), (o) => {
    n ? n.clear() : n = new he();
    const r = t(o);
    return r && n.add(r), r;
  }, void 0, void 0, () => {
    n && (n.dispose(), n = void 0);
  }, Fs);
}
class Nd extends Ud {
  get debugName() {
    return this._debugNameData.getDebugName(this) ?? "(anonymous)";
  }
  constructor(e, t, i, n, o = void 0, r) {
    var a;
    super(), this._debugNameData = e, this._computeFn = t, this.createChangeSummary = i, this._handleChange = n, this._handleLastObserverRemoved = o, this._equalityComparator = r, this.state = 0, this.value = void 0, this.updateCount = 0, this.dependencies = /* @__PURE__ */ new Set(), this.dependenciesToBeRemoved = /* @__PURE__ */ new Set(), this.changeSummary = void 0, this.changeSummary = (a = this.createChangeSummary) == null ? void 0 : a.call(this);
  }
  onLastObserverRemoved() {
    var e;
    this.state = 0, this.value = void 0;
    for (const t of this.dependencies)
      t.removeObserver(this);
    this.dependencies.clear(), (e = this._handleLastObserverRemoved) == null || e.call(this);
  }
  get() {
    var e;
    if (this.observers.size === 0) {
      const t = this._computeFn(this, (e = this.createChangeSummary) == null ? void 0 : e.call(this));
      return this.onLastObserverRemoved(), t;
    } else {
      do {
        if (this.state === 1) {
          for (const t of this.dependencies)
            if (t.reportChanges(), this.state === 2)
              break;
        }
        this.state === 1 && (this.state = 3), this._recomputeIfNeeded();
      } while (this.state !== 3);
      return this.value;
    }
  }
  _recomputeIfNeeded() {
    var r;
    if (this.state === 3)
      return;
    const e = this.dependenciesToBeRemoved;
    this.dependenciesToBeRemoved = this.dependencies, this.dependencies = e;
    const t = this.state !== 0, i = this.value;
    this.state = 3;
    const n = this.changeSummary;
    this.changeSummary = (r = this.createChangeSummary) == null ? void 0 : r.call(this);
    try {
      this.value = this._computeFn(this, n);
    } finally {
      for (const a of this.dependenciesToBeRemoved)
        a.removeObserver(this);
      this.dependenciesToBeRemoved.clear();
    }
    if (t && !this._equalityComparator(i, this.value))
      for (const a of this.observers)
        a.handleChange(this, void 0);
  }
  toString() {
    return `LazyDerived<${this.debugName}>`;
  }
  // IObserver Implementation
  beginUpdate(e) {
    this.updateCount++;
    const t = this.updateCount === 1;
    if (this.state === 3 && (this.state = 1, !t))
      for (const i of this.observers)
        i.handlePossibleChange(this);
    if (t)
      for (const i of this.observers)
        i.beginUpdate(this);
  }
  endUpdate(e) {
    if (this.updateCount--, this.updateCount === 0) {
      const t = [...this.observers];
      for (const i of t)
        i.endUpdate(this);
    }
    bc(() => this.updateCount >= 0);
  }
  handlePossibleChange(e) {
    if (this.state === 3 && this.dependencies.has(e) && !this.dependenciesToBeRemoved.has(e)) {
      this.state = 1;
      for (const t of this.observers)
        t.handlePossibleChange(this);
    }
  }
  handleChange(e, t) {
    if (this.dependencies.has(e) && !this.dependenciesToBeRemoved.has(e)) {
      const i = this._handleChange ? this._handleChange({
        changedObservable: e,
        change: t,
        didChange: (o) => o === e
      }, this.changeSummary) : !0, n = this.state === 3;
      if (i && (this.state === 1 || n) && (this.state = 2, n))
        for (const o of this.observers)
          o.handlePossibleChange(this);
    }
  }
  // IReader Implementation
  readObservable(e) {
    e.addObserver(this);
    const t = e.get();
    return this.dependencies.add(e), this.dependenciesToBeRemoved.delete(e), t;
  }
  addObserver(e) {
    const t = !this.observers.has(e) && this.updateCount > 0;
    super.addObserver(e), t && e.beginUpdate(this);
  }
  removeObserver(e) {
    const t = this.observers.has(e) && this.updateCount > 0;
    super.removeObserver(e), t && e.endUpdate(this);
  }
}
class mH extends Nd {
  constructor(e, t, i, n, o = void 0, r, a) {
    super(e, t, i, n, o, r), this.set = a;
  }
}
function Qe(s) {
  return new Ab(new ln(void 0, void 0, s), s, void 0, void 0);
}
function Mb(s, e) {
  return new Ab(new ln(s.owner, s.debugName, s.debugReferenceFn ?? e), e, void 0, void 0);
}
function Rb(s, e) {
  return new Ab(new ln(s.owner, s.debugName, s.debugReferenceFn ?? e), e, s.createEmptyChangeSummary, s.handleChange);
}
function so(s) {
  const e = new he(), t = Mb({
    owner: void 0,
    debugName: void 0,
    debugReferenceFn: s
  }, (i) => {
    e.clear(), s(i, e);
  });
  return ke(() => {
    t.dispose(), e.dispose();
  });
}
class Ab {
  get debugName() {
    return this._debugNameData.getDebugName(this) ?? "(anonymous)";
  }
  constructor(e, t, i, n) {
    var o;
    this._debugNameData = e, this._runFn = t, this.createChangeSummary = i, this._handleChange = n, this.state = 2, this.updateCount = 0, this.disposed = !1, this.dependencies = /* @__PURE__ */ new Set(), this.dependenciesToBeRemoved = /* @__PURE__ */ new Set(), this.changeSummary = (o = this.createChangeSummary) == null ? void 0 : o.call(this), this._runIfNeeded();
  }
  dispose() {
    this.disposed = !0;
    for (const e of this.dependencies)
      e.removeObserver(this);
    this.dependencies.clear();
  }
  _runIfNeeded() {
    var i, n;
    if (this.state === 3)
      return;
    const e = this.dependenciesToBeRemoved;
    this.dependenciesToBeRemoved = this.dependencies, this.dependencies = e, this.state = 3;
    const t = this.disposed;
    try {
      if (!t) {
        (i = fA()) == null || i.handleAutorunTriggered(this);
        const o = this.changeSummary;
        this.changeSummary = (n = this.createChangeSummary) == null ? void 0 : n.call(this), this._runFn(this, o);
      }
    } finally {
      for (const o of this.dependenciesToBeRemoved)
        o.removeObserver(this);
      this.dependenciesToBeRemoved.clear();
    }
  }
  toString() {
    return `Autorun<${this.debugName}>`;
  }
  // IObserver implementation
  beginUpdate() {
    this.state === 3 && (this.state = 1), this.updateCount++;
  }
  endUpdate() {
    if (this.updateCount === 1)
      do {
        if (this.state === 1) {
          this.state = 3;
          for (const e of this.dependencies)
            if (e.reportChanges(), this.state === 2)
              break;
        }
        this._runIfNeeded();
      } while (this.state !== 3);
    this.updateCount--, bc(() => this.updateCount >= 0);
  }
  handlePossibleChange(e) {
    this.state === 3 && this.dependencies.has(e) && !this.dependenciesToBeRemoved.has(e) && (this.state = 1);
  }
  handleChange(e, t) {
    this.dependencies.has(e) && !this.dependenciesToBeRemoved.has(e) && (!this._handleChange || this._handleChange({
      changedObservable: e,
      change: t,
      didChange: (n) => n === e
    }, this.changeSummary)) && (this.state = 2);
  }
  // IReader implementation
  readObservable(e) {
    if (this.disposed)
      return e.get();
    e.addObserver(this);
    const t = e.get();
    return this.dependencies.add(e), this.dependenciesToBeRemoved.delete(e), t;
  }
}
(function(s) {
  s.Observer = Ab;
})(Qe || (Qe = {}));
function n_(s) {
  return new pH(s);
}
class pH extends pA {
  constructor(e) {
    super(), this.value = e;
  }
  get debugName() {
    return this.toString();
  }
  get() {
    return this.value;
  }
  addObserver(e) {
  }
  removeObserver(e) {
  }
  toString() {
    return `Const: ${this.value}`;
  }
}
function Wt(...s) {
  let e, t, i;
  return s.length === 3 ? [e, t, i] = s : [t, i] = s, new wh(new ln(e, void 0, i), t, i, () => wh.globalTransaction, Fs);
}
class wh extends Ud {
  constructor(e, t, i, n, o) {
    super(), this._debugNameData = e, this.event = t, this._getValue = i, this._getTransaction = n, this._equalityComparator = o, this.hasValue = !1, this.handleEvent = (r) => {
      const a = this._getValue(r), l = this.value;
      (!this.hasValue || !this._equalityComparator(l, a)) && (this.value = a, this.hasValue && Ik(this._getTransaction(), (h) => {
        for (const d of this.observers)
          h.updateObserver(d, this), d.handleChange(this, void 0);
      }, () => {
        const h = this.getDebugName();
        return "Event fired" + (h ? `: ${h}` : "");
      }), this.hasValue = !0);
    };
  }
  getDebugName() {
    return this._debugNameData.getDebugName(this);
  }
  get debugName() {
    const e = this.getDebugName();
    return "From Event" + (e ? `: ${e}` : "");
  }
  onFirstObserverAdded() {
    this.subscription = this.event(this.handleEvent);
  }
  onLastObserverRemoved() {
    this.subscription.dispose(), this.subscription = void 0, this.hasValue = !1, this.value = void 0;
  }
  get() {
    return this.subscription ? (this.hasValue || this.handleEvent(void 0), this.value) : this._getValue(void 0);
  }
}
(function(s) {
  s.Observer = wh;
  function e(t, i) {
    let n = !1;
    wh.globalTransaction === void 0 && (wh.globalTransaction = t, n = !0);
    try {
      i();
    } finally {
      n && (wh.globalTransaction = void 0);
    }
  }
  s.batchEventsGlobally = e;
})(Wt || (Wt = {}));
function ds(s, e) {
  return new _H(s, e);
}
class _H extends Ud {
  constructor(e, t) {
    super(), this.debugName = e, this.event = t, this.handleEvent = () => {
      ni((i) => {
        for (const n of this.observers)
          i.updateObserver(n, this), n.handleChange(this, void 0);
      }, () => this.debugName);
    };
  }
  onFirstObserverAdded() {
    this.subscription = this.event(this.handleEvent);
  }
  onLastObserverRemoved() {
    this.subscription.dispose(), this.subscription = void 0;
  }
  get() {
  }
}
function Mk(s) {
  return typeof s == "string" ? new WI(s) : new WI(void 0, s);
}
class WI extends Ud {
  get debugName() {
    return new ln(this._owner, this._debugName, void 0).getDebugName(this) ?? "Observable Signal";
  }
  toString() {
    return this.debugName;
  }
  constructor(e, t) {
    super(), this._debugName = e, this._owner = t;
  }
  trigger(e, t) {
    if (!e) {
      ni((i) => {
        this.trigger(i, t);
      }, () => `Trigger signal ${this.debugName}`);
      return;
    }
    for (const i of this.observers)
      e.updateObserver(i, this), i.handleChange(this, t);
  }
  get() {
  }
}
function bH(s) {
  const e = new bA(!1, void 0);
  return s.addObserver(e), ke(() => {
    s.removeObserver(e);
  });
}
uH(bH);
function Pb(s, e) {
  const t = new bA(!0, e);
  return s.addObserver(t), e ? e(s.get()) : s.reportChanges(), ke(() => {
    s.removeObserver(t);
  });
}
dH(Pb);
class bA {
  constructor(e, t) {
    this._forceRecompute = e, this._handleValue = t, this._counter = 0;
  }
  beginUpdate(e) {
    this._counter++;
  }
  endUpdate(e) {
    this._counter--, this._counter === 0 && this._forceRecompute && (this._handleValue ? this._handleValue(e.get()) : e.reportChanges());
  }
  handlePossibleChange(e) {
  }
  handleChange(e, t) {
  }
}
function CH(s, e) {
  let t;
  return Tb({ owner: s, debugReferenceFn: e }, (n) => (t = e(n, t), t));
}
function wH(s, e) {
  return CH(s, (t, i) => i ?? e(t));
}
function vH(s, e, t, i) {
  return e || (e = (n) => n != null), new Promise((n, o) => {
    let r = !0, a = !1;
    const l = s.map((h) => ({
      isFinished: e(h),
      error: !1,
      state: h
    })), c = Qe((h) => {
      const { isFinished: d, error: u, state: f } = l.read(h);
      (d || u) && (r ? a = !0 : c.dispose(), u ? o(u === !0 ? f : u) : n(f));
    });
    r = !1, a && c.dispose();
  });
}
class yH extends Ud {
  get debugName() {
    return this._debugNameData.getDebugName(this) ?? "LazyObservableValue";
  }
  constructor(e, t, i) {
    super(), this._debugNameData = e, this._equalityComparator = i, this._isUpToDate = !0, this._deltas = [], this._updateCounter = 0, this._value = t;
  }
  get() {
    return this._update(), this._value;
  }
  _update() {
    if (!this._isUpToDate)
      if (this._isUpToDate = !0, this._deltas.length > 0) {
        for (const e of this.observers)
          for (const t of this._deltas)
            e.handleChange(this, t);
        this._deltas.length = 0;
      } else
        for (const e of this.observers)
          e.handleChange(this, void 0);
  }
  _beginUpdate() {
    if (this._updateCounter++, this._updateCounter === 1)
      for (const e of this.observers)
        e.beginUpdate(this);
  }
  _endUpdate() {
    if (this._updateCounter--, this._updateCounter === 0) {
      this._update();
      const e = [...this.observers];
      for (const t of e)
        t.endUpdate(this);
    }
  }
  addObserver(e) {
    const t = !this.observers.has(e) && this._updateCounter > 0;
    super.addObserver(e), t && e.beginUpdate(this);
  }
  removeObserver(e) {
    const t = this.observers.has(e) && this._updateCounter > 0;
    super.removeObserver(e), t && e.endUpdate(this);
  }
  set(e, t, i) {
    if (i === void 0 && this._equalityComparator(this._value, e))
      return;
    let n;
    t || (t = n = new Fg(() => {
    }, () => `Setting ${this.debugName}`));
    try {
      if (this._isUpToDate = !1, this._setValue(e), i !== void 0 && this._deltas.push(i), t.updateObserver({
        beginUpdate: () => this._beginUpdate(),
        endUpdate: () => this._endUpdate(),
        handleChange: (o, r) => {
        },
        handlePossibleChange: (o) => {
        }
      }, this), this._updateCounter > 1)
        for (const o of this.observers)
          o.handlePossibleChange(this);
    } finally {
      n && n.finish();
    }
  }
  toString() {
    return `${this.debugName}: ${this._value}`;
  }
  _setValue(e) {
    this._value = e;
  }
}
function ry(s, e) {
  return s.lazy ? new yH(new ln(s.owner, s.debugName, void 0), e, s.equalsFn ?? Fs) : new Nk(new ln(s.owner, s.debugName, void 0), e, s.equalsFn ?? Fs);
}
const vf = class vf extends q {
  constructor(e = !1) {
    super(), this._onDidRequestBasicLanguageFeatures = this._register(new O()), this.onDidRequestBasicLanguageFeatures = this._onDidRequestBasicLanguageFeatures.event, this._onDidRequestRichLanguageFeatures = this._register(new O()), this.onDidRequestRichLanguageFeatures = this._onDidRequestRichLanguageFeatures.event, this._onDidChange = this._register(new O({
      leakWarningThreshold: 200
      /* https://github.com/microsoft/vscode/issues/119968 */
    })), this.onDidChange = this._onDidChange.event, this._requestedBasicLanguages = /* @__PURE__ */ new Set(), this._requestedRichLanguages = /* @__PURE__ */ new Set(), vf.instanceCount++, this._registry = this._register(new ny(!0, e)), this.languageIdCodec = this._registry.languageIdCodec, this._register(this._registry.onDidChange(() => this._onDidChange.fire()));
  }
  dispose() {
    vf.instanceCount--, super.dispose();
  }
  isRegisteredLanguageId(e) {
    return this._registry.isRegisteredLanguageId(e);
  }
  getLanguageIdByLanguageName(e) {
    return this._registry.getLanguageIdByLanguageName(e);
  }
  getLanguageIdByMimeType(e) {
    return this._registry.getLanguageIdByMimeType(e);
  }
  guessLanguageIdByFilepathOrFirstLine(e, t) {
    const i = this._registry.guessLanguageIdByFilepathOrFirstLine(e, t);
    return gL(i, null);
  }
  createById(e) {
    return new VI(this.onDidChange, () => this._createAndGetLanguageIdentifier(e));
  }
  createByFilepathOrFirstLine(e, t) {
    return new VI(this.onDidChange, () => {
      const i = this.guessLanguageIdByFilepathOrFirstLine(e, t);
      return this._createAndGetLanguageIdentifier(i);
    });
  }
  _createAndGetLanguageIdentifier(e) {
    return (!e || !this.isRegisteredLanguageId(e)) && (e = Ms), e;
  }
  requestBasicLanguageFeatures(e) {
    this._requestedBasicLanguages.has(e) || (this._requestedBasicLanguages.add(e), this._onDidRequestBasicLanguageFeatures.fire(e));
  }
  requestRichLanguageFeatures(e) {
    this._requestedRichLanguages.has(e) || (this._requestedRichLanguages.add(e), this.requestBasicLanguageFeatures(e), Yt.getOrCreate(e), this._onDidRequestRichLanguageFeatures.fire(e));
  }
};
vf.instanceCount = 0;
let ay = vf;
class VI {
  constructor(e, t) {
    this._value = Wt(this, e, () => t()), this.onDidChange = J.fromObservable(this._value);
  }
  get languageId() {
    return this._value.get();
  }
}
const CA = {
  /**
   * Typically transfer type for copy/paste transfers.
   */
  TEXT: Dr.text
}, SH = () => ({
  get delay() {
    return -1;
  },
  dispose: () => {
  },
  showHover: () => {
  }
});
let Ob = SH;
const LH = new Ha(() => Ob("mouse", !1)), kH = new Ha(() => Ob("element", !1));
function xH(s) {
  Ob = s;
}
function Cs(s) {
  return s === "element" ? kH.value : LH.value;
}
function Rk() {
  return Ob("element", !0);
}
let wA = {
  showHover: () => {
  },
  hideHover: () => {
  },
  showAndFocusLastHover: () => {
  },
  setupManagedHover: () => null,
  showManagedHover: () => {
  }
};
function DH(s) {
  wA = s;
}
function Yo() {
  return wA;
}
class EH {
  constructor(e) {
    this.spliceables = e;
  }
  splice(e, t, i) {
    this.spliceables.forEach((n) => n.splice(e, t, i));
  }
}
class ll extends Error {
  constructor(e, t) {
    super(`ListError [${e}] ${t}`);
  }
}
function HI(s, e) {
  const t = [];
  for (const i of e) {
    if (s.start >= i.range.end)
      continue;
    if (s.end < i.range.start)
      break;
    const n = Pi.intersect(s, i.range);
    Pi.isEmpty(n) || t.push({
      range: n,
      size: i.size
    });
  }
  return t;
}
function ly({ start: s, end: e }, t) {
  return { start: s + t, end: e + t };
}
function IH(s) {
  const e = [];
  let t = null;
  for (const i of s) {
    const n = i.range.start, o = i.range.end, r = i.size;
    if (t && r === t.size) {
      t.range.end = o;
      continue;
    }
    t = { range: { start: n, end: o }, size: r }, e.push(t);
  }
  return e;
}
function NH(...s) {
  return IH(s.reduce((e, t) => e.concat(t), []));
}
class TH {
  get paddingTop() {
    return this._paddingTop;
  }
  set paddingTop(e) {
    this._size = this._size + e - this._paddingTop, this._paddingTop = e;
  }
  constructor(e) {
    this.groups = [], this._size = 0, this._paddingTop = 0, this._paddingTop = e ?? 0, this._size = this._paddingTop;
  }
  splice(e, t, i = []) {
    const n = i.length - t, o = HI({ start: 0, end: e }, this.groups), r = HI({ start: e + t, end: Number.POSITIVE_INFINITY }, this.groups).map((l) => ({ range: ly(l.range, n), size: l.size })), a = i.map((l, c) => ({
      range: { start: e + c, end: e + c + 1 },
      size: l.size
    }));
    this.groups = NH(o, a, r), this._size = this._paddingTop + this.groups.reduce((l, c) => l + c.size * (c.range.end - c.range.start), 0);
  }
  /**
   * Returns the number of items in the range map.
   */
  get count() {
    const e = this.groups.length;
    return e ? this.groups[e - 1].range.end : 0;
  }
  /**
   * Returns the sum of the sizes of all items in the range map.
   */
  get size() {
    return this._size;
  }
  /**
   * Returns the index of the item at the given position.
   */
  indexAt(e) {
    if (e < 0)
      return -1;
    if (e < this._paddingTop)
      return 0;
    let t = 0, i = this._paddingTop;
    for (const n of this.groups) {
      const o = n.range.end - n.range.start, r = i + o * n.size;
      if (e < r)
        return t + Math.floor((e - i) / n.size);
      t += o, i = r;
    }
    return t;
  }
  /**
   * Returns the index of the item right after the item at the
   * index of the given position.
   */
  indexAfter(e) {
    return Math.min(this.indexAt(e) + 1, this.count);
  }
  /**
   * Returns the start position of the item at the given index.
   */
  positionAt(e) {
    if (e < 0)
      return -1;
    let t = 0, i = 0;
    for (const n of this.groups) {
      const o = n.range.end - n.range.start, r = i + o;
      if (e < r)
        return this._paddingTop + t + (e - i) * n.size;
      t += o * n.size, i = r;
    }
    return -1;
  }
}
class MH {
  constructor(e) {
    this.renderers = e, this.cache = /* @__PURE__ */ new Map(), this.transactionNodesPendingRemoval = /* @__PURE__ */ new Set(), this.inTransaction = !1;
  }
  /**
   * Returns a row either by creating a new one or reusing
   * a previously released row which shares the same templateId.
   *
   * @returns A row and `isReusingConnectedDomNode` if the row's node is already in the dom in a stale position.
   */
  alloc(e) {
    let t = this.getTemplateCache(e).pop(), i = !1;
    if (t)
      i = this.transactionNodesPendingRemoval.has(t.domNode), i && this.transactionNodesPendingRemoval.delete(t.domNode);
    else {
      const n = pe(".monaco-list-row"), r = this.getRenderer(e).renderTemplate(n);
      t = { domNode: n, templateId: e, templateData: r };
    }
    return { row: t, isReusingConnectedDomNode: i };
  }
  /**
   * Releases the row for eventual reuse.
   */
  release(e) {
    e && this.releaseRow(e);
  }
  /**
   * Begin a set of changes that use the cache. This lets us skip work when a row is removed and then inserted again.
   */
  transact(e) {
    if (this.inTransaction)
      throw new Error("Already in transaction");
    this.inTransaction = !0;
    try {
      e();
    } finally {
      for (const t of this.transactionNodesPendingRemoval)
        this.doRemoveNode(t);
      this.transactionNodesPendingRemoval.clear(), this.inTransaction = !1;
    }
  }
  releaseRow(e) {
    const { domNode: t, templateId: i } = e;
    t && (this.inTransaction ? this.transactionNodesPendingRemoval.add(t) : this.doRemoveNode(t)), this.getTemplateCache(i).push(e);
  }
  doRemoveNode(e) {
    e.classList.remove("scrolling"), e.remove();
  }
  getTemplateCache(e) {
    let t = this.cache.get(e);
    return t || (t = [], this.cache.set(e, t)), t;
  }
  dispose() {
    this.cache.forEach((e, t) => {
      for (const i of e)
        this.getRenderer(t).disposeTemplate(i.templateData), i.templateData = null;
    }), this.cache.clear(), this.transactionNodesPendingRemoval.clear();
  }
  getRenderer(e) {
    const t = this.renderers.get(e);
    if (!t)
      throw new Error(`No renderer found for ${e}`);
    return t;
  }
}
var ia = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
};
const cl = {
  CurrentDragAndDropData: void 0
}, vo = {
  useShadows: !0,
  verticalScrollMode: 1,
  setRowLineHeight: !0,
  setRowHeight: !0,
  supportDynamicHeights: !1,
  dnd: {
    getDragElements(s) {
      return [s];
    },
    getDragURI() {
      return null;
    },
    onDragStart() {
    },
    onDragOver() {
      return !1;
    },
    drop() {
    },
    dispose() {
    }
  },
  horizontalScrolling: !1,
  transformOptimization: !0,
  alwaysConsumeMouseWheel: !0
};
class Bg {
  constructor(e) {
    this.elements = e;
  }
  update() {
  }
  getData() {
    return this.elements;
  }
}
class RH {
  constructor(e) {
    this.elements = e;
  }
  update() {
  }
  getData() {
    return this.elements;
  }
}
class AH {
  constructor() {
    this.types = [], this.files = [];
  }
  update(e) {
    if (e.types && this.types.splice(0, this.types.length, ...e.types), e.files) {
      this.files.splice(0, this.files.length);
      for (let t = 0; t < e.files.length; t++) {
        const i = e.files.item(t);
        i && (i.size || i.type) && this.files.push(i);
      }
    }
  }
  getData() {
    return {
      types: this.types,
      files: this.files
    };
  }
}
function PH(s, e) {
  return Array.isArray(s) && Array.isArray(e) ? oi(s, e) : s === e;
}
class OH {
  constructor(e) {
    e != null && e.getSetSize ? this.getSetSize = e.getSetSize.bind(e) : this.getSetSize = (t, i, n) => n, e != null && e.getPosInSet ? this.getPosInSet = e.getPosInSet.bind(e) : this.getPosInSet = (t, i) => i + 1, e != null && e.getRole ? this.getRole = e.getRole.bind(e) : this.getRole = (t) => "listitem", e != null && e.isChecked ? this.isChecked = e.isChecked.bind(e) : this.isChecked = (t) => {
    };
  }
}
const w1 = class w1 {
  get contentHeight() {
    return this.rangeMap.size;
  }
  get onDidScroll() {
    return this.scrollableElement.onScroll;
  }
  get scrollableElementDomNode() {
    return this.scrollableElement.getDomNode();
  }
  get horizontalScrolling() {
    return this._horizontalScrolling;
  }
  set horizontalScrolling(e) {
    if (e !== this._horizontalScrolling) {
      if (e && this.supportDynamicHeights)
        throw new Error("Horizontal scrolling and dynamic heights not supported simultaneously");
      if (this._horizontalScrolling = e, this.domNode.classList.toggle("horizontal-scrolling", this._horizontalScrolling), this._horizontalScrolling) {
        for (const t of this.items)
          this.measureItemWidth(t);
        this.updateScrollWidth(), this.scrollableElement.setScrollDimensions({ width: b0(this.domNode) }), this.rowsContainer.style.width = `${Math.max(this.scrollWidth || 0, this.renderWidth)}px`;
      } else
        this.scrollableElementWidthDelayer.cancel(), this.scrollableElement.setScrollDimensions({ width: this.renderWidth, scrollWidth: this.renderWidth }), this.rowsContainer.style.width = "";
    }
  }
  constructor(e, t, i, n = vo) {
    var r, a;
    if (this.virtualDelegate = t, this.domId = `list_id_${++w1.InstanceCount}`, this.renderers = /* @__PURE__ */ new Map(), this.renderWidth = 0, this._scrollHeight = 0, this.scrollableElementUpdateDisposable = null, this.scrollableElementWidthDelayer = new kg(50), this.splicing = !1, this.dragOverAnimationStopDisposable = q.None, this.dragOverMouseY = 0, this.canDrop = !1, this.currentDragFeedbackDisposable = q.None, this.onDragLeaveTimeout = q.None, this.disposables = new he(), this._onDidChangeContentHeight = new O(), this._onDidChangeContentWidth = new O(), this.onDidChangeContentHeight = J.latch(this._onDidChangeContentHeight.event, void 0, this.disposables), this._horizontalScrolling = !1, n.horizontalScrolling && n.supportDynamicHeights)
      throw new Error("Horizontal scrolling and dynamic heights not supported simultaneously");
    this.items = [], this.itemId = 0, this.rangeMap = this.createRangeMap(n.paddingTop ?? 0);
    for (const l of i)
      this.renderers.set(l.templateId, l);
    this.cache = this.disposables.add(new MH(this.renderers)), this.lastRenderTop = 0, this.lastRenderHeight = 0, this.domNode = document.createElement("div"), this.domNode.className = "monaco-list", this.domNode.classList.add(this.domId), this.domNode.tabIndex = 0, this.domNode.classList.toggle("mouse-support", typeof n.mouseSupport == "boolean" ? n.mouseSupport : !0), this._horizontalScrolling = n.horizontalScrolling ?? vo.horizontalScrolling, this.domNode.classList.toggle("horizontal-scrolling", this._horizontalScrolling), this.paddingBottom = typeof n.paddingBottom > "u" ? 0 : n.paddingBottom, this.accessibilityProvider = new OH(n.accessibilityProvider), this.rowsContainer = document.createElement("div"), this.rowsContainer.className = "monaco-list-rows", (n.transformOptimization ?? vo.transformOptimization) && (this.rowsContainer.style.transform = "translate3d(0px, 0px, 0px)", this.rowsContainer.style.overflow = "hidden", this.rowsContainer.style.contain = "strict"), this.disposables.add(an.addTarget(this.rowsContainer)), this.scrollable = this.disposables.add(new zd({
      forceIntegerValues: !0,
      smoothScrollDuration: n.smoothScrolling ?? !1 ? 125 : 0,
      scheduleAtNextAnimationFrame: (l) => Wn(ue(this.domNode), l)
    })), this.scrollableElement = this.disposables.add(new xb(this.rowsContainer, {
      alwaysConsumeMouseWheel: n.alwaysConsumeMouseWheel ?? vo.alwaysConsumeMouseWheel,
      horizontal: 1,
      vertical: n.verticalScrollMode ?? vo.verticalScrollMode,
      useShadows: n.useShadows ?? vo.useShadows,
      mouseWheelScrollSensitivity: n.mouseWheelScrollSensitivity,
      fastScrollSensitivity: n.fastScrollSensitivity,
      scrollByPage: n.scrollByPage
    }, this.scrollable)), this.domNode.appendChild(this.scrollableElement.getDomNode()), e.appendChild(this.domNode), this.scrollableElement.onScroll(this.onScroll, this, this.disposables), this.disposables.add($(this.rowsContainer, bt.Change, (l) => this.onTouchChange(l))), this.disposables.add($(this.scrollableElement.getDomNode(), "scroll", (l) => l.target.scrollTop = 0)), this.disposables.add($(this.domNode, "dragover", (l) => this.onDragOver(this.toDragEvent(l)))), this.disposables.add($(this.domNode, "drop", (l) => this.onDrop(this.toDragEvent(l)))), this.disposables.add($(this.domNode, "dragleave", (l) => this.onDragLeave(this.toDragEvent(l)))), this.disposables.add($(this.domNode, "dragend", (l) => this.onDragEnd(l))), this.setRowLineHeight = n.setRowLineHeight ?? vo.setRowLineHeight, this.setRowHeight = n.setRowHeight ?? vo.setRowHeight, this.supportDynamicHeights = n.supportDynamicHeights ?? vo.supportDynamicHeights, this.dnd = n.dnd ?? this.disposables.add(vo.dnd), this.layout((r = n.initialSize) == null ? void 0 : r.height, (a = n.initialSize) == null ? void 0 : a.width);
  }
  updateOptions(e) {
    e.paddingBottom !== void 0 && (this.paddingBottom = e.paddingBottom, this.scrollableElement.setScrollDimensions({ scrollHeight: this.scrollHeight })), e.smoothScrolling !== void 0 && this.scrollable.setSmoothScrollDuration(e.smoothScrolling ? 125 : 0), e.horizontalScrolling !== void 0 && (this.horizontalScrolling = e.horizontalScrolling);
    let t;
    if (e.scrollByPage !== void 0 && (t = { ...t ?? {}, scrollByPage: e.scrollByPage }), e.mouseWheelScrollSensitivity !== void 0 && (t = { ...t ?? {}, mouseWheelScrollSensitivity: e.mouseWheelScrollSensitivity }), e.fastScrollSensitivity !== void 0 && (t = { ...t ?? {}, fastScrollSensitivity: e.fastScrollSensitivity }), t && this.scrollableElement.updateOptions(t), e.paddingTop !== void 0 && e.paddingTop !== this.rangeMap.paddingTop) {
      const i = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight), n = e.paddingTop - this.rangeMap.paddingTop;
      this.rangeMap.paddingTop = e.paddingTop, this.render(i, Math.max(0, this.lastRenderTop + n), this.lastRenderHeight, void 0, void 0, !0), this.setScrollTop(this.lastRenderTop), this.eventuallyUpdateScrollDimensions(), this.supportDynamicHeights && this._rerender(this.lastRenderTop, this.lastRenderHeight);
    }
  }
  createRangeMap(e) {
    return new TH(e);
  }
  splice(e, t, i = []) {
    if (this.splicing)
      throw new Error("Can't run recursive splices.");
    this.splicing = !0;
    try {
      return this._splice(e, t, i);
    } finally {
      this.splicing = !1, this._onDidChangeContentHeight.fire(this.contentHeight);
    }
  }
  _splice(e, t, i = []) {
    const n = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight), o = { start: e, end: e + t }, r = Pi.intersect(n, o), a = /* @__PURE__ */ new Map();
    for (let S = r.end - 1; S >= r.start; S--) {
      const L = this.items[S];
      if (L.dragStartDisposable.dispose(), L.checkedDisposable.dispose(), L.row) {
        let k = a.get(L.templateId);
        k || (k = [], a.set(L.templateId, k));
        const D = this.renderers.get(L.templateId);
        D && D.disposeElement && D.disposeElement(L.element, S, L.row.templateData, L.size), k.unshift(L.row);
      }
      L.row = null, L.stale = !0;
    }
    const l = { start: e + t, end: this.items.length }, c = Pi.intersect(l, n), h = Pi.relativeComplement(l, n), d = i.map((S) => ({
      id: String(this.itemId++),
      element: S,
      templateId: this.virtualDelegate.getTemplateId(S),
      size: this.virtualDelegate.getHeight(S),
      width: void 0,
      hasDynamicHeight: !!this.virtualDelegate.hasDynamicHeight && this.virtualDelegate.hasDynamicHeight(S),
      lastDynamicHeightWidth: void 0,
      row: null,
      uri: void 0,
      dropTarget: !1,
      dragStartDisposable: q.None,
      checkedDisposable: q.None,
      stale: !1
    }));
    let u;
    e === 0 && t >= this.items.length ? (this.rangeMap = this.createRangeMap(this.rangeMap.paddingTop), this.rangeMap.splice(0, 0, d), u = this.items, this.items = d) : (this.rangeMap.splice(e, t, d), u = this.items.splice(e, t, ...d));
    const f = i.length - t, g = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight), m = ly(c, f), _ = Pi.intersect(g, m);
    for (let S = _.start; S < _.end; S++)
      this.updateItemInDOM(this.items[S], S);
    const b = Pi.relativeComplement(m, g);
    for (const S of b)
      for (let L = S.start; L < S.end; L++)
        this.removeItemFromDOM(L);
    const C = h.map((S) => ly(S, f)), w = [{ start: e, end: e + i.length }, ...C].map((S) => Pi.intersect(g, S)).reverse();
    for (const S of w)
      for (let L = S.end - 1; L >= S.start; L--) {
        const k = this.items[L], D = a.get(k.templateId), E = D == null ? void 0 : D.pop();
        this.insertItemInDOM(L, E);
      }
    for (const S of a.values())
      for (const L of S)
        this.cache.release(L);
    return this.eventuallyUpdateScrollDimensions(), this.supportDynamicHeights && this._rerender(this.scrollTop, this.renderHeight), u.map((S) => S.element);
  }
  eventuallyUpdateScrollDimensions() {
    this._scrollHeight = this.contentHeight, this.rowsContainer.style.height = `${this._scrollHeight}px`, this.scrollableElementUpdateDisposable || (this.scrollableElementUpdateDisposable = Wn(ue(this.domNode), () => {
      this.scrollableElement.setScrollDimensions({ scrollHeight: this.scrollHeight }), this.updateScrollWidth(), this.scrollableElementUpdateDisposable = null;
    }));
  }
  eventuallyUpdateScrollWidth() {
    if (!this.horizontalScrolling) {
      this.scrollableElementWidthDelayer.cancel();
      return;
    }
    this.scrollableElementWidthDelayer.trigger(() => this.updateScrollWidth());
  }
  updateScrollWidth() {
    if (!this.horizontalScrolling)
      return;
    let e = 0;
    for (const t of this.items)
      typeof t.width < "u" && (e = Math.max(e, t.width));
    this.scrollWidth = e, this.scrollableElement.setScrollDimensions({ scrollWidth: e === 0 ? 0 : e + 10 }), this._onDidChangeContentWidth.fire(this.scrollWidth);
  }
  rerender() {
    if (this.supportDynamicHeights) {
      for (const e of this.items)
        e.lastDynamicHeightWidth = void 0;
      this._rerender(this.lastRenderTop, this.lastRenderHeight);
    }
  }
  get length() {
    return this.items.length;
  }
  get renderHeight() {
    return this.scrollableElement.getScrollDimensions().height;
  }
  get firstVisibleIndex() {
    return this.getRenderRange(this.lastRenderTop, this.lastRenderHeight).start;
  }
  element(e) {
    return this.items[e].element;
  }
  indexOf(e) {
    return this.items.findIndex((t) => t.element === e);
  }
  domElement(e) {
    const t = this.items[e].row;
    return t && t.domNode;
  }
  elementHeight(e) {
    return this.items[e].size;
  }
  elementTop(e) {
    return this.rangeMap.positionAt(e);
  }
  indexAt(e) {
    return this.rangeMap.indexAt(e);
  }
  indexAfter(e) {
    return this.rangeMap.indexAfter(e);
  }
  layout(e, t) {
    const i = {
      height: typeof e == "number" ? e : t7(this.domNode)
    };
    this.scrollableElementUpdateDisposable && (this.scrollableElementUpdateDisposable.dispose(), this.scrollableElementUpdateDisposable = null, i.scrollHeight = this.scrollHeight), this.scrollableElement.setScrollDimensions(i), typeof t < "u" && (this.renderWidth = t, this.supportDynamicHeights && this._rerender(this.scrollTop, this.renderHeight)), this.horizontalScrolling && this.scrollableElement.setScrollDimensions({
      width: typeof t == "number" ? t : b0(this.domNode)
    });
  }
  // Render
  render(e, t, i, n, o, r = !1) {
    const a = this.getRenderRange(t, i), l = Pi.relativeComplement(a, e).reverse(), c = Pi.relativeComplement(e, a);
    if (r) {
      const h = Pi.intersect(e, a);
      for (let d = h.start; d < h.end; d++)
        this.updateItemInDOM(this.items[d], d);
    }
    this.cache.transact(() => {
      for (const h of c)
        for (let d = h.start; d < h.end; d++)
          this.removeItemFromDOM(d);
      for (const h of l)
        for (let d = h.end - 1; d >= h.start; d--)
          this.insertItemInDOM(d);
    }), n !== void 0 && (this.rowsContainer.style.left = `-${n}px`), this.rowsContainer.style.top = `-${t}px`, this.horizontalScrolling && o !== void 0 && (this.rowsContainer.style.width = `${Math.max(o, this.renderWidth)}px`), this.lastRenderTop = t, this.lastRenderHeight = i;
  }
  // DOM operations
  insertItemInDOM(e, t) {
    var l, c;
    const i = this.items[e];
    if (!i.row)
      if (t)
        i.row = t, i.stale = !0;
      else {
        const h = this.cache.alloc(i.templateId);
        i.row = h.row, i.stale || (i.stale = h.isReusingConnectedDomNode);
      }
    const n = this.accessibilityProvider.getRole(i.element) || "listitem";
    i.row.domNode.setAttribute("role", n);
    const o = this.accessibilityProvider.isChecked(i.element);
    if (typeof o == "boolean")
      i.row.domNode.setAttribute("aria-checked", String(!!o));
    else if (o) {
      const h = (d) => i.row.domNode.setAttribute("aria-checked", String(!!d));
      h(o.value), i.checkedDisposable = o.onDidChange(() => h(o.value));
    }
    if (i.stale || !i.row.domNode.parentElement) {
      const h = ((c = (l = this.items.at(e + 1)) == null ? void 0 : l.row) == null ? void 0 : c.domNode) ?? null;
      (i.row.domNode.parentElement !== this.rowsContainer || i.row.domNode.nextElementSibling !== h) && this.rowsContainer.insertBefore(i.row.domNode, h), i.stale = !1;
    }
    this.updateItemInDOM(i, e);
    const r = this.renderers.get(i.templateId);
    if (!r)
      throw new Error(`No renderer found for template id ${i.templateId}`);
    r == null || r.renderElement(i.element, e, i.row.templateData, i.size);
    const a = this.dnd.getDragURI(i.element);
    i.dragStartDisposable.dispose(), i.row.domNode.draggable = !!a, a && (i.dragStartDisposable = $(i.row.domNode, "dragstart", (h) => this.onDragStart(i.element, a, h))), this.horizontalScrolling && (this.measureItemWidth(i), this.eventuallyUpdateScrollWidth());
  }
  measureItemWidth(e) {
    if (!e.row || !e.row.domNode)
      return;
    e.row.domNode.style.width = "fit-content", e.width = b0(e.row.domNode);
    const t = ue(e.row.domNode).getComputedStyle(e.row.domNode);
    t.paddingLeft && (e.width += parseFloat(t.paddingLeft)), t.paddingRight && (e.width += parseFloat(t.paddingRight)), e.row.domNode.style.width = "";
  }
  updateItemInDOM(e, t) {
    e.row.domNode.style.top = `${this.elementTop(t)}px`, this.setRowHeight && (e.row.domNode.style.height = `${e.size}px`), this.setRowLineHeight && (e.row.domNode.style.lineHeight = `${e.size}px`), e.row.domNode.setAttribute("data-index", `${t}`), e.row.domNode.setAttribute("data-last-element", t === this.length - 1 ? "true" : "false"), e.row.domNode.setAttribute("data-parity", t % 2 === 0 ? "even" : "odd"), e.row.domNode.setAttribute("aria-setsize", String(this.accessibilityProvider.getSetSize(e.element, t, this.length))), e.row.domNode.setAttribute("aria-posinset", String(this.accessibilityProvider.getPosInSet(e.element, t))), e.row.domNode.setAttribute("id", this.getElementDomId(t)), e.row.domNode.classList.toggle("drop-target", e.dropTarget);
  }
  removeItemFromDOM(e) {
    const t = this.items[e];
    if (t.dragStartDisposable.dispose(), t.checkedDisposable.dispose(), t.row) {
      const i = this.renderers.get(t.templateId);
      i && i.disposeElement && i.disposeElement(t.element, e, t.row.templateData, t.size), this.cache.release(t.row), t.row = null;
    }
    this.horizontalScrolling && this.eventuallyUpdateScrollWidth();
  }
  getScrollTop() {
    return this.scrollableElement.getScrollPosition().scrollTop;
  }
  setScrollTop(e, t) {
    this.scrollableElementUpdateDisposable && (this.scrollableElementUpdateDisposable.dispose(), this.scrollableElementUpdateDisposable = null, this.scrollableElement.setScrollDimensions({ scrollHeight: this.scrollHeight })), this.scrollableElement.setScrollPosition({ scrollTop: e, reuseAnimation: t });
  }
  get scrollTop() {
    return this.getScrollTop();
  }
  set scrollTop(e) {
    this.setScrollTop(e);
  }
  get scrollHeight() {
    return this._scrollHeight + (this.horizontalScrolling ? 10 : 0) + this.paddingBottom;
  }
  // Events
  get onMouseClick() {
    return J.map(this.disposables.add(new Re(this.domNode, "click")).event, (e) => this.toMouseEvent(e), this.disposables);
  }
  get onMouseDblClick() {
    return J.map(this.disposables.add(new Re(this.domNode, "dblclick")).event, (e) => this.toMouseEvent(e), this.disposables);
  }
  get onMouseMiddleClick() {
    return J.filter(J.map(this.disposables.add(new Re(this.domNode, "auxclick")).event, (e) => this.toMouseEvent(e), this.disposables), (e) => e.browserEvent.button === 1, this.disposables);
  }
  get onMouseDown() {
    return J.map(this.disposables.add(new Re(this.domNode, "mousedown")).event, (e) => this.toMouseEvent(e), this.disposables);
  }
  get onMouseOver() {
    return J.map(this.disposables.add(new Re(this.domNode, "mouseover")).event, (e) => this.toMouseEvent(e), this.disposables);
  }
  get onMouseOut() {
    return J.map(this.disposables.add(new Re(this.domNode, "mouseout")).event, (e) => this.toMouseEvent(e), this.disposables);
  }
  get onContextMenu() {
    return J.any(J.map(this.disposables.add(new Re(this.domNode, "contextmenu")).event, (e) => this.toMouseEvent(e), this.disposables), J.map(this.disposables.add(new Re(this.domNode, bt.Contextmenu)).event, (e) => this.toGestureEvent(e), this.disposables));
  }
  get onTouchStart() {
    return J.map(this.disposables.add(new Re(this.domNode, "touchstart")).event, (e) => this.toTouchEvent(e), this.disposables);
  }
  get onTap() {
    return J.map(this.disposables.add(new Re(this.rowsContainer, bt.Tap)).event, (e) => this.toGestureEvent(e), this.disposables);
  }
  toMouseEvent(e) {
    const t = this.getItemIndexFromEventTarget(e.target || null), i = typeof t > "u" ? void 0 : this.items[t], n = i && i.element;
    return { browserEvent: e, index: t, element: n };
  }
  toTouchEvent(e) {
    const t = this.getItemIndexFromEventTarget(e.target || null), i = typeof t > "u" ? void 0 : this.items[t], n = i && i.element;
    return { browserEvent: e, index: t, element: n };
  }
  toGestureEvent(e) {
    const t = this.getItemIndexFromEventTarget(e.initialTarget || null), i = typeof t > "u" ? void 0 : this.items[t], n = i && i.element;
    return { browserEvent: e, index: t, element: n };
  }
  toDragEvent(e) {
    const t = this.getItemIndexFromEventTarget(e.target || null), i = typeof t > "u" ? void 0 : this.items[t], n = i && i.element, o = this.getTargetSector(e, t);
    return { browserEvent: e, index: t, element: n, sector: o };
  }
  onScroll(e) {
    try {
      const t = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
      this.render(t, e.scrollTop, e.height, e.scrollLeft, e.scrollWidth), this.supportDynamicHeights && this._rerender(e.scrollTop, e.height, e.inSmoothScrolling);
    } catch (t) {
      throw console.error("Got bad scroll event:", e), t;
    }
  }
  onTouchChange(e) {
    e.preventDefault(), e.stopPropagation(), this.scrollTop -= e.translationY;
  }
  // DND
  onDragStart(e, t, i) {
    var o, r;
    if (!i.dataTransfer)
      return;
    const n = this.dnd.getDragElements(e);
    if (i.dataTransfer.effectAllowed = "copyMove", i.dataTransfer.setData(CA.TEXT, t), i.dataTransfer.setDragImage) {
      let a;
      this.dnd.getDragLabel && (a = this.dnd.getDragLabel(n, i)), typeof a > "u" && (a = String(n.length));
      const l = pe(".monaco-drag-image");
      l.textContent = a, ((d) => {
        for (; d && !d.classList.contains("monaco-workbench"); )
          d = d.parentElement;
        return d || this.domNode.ownerDocument;
      })(this.domNode).appendChild(l), i.dataTransfer.setDragImage(l, -10, -10), setTimeout(() => l.remove(), 0);
    }
    this.domNode.classList.add("dragging"), this.currentDragData = new Bg(n), cl.CurrentDragAndDropData = new RH(n), (r = (o = this.dnd).onDragStart) == null || r.call(o, this.currentDragData, i);
  }
  onDragOver(e) {
    var o, r;
    if (e.browserEvent.preventDefault(), this.onDragLeaveTimeout.dispose(), cl.CurrentDragAndDropData && cl.CurrentDragAndDropData.getData() === "vscode-ui" || (this.setupDragAndDropScrollTopAnimation(e.browserEvent), !e.browserEvent.dataTransfer))
      return !1;
    if (!this.currentDragData)
      if (cl.CurrentDragAndDropData)
        this.currentDragData = cl.CurrentDragAndDropData;
      else {
        if (!e.browserEvent.dataTransfer.types)
          return !1;
        this.currentDragData = new AH();
      }
    const t = this.dnd.onDragOver(this.currentDragData, e.element, e.index, e.sector, e.browserEvent);
    if (this.canDrop = typeof t == "boolean" ? t : t.accept, !this.canDrop)
      return this.currentDragFeedback = void 0, this.currentDragFeedbackDisposable.dispose(), !1;
    e.browserEvent.dataTransfer.dropEffect = typeof t != "boolean" && ((o = t.effect) == null ? void 0 : o.type) === 0 ? "copy" : "move";
    let i;
    typeof t != "boolean" && t.feedback ? i = t.feedback : typeof e.index > "u" ? i = [-1] : i = [e.index], i = uc(i).filter((a) => a >= -1 && a < this.length).sort((a, l) => a - l), i = i[0] === -1 ? [-1] : i;
    let n = typeof t != "boolean" && t.effect && t.effect.position ? t.effect.position : "drop-target";
    if (PH(this.currentDragFeedback, i) && this.currentDragFeedbackPosition === n)
      return !0;
    if (this.currentDragFeedback = i, this.currentDragFeedbackPosition = n, this.currentDragFeedbackDisposable.dispose(), i[0] === -1)
      this.domNode.classList.add(n), this.rowsContainer.classList.add(n), this.currentDragFeedbackDisposable = ke(() => {
        this.domNode.classList.remove(n), this.rowsContainer.classList.remove(n);
      });
    else {
      if (i.length > 1 && n !== "drop-target")
        throw new Error("Can't use multiple feedbacks with position different than 'over'");
      n === "drop-target-after" && i[0] < this.length - 1 && (i[0] += 1, n = "drop-target-before");
      for (const a of i) {
        const l = this.items[a];
        l.dropTarget = !0, (r = l.row) == null || r.domNode.classList.add(n);
      }
      this.currentDragFeedbackDisposable = ke(() => {
        var a;
        for (const l of i) {
          const c = this.items[l];
          c.dropTarget = !1, (a = c.row) == null || a.domNode.classList.remove(n);
        }
      });
    }
    return !0;
  }
  onDragLeave(e) {
    var t, i;
    this.onDragLeaveTimeout.dispose(), this.onDragLeaveTimeout = zw(() => this.clearDragOverFeedback(), 100, this.disposables), this.currentDragData && ((i = (t = this.dnd).onDragLeave) == null || i.call(t, this.currentDragData, e.element, e.index, e.browserEvent));
  }
  onDrop(e) {
    if (!this.canDrop)
      return;
    const t = this.currentDragData;
    this.teardownDragAndDropScrollTopAnimation(), this.clearDragOverFeedback(), this.domNode.classList.remove("dragging"), this.currentDragData = void 0, cl.CurrentDragAndDropData = void 0, !(!t || !e.browserEvent.dataTransfer) && (e.browserEvent.preventDefault(), t.update(e.browserEvent.dataTransfer), this.dnd.drop(t, e.element, e.index, e.sector, e.browserEvent));
  }
  onDragEnd(e) {
    var t, i;
    this.canDrop = !1, this.teardownDragAndDropScrollTopAnimation(), this.clearDragOverFeedback(), this.domNode.classList.remove("dragging"), this.currentDragData = void 0, cl.CurrentDragAndDropData = void 0, (i = (t = this.dnd).onDragEnd) == null || i.call(t, e);
  }
  clearDragOverFeedback() {
    this.currentDragFeedback = void 0, this.currentDragFeedbackPosition = void 0, this.currentDragFeedbackDisposable.dispose(), this.currentDragFeedbackDisposable = q.None;
  }
  // DND scroll top animation
  setupDragAndDropScrollTopAnimation(e) {
    if (!this.dragOverAnimationDisposable) {
      const t = e7(this.domNode).top;
      this.dragOverAnimationDisposable = f7(ue(this.domNode), this.animateDragAndDropScrollTop.bind(this, t));
    }
    this.dragOverAnimationStopDisposable.dispose(), this.dragOverAnimationStopDisposable = zw(() => {
      this.dragOverAnimationDisposable && (this.dragOverAnimationDisposable.dispose(), this.dragOverAnimationDisposable = void 0);
    }, 1e3, this.disposables), this.dragOverMouseY = e.pageY;
  }
  animateDragAndDropScrollTop(e) {
    if (this.dragOverMouseY === void 0)
      return;
    const t = this.dragOverMouseY - e, i = this.renderHeight - 35;
    t < 35 ? this.scrollTop += Math.max(-14, Math.floor(0.3 * (t - 35))) : t > i && (this.scrollTop += Math.min(14, Math.floor(0.3 * (t - i))));
  }
  teardownDragAndDropScrollTopAnimation() {
    this.dragOverAnimationStopDisposable.dispose(), this.dragOverAnimationDisposable && (this.dragOverAnimationDisposable.dispose(), this.dragOverAnimationDisposable = void 0);
  }
  // Util
  getTargetSector(e, t) {
    if (t === void 0)
      return;
    const i = e.offsetY / this.items[t].size, n = Math.floor(i / 0.25);
    return gn(n, 0, 3);
  }
  getItemIndexFromEventTarget(e) {
    const t = this.scrollableElement.getDomNode();
    let i = e;
    for (; (yi(i) || a7(i)) && i !== this.rowsContainer && t.contains(i); ) {
      const n = i.getAttribute("data-index");
      if (n) {
        const o = Number(n);
        if (!isNaN(o))
          return o;
      }
      i = i.parentElement;
    }
  }
  getRenderRange(e, t) {
    return {
      start: this.rangeMap.indexAt(e),
      end: this.rangeMap.indexAfter(e + t - 1)
    };
  }
  /**
   * Given a stable rendered state, checks every rendered element whether it needs
   * to be probed for dynamic height. Adjusts scroll height and top if necessary.
   */
  _rerender(e, t, i) {
    const n = this.getRenderRange(e, t);
    let o, r;
    e === this.elementTop(n.start) ? (o = n.start, r = 0) : n.end - n.start > 1 && (o = n.start + 1, r = this.elementTop(o) - e);
    let a = 0;
    for (; ; ) {
      const l = this.getRenderRange(e, t);
      let c = !1;
      for (let h = l.start; h < l.end; h++) {
        const d = this.probeDynamicHeight(h);
        d !== 0 && this.rangeMap.splice(h, 1, [this.items[h]]), a += d, c = c || d !== 0;
      }
      if (!c) {
        a !== 0 && this.eventuallyUpdateScrollDimensions();
        const h = Pi.relativeComplement(n, l);
        for (const u of h)
          for (let f = u.start; f < u.end; f++)
            this.items[f].row && this.removeItemFromDOM(f);
        const d = Pi.relativeComplement(l, n).reverse();
        for (const u of d)
          for (let f = u.end - 1; f >= u.start; f--)
            this.insertItemInDOM(f);
        for (let u = l.start; u < l.end; u++)
          this.items[u].row && this.updateItemInDOM(this.items[u], u);
        if (typeof o == "number") {
          const u = this.scrollable.getFutureScrollPosition().scrollTop - e, f = this.elementTop(o) - r + u;
          this.setScrollTop(f, i);
        }
        this._onDidChangeContentHeight.fire(this.contentHeight);
        return;
      }
    }
  }
  probeDynamicHeight(e) {
    var r, a, l;
    const t = this.items[e];
    if (this.virtualDelegate.getDynamicHeight) {
      const c = this.virtualDelegate.getDynamicHeight(t.element);
      if (c !== null) {
        const h = t.size;
        return t.size = c, t.lastDynamicHeightWidth = this.renderWidth, c - h;
      }
    }
    if (!t.hasDynamicHeight || t.lastDynamicHeightWidth === this.renderWidth || this.virtualDelegate.hasDynamicHeight && !this.virtualDelegate.hasDynamicHeight(t.element))
      return 0;
    const i = t.size;
    if (t.row)
      return t.row.domNode.style.height = "", t.size = t.row.domNode.offsetHeight, t.size === 0 && !ui(t.row.domNode, ue(t.row.domNode).document.body) && console.warn("Measuring item node that is not in DOM! Add ListView to the DOM before measuring row height!", new Error().stack), t.lastDynamicHeightWidth = this.renderWidth, t.size - i;
    const { row: n } = this.cache.alloc(t.templateId);
    n.domNode.style.height = "", this.rowsContainer.appendChild(n.domNode);
    const o = this.renderers.get(t.templateId);
    if (!o)
      throw new it("Missing renderer for templateId: " + t.templateId);
    return o.renderElement(t.element, e, n.templateData, void 0), t.size = n.domNode.offsetHeight, (r = o.disposeElement) == null || r.call(o, t.element, e, n.templateData, void 0), (l = (a = this.virtualDelegate).setDynamicHeight) == null || l.call(a, t.element, t.size), t.lastDynamicHeightWidth = this.renderWidth, n.domNode.remove(), this.cache.release(n), t.size - i;
  }
  getElementDomId(e) {
    return `${this.domId}_${e}`;
  }
  // Dispose
  dispose() {
    var e, t, i;
    for (const n of this.items)
      if (n.dragStartDisposable.dispose(), n.checkedDisposable.dispose(), n.row) {
        const o = this.renderers.get(n.row.templateId);
        o && ((e = o.disposeElement) == null || e.call(o, n.element, -1, n.row.templateData, void 0), o.disposeTemplate(n.row.templateData));
      }
    this.items = [], (t = this.domNode) == null || t.remove(), (i = this.dragOverAnimationDisposable) == null || i.dispose(), this.disposables.dispose();
  }
};
w1.InstanceCount = 0;
let Bs = w1;
ia([
  Ht
], Bs.prototype, "onMouseClick", null);
ia([
  Ht
], Bs.prototype, "onMouseDblClick", null);
ia([
  Ht
], Bs.prototype, "onMouseMiddleClick", null);
ia([
  Ht
], Bs.prototype, "onMouseDown", null);
ia([
  Ht
], Bs.prototype, "onMouseOver", null);
ia([
  Ht
], Bs.prototype, "onMouseOut", null);
ia([
  Ht
], Bs.prototype, "onContextMenu", null);
ia([
  Ht
], Bs.prototype, "onTouchStart", null);
ia([
  Ht
], Bs.prototype, "onTap", null);
var el = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
};
class FH {
  constructor(e) {
    this.trait = e, this.renderedElements = [];
  }
  get templateId() {
    return `template:${this.trait.name}`;
  }
  renderTemplate(e) {
    return e;
  }
  renderElement(e, t, i) {
    const n = this.renderedElements.findIndex((o) => o.templateData === i);
    if (n >= 0) {
      const o = this.renderedElements[n];
      this.trait.unrender(i), o.index = t;
    } else {
      const o = { index: t, templateData: i };
      this.renderedElements.push(o);
    }
    this.trait.renderIndex(t, i);
  }
  splice(e, t, i) {
    const n = [];
    for (const o of this.renderedElements)
      o.index < e ? n.push(o) : o.index >= e + t && n.push({
        index: o.index + i - t,
        templateData: o.templateData
      });
    this.renderedElements = n;
  }
  renderIndexes(e) {
    for (const { index: t, templateData: i } of this.renderedElements)
      e.indexOf(t) > -1 && this.trait.renderIndex(t, i);
  }
  disposeTemplate(e) {
    const t = this.renderedElements.findIndex((i) => i.templateData === e);
    t < 0 || this.renderedElements.splice(t, 1);
  }
}
let s_ = class {
  get name() {
    return this._trait;
  }
  get renderer() {
    return new FH(this);
  }
  constructor(e) {
    this._trait = e, this.indexes = [], this.sortedIndexes = [], this._onChange = new O(), this.onChange = this._onChange.event;
  }
  splice(e, t, i) {
    const n = i.length - t, o = e + t, r = [];
    let a = 0;
    for (; a < this.sortedIndexes.length && this.sortedIndexes[a] < e; )
      r.push(this.sortedIndexes[a++]);
    for (let l = 0; l < i.length; l++)
      i[l] && r.push(l + e);
    for (; a < this.sortedIndexes.length && this.sortedIndexes[a] >= o; )
      r.push(this.sortedIndexes[a++] + n);
    this.renderer.splice(e, t, i.length), this._set(r, r);
  }
  renderIndex(e, t) {
    t.classList.toggle(this._trait, this.contains(e));
  }
  unrender(e) {
    e.classList.remove(this._trait);
  }
  /**
   * Sets the indexes which should have this trait.
   *
   * @param indexes Indexes which should have this trait.
   * @return The old indexes which had this trait.
   */
  set(e, t) {
    return this._set(e, [...e].sort(UI), t);
  }
  _set(e, t, i) {
    const n = this.indexes, o = this.sortedIndexes;
    this.indexes = e, this.sortedIndexes = t;
    const r = cy(o, e);
    return this.renderer.renderIndexes(r), this._onChange.fire({ indexes: e, browserEvent: i }), n;
  }
  get() {
    return this.indexes;
  }
  contains(e) {
    return P5(this.sortedIndexes, e, UI) >= 0;
  }
  dispose() {
    Ri(this._onChange);
  }
};
el([
  Ht
], s_.prototype, "renderer", null);
class BH extends s_ {
  constructor(e) {
    super("selected"), this.setAriaSelected = e;
  }
  renderIndex(e, t) {
    super.renderIndex(e, t), this.setAriaSelected && (this.contains(e) ? t.setAttribute("aria-selected", "true") : t.setAttribute("aria-selected", "false"));
  }
}
class K0 {
  constructor(e, t, i) {
    this.trait = e, this.view = t, this.identityProvider = i;
  }
  splice(e, t, i) {
    if (!this.identityProvider)
      return this.trait.splice(e, t, new Array(i.length).fill(!1));
    const n = this.trait.get().map((a) => this.identityProvider.getId(this.view.element(a)).toString());
    if (n.length === 0)
      return this.trait.splice(e, t, new Array(i.length).fill(!1));
    const o = new Set(n), r = i.map((a) => o.has(this.identityProvider.getId(a).toString()));
    this.trait.splice(e, t, r);
  }
}
function Wa(s) {
  return s.tagName === "INPUT" || s.tagName === "TEXTAREA";
}
function Wg(s, e) {
  return s.classList.contains(e) ? !0 : s.classList.contains("monaco-list") || !s.parentElement ? !1 : Wg(s.parentElement, e);
}
function Nu(s) {
  return Wg(s, "monaco-editor");
}
function WH(s) {
  return Wg(s, "monaco-custom-toggle");
}
function VH(s) {
  return Wg(s, "action-item");
}
function ju(s) {
  return Wg(s, "monaco-tree-sticky-row");
}
function Yf(s) {
  return s.classList.contains("monaco-tree-sticky-container");
}
function vA(s) {
  return s.tagName === "A" && s.classList.contains("monaco-button") || s.tagName === "DIV" && s.classList.contains("monaco-button-dropdown") ? !0 : s.classList.contains("monaco-list") || !s.parentElement ? !1 : vA(s.parentElement);
}
class yA {
  get onKeyDown() {
    return J.chain(this.disposables.add(new Re(this.view.domNode, "keydown")).event, (e) => e.filter((t) => !Wa(t.target)).map((t) => new Lt(t)));
  }
  constructor(e, t, i) {
    this.list = e, this.view = t, this.disposables = new he(), this.multipleSelectionDisposables = new he(), this.multipleSelectionSupport = i.multipleSelectionSupport, this.disposables.add(this.onKeyDown((n) => {
      switch (n.keyCode) {
        case 3:
          return this.onEnter(n);
        case 16:
          return this.onUpArrow(n);
        case 18:
          return this.onDownArrow(n);
        case 11:
          return this.onPageUpArrow(n);
        case 12:
          return this.onPageDownArrow(n);
        case 9:
          return this.onEscape(n);
        case 31:
          this.multipleSelectionSupport && (He ? n.metaKey : n.ctrlKey) && this.onCtrlA(n);
      }
    }));
  }
  updateOptions(e) {
    e.multipleSelectionSupport !== void 0 && (this.multipleSelectionSupport = e.multipleSelectionSupport);
  }
  onEnter(e) {
    e.preventDefault(), e.stopPropagation(), this.list.setSelection(this.list.getFocus(), e.browserEvent);
  }
  onUpArrow(e) {
    e.preventDefault(), e.stopPropagation(), this.list.focusPrevious(1, !1, e.browserEvent);
    const t = this.list.getFocus()[0];
    this.list.setAnchor(t), this.list.reveal(t), this.view.domNode.focus();
  }
  onDownArrow(e) {
    e.preventDefault(), e.stopPropagation(), this.list.focusNext(1, !1, e.browserEvent);
    const t = this.list.getFocus()[0];
    this.list.setAnchor(t), this.list.reveal(t), this.view.domNode.focus();
  }
  onPageUpArrow(e) {
    e.preventDefault(), e.stopPropagation(), this.list.focusPreviousPage(e.browserEvent);
    const t = this.list.getFocus()[0];
    this.list.setAnchor(t), this.list.reveal(t), this.view.domNode.focus();
  }
  onPageDownArrow(e) {
    e.preventDefault(), e.stopPropagation(), this.list.focusNextPage(e.browserEvent);
    const t = this.list.getFocus()[0];
    this.list.setAnchor(t), this.list.reveal(t), this.view.domNode.focus();
  }
  onCtrlA(e) {
    e.preventDefault(), e.stopPropagation(), this.list.setSelection(fn(this.list.length), e.browserEvent), this.list.setAnchor(void 0), this.view.domNode.focus();
  }
  onEscape(e) {
    this.list.getSelection().length && (e.preventDefault(), e.stopPropagation(), this.list.setSelection([], e.browserEvent), this.list.setAnchor(void 0), this.view.domNode.focus());
  }
  dispose() {
    this.disposables.dispose(), this.multipleSelectionDisposables.dispose();
  }
}
el([
  Ht
], yA.prototype, "onKeyDown", null);
var Fo;
(function(s) {
  s[s.Automatic = 0] = "Automatic", s[s.Trigger = 1] = "Trigger";
})(Fo || (Fo = {}));
var vh;
(function(s) {
  s[s.Idle = 0] = "Idle", s[s.Typing = 1] = "Typing";
})(vh || (vh = {}));
const HH = new class {
  mightProducePrintableCharacter(s) {
    return s.ctrlKey || s.metaKey || s.altKey ? !1 : s.keyCode >= 31 && s.keyCode <= 56 || s.keyCode >= 21 && s.keyCode <= 30 || s.keyCode >= 98 && s.keyCode <= 107 || s.keyCode >= 85 && s.keyCode <= 95;
  }
}();
class zH {
  constructor(e, t, i, n, o) {
    this.list = e, this.view = t, this.keyboardNavigationLabelProvider = i, this.keyboardNavigationEventFilter = n, this.delegate = o, this.enabled = !1, this.state = vh.Idle, this.mode = Fo.Automatic, this.triggered = !1, this.previouslyFocused = -1, this.enabledDisposables = new he(), this.disposables = new he(), this.updateOptions(e.options);
  }
  updateOptions(e) {
    e.typeNavigationEnabled ?? !0 ? this.enable() : this.disable(), this.mode = e.typeNavigationMode ?? Fo.Automatic;
  }
  enable() {
    if (this.enabled)
      return;
    let e = !1;
    const t = J.chain(this.enabledDisposables.add(new Re(this.view.domNode, "keydown")).event, (o) => o.filter((r) => !Wa(r.target)).filter(() => this.mode === Fo.Automatic || this.triggered).map((r) => new Lt(r)).filter((r) => e || this.keyboardNavigationEventFilter(r)).filter((r) => this.delegate.mightProducePrintableCharacter(r)).forEach((r) => Be.stop(r, !0)).map((r) => r.browserEvent.key)), i = J.debounce(t, () => null, 800, void 0, void 0, void 0, this.enabledDisposables);
    J.reduce(J.any(t, i), (o, r) => r === null ? null : (o || "") + r, void 0, this.enabledDisposables)(this.onInput, this, this.enabledDisposables), i(this.onClear, this, this.enabledDisposables), t(() => e = !0, void 0, this.enabledDisposables), i(() => e = !1, void 0, this.enabledDisposables), this.enabled = !0, this.triggered = !1;
  }
  disable() {
    this.enabled && (this.enabledDisposables.clear(), this.enabled = !1, this.triggered = !1);
  }
  onClear() {
    var t;
    const e = this.list.getFocus();
    if (e.length > 0 && e[0] === this.previouslyFocused) {
      const i = (t = this.list.options.accessibilityProvider) == null ? void 0 : t.getAriaLabel(this.list.element(e[0]));
      typeof i == "string" ? Gf(i) : i && Gf(i.get());
    }
    this.previouslyFocused = -1;
  }
  onInput(e) {
    if (!e) {
      this.state = vh.Idle, this.triggered = !1;
      return;
    }
    const t = this.list.getFocus(), i = t.length > 0 ? t[0] : 0, n = this.state === vh.Idle ? 1 : 0;
    this.state = vh.Typing;
    for (let o = 0; o < this.list.length; o++) {
      const r = (i + o + n) % this.list.length, a = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(this.view.element(r)), l = a && a.toString();
      if (this.list.options.typeNavigationEnabled) {
        if (typeof l < "u") {
          if (Zp(e, l)) {
            this.previouslyFocused = i, this.list.setFocus([r]), this.list.reveal(r);
            return;
          }
          const c = dW(e, l);
          if (c && c[0].end - c[0].start > 1 && c.length === 1) {
            this.previouslyFocused = i, this.list.setFocus([r]), this.list.reveal(r);
            return;
          }
        }
      } else if (typeof l > "u" || Zp(e, l)) {
        this.previouslyFocused = i, this.list.setFocus([r]), this.list.reveal(r);
        return;
      }
    }
  }
  dispose() {
    this.disable(), this.enabledDisposables.dispose(), this.disposables.dispose();
  }
}
class UH {
  constructor(e, t) {
    this.list = e, this.view = t, this.disposables = new he();
    const i = J.chain(this.disposables.add(new Re(t.domNode, "keydown")).event, (o) => o.filter((r) => !Wa(r.target)).map((r) => new Lt(r)));
    J.chain(i, (o) => o.filter((r) => r.keyCode === 2 && !r.ctrlKey && !r.metaKey && !r.shiftKey && !r.altKey))(this.onTab, this, this.disposables);
  }
  onTab(e) {
    if (e.target !== this.view.domNode)
      return;
    const t = this.list.getFocus();
    if (t.length === 0)
      return;
    const i = this.view.domElement(t[0]);
    if (!i)
      return;
    const n = i.querySelector("[tabIndex]");
    if (!n || !yi(n) || n.tabIndex === -1)
      return;
    const o = ue(n).getComputedStyle(n);
    o.visibility === "hidden" || o.display === "none" || (e.preventDefault(), e.stopPropagation(), n.focus());
  }
  dispose() {
    this.disposables.dispose();
  }
}
function SA(s) {
  return He ? s.browserEvent.metaKey : s.browserEvent.ctrlKey;
}
function LA(s) {
  return s.browserEvent.shiftKey;
}
function $H(s) {
  return UL(s) && s.button === 2;
}
const zI = {
  isSelectionSingleChangeEvent: SA,
  isSelectionRangeChangeEvent: LA
};
class kA {
  constructor(e) {
    this.list = e, this.disposables = new he(), this._onPointer = new O(), this.onPointer = this._onPointer.event, e.options.multipleSelectionSupport !== !1 && (this.multipleSelectionController = this.list.options.multipleSelectionController || zI), this.mouseSupport = typeof e.options.mouseSupport > "u" || !!e.options.mouseSupport, this.mouseSupport && (e.onMouseDown(this.onMouseDown, this, this.disposables), e.onContextMenu(this.onContextMenu, this, this.disposables), e.onMouseDblClick(this.onDoubleClick, this, this.disposables), e.onTouchStart(this.onMouseDown, this, this.disposables), this.disposables.add(an.addTarget(e.getHTMLElement()))), J.any(e.onMouseClick, e.onMouseMiddleClick, e.onTap)(this.onViewPointer, this, this.disposables);
  }
  updateOptions(e) {
    e.multipleSelectionSupport !== void 0 && (this.multipleSelectionController = void 0, e.multipleSelectionSupport && (this.multipleSelectionController = this.list.options.multipleSelectionController || zI));
  }
  isSelectionSingleChangeEvent(e) {
    return this.multipleSelectionController ? this.multipleSelectionController.isSelectionSingleChangeEvent(e) : !1;
  }
  isSelectionRangeChangeEvent(e) {
    return this.multipleSelectionController ? this.multipleSelectionController.isSelectionRangeChangeEvent(e) : !1;
  }
  isSelectionChangeEvent(e) {
    return this.isSelectionSingleChangeEvent(e) || this.isSelectionRangeChangeEvent(e);
  }
  onMouseDown(e) {
    Nu(e.browserEvent.target) || Gi() !== e.browserEvent.target && this.list.domFocus();
  }
  onContextMenu(e) {
    if (Wa(e.browserEvent.target) || Nu(e.browserEvent.target))
      return;
    const t = typeof e.index > "u" ? [] : [e.index];
    this.list.setFocus(t, e.browserEvent);
  }
  onViewPointer(e) {
    if (!this.mouseSupport || Wa(e.browserEvent.target) || Nu(e.browserEvent.target) || e.browserEvent.isHandledByList)
      return;
    e.browserEvent.isHandledByList = !0;
    const t = e.index;
    if (typeof t > "u") {
      this.list.setFocus([], e.browserEvent), this.list.setSelection([], e.browserEvent), this.list.setAnchor(void 0);
      return;
    }
    if (this.isSelectionChangeEvent(e))
      return this.changeSelection(e);
    this.list.setFocus([t], e.browserEvent), this.list.setAnchor(t), $H(e.browserEvent) || this.list.setSelection([t], e.browserEvent), this._onPointer.fire(e);
  }
  onDoubleClick(e) {
    if (Wa(e.browserEvent.target) || Nu(e.browserEvent.target) || this.isSelectionChangeEvent(e) || e.browserEvent.isHandledByList)
      return;
    e.browserEvent.isHandledByList = !0;
    const t = this.list.getFocus();
    this.list.setSelection(t, e.browserEvent);
  }
  changeSelection(e) {
    const t = e.index;
    let i = this.list.getAnchor();
    if (this.isSelectionRangeChangeEvent(e)) {
      typeof i > "u" && (i = this.list.getFocus()[0] ?? t, this.list.setAnchor(i));
      const n = Math.min(i, t), o = Math.max(i, t), r = fn(n, o + 1), a = this.list.getSelection(), l = jH(cy(a, [i]), i);
      if (l.length === 0)
        return;
      const c = cy(r, GH(a, l));
      this.list.setSelection(c, e.browserEvent), this.list.setFocus([t], e.browserEvent);
    } else if (this.isSelectionSingleChangeEvent(e)) {
      const n = this.list.getSelection(), o = n.filter((r) => r !== t);
      this.list.setFocus([t]), this.list.setAnchor(t), n.length === o.length ? this.list.setSelection([...o, t], e.browserEvent) : this.list.setSelection(o, e.browserEvent);
    }
  }
  dispose() {
    this.disposables.dispose();
  }
}
class xA {
  constructor(e, t) {
    this.styleElement = e, this.selectorSuffix = t;
  }
  style(e) {
    const t = this.selectorSuffix && `.${this.selectorSuffix}`, i = [];
    e.listBackground && i.push(`.monaco-list${t} .monaco-list-rows { background: ${e.listBackground}; }`), e.listFocusBackground && (i.push(`.monaco-list${t}:focus .monaco-list-row.focused { background-color: ${e.listFocusBackground}; }`), i.push(`.monaco-list${t}:focus .monaco-list-row.focused:hover { background-color: ${e.listFocusBackground}; }`)), e.listFocusForeground && i.push(`.monaco-list${t}:focus .monaco-list-row.focused { color: ${e.listFocusForeground}; }`), e.listActiveSelectionBackground && (i.push(`.monaco-list${t}:focus .monaco-list-row.selected { background-color: ${e.listActiveSelectionBackground}; }`), i.push(`.monaco-list${t}:focus .monaco-list-row.selected:hover { background-color: ${e.listActiveSelectionBackground}; }`)), e.listActiveSelectionForeground && i.push(`.monaco-list${t}:focus .monaco-list-row.selected { color: ${e.listActiveSelectionForeground}; }`), e.listActiveSelectionIconForeground && i.push(`.monaco-list${t}:focus .monaco-list-row.selected .codicon { color: ${e.listActiveSelectionIconForeground}; }`), e.listFocusAndSelectionBackground && i.push(`
				.monaco-drag-image,
				.monaco-list${t}:focus .monaco-list-row.selected.focused { background-color: ${e.listFocusAndSelectionBackground}; }
			`), e.listFocusAndSelectionForeground && i.push(`
				.monaco-drag-image,
				.monaco-list${t}:focus .monaco-list-row.selected.focused { color: ${e.listFocusAndSelectionForeground}; }
			`), e.listInactiveFocusForeground && (i.push(`.monaco-list${t} .monaco-list-row.focused { color:  ${e.listInactiveFocusForeground}; }`), i.push(`.monaco-list${t} .monaco-list-row.focused:hover { color:  ${e.listInactiveFocusForeground}; }`)), e.listInactiveSelectionIconForeground && i.push(`.monaco-list${t} .monaco-list-row.focused .codicon { color:  ${e.listInactiveSelectionIconForeground}; }`), e.listInactiveFocusBackground && (i.push(`.monaco-list${t} .monaco-list-row.focused { background-color:  ${e.listInactiveFocusBackground}; }`), i.push(`.monaco-list${t} .monaco-list-row.focused:hover { background-color:  ${e.listInactiveFocusBackground}; }`)), e.listInactiveSelectionBackground && (i.push(`.monaco-list${t} .monaco-list-row.selected { background-color:  ${e.listInactiveSelectionBackground}; }`), i.push(`.monaco-list${t} .monaco-list-row.selected:hover { background-color:  ${e.listInactiveSelectionBackground}; }`)), e.listInactiveSelectionForeground && i.push(`.monaco-list${t} .monaco-list-row.selected { color: ${e.listInactiveSelectionForeground}; }`), e.listHoverBackground && i.push(`.monaco-list${t}:not(.drop-target):not(.dragging) .monaco-list-row:hover:not(.selected):not(.focused) { background-color: ${e.listHoverBackground}; }`), e.listHoverForeground && i.push(`.monaco-list${t}:not(.drop-target):not(.dragging) .monaco-list-row:hover:not(.selected):not(.focused) { color:  ${e.listHoverForeground}; }`);
    const n = Hr(e.listFocusAndSelectionOutline, Hr(e.listSelectionOutline, e.listFocusOutline ?? ""));
    n && i.push(`.monaco-list${t}:focus .monaco-list-row.focused.selected { outline: 1px solid ${n}; outline-offset: -1px;}`), e.listFocusOutline && i.push(`
				.monaco-drag-image,
				.monaco-list${t}:focus .monaco-list-row.focused { outline: 1px solid ${e.listFocusOutline}; outline-offset: -1px; }
				.monaco-workbench.context-menu-visible .monaco-list${t}.last-focused .monaco-list-row.focused { outline: 1px solid ${e.listFocusOutline}; outline-offset: -1px; }
			`);
    const o = Hr(e.listSelectionOutline, e.listInactiveFocusOutline ?? "");
    o && i.push(`.monaco-list${t} .monaco-list-row.focused.selected { outline: 1px dotted ${o}; outline-offset: -1px; }`), e.listSelectionOutline && i.push(`.monaco-list${t} .monaco-list-row.selected { outline: 1px dotted ${e.listSelectionOutline}; outline-offset: -1px; }`), e.listInactiveFocusOutline && i.push(`.monaco-list${t} .monaco-list-row.focused { outline: 1px dotted ${e.listInactiveFocusOutline}; outline-offset: -1px; }`), e.listHoverOutline && i.push(`.monaco-list${t} .monaco-list-row:hover { outline: 1px dashed ${e.listHoverOutline}; outline-offset: -1px; }`), e.listDropOverBackground && i.push(`
				.monaco-list${t}.drop-target,
				.monaco-list${t} .monaco-list-rows.drop-target,
				.monaco-list${t} .monaco-list-row.drop-target { background-color: ${e.listDropOverBackground} !important; color: inherit !important; }
			`), e.listDropBetweenBackground && (i.push(`
			.monaco-list${t} .monaco-list-rows.drop-target-before .monaco-list-row:first-child::before,
			.monaco-list${t} .monaco-list-row.drop-target-before::before {
				content: ""; position: absolute; top: 0px; left: 0px; width: 100%; height: 1px;
				background-color: ${e.listDropBetweenBackground};
			}`), i.push(`
			.monaco-list${t} .monaco-list-rows.drop-target-after .monaco-list-row:last-child::after,
			.monaco-list${t} .monaco-list-row.drop-target-after::after {
				content: ""; position: absolute; bottom: 0px; left: 0px; width: 100%; height: 1px;
				background-color: ${e.listDropBetweenBackground};
			}`)), e.tableColumnsBorder && i.push(`
				.monaco-table > .monaco-split-view2,
				.monaco-table > .monaco-split-view2 .monaco-sash.vertical::before,
				.monaco-workbench:not(.reduce-motion) .monaco-table:hover > .monaco-split-view2,
				.monaco-workbench:not(.reduce-motion) .monaco-table:hover > .monaco-split-view2 .monaco-sash.vertical::before {
					border-color: ${e.tableColumnsBorder};
				}

				.monaco-workbench:not(.reduce-motion) .monaco-table > .monaco-split-view2,
				.monaco-workbench:not(.reduce-motion) .monaco-table > .monaco-split-view2 .monaco-sash.vertical::before {
					border-color: transparent;
				}
			`), e.tableOddRowsBackgroundColor && i.push(`
				.monaco-table .monaco-list-row[data-parity=odd]:not(.focused):not(.selected):not(:hover) .monaco-table-tr,
				.monaco-table .monaco-list:not(:focus) .monaco-list-row[data-parity=odd].focused:not(.selected):not(:hover) .monaco-table-tr,
				.monaco-table .monaco-list:not(.focused) .monaco-list-row[data-parity=odd].focused:not(.selected):not(:hover) .monaco-table-tr {
					background-color: ${e.tableOddRowsBackgroundColor};
				}
			`), this.styleElement.textContent = i.join(`
`);
  }
}
const KH = {
  listFocusBackground: "#7FB0D0",
  listActiveSelectionBackground: "#0E639C",
  listActiveSelectionForeground: "#FFFFFF",
  listActiveSelectionIconForeground: "#FFFFFF",
  listFocusAndSelectionOutline: "#90C2F9",
  listFocusAndSelectionBackground: "#094771",
  listFocusAndSelectionForeground: "#FFFFFF",
  listInactiveSelectionBackground: "#3F3F46",
  listInactiveSelectionIconForeground: "#FFFFFF",
  listHoverBackground: "#2A2D2E",
  listDropOverBackground: "#383B3D",
  listDropBetweenBackground: "#EEEEEE",
  treeIndentGuidesStroke: "#a9a9a9",
  treeInactiveIndentGuidesStroke: Z.fromHex("#a9a9a9").transparent(0.4).toString(),
  tableColumnsBorder: Z.fromHex("#cccccc").transparent(0.2).toString(),
  tableOddRowsBackgroundColor: Z.fromHex("#cccccc").transparent(0.04).toString(),
  listBackground: void 0,
  listFocusForeground: void 0,
  listInactiveSelectionForeground: void 0,
  listInactiveFocusForeground: void 0,
  listInactiveFocusBackground: void 0,
  listHoverForeground: void 0,
  listFocusOutline: void 0,
  listInactiveFocusOutline: void 0,
  listSelectionOutline: void 0,
  listHoverOutline: void 0,
  treeStickyScrollBackground: void 0,
  treeStickyScrollBorder: void 0,
  treeStickyScrollShadow: void 0
}, qH = {
  keyboardSupport: !0,
  mouseSupport: !0,
  multipleSelectionSupport: !0,
  dnd: {
    getDragURI() {
      return null;
    },
    onDragStart() {
    },
    onDragOver() {
      return !1;
    },
    drop() {
    },
    dispose() {
    }
  }
};
function jH(s, e) {
  const t = s.indexOf(e);
  if (t === -1)
    return [];
  const i = [];
  let n = t - 1;
  for (; n >= 0 && s[n] === e - (t - n); )
    i.push(s[n--]);
  for (i.reverse(), n = t; n < s.length && s[n] === e + (n - t); )
    i.push(s[n++]);
  return i;
}
function cy(s, e) {
  const t = [];
  let i = 0, n = 0;
  for (; i < s.length || n < e.length; )
    if (i >= s.length)
      t.push(e[n++]);
    else if (n >= e.length)
      t.push(s[i++]);
    else if (s[i] === e[n]) {
      t.push(s[i]), i++, n++;
      continue;
    } else s[i] < e[n] ? t.push(s[i++]) : t.push(e[n++]);
  return t;
}
function GH(s, e) {
  const t = [];
  let i = 0, n = 0;
  for (; i < s.length || n < e.length; )
    if (i >= s.length)
      t.push(e[n++]);
    else if (n >= e.length)
      t.push(s[i++]);
    else if (s[i] === e[n]) {
      i++, n++;
      continue;
    } else s[i] < e[n] ? t.push(s[i++]) : n++;
  return t;
}
const UI = (s, e) => s - e;
class ZH {
  constructor(e, t) {
    this._templateId = e, this.renderers = t;
  }
  get templateId() {
    return this._templateId;
  }
  renderTemplate(e) {
    return this.renderers.map((t) => t.renderTemplate(e));
  }
  renderElement(e, t, i, n) {
    let o = 0;
    for (const r of this.renderers)
      r.renderElement(e, t, i[o++], n);
  }
  disposeElement(e, t, i, n) {
    var r;
    let o = 0;
    for (const a of this.renderers)
      (r = a.disposeElement) == null || r.call(a, e, t, i[o], n), o += 1;
  }
  disposeTemplate(e) {
    let t = 0;
    for (const i of this.renderers)
      i.disposeTemplate(e[t++]);
  }
}
class YH {
  constructor(e) {
    this.accessibilityProvider = e, this.templateId = "a18n";
  }
  renderTemplate(e) {
    return { container: e, disposables: new he() };
  }
  renderElement(e, t, i) {
    const n = this.accessibilityProvider.getAriaLabel(e), o = n && typeof n != "string" ? n : n_(n);
    i.disposables.add(Qe((a) => {
      this.setAriaLabel(a.readObservable(o), i.container);
    }));
    const r = this.accessibilityProvider.getAriaLevel && this.accessibilityProvider.getAriaLevel(e);
    typeof r == "number" ? i.container.setAttribute("aria-level", `${r}`) : i.container.removeAttribute("aria-level");
  }
  setAriaLabel(e, t) {
    e ? t.setAttribute("aria-label", e) : t.removeAttribute("aria-label");
  }
  disposeElement(e, t, i, n) {
    i.disposables.clear();
  }
  disposeTemplate(e) {
    e.disposables.dispose();
  }
}
class QH {
  constructor(e, t) {
    this.list = e, this.dnd = t;
  }
  getDragElements(e) {
    const t = this.list.getSelectedElements();
    return t.indexOf(e) > -1 ? t : [e];
  }
  getDragURI(e) {
    return this.dnd.getDragURI(e);
  }
  getDragLabel(e, t) {
    if (this.dnd.getDragLabel)
      return this.dnd.getDragLabel(e, t);
  }
  onDragStart(e, t) {
    var i, n;
    (n = (i = this.dnd).onDragStart) == null || n.call(i, e, t);
  }
  onDragOver(e, t, i, n, o) {
    return this.dnd.onDragOver(e, t, i, n, o);
  }
  onDragLeave(e, t, i, n) {
    var o, r;
    (r = (o = this.dnd).onDragLeave) == null || r.call(o, e, t, i, n);
  }
  onDragEnd(e) {
    var t, i;
    (i = (t = this.dnd).onDragEnd) == null || i.call(t, e);
  }
  drop(e, t, i, n, o) {
    this.dnd.drop(e, t, i, n, o);
  }
  dispose() {
    this.dnd.dispose();
  }
}
class mo {
  get onDidChangeFocus() {
    return J.map(this.eventBufferer.wrapEvent(this.focus.onChange), (e) => this.toListEvent(e), this.disposables);
  }
  get onDidChangeSelection() {
    return J.map(this.eventBufferer.wrapEvent(this.selection.onChange), (e) => this.toListEvent(e), this.disposables);
  }
  get domId() {
    return this.view.domId;
  }
  get onDidScroll() {
    return this.view.onDidScroll;
  }
  get onMouseClick() {
    return this.view.onMouseClick;
  }
  get onMouseDblClick() {
    return this.view.onMouseDblClick;
  }
  get onMouseMiddleClick() {
    return this.view.onMouseMiddleClick;
  }
  get onPointer() {
    return this.mouseController.onPointer;
  }
  get onMouseDown() {
    return this.view.onMouseDown;
  }
  get onMouseOver() {
    return this.view.onMouseOver;
  }
  get onMouseOut() {
    return this.view.onMouseOut;
  }
  get onTouchStart() {
    return this.view.onTouchStart;
  }
  get onTap() {
    return this.view.onTap;
  }
  /**
   * Possible context menu trigger events:
   * - ContextMenu key
   * - Shift F10
   * - Ctrl Option Shift M (macOS with VoiceOver)
   * - Mouse right click
   */
  get onContextMenu() {
    let e = !1;
    const t = J.chain(this.disposables.add(new Re(this.view.domNode, "keydown")).event, (o) => o.map((r) => new Lt(r)).filter((r) => e = r.keyCode === 58 || r.shiftKey && r.keyCode === 68).map((r) => Be.stop(r, !0)).filter(() => !1)), i = J.chain(this.disposables.add(new Re(this.view.domNode, "keyup")).event, (o) => o.forEach(() => e = !1).map((r) => new Lt(r)).filter((r) => r.keyCode === 58 || r.shiftKey && r.keyCode === 68).map((r) => Be.stop(r, !0)).map(({ browserEvent: r }) => {
      const a = this.getFocus(), l = a.length ? a[0] : void 0, c = typeof l < "u" ? this.view.element(l) : void 0, h = typeof l < "u" ? this.view.domElement(l) : this.view.domNode;
      return { index: l, element: c, anchor: h, browserEvent: r };
    })), n = J.chain(this.view.onContextMenu, (o) => o.filter((r) => !e).map(({ element: r, index: a, browserEvent: l }) => ({ element: r, index: a, anchor: new to(ue(this.view.domNode), l), browserEvent: l })));
    return J.any(t, i, n);
  }
  get onKeyDown() {
    return this.disposables.add(new Re(this.view.domNode, "keydown")).event;
  }
  get onDidFocus() {
    return J.signal(this.disposables.add(new Re(this.view.domNode, "focus", !0)).event);
  }
  get onDidBlur() {
    return J.signal(this.disposables.add(new Re(this.view.domNode, "blur", !0)).event);
  }
  constructor(e, t, i, n, o = qH) {
    var c, h, d;
    this.user = e, this._options = o, this.focus = new s_("focused"), this.anchor = new s_("anchor"), this.eventBufferer = new yg(), this._ariaLabel = "", this.disposables = new he(), this._onDidDispose = new O(), this.onDidDispose = this._onDidDispose.event;
    const r = this._options.accessibilityProvider && this._options.accessibilityProvider.getWidgetRole ? (c = this._options.accessibilityProvider) == null ? void 0 : c.getWidgetRole() : "list";
    this.selection = new BH(r !== "listbox");
    const a = [this.focus.renderer, this.selection.renderer];
    this.accessibilityProvider = o.accessibilityProvider, this.accessibilityProvider && (a.push(new YH(this.accessibilityProvider)), (d = (h = this.accessibilityProvider).onDidChangeActiveDescendant) == null || d.call(h, this.onDidChangeActiveDescendant, this, this.disposables)), n = n.map((u) => new ZH(u.templateId, [...a, u]));
    const l = {
      ...o,
      dnd: o.dnd && new QH(this, o.dnd)
    };
    if (this.view = this.createListView(t, i, n, l), this.view.domNode.setAttribute("role", r), o.styleController)
      this.styleController = o.styleController(this.view.domId);
    else {
      const u = Os(this.view.domNode);
      this.styleController = new xA(u, this.view.domId);
    }
    if (this.spliceable = new EH([
      new K0(this.focus, this.view, o.identityProvider),
      new K0(this.selection, this.view, o.identityProvider),
      new K0(this.anchor, this.view, o.identityProvider),
      this.view
    ]), this.disposables.add(this.focus), this.disposables.add(this.selection), this.disposables.add(this.anchor), this.disposables.add(this.view), this.disposables.add(this._onDidDispose), this.disposables.add(new UH(this, this.view)), (typeof o.keyboardSupport != "boolean" || o.keyboardSupport) && (this.keyboardController = new yA(this, this.view, o), this.disposables.add(this.keyboardController)), o.keyboardNavigationLabelProvider) {
      const u = o.keyboardNavigationDelegate || HH;
      this.typeNavigationController = new zH(this, this.view, o.keyboardNavigationLabelProvider, o.keyboardNavigationEventFilter ?? (() => !0), u), this.disposables.add(this.typeNavigationController);
    }
    this.mouseController = this.createMouseController(o), this.disposables.add(this.mouseController), this.onDidChangeFocus(this._onFocusChange, this, this.disposables), this.onDidChangeSelection(this._onSelectionChange, this, this.disposables), this.accessibilityProvider && (this.ariaLabel = this.accessibilityProvider.getWidgetAriaLabel()), this._options.multipleSelectionSupport !== !1 && this.view.domNode.setAttribute("aria-multiselectable", "true");
  }
  createListView(e, t, i, n) {
    return new Bs(e, t, i, n);
  }
  createMouseController(e) {
    return new kA(this);
  }
  updateOptions(e = {}) {
    var t, i;
    this._options = { ...this._options, ...e }, (t = this.typeNavigationController) == null || t.updateOptions(this._options), this._options.multipleSelectionController !== void 0 && (this._options.multipleSelectionSupport ? this.view.domNode.setAttribute("aria-multiselectable", "true") : this.view.domNode.removeAttribute("aria-multiselectable")), this.mouseController.updateOptions(e), (i = this.keyboardController) == null || i.updateOptions(e), this.view.updateOptions(e);
  }
  get options() {
    return this._options;
  }
  splice(e, t, i = []) {
    if (e < 0 || e > this.view.length)
      throw new ll(this.user, `Invalid start index: ${e}`);
    if (t < 0)
      throw new ll(this.user, `Invalid delete count: ${t}`);
    t === 0 && i.length === 0 || this.eventBufferer.bufferEvents(() => this.spliceable.splice(e, t, i));
  }
  rerender() {
    this.view.rerender();
  }
  element(e) {
    return this.view.element(e);
  }
  indexOf(e) {
    return this.view.indexOf(e);
  }
  indexAt(e) {
    return this.view.indexAt(e);
  }
  get length() {
    return this.view.length;
  }
  get contentHeight() {
    return this.view.contentHeight;
  }
  get onDidChangeContentHeight() {
    return this.view.onDidChangeContentHeight;
  }
  get scrollTop() {
    return this.view.getScrollTop();
  }
  set scrollTop(e) {
    this.view.setScrollTop(e);
  }
  get scrollHeight() {
    return this.view.scrollHeight;
  }
  get renderHeight() {
    return this.view.renderHeight;
  }
  get firstVisibleIndex() {
    return this.view.firstVisibleIndex;
  }
  get ariaLabel() {
    return this._ariaLabel;
  }
  set ariaLabel(e) {
    this._ariaLabel = e, this.view.domNode.setAttribute("aria-label", e);
  }
  domFocus() {
    this.view.domNode.focus({ preventScroll: !0 });
  }
  layout(e, t) {
    this.view.layout(e, t);
  }
  setSelection(e, t) {
    for (const i of e)
      if (i < 0 || i >= this.length)
        throw new ll(this.user, `Invalid index ${i}`);
    this.selection.set(e, t);
  }
  getSelection() {
    return this.selection.get();
  }
  getSelectedElements() {
    return this.getSelection().map((e) => this.view.element(e));
  }
  setAnchor(e) {
    if (typeof e > "u") {
      this.anchor.set([]);
      return;
    }
    if (e < 0 || e >= this.length)
      throw new ll(this.user, `Invalid index ${e}`);
    this.anchor.set([e]);
  }
  getAnchor() {
    return gL(this.anchor.get(), void 0);
  }
  getAnchorElement() {
    const e = this.getAnchor();
    return typeof e > "u" ? void 0 : this.element(e);
  }
  setFocus(e, t) {
    for (const i of e)
      if (i < 0 || i >= this.length)
        throw new ll(this.user, `Invalid index ${i}`);
    this.focus.set(e, t);
  }
  focusNext(e = 1, t = !1, i, n) {
    if (this.length === 0)
      return;
    const o = this.focus.get(), r = this.findNextIndex(o.length > 0 ? o[0] + e : 0, t, n);
    r > -1 && this.setFocus([r], i);
  }
  focusPrevious(e = 1, t = !1, i, n) {
    if (this.length === 0)
      return;
    const o = this.focus.get(), r = this.findPreviousIndex(o.length > 0 ? o[0] - e : 0, t, n);
    r > -1 && this.setFocus([r], i);
  }
  async focusNextPage(e, t) {
    let i = this.view.indexAt(this.view.getScrollTop() + this.view.renderHeight);
    i = i === 0 ? 0 : i - 1;
    const n = this.getFocus()[0];
    if (n !== i && (n === void 0 || i > n)) {
      const o = this.findPreviousIndex(i, !1, t);
      o > -1 && n !== o ? this.setFocus([o], e) : this.setFocus([i], e);
    } else {
      const o = this.view.getScrollTop();
      let r = o + this.view.renderHeight;
      i > n && (r -= this.view.elementHeight(i)), this.view.setScrollTop(r), this.view.getScrollTop() !== o && (this.setFocus([]), await Of(0), await this.focusNextPage(e, t));
    }
  }
  async focusPreviousPage(e, t, i = () => 0) {
    let n;
    const o = i(), r = this.view.getScrollTop() + o;
    r === 0 ? n = this.view.indexAt(r) : n = this.view.indexAfter(r - 1);
    const a = this.getFocus()[0];
    if (a !== n && (a === void 0 || a >= n)) {
      const l = this.findNextIndex(n, !1, t);
      l > -1 && a !== l ? this.setFocus([l], e) : this.setFocus([n], e);
    } else {
      const l = r;
      this.view.setScrollTop(r - this.view.renderHeight - o), this.view.getScrollTop() + i() !== l && (this.setFocus([]), await Of(0), await this.focusPreviousPage(e, t, i));
    }
  }
  focusLast(e, t) {
    if (this.length === 0)
      return;
    const i = this.findPreviousIndex(this.length - 1, !1, t);
    i > -1 && this.setFocus([i], e);
  }
  focusFirst(e, t) {
    this.focusNth(0, e, t);
  }
  focusNth(e, t, i) {
    if (this.length === 0)
      return;
    const n = this.findNextIndex(e, !1, i);
    n > -1 && this.setFocus([n], t);
  }
  findNextIndex(e, t = !1, i) {
    for (let n = 0; n < this.length; n++) {
      if (e >= this.length && !t)
        return -1;
      if (e = e % this.length, !i || i(this.element(e)))
        return e;
      e++;
    }
    return -1;
  }
  findPreviousIndex(e, t = !1, i) {
    for (let n = 0; n < this.length; n++) {
      if (e < 0 && !t)
        return -1;
      if (e = (this.length + e % this.length) % this.length, !i || i(this.element(e)))
        return e;
      e--;
    }
    return -1;
  }
  getFocus() {
    return this.focus.get();
  }
  getFocusedElements() {
    return this.getFocus().map((e) => this.view.element(e));
  }
  reveal(e, t, i = 0) {
    if (e < 0 || e >= this.length)
      throw new ll(this.user, `Invalid index ${e}`);
    const n = this.view.getScrollTop(), o = this.view.elementTop(e), r = this.view.elementHeight(e);
    if (Od(t)) {
      const a = r - this.view.renderHeight + i;
      this.view.setScrollTop(a * gn(t, 0, 1) + o - i);
    } else {
      const a = o + r, l = n + this.view.renderHeight;
      o < n + i && a >= l || (o < n + i || a >= l && r >= this.view.renderHeight ? this.view.setScrollTop(o - i) : a >= l && this.view.setScrollTop(a - this.view.renderHeight));
    }
  }
  /**
   * Returns the relative position of an element rendered in the list.
   * Returns `null` if the element isn't *entirely* in the visible viewport.
   */
  getRelativeTop(e, t = 0) {
    if (e < 0 || e >= this.length)
      throw new ll(this.user, `Invalid index ${e}`);
    const i = this.view.getScrollTop(), n = this.view.elementTop(e), o = this.view.elementHeight(e);
    if (n < i + t || n + o > i + this.view.renderHeight)
      return null;
    const r = o - this.view.renderHeight + t;
    return Math.abs((i + t - n) / r);
  }
  getHTMLElement() {
    return this.view.domNode;
  }
  getScrollableElement() {
    return this.view.scrollableElementDomNode;
  }
  getElementID(e) {
    return this.view.getElementDomId(e);
  }
  getElementTop(e) {
    return this.view.elementTop(e);
  }
  style(e) {
    this.styleController.style(e);
  }
  toListEvent({ indexes: e, browserEvent: t }) {
    return { indexes: e, elements: e.map((i) => this.view.element(i)), browserEvent: t };
  }
  _onFocusChange() {
    const e = this.focus.get();
    this.view.domNode.classList.toggle("element-focused", e.length > 0), this.onDidChangeActiveDescendant();
  }
  onDidChangeActiveDescendant() {
    var t;
    const e = this.focus.get();
    if (e.length > 0) {
      let i;
      (t = this.accessibilityProvider) != null && t.getActiveDescendantId && (i = this.accessibilityProvider.getActiveDescendantId(this.view.element(e[0]))), this.view.domNode.setAttribute("aria-activedescendant", i || this.view.getElementDomId(e[0]));
    } else
      this.view.domNode.removeAttribute("aria-activedescendant");
  }
  _onSelectionChange() {
    const e = this.selection.get();
    this.view.domNode.classList.toggle("selection-none", e.length === 0), this.view.domNode.classList.toggle("selection-single", e.length === 1), this.view.domNode.classList.toggle("selection-multiple", e.length > 1);
  }
  dispose() {
    this._onDidDispose.fire(), this.disposables.dispose(), this._onDidDispose.dispose();
  }
}
el([
  Ht
], mo.prototype, "onDidChangeFocus", null);
el([
  Ht
], mo.prototype, "onDidChangeSelection", null);
el([
  Ht
], mo.prototype, "onContextMenu", null);
el([
  Ht
], mo.prototype, "onKeyDown", null);
el([
  Ht
], mo.prototype, "onDidFocus", null);
el([
  Ht
], mo.prototype, "onDidBlur", null);
const $l = pe, DA = "selectOption.entry.template";
class XH {
  get templateId() {
    return DA;
  }
  renderTemplate(e) {
    const t = /* @__PURE__ */ Object.create(null);
    return t.root = e, t.text = ae(e, $l(".option-text")), t.detail = ae(e, $l(".option-detail")), t.decoratorRight = ae(e, $l(".option-decorator-right")), t;
  }
  renderElement(e, t, i) {
    const n = i, o = e.text, r = e.detail, a = e.decoratorRight, l = e.isDisabled;
    n.text.textContent = o, n.detail.textContent = r || "", n.decoratorRight.innerText = a || "", l ? n.root.classList.add("option-disabled") : n.root.classList.remove("option-disabled");
  }
  disposeTemplate(e) {
  }
}
const Io = class Io extends q {
  constructor(e, t, i, n, o) {
    super(), this.options = [], this._currentSelection = 0, this._hasDetails = !1, this._skipLayout = !1, this._sticky = !1, this._isVisible = !1, this.styles = n, this.selectBoxOptions = o || /* @__PURE__ */ Object.create(null), typeof this.selectBoxOptions.minBottomMargin != "number" ? this.selectBoxOptions.minBottomMargin = Io.DEFAULT_DROPDOWN_MINIMUM_BOTTOM_MARGIN : this.selectBoxOptions.minBottomMargin < 0 && (this.selectBoxOptions.minBottomMargin = 0), this.selectElement = document.createElement("select"), this.selectElement.className = "monaco-select-box monaco-select-box-dropdown-padding", typeof this.selectBoxOptions.ariaLabel == "string" && this.selectElement.setAttribute("aria-label", this.selectBoxOptions.ariaLabel), typeof this.selectBoxOptions.ariaDescription == "string" && this.selectElement.setAttribute("aria-description", this.selectBoxOptions.ariaDescription), this._onDidSelect = new O(), this._register(this._onDidSelect), this.registerListeners(), this.constructSelectDropDown(i), this.selected = t || 0, e && this.setOptions(e, t), this.initStyleSheet();
  }
  setTitle(e) {
    !this._hover && e ? this._hover = this._register(Yo().setupManagedHover(Cs("mouse"), this.selectElement, e)) : this._hover && this._hover.update(e);
  }
  // IDelegate - List renderer
  getHeight() {
    return 22;
  }
  getTemplateId() {
    return DA;
  }
  constructSelectDropDown(e) {
    this.contextViewProvider = e, this.selectDropDownContainer = pe(".monaco-select-box-dropdown-container"), this.selectDropDownContainer.classList.add("monaco-select-box-dropdown-padding"), this.selectionDetailsPane = ae(this.selectDropDownContainer, $l(".select-box-details-pane"));
    const t = ae(this.selectDropDownContainer, $l(".select-box-dropdown-container-width-control")), i = ae(t, $l(".width-control-div"));
    this.widthControlElement = document.createElement("span"), this.widthControlElement.className = "option-text-width-control", ae(i, this.widthControlElement), this._dropDownPosition = 0, this.styleElement = Os(this.selectDropDownContainer), this.selectDropDownContainer.setAttribute("draggable", "true"), this._register($(this.selectDropDownContainer, ee.DRAG_START, (n) => {
      Be.stop(n, !0);
    }));
  }
  registerListeners() {
    this._register(fi(this.selectElement, "change", (t) => {
      this.selected = t.target.selectedIndex, this._onDidSelect.fire({
        index: t.target.selectedIndex,
        selected: t.target.value
      }), this.options[this.selected] && this.options[this.selected].text && this.setTitle(this.options[this.selected].text);
    })), this._register($(this.selectElement, ee.CLICK, (t) => {
      Be.stop(t), this._isVisible ? this.hideSelectDropDown(!0) : this.showSelectDropDown();
    })), this._register($(this.selectElement, ee.MOUSE_DOWN, (t) => {
      Be.stop(t);
    }));
    let e;
    this._register($(this.selectElement, "touchstart", (t) => {
      e = this._isVisible;
    })), this._register($(this.selectElement, "touchend", (t) => {
      Be.stop(t), e ? this.hideSelectDropDown(!0) : this.showSelectDropDown();
    })), this._register($(this.selectElement, ee.KEY_DOWN, (t) => {
      const i = new Lt(t);
      let n = !1;
      He ? (i.keyCode === 18 || i.keyCode === 16 || i.keyCode === 10 || i.keyCode === 3) && (n = !0) : (i.keyCode === 18 && i.altKey || i.keyCode === 16 && i.altKey || i.keyCode === 10 || i.keyCode === 3) && (n = !0), n && (this.showSelectDropDown(), Be.stop(t, !0));
    }));
  }
  get onDidSelect() {
    return this._onDidSelect.event;
  }
  setOptions(e, t) {
    oi(this.options, e) || (this.options = e, this.selectElement.options.length = 0, this._hasDetails = !1, this._cachedMaxDetailsHeight = void 0, this.options.forEach((i, n) => {
      this.selectElement.add(this.createOption(i.text, n, i.isDisabled)), typeof i.description == "string" && (this._hasDetails = !0);
    })), t !== void 0 && (this.select(t), this._currentSelection = this.selected);
  }
  setOptionsList() {
    var e;
    (e = this.selectList) == null || e.splice(0, this.selectList.length, this.options);
  }
  select(e) {
    e >= 0 && e < this.options.length ? this.selected = e : e > this.options.length - 1 ? this.select(this.options.length - 1) : this.selected < 0 && (this.selected = 0), this.selectElement.selectedIndex = this.selected, this.options[this.selected] && this.options[this.selected].text && this.setTitle(this.options[this.selected].text);
  }
  focus() {
    this.selectElement && (this.selectElement.tabIndex = 0, this.selectElement.focus());
  }
  blur() {
    this.selectElement && (this.selectElement.tabIndex = -1, this.selectElement.blur());
  }
  setFocusable(e) {
    this.selectElement.tabIndex = e ? 0 : -1;
  }
  render(e) {
    this.container = e, e.classList.add("select-container"), e.appendChild(this.selectElement), this.styleSelectElement();
  }
  initStyleSheet() {
    const e = [];
    this.styles.listFocusBackground && e.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { background-color: ${this.styles.listFocusBackground} !important; }`), this.styles.listFocusForeground && e.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { color: ${this.styles.listFocusForeground} !important; }`), this.styles.decoratorRightForeground && e.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.focused) .option-decorator-right { color: ${this.styles.decoratorRightForeground}; }`), this.styles.selectBackground && this.styles.selectBorder && this.styles.selectBorder !== this.styles.selectBackground ? (e.push(`.monaco-select-box-dropdown-container { border: 1px solid ${this.styles.selectBorder} } `), e.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-top { border-top: 1px solid ${this.styles.selectBorder} } `), e.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-bottom { border-bottom: 1px solid ${this.styles.selectBorder} } `)) : this.styles.selectListBorder && (e.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-top { border-top: 1px solid ${this.styles.selectListBorder} } `), e.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-bottom { border-bottom: 1px solid ${this.styles.selectListBorder} } `)), this.styles.listHoverForeground && e.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.option-disabled):not(.focused):hover { color: ${this.styles.listHoverForeground} !important; }`), this.styles.listHoverBackground && e.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.option-disabled):not(.focused):hover { background-color: ${this.styles.listHoverBackground} !important; }`), this.styles.listFocusOutline && e.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { outline: 1.6px dotted ${this.styles.listFocusOutline} !important; outline-offset: -1.6px !important; }`), this.styles.listHoverOutline && e.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.option-disabled):not(.focused):hover { outline: 1.6px dashed ${this.styles.listHoverOutline} !important; outline-offset: -1.6px !important; }`), e.push(".monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled.focused { background-color: transparent !important; color: inherit !important; outline: none !important; }"), e.push(".monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled:hover { background-color: transparent !important; color: inherit !important; outline: none !important; }"), this.styleElement.textContent = e.join(`
`);
  }
  styleSelectElement() {
    const e = this.styles.selectBackground ?? "", t = this.styles.selectForeground ?? "", i = this.styles.selectBorder ?? "";
    this.selectElement.style.backgroundColor = e, this.selectElement.style.color = t, this.selectElement.style.borderColor = i;
  }
  styleList() {
    const e = this.styles.selectBackground ?? "", t = Hr(this.styles.selectListBackground, e);
    this.selectDropDownListContainer.style.backgroundColor = t, this.selectionDetailsPane.style.backgroundColor = t;
    const i = this.styles.focusBorder ?? "";
    this.selectDropDownContainer.style.outlineColor = i, this.selectDropDownContainer.style.outlineOffset = "-1px", this.selectList.style(this.styles);
  }
  createOption(e, t, i) {
    const n = document.createElement("option");
    return n.value = e, n.text = e, n.disabled = !!i, n;
  }
  // ContextView dropdown methods
  showSelectDropDown() {
    this.selectionDetailsPane.innerText = "", !(!this.contextViewProvider || this._isVisible) && (this.createSelectList(this.selectDropDownContainer), this.setOptionsList(), this.contextViewProvider.showContextView({
      getAnchor: () => this.selectElement,
      render: (e) => this.renderSelectDropDown(e, !0),
      layout: () => {
        this.layoutSelectDropDown();
      },
      onHide: () => {
        this.selectDropDownContainer.classList.remove("visible"), this.selectElement.classList.remove("synthetic-focus");
      },
      anchorPosition: this._dropDownPosition
    }, this.selectBoxOptions.optionsAsChildren ? this.container : void 0), this._isVisible = !0, this.hideSelectDropDown(!1), this.contextViewProvider.showContextView({
      getAnchor: () => this.selectElement,
      render: (e) => this.renderSelectDropDown(e),
      layout: () => this.layoutSelectDropDown(),
      onHide: () => {
        this.selectDropDownContainer.classList.remove("visible"), this.selectElement.classList.remove("synthetic-focus");
      },
      anchorPosition: this._dropDownPosition
    }, this.selectBoxOptions.optionsAsChildren ? this.container : void 0), this._currentSelection = this.selected, this._isVisible = !0, this.selectElement.setAttribute("aria-expanded", "true"));
  }
  hideSelectDropDown(e) {
    !this.contextViewProvider || !this._isVisible || (this._isVisible = !1, this.selectElement.setAttribute("aria-expanded", "false"), e && this.selectElement.focus(), this.contextViewProvider.hideContextView());
  }
  renderSelectDropDown(e, t) {
    return e.appendChild(this.selectDropDownContainer), this.layoutSelectDropDown(t), {
      dispose: () => {
        this.selectDropDownContainer.remove();
      }
    };
  }
  // Iterate over detailed descriptions, find max height
  measureMaxDetailsHeight() {
    let e = 0;
    return this.options.forEach((t, i) => {
      this.updateDetail(i), this.selectionDetailsPane.offsetHeight > e && (e = this.selectionDetailsPane.offsetHeight);
    }), e;
  }
  layoutSelectDropDown(e) {
    if (this._skipLayout)
      return !1;
    if (this.selectList) {
      this.selectDropDownContainer.classList.add("visible");
      const t = ue(this.selectElement), i = gs(this.selectElement), n = ue(this.selectElement).getComputedStyle(this.selectElement), o = parseFloat(n.getPropertyValue("--dropdown-padding-top")) + parseFloat(n.getPropertyValue("--dropdown-padding-bottom")), r = t.innerHeight - i.top - i.height - (this.selectBoxOptions.minBottomMargin || 0), a = i.top - Io.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN, l = this.selectElement.offsetWidth, c = this.setWidthControlElement(this.widthControlElement), h = Math.max(c, Math.round(l)).toString() + "px";
      this.selectDropDownContainer.style.width = h, this.selectList.getHTMLElement().style.height = "", this.selectList.layout();
      let d = this.selectList.contentHeight;
      this._hasDetails && this._cachedMaxDetailsHeight === void 0 && (this._cachedMaxDetailsHeight = this.measureMaxDetailsHeight());
      const u = this._hasDetails ? this._cachedMaxDetailsHeight : 0, f = d + o + u, g = Math.floor((r - o - u) / this.getHeight()), m = Math.floor((a - o - u) / this.getHeight());
      if (e)
        return i.top + i.height > t.innerHeight - 22 || i.top < Io.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN || g < 1 && m < 1 ? !1 : (g < Io.DEFAULT_MINIMUM_VISIBLE_OPTIONS && m > g && this.options.length > g ? (this._dropDownPosition = 1, this.selectDropDownListContainer.remove(), this.selectionDetailsPane.remove(), this.selectDropDownContainer.appendChild(this.selectionDetailsPane), this.selectDropDownContainer.appendChild(this.selectDropDownListContainer), this.selectionDetailsPane.classList.remove("border-top"), this.selectionDetailsPane.classList.add("border-bottom")) : (this._dropDownPosition = 0, this.selectDropDownListContainer.remove(), this.selectionDetailsPane.remove(), this.selectDropDownContainer.appendChild(this.selectDropDownListContainer), this.selectDropDownContainer.appendChild(this.selectionDetailsPane), this.selectionDetailsPane.classList.remove("border-bottom"), this.selectionDetailsPane.classList.add("border-top")), !0);
      if (i.top + i.height > t.innerHeight - 22 || i.top < Io.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN || this._dropDownPosition === 0 && g < 1 || this._dropDownPosition === 1 && m < 1)
        return this.hideSelectDropDown(!0), !1;
      if (this._dropDownPosition === 0) {
        if (this._isVisible && g + m < 1)
          return this.hideSelectDropDown(!0), !1;
        f > r && (d = g * this.getHeight());
      } else
        f > a && (d = m * this.getHeight());
      return this.selectList.layout(d), this.selectList.domFocus(), this.selectList.length > 0 && (this.selectList.setFocus([this.selected || 0]), this.selectList.reveal(this.selectList.getFocus()[0] || 0)), this._hasDetails ? (this.selectList.getHTMLElement().style.height = d + o + "px", this.selectDropDownContainer.style.height = "") : this.selectDropDownContainer.style.height = d + o + "px", this.updateDetail(this.selected), this.selectDropDownContainer.style.width = h, this.selectDropDownListContainer.setAttribute("tabindex", "0"), this.selectElement.classList.add("synthetic-focus"), this.selectDropDownContainer.classList.add("synthetic-focus"), !0;
    } else
      return !1;
  }
  setWidthControlElement(e) {
    let t = 0;
    if (e) {
      let i = 0, n = 0;
      this.options.forEach((o, r) => {
        const a = o.detail ? o.detail.length : 0, l = o.decoratorRight ? o.decoratorRight.length : 0, c = o.text.length + a + l;
        c > n && (i = r, n = c);
      }), e.textContent = this.options[i].text + (this.options[i].decoratorRight ? this.options[i].decoratorRight + " " : ""), t = VL(e);
    }
    return t;
  }
  createSelectList(e) {
    if (this.selectList)
      return;
    this.selectDropDownListContainer = ae(e, $l(".select-box-dropdown-list-container")), this.listRenderer = new XH(), this.selectList = this._register(new mo("SelectBoxCustom", this.selectDropDownListContainer, this, [this.listRenderer], {
      useShadows: !1,
      verticalScrollMode: 3,
      keyboardSupport: !1,
      mouseSupport: !1,
      accessibilityProvider: {
        getAriaLabel: (n) => {
          let o = n.text;
          return n.detail && (o += `. ${n.detail}`), n.decoratorRight && (o += `. ${n.decoratorRight}`), n.description && (o += `. ${n.description}`), o;
        },
        getWidgetAriaLabel: () => p({ key: "selectBox", comment: ["Behave like native select dropdown element."] }, "Select Box"),
        getRole: () => He ? "" : "option",
        getWidgetRole: () => "listbox"
      }
    })), this.selectBoxOptions.ariaLabel && (this.selectList.ariaLabel = this.selectBoxOptions.ariaLabel);
    const t = this._register(new Re(this.selectDropDownListContainer, "keydown")), i = J.chain(t.event, (n) => n.filter(() => this.selectList.length > 0).map((o) => new Lt(o)));
    this._register(J.chain(i, (n) => n.filter(
      (o) => o.keyCode === 3
      /* KeyCode.Enter */
    ))(this.onEnter, this)), this._register(J.chain(i, (n) => n.filter(
      (o) => o.keyCode === 2
      /* KeyCode.Tab */
    ))(this.onEnter, this)), this._register(J.chain(i, (n) => n.filter(
      (o) => o.keyCode === 9
      /* KeyCode.Escape */
    ))(this.onEscape, this)), this._register(J.chain(i, (n) => n.filter(
      (o) => o.keyCode === 16
      /* KeyCode.UpArrow */
    ))(this.onUpArrow, this)), this._register(J.chain(i, (n) => n.filter(
      (o) => o.keyCode === 18
      /* KeyCode.DownArrow */
    ))(this.onDownArrow, this)), this._register(J.chain(i, (n) => n.filter(
      (o) => o.keyCode === 12
      /* KeyCode.PageDown */
    ))(this.onPageDown, this)), this._register(J.chain(i, (n) => n.filter(
      (o) => o.keyCode === 11
      /* KeyCode.PageUp */
    ))(this.onPageUp, this)), this._register(J.chain(i, (n) => n.filter(
      (o) => o.keyCode === 14
      /* KeyCode.Home */
    ))(this.onHome, this)), this._register(J.chain(i, (n) => n.filter(
      (o) => o.keyCode === 13
      /* KeyCode.End */
    ))(this.onEnd, this)), this._register(J.chain(i, (n) => n.filter((o) => o.keyCode >= 21 && o.keyCode <= 56 || o.keyCode >= 85 && o.keyCode <= 113))(this.onCharacter, this)), this._register($(this.selectList.getHTMLElement(), ee.POINTER_UP, (n) => this.onPointerUp(n))), this._register(this.selectList.onMouseOver((n) => typeof n.index < "u" && this.selectList.setFocus([n.index]))), this._register(this.selectList.onDidChangeFocus((n) => this.onListFocus(n))), this._register($(this.selectDropDownContainer, ee.FOCUS_OUT, (n) => {
      !this._isVisible || ui(n.relatedTarget, this.selectDropDownContainer) || this.onListBlur();
    })), this.selectList.getHTMLElement().setAttribute("aria-label", this.selectBoxOptions.ariaLabel || ""), this.selectList.getHTMLElement().setAttribute("aria-expanded", "true"), this.styleList();
  }
  // List methods
  // List mouse controller - active exit, select option, fire onDidSelect if change, return focus to parent select
  // Also takes in touchend events
  onPointerUp(e) {
    if (!this.selectList.length)
      return;
    Be.stop(e);
    const t = e.target;
    if (!t || t.classList.contains("slider"))
      return;
    const i = t.closest(".monaco-list-row");
    if (!i)
      return;
    const n = Number(i.getAttribute("data-index")), o = i.classList.contains("option-disabled");
    n >= 0 && n < this.options.length && !o && (this.selected = n, this.select(this.selected), this.selectList.setFocus([this.selected]), this.selectList.reveal(this.selectList.getFocus()[0]), this.selected !== this._currentSelection && (this._currentSelection = this.selected, this._onDidSelect.fire({
      index: this.selectElement.selectedIndex,
      selected: this.options[this.selected].text
    }), this.options[this.selected] && this.options[this.selected].text && this.setTitle(this.options[this.selected].text)), this.hideSelectDropDown(!0));
  }
  // List Exit - passive - implicit no selection change, hide drop-down
  onListBlur() {
    this._sticky || (this.selected !== this._currentSelection && this.select(this._currentSelection), this.hideSelectDropDown(!1));
  }
  renderDescriptionMarkdown(e, t) {
    const i = (o) => {
      for (let r = 0; r < o.childNodes.length; r++) {
        const a = o.childNodes.item(r);
        (a.tagName && a.tagName.toLowerCase()) === "img" ? a.remove() : i(a);
      }
    }, n = vk({ value: e, supportThemeIcons: !0 }, { actionHandler: t });
    return n.element.classList.add("select-box-description-markdown"), i(n.element), n.element;
  }
  // List Focus Change - passive - update details pane with newly focused element's data
  onListFocus(e) {
    !this._isVisible || !this._hasDetails || this.updateDetail(e.indexes[0]);
  }
  updateDetail(e) {
    this.selectionDetailsPane.innerText = "";
    const t = this.options[e], i = (t == null ? void 0 : t.description) ?? "", n = (t == null ? void 0 : t.descriptionIsMarkdown) ?? !1;
    if (i) {
      if (n) {
        const o = t.descriptionMarkdownActionHandler;
        this.selectionDetailsPane.appendChild(this.renderDescriptionMarkdown(i, o));
      } else
        this.selectionDetailsPane.innerText = i;
      this.selectionDetailsPane.style.display = "block";
    } else
      this.selectionDetailsPane.style.display = "none";
    this._skipLayout = !0, this.contextViewProvider.layout(), this._skipLayout = !1;
  }
  // List keyboard controller
  // List exit - active - hide ContextView dropdown, reset selection, return focus to parent select
  onEscape(e) {
    Be.stop(e), this.select(this._currentSelection), this.hideSelectDropDown(!0);
  }
  // List exit - active - hide ContextView dropdown, return focus to parent select, fire onDidSelect if change
  onEnter(e) {
    Be.stop(e), this.selected !== this._currentSelection && (this._currentSelection = this.selected, this._onDidSelect.fire({
      index: this.selectElement.selectedIndex,
      selected: this.options[this.selected].text
    }), this.options[this.selected] && this.options[this.selected].text && this.setTitle(this.options[this.selected].text)), this.hideSelectDropDown(!0);
  }
  // List navigation - have to handle a disabled option (jump over)
  onDownArrow(e) {
    if (this.selected < this.options.length - 1) {
      Be.stop(e, !0);
      const t = this.options[this.selected + 1].isDisabled;
      if (t && this.options.length > this.selected + 2)
        this.selected += 2;
      else {
        if (t)
          return;
        this.selected++;
      }
      this.select(this.selected), this.selectList.setFocus([this.selected]), this.selectList.reveal(this.selectList.getFocus()[0]);
    }
  }
  onUpArrow(e) {
    this.selected > 0 && (Be.stop(e, !0), this.options[this.selected - 1].isDisabled && this.selected > 1 ? this.selected -= 2 : this.selected--, this.select(this.selected), this.selectList.setFocus([this.selected]), this.selectList.reveal(this.selectList.getFocus()[0]));
  }
  onPageUp(e) {
    Be.stop(e), this.selectList.focusPreviousPage(), setTimeout(() => {
      this.selected = this.selectList.getFocus()[0], this.options[this.selected].isDisabled && this.selected < this.options.length - 1 && (this.selected++, this.selectList.setFocus([this.selected])), this.selectList.reveal(this.selected), this.select(this.selected);
    }, 1);
  }
  onPageDown(e) {
    Be.stop(e), this.selectList.focusNextPage(), setTimeout(() => {
      this.selected = this.selectList.getFocus()[0], this.options[this.selected].isDisabled && this.selected > 0 && (this.selected--, this.selectList.setFocus([this.selected])), this.selectList.reveal(this.selected), this.select(this.selected);
    }, 1);
  }
  onHome(e) {
    Be.stop(e), !(this.options.length < 2) && (this.selected = 0, this.options[this.selected].isDisabled && this.selected > 1 && this.selected++, this.selectList.setFocus([this.selected]), this.selectList.reveal(this.selected), this.select(this.selected));
  }
  onEnd(e) {
    Be.stop(e), !(this.options.length < 2) && (this.selected = this.options.length - 1, this.options[this.selected].isDisabled && this.selected > 1 && this.selected--, this.selectList.setFocus([this.selected]), this.selectList.reveal(this.selected), this.select(this.selected));
  }
  // Mimic option first character navigation of native select
  onCharacter(e) {
    const t = Lr.toString(e.keyCode);
    let i = -1;
    for (let n = 0; n < this.options.length - 1; n++)
      if (i = (n + this.selected + 1) % this.options.length, this.options[i].text.charAt(0).toUpperCase() === t && !this.options[i].isDisabled) {
        this.select(i), this.selectList.setFocus([i]), this.selectList.reveal(this.selectList.getFocus()[0]), Be.stop(e);
        break;
      }
  }
  dispose() {
    this.hideSelectDropDown(!1), super.dispose();
  }
};
Io.DEFAULT_DROPDOWN_MINIMUM_BOTTOM_MARGIN = 32, Io.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN = 2, Io.DEFAULT_MINIMUM_VISIBLE_OPTIONS = 3;
let hy = Io;
class JH extends q {
  constructor(e, t, i, n) {
    super(), this.selected = 0, this.selectBoxOptions = n || /* @__PURE__ */ Object.create(null), this.options = [], this.selectElement = document.createElement("select"), this.selectElement.className = "monaco-select-box", typeof this.selectBoxOptions.ariaLabel == "string" && this.selectElement.setAttribute("aria-label", this.selectBoxOptions.ariaLabel), typeof this.selectBoxOptions.ariaDescription == "string" && this.selectElement.setAttribute("aria-description", this.selectBoxOptions.ariaDescription), this._onDidSelect = this._register(new O()), this.styles = i, this.registerListeners(), this.setOptions(e, t);
  }
  registerListeners() {
    this._register(an.addTarget(this.selectElement)), [bt.Tap].forEach((e) => {
      this._register($(this.selectElement, e, (t) => {
        this.selectElement.focus();
      }));
    }), this._register(fi(this.selectElement, "click", (e) => {
      Be.stop(e, !0);
    })), this._register(fi(this.selectElement, "change", (e) => {
      this.selectElement.title = e.target.value, this._onDidSelect.fire({
        index: e.target.selectedIndex,
        selected: e.target.value
      });
    })), this._register(fi(this.selectElement, "keydown", (e) => {
      let t = !1;
      He ? (e.keyCode === 18 || e.keyCode === 16 || e.keyCode === 10) && (t = !0) : (e.keyCode === 18 && e.altKey || e.keyCode === 10 || e.keyCode === 3) && (t = !0), t && e.stopPropagation();
    }));
  }
  get onDidSelect() {
    return this._onDidSelect.event;
  }
  setOptions(e, t) {
    (!this.options || !oi(this.options, e)) && (this.options = e, this.selectElement.options.length = 0, this.options.forEach((i, n) => {
      this.selectElement.add(this.createOption(i.text, n, i.isDisabled));
    })), t !== void 0 && this.select(t);
  }
  select(e) {
    this.options.length === 0 ? this.selected = 0 : e >= 0 && e < this.options.length ? this.selected = e : e > this.options.length - 1 ? this.select(this.options.length - 1) : this.selected < 0 && (this.selected = 0), this.selectElement.selectedIndex = this.selected, this.selected < this.options.length && typeof this.options[this.selected].text == "string" ? this.selectElement.title = this.options[this.selected].text : this.selectElement.title = "";
  }
  focus() {
    this.selectElement && (this.selectElement.tabIndex = 0, this.selectElement.focus());
  }
  blur() {
    this.selectElement && (this.selectElement.tabIndex = -1, this.selectElement.blur());
  }
  setFocusable(e) {
    this.selectElement.tabIndex = e ? 0 : -1;
  }
  render(e) {
    e.classList.add("select-container"), e.appendChild(this.selectElement), this.setOptions(this.options, this.selected), this.applyStyles();
  }
  applyStyles() {
    this.selectElement && (this.selectElement.style.backgroundColor = this.styles.selectBackground ?? "", this.selectElement.style.color = this.styles.selectForeground ?? "", this.selectElement.style.borderColor = this.styles.selectBorder ?? "");
  }
  createOption(e, t, i) {
    const n = document.createElement("option");
    return n.value = e, n.text = e, n.disabled = !!i, n;
  }
}
class ez extends ta {
  constructor(e, t, i, n, o) {
    super(), He && !(o != null && o.useCustomDrawn) ? this.selectBoxDelegate = new JH(e, t, n, o) : this.selectBoxDelegate = new hy(e, t, i, n, o), this._register(this.selectBoxDelegate);
  }
  // Public SelectBox Methods - routed through delegate interface
  get onDidSelect() {
    return this.selectBoxDelegate.onDidSelect;
  }
  setOptions(e, t) {
    this.selectBoxDelegate.setOptions(e, t);
  }
  select(e) {
    this.selectBoxDelegate.select(e);
  }
  focus() {
    this.selectBoxDelegate.focus();
  }
  blur() {
    this.selectBoxDelegate.blur();
  }
  setFocusable(e) {
    this.selectBoxDelegate.setFocusable(e);
  }
  render(e) {
    this.selectBoxDelegate.render(e);
  }
}
class Js extends q {
  get action() {
    return this._action;
  }
  constructor(e, t, i = {}) {
    super(), this.options = i, this._context = e || this, this._action = t, t instanceof zr && this._register(t.onDidChange((n) => {
      this.element && this.handleActionChangeEvent(n);
    }));
  }
  handleActionChangeEvent(e) {
    e.enabled !== void 0 && this.updateEnabled(), e.checked !== void 0 && this.updateChecked(), e.class !== void 0 && this.updateClass(), e.label !== void 0 && (this.updateLabel(), this.updateTooltip()), e.tooltip !== void 0 && this.updateTooltip();
  }
  get actionRunner() {
    return this._actionRunner || (this._actionRunner = this._register(new _c())), this._actionRunner;
  }
  set actionRunner(e) {
    this._actionRunner = e;
  }
  isEnabled() {
    return this._action.enabled;
  }
  setActionContext(e) {
    this._context = e;
  }
  render(e) {
    const t = this.element = e;
    this._register(an.addTarget(e));
    const i = this.options && this.options.draggable;
    i && (e.draggable = !0, As && this._register($(e, ee.DRAG_START, (n) => {
      var o;
      return (o = n.dataTransfer) == null ? void 0 : o.setData(CA.TEXT, this._action.label);
    }))), this._register($(t, bt.Tap, (n) => this.onClick(n, !0))), this._register($(t, ee.MOUSE_DOWN, (n) => {
      i || Be.stop(n, !0), this._action.enabled && n.button === 0 && t.classList.add("active");
    })), He && this._register($(t, ee.CONTEXT_MENU, (n) => {
      n.button === 0 && n.ctrlKey === !0 && this.onClick(n);
    })), this._register($(t, ee.CLICK, (n) => {
      Be.stop(n, !0), this.options && this.options.isMenu || this.onClick(n);
    })), this._register($(t, ee.DBLCLICK, (n) => {
      Be.stop(n, !0);
    })), [ee.MOUSE_UP, ee.MOUSE_OUT].forEach((n) => {
      this._register($(t, n, (o) => {
        Be.stop(o), t.classList.remove("active");
      }));
    });
  }
  onClick(e, t = !1) {
    var n;
    Be.stop(e, !0);
    const i = Zn(this._context) ? (n = this.options) != null && n.useEventAsContext ? e : { preserveFocus: t } : this._context;
    this.actionRunner.run(this._action, i);
  }
  // Only set the tabIndex on the element once it is about to get focused
  // That way this element wont be a tab stop when it is not needed #106441
  focus() {
    this.element && (this.element.tabIndex = 0, this.element.focus(), this.element.classList.add("focused"));
  }
  blur() {
    this.element && (this.element.blur(), this.element.tabIndex = -1, this.element.classList.remove("focused"));
  }
  setFocusable(e) {
    this.element && (this.element.tabIndex = e ? 0 : -1);
  }
  get trapsArrowNavigation() {
    return !1;
  }
  updateEnabled() {
  }
  updateLabel() {
  }
  getClass() {
    return this.action.class;
  }
  getTooltip() {
    return this.action.tooltip;
  }
  updateTooltip() {
    var t;
    if (!this.element)
      return;
    const e = this.getTooltip() ?? "";
    if (this.updateAriaLabel(), (t = this.options.hoverDelegate) != null && t.showNativeHover)
      this.element.title = e;
    else if (!this.customHover && e !== "") {
      const i = this.options.hoverDelegate ?? Cs("element");
      this.customHover = this._store.add(Yo().setupManagedHover(i, this.element, e));
    } else this.customHover && this.customHover.update(e);
  }
  updateAriaLabel() {
    if (this.element) {
      const e = this.getTooltip() ?? "";
      this.element.setAttribute("aria-label", e);
    }
  }
  updateClass() {
  }
  updateChecked() {
  }
  dispose() {
    this.element && (this.element.remove(), this.element = void 0), this._context = void 0, super.dispose();
  }
}
class Ak extends Js {
  constructor(e, t, i) {
    super(e, t, i), this.options = i, this.options.icon = i.icon !== void 0 ? i.icon : !1, this.options.label = i.label !== void 0 ? i.label : !0, this.cssClass = "";
  }
  render(e) {
    super.render(e), Pa(this.element);
    const t = document.createElement("a");
    if (t.classList.add("action-label"), t.setAttribute("role", this.getDefaultAriaRole()), this.label = t, this.element.appendChild(t), this.options.label && this.options.keybinding) {
      const i = document.createElement("span");
      i.classList.add("keybinding"), i.textContent = this.options.keybinding, this.element.appendChild(i);
    }
    this.updateClass(), this.updateLabel(), this.updateTooltip(), this.updateEnabled(), this.updateChecked();
  }
  getDefaultAriaRole() {
    return this._action.id === Zi.ID ? "presentation" : this.options.isMenu ? "menuitem" : this.options.isTabList ? "tab" : "button";
  }
  // Only set the tabIndex on the element once it is about to get focused
  // That way this element wont be a tab stop when it is not needed #106441
  focus() {
    this.label && (this.label.tabIndex = 0, this.label.focus());
  }
  blur() {
    this.label && (this.label.tabIndex = -1);
  }
  setFocusable(e) {
    this.label && (this.label.tabIndex = e ? 0 : -1);
  }
  updateLabel() {
    this.options.label && this.label && (this.label.textContent = this.action.label);
  }
  getTooltip() {
    let e = null;
    return this.action.tooltip ? e = this.action.tooltip : !this.options.label && this.action.label && this.options.icon && (e = this.action.label, this.options.keybinding && (e = p({ key: "titleLabel", comment: ["action title", "action keybinding"] }, "{0} ({1})", e, this.options.keybinding))), e ?? void 0;
  }
  updateClass() {
    var e;
    this.cssClass && this.label && this.label.classList.remove(...this.cssClass.split(" ")), this.options.icon ? (this.cssClass = this.getClass(), this.label && (this.label.classList.add("codicon"), this.cssClass && this.label.classList.add(...this.cssClass.split(" "))), this.updateEnabled()) : (e = this.label) == null || e.classList.remove("codicon");
  }
  updateEnabled() {
    var e, t;
    this.action.enabled ? (this.label && (this.label.removeAttribute("aria-disabled"), this.label.classList.remove("disabled")), (e = this.element) == null || e.classList.remove("disabled")) : (this.label && (this.label.setAttribute("aria-disabled", "true"), this.label.classList.add("disabled")), (t = this.element) == null || t.classList.add("disabled"));
  }
  updateAriaLabel() {
    if (this.label) {
      const e = this.getTooltip() ?? "";
      this.label.setAttribute("aria-label", e);
    }
  }
  updateChecked() {
    this.label && (this.action.checked !== void 0 ? (this.label.classList.toggle("checked", this.action.checked), this.options.isTabList ? this.label.setAttribute("aria-selected", this.action.checked ? "true" : "false") : (this.label.setAttribute("aria-checked", this.action.checked ? "true" : "false"), this.label.setAttribute("role", "checkbox"))) : (this.label.classList.remove("checked"), this.label.removeAttribute(this.options.isTabList ? "aria-selected" : "aria-checked"), this.label.setAttribute("role", this.getDefaultAriaRole())));
  }
}
class tz extends Js {
  constructor(e, t, i, n, o, r, a) {
    super(e, t), this.selectBox = new ez(i, n, o, r, a), this.selectBox.setFocusable(!1), this._register(this.selectBox), this.registerListeners();
  }
  select(e) {
    this.selectBox.select(e);
  }
  registerListeners() {
    this._register(this.selectBox.onDidSelect((e) => this.runAction(e.selected, e.index)));
  }
  runAction(e, t) {
    this.actionRunner.run(this._action, this.getActionContext(e, t));
  }
  getActionContext(e, t) {
    return e;
  }
  setFocusable(e) {
    this.selectBox.setFocusable(e);
  }
  focus() {
    var e;
    (e = this.selectBox) == null || e.focus();
  }
  blur() {
    var e;
    (e = this.selectBox) == null || e.blur();
  }
  render(e) {
    this.selectBox.render(e);
  }
}
class iz extends _c {
  constructor(e, t) {
    super(), this._onDidChangeVisibility = this._register(new O()), this.onDidChangeVisibility = this._onDidChangeVisibility.event, this._element = ae(e, pe(".monaco-dropdown")), this._label = ae(this._element, pe(".dropdown-label"));
    let i = t.labelRenderer;
    i || (i = (o) => (o.textContent = t.label || "", null));
    for (const o of [ee.CLICK, ee.MOUSE_DOWN, bt.Tap])
      this._register($(this.element, o, (r) => Be.stop(r, !0)));
    for (const o of [ee.MOUSE_DOWN, bt.Tap])
      this._register($(this._label, o, (r) => {
        UL(r) && (r.detail > 1 || r.button !== 0) || (this.visible ? this.hide() : this.show());
      }));
    this._register($(this._label, ee.KEY_UP, (o) => {
      const r = new Lt(o);
      (r.equals(
        3
        /* KeyCode.Enter */
      ) || r.equals(
        10
        /* KeyCode.Space */
      )) && (Be.stop(o, !0), this.visible ? this.hide() : this.show());
    }));
    const n = i(this._label);
    n && this._register(n), this._register(an.addTarget(this._label));
  }
  get element() {
    return this._element;
  }
  show() {
    this.visible || (this.visible = !0, this._onDidChangeVisibility.fire(!0));
  }
  hide() {
    this.visible && (this.visible = !1, this._onDidChangeVisibility.fire(!1));
  }
  dispose() {
    super.dispose(), this.hide(), this.boxContainer && (this.boxContainer.remove(), this.boxContainer = void 0), this.contents && (this.contents.remove(), this.contents = void 0), this._label && (this._label.remove(), this._label = void 0);
  }
}
class nz extends iz {
  constructor(e, t) {
    super(e, t), this._options = t, this._actions = [], this.actions = t.actions || [];
  }
  set menuOptions(e) {
    this._menuOptions = e;
  }
  get menuOptions() {
    return this._menuOptions;
  }
  get actions() {
    return this._options.actionProvider ? this._options.actionProvider.getActions() : this._actions;
  }
  set actions(e) {
    this._actions = e;
  }
  show() {
    super.show(), this.element.classList.add("active"), this._options.contextMenuProvider.showContextMenu({
      getAnchor: () => this.element,
      getActions: () => this.actions,
      getActionsContext: () => this.menuOptions ? this.menuOptions.context : null,
      getActionViewItem: (e, t) => this.menuOptions && this.menuOptions.actionViewItemProvider ? this.menuOptions.actionViewItemProvider(e, t) : void 0,
      getKeyBinding: (e) => this.menuOptions && this.menuOptions.getKeyBinding ? this.menuOptions.getKeyBinding(e) : void 0,
      getMenuClassName: () => this._options.menuClassName || "",
      onHide: () => this.onHide(),
      actionRunner: this.menuOptions ? this.menuOptions.actionRunner : void 0,
      anchorAlignment: this.menuOptions ? this.menuOptions.anchorAlignment : 0,
      domForShadowRoot: this._options.menuAsChild ? this.element : void 0,
      skipTelemetry: this._options.skipTelemetry
    });
  }
  hide() {
    super.hide();
  }
  onHide() {
    this.hide(), this.element.classList.remove("active");
  }
}
class o_ extends Js {
  constructor(e, t, i, n = /* @__PURE__ */ Object.create(null)) {
    super(null, e, n), this.actionItem = null, this._onDidChangeVisibility = this._register(new O()), this.onDidChangeVisibility = this._onDidChangeVisibility.event, this.menuActionsOrProvider = t, this.contextMenuProvider = i, this.options = n, this.options.actionRunner && (this.actionRunner = this.options.actionRunner);
  }
  render(e) {
    this.actionItem = e;
    const t = (o) => {
      this.element = ae(o, pe("a.action-label"));
      let r = [];
      return typeof this.options.classNames == "string" ? r = this.options.classNames.split(/\s+/g).filter((a) => !!a) : this.options.classNames && (r = this.options.classNames), r.find((a) => a === "icon") || r.push("codicon"), this.element.classList.add(...r), this.element.setAttribute("role", "button"), this.element.setAttribute("aria-haspopup", "true"), this.element.setAttribute("aria-expanded", "false"), this._action.label && this._register(Yo().setupManagedHover(this.options.hoverDelegate ?? Cs("mouse"), this.element, this._action.label)), this.element.ariaLabel = this._action.label || "", null;
    }, i = Array.isArray(this.menuActionsOrProvider), n = {
      contextMenuProvider: this.contextMenuProvider,
      labelRenderer: t,
      menuAsChild: this.options.menuAsChild,
      actions: i ? this.menuActionsOrProvider : void 0,
      actionProvider: i ? void 0 : this.menuActionsOrProvider,
      skipTelemetry: this.options.skipTelemetry
    };
    if (this.dropdownMenu = this._register(new nz(e, n)), this._register(this.dropdownMenu.onDidChangeVisibility((o) => {
      var r;
      (r = this.element) == null || r.setAttribute("aria-expanded", `${o}`), this._onDidChangeVisibility.fire(o);
    })), this.dropdownMenu.menuOptions = {
      actionViewItemProvider: this.options.actionViewItemProvider,
      actionRunner: this.actionRunner,
      getKeyBinding: this.options.keybindingProvider,
      context: this._context
    }, this.options.anchorAlignmentProvider) {
      const o = this;
      this.dropdownMenu.menuOptions = {
        ...this.dropdownMenu.menuOptions,
        get anchorAlignment() {
          return o.options.anchorAlignmentProvider();
        }
      };
    }
    this.updateTooltip(), this.updateEnabled();
  }
  getTooltip() {
    let e = null;
    return this.action.tooltip ? e = this.action.tooltip : this.action.label && (e = this.action.label), e ?? void 0;
  }
  setActionContext(e) {
    super.setActionContext(e), this.dropdownMenu && (this.dropdownMenu.menuOptions ? this.dropdownMenu.menuOptions.context = e : this.dropdownMenu.menuOptions = { context: e });
  }
  show() {
    var e;
    (e = this.dropdownMenu) == null || e.show();
  }
  updateEnabled() {
    var t, i;
    const e = !this.action.enabled;
    (t = this.actionItem) == null || t.classList.toggle("disabled", e), (i = this.element) == null || i.classList.toggle("disabled", e);
  }
}
function sz(s) {
  return s ? s.condition !== void 0 : !1;
}
var Xh;
(function(s) {
  s[s.STORAGE_DOES_NOT_EXIST = 0] = "STORAGE_DOES_NOT_EXIST", s[s.STORAGE_IN_MEMORY = 1] = "STORAGE_IN_MEMORY";
})(Xh || (Xh = {}));
var yh;
(function(s) {
  s[s.None = 0] = "None", s[s.Initialized = 1] = "Initialized", s[s.Closed = 2] = "Closed";
})(yh || (yh = {}));
const v1 = class v1 extends q {
  constructor(e, t = /* @__PURE__ */ Object.create(null)) {
    super(), this.database = e, this.options = t, this._onDidChangeStorage = this._register(new Mf()), this.onDidChangeStorage = this._onDidChangeStorage.event, this.state = yh.None, this.cache = /* @__PURE__ */ new Map(), this.flushDelayer = this._register(new rM(v1.DEFAULT_FLUSH_DELAY)), this.pendingDeletes = /* @__PURE__ */ new Set(), this.pendingInserts = /* @__PURE__ */ new Map(), this.whenFlushedCallbacks = [], this.registerListeners();
  }
  registerListeners() {
    this._register(this.database.onDidChangeItemsExternal((e) => this.onDidChangeItemsExternal(e)));
  }
  onDidChangeItemsExternal(e) {
    var t, i;
    this._onDidChangeStorage.pause();
    try {
      (t = e.changed) == null || t.forEach((n, o) => this.acceptExternal(o, n)), (i = e.deleted) == null || i.forEach((n) => this.acceptExternal(n, void 0));
    } finally {
      this._onDidChangeStorage.resume();
    }
  }
  acceptExternal(e, t) {
    if (this.state === yh.Closed)
      return;
    let i = !1;
    Zn(t) ? i = this.cache.delete(e) : this.cache.get(e) !== t && (this.cache.set(e, t), i = !0), i && this._onDidChangeStorage.fire({ key: e, external: !0 });
  }
  get(e, t) {
    const i = this.cache.get(e);
    return Zn(i) ? t : i;
  }
  getBoolean(e, t) {
    const i = this.get(e);
    return Zn(i) ? t : i === "true";
  }
  getNumber(e, t) {
    const i = this.get(e);
    return Zn(i) ? t : parseInt(i, 10);
  }
  async set(e, t, i = !1) {
    if (this.state === yh.Closed)
      return;
    if (Zn(t))
      return this.delete(e, i);
    const n = _n(t) || Array.isArray(t) ? RW(t) : String(t);
    if (this.cache.get(e) !== n)
      return this.cache.set(e, n), this.pendingInserts.set(e, n), this.pendingDeletes.delete(e), this._onDidChangeStorage.fire({ key: e, external: i }), this.doFlush();
  }
  async delete(e, t = !1) {
    if (!(this.state === yh.Closed || !this.cache.delete(e)))
      return this.pendingDeletes.has(e) || this.pendingDeletes.add(e), this.pendingInserts.delete(e), this._onDidChangeStorage.fire({ key: e, external: t }), this.doFlush();
  }
  get hasPending() {
    return this.pendingInserts.size > 0 || this.pendingDeletes.size > 0;
  }
  async flushPending() {
    if (!this.hasPending)
      return;
    const e = { insert: this.pendingInserts, delete: this.pendingDeletes };
    return this.pendingDeletes = /* @__PURE__ */ new Set(), this.pendingInserts = /* @__PURE__ */ new Map(), this.database.updateItems(e).finally(() => {
      var t;
      if (!this.hasPending)
        for (; this.whenFlushedCallbacks.length; )
          (t = this.whenFlushedCallbacks.pop()) == null || t();
    });
  }
  async doFlush(e) {
    return this.options.hint === Xh.STORAGE_IN_MEMORY ? this.flushPending() : this.flushDelayer.trigger(() => this.flushPending(), e);
  }
};
v1.DEFAULT_FLUSH_DELAY = 100;
let Gu = v1;
class q0 {
  constructor() {
    this.onDidChangeItemsExternal = J.None, this.items = /* @__PURE__ */ new Map();
  }
  async updateItems(e) {
    var t, i;
    (t = e.insert) == null || t.forEach((n, o) => this.items.set(o, n)), (i = e.delete) == null || i.forEach((n) => this.items.delete(n));
  }
}
const np = "__$__targetStorageMarker", Fb = Ve("storageService");
var $I;
(function(s) {
  s[s.NONE = 0] = "NONE", s[s.SHUTDOWN = 1] = "SHUTDOWN";
})($I || ($I = {}));
function oz(s) {
  const e = s.get(np);
  if (e)
    try {
      return JSON.parse(e);
    } catch {
    }
  return /* @__PURE__ */ Object.create(null);
}
const y1 = class y1 extends q {
  // every minute
  constructor(e = { flushInterval: y1.DEFAULT_FLUSH_INTERVAL }) {
    super(), this.options = e, this._onDidChangeValue = this._register(new Mf()), this._onDidChangeTarget = this._register(new Mf()), this._onWillSaveState = this._register(new O()), this.onWillSaveState = this._onWillSaveState.event, this._workspaceKeyTargets = void 0, this._profileKeyTargets = void 0, this._applicationKeyTargets = void 0;
  }
  onDidChangeValue(e, t, i) {
    return J.filter(this._onDidChangeValue.event, (n) => n.scope === e && (t === void 0 || n.key === t), i);
  }
  emitDidChangeValue(e, t) {
    const { key: i, external: n } = t;
    if (i === np) {
      switch (e) {
        case -1:
          this._applicationKeyTargets = void 0;
          break;
        case 0:
          this._profileKeyTargets = void 0;
          break;
        case 1:
          this._workspaceKeyTargets = void 0;
          break;
      }
      this._onDidChangeTarget.fire({ scope: e });
    } else
      this._onDidChangeValue.fire({ scope: e, key: i, target: this.getKeyTargets(e)[i], external: n });
  }
  get(e, t, i) {
    var n;
    return (n = this.getStorage(t)) == null ? void 0 : n.get(e, i);
  }
  getBoolean(e, t, i) {
    var n;
    return (n = this.getStorage(t)) == null ? void 0 : n.getBoolean(e, i);
  }
  getNumber(e, t, i) {
    var n;
    return (n = this.getStorage(t)) == null ? void 0 : n.getNumber(e, i);
  }
  store(e, t, i, n, o = !1) {
    if (Zn(t)) {
      this.remove(e, i, o);
      return;
    }
    this.withPausedEmitters(() => {
      var r;
      this.updateKeyTarget(e, i, n), (r = this.getStorage(i)) == null || r.set(e, t, o);
    });
  }
  remove(e, t, i = !1) {
    this.withPausedEmitters(() => {
      var n;
      this.updateKeyTarget(e, t, void 0), (n = this.getStorage(t)) == null || n.delete(e, i);
    });
  }
  withPausedEmitters(e) {
    this._onDidChangeValue.pause(), this._onDidChangeTarget.pause();
    try {
      e();
    } finally {
      this._onDidChangeValue.resume(), this._onDidChangeTarget.resume();
    }
  }
  updateKeyTarget(e, t, i, n = !1) {
    var r, a;
    const o = this.getKeyTargets(t);
    typeof i == "number" ? o[e] !== i && (o[e] = i, (r = this.getStorage(t)) == null || r.set(np, JSON.stringify(o), n)) : typeof o[e] == "number" && (delete o[e], (a = this.getStorage(t)) == null || a.set(np, JSON.stringify(o), n));
  }
  get workspaceKeyTargets() {
    return this._workspaceKeyTargets || (this._workspaceKeyTargets = this.loadKeyTargets(
      1
      /* StorageScope.WORKSPACE */
    )), this._workspaceKeyTargets;
  }
  get profileKeyTargets() {
    return this._profileKeyTargets || (this._profileKeyTargets = this.loadKeyTargets(
      0
      /* StorageScope.PROFILE */
    )), this._profileKeyTargets;
  }
  get applicationKeyTargets() {
    return this._applicationKeyTargets || (this._applicationKeyTargets = this.loadKeyTargets(
      -1
      /* StorageScope.APPLICATION */
    )), this._applicationKeyTargets;
  }
  getKeyTargets(e) {
    switch (e) {
      case -1:
        return this.applicationKeyTargets;
      case 0:
        return this.profileKeyTargets;
      default:
        return this.workspaceKeyTargets;
    }
  }
  loadKeyTargets(e) {
    const t = this.getStorage(e);
    return t ? oz(t) : /* @__PURE__ */ Object.create(null);
  }
};
y1.DEFAULT_FLUSH_INTERVAL = 60 * 1e3;
let dy = y1;
class rz extends dy {
  constructor() {
    super(), this.applicationStorage = this._register(new Gu(new q0(), { hint: Xh.STORAGE_IN_MEMORY })), this.profileStorage = this._register(new Gu(new q0(), { hint: Xh.STORAGE_IN_MEMORY })), this.workspaceStorage = this._register(new Gu(new q0(), { hint: Xh.STORAGE_IN_MEMORY })), this._register(this.workspaceStorage.onDidChangeStorage((e) => this.emitDidChangeValue(1, e))), this._register(this.profileStorage.onDidChangeStorage((e) => this.emitDidChangeValue(0, e))), this._register(this.applicationStorage.onDidChangeStorage((e) => this.emitDidChangeValue(-1, e)));
  }
  getStorage(e) {
    switch (e) {
      case -1:
        return this.applicationStorage;
      case 0:
        return this.profileStorage;
      default:
        return this.workspaceStorage;
    }
  }
}
function az(s, e) {
  const t = { ...e };
  for (const i in s) {
    const n = s[i];
    t[i] = n !== void 0 ? te(n) : void 0;
  }
  return t;
}
const lz = {
  keybindingLabelBackground: te(Q8),
  keybindingLabelForeground: te(X8),
  keybindingLabelBorder: te(J8),
  keybindingLabelBottomBorder: te(eB),
  keybindingLabelShadow: te(Rg)
}, cz = {
  buttonForeground: te(WR),
  buttonSeparator: te(F8),
  buttonBackground: te(xu),
  buttonHoverBackground: te(B8),
  buttonSecondaryForeground: te(V8),
  buttonSecondaryBackground: te(Ov),
  buttonSecondaryHoverBackground: te(H8),
  buttonBorder: te(W8)
}, hz = {
  progressBarBackground: te(e8)
}, EA = {
  inputActiveOptionBorder: te(OR),
  inputActiveOptionForeground: te(BR),
  inputActiveOptionBackground: te(FR)
};
te(Du), te(z8), te(U8), te($8), te(K8), te(q8), te(j8);
te(G8), te(Y8), te(Z8);
te(Is), te(Sb), te(Rg), te(Xe), te(g8), te(m8), te(p8), te(XF);
const IA = {
  inputBackground: te(S8),
  inputForeground: te(L8),
  inputBorder: te(k8),
  inputValidationInfoBorder: te(I8),
  inputValidationInfoBackground: te(D8),
  inputValidationInfoForeground: te(E8),
  inputValidationWarningBorder: te(M8),
  inputValidationWarningBackground: te(N8),
  inputValidationWarningForeground: te(T8),
  inputValidationErrorBorder: te(P8),
  inputValidationErrorBackground: te(R8),
  inputValidationErrorForeground: te(A8)
}, dz = {
  listFilterWidgetBackground: te(uB),
  listFilterWidgetOutline: te(fB),
  listFilterWidgetNoMatchesOutline: te(gB),
  listFilterWidgetShadow: te(mB),
  inputBoxStyles: IA,
  toggleStyles: EA
}, uz = {
  badgeBackground: te(Jm),
  badgeForeground: te(JF),
  badgeBorder: te(Xe)
};
te(u8), te(d8), te(XE), te(XE), te(f8);
const Kd = {
  listBackground: void 0,
  listInactiveFocusForeground: void 0,
  listFocusBackground: te(tB),
  listFocusForeground: te(iB),
  listFocusOutline: te(nB),
  listActiveSelectionBackground: te(vc),
  listActiveSelectionForeground: te($f),
  listActiveSelectionIconForeground: te(VR),
  listFocusAndSelectionOutline: te(sB),
  listFocusAndSelectionBackground: te(vc),
  listFocusAndSelectionForeground: te($f),
  listInactiveSelectionBackground: te(oB),
  listInactiveSelectionIconForeground: te(aB),
  listInactiveSelectionForeground: te(rB),
  listInactiveFocusBackground: te(lB),
  listInactiveFocusOutline: te(cB),
  listHoverBackground: te(HR),
  listHoverForeground: te(zR),
  listDropOverBackground: te(hB),
  listDropBetweenBackground: te(dB),
  listSelectionOutline: te(jt),
  listHoverOutline: te(jt),
  treeIndentGuidesStroke: te(UR),
  treeInactiveIndentGuidesStroke: te(pB),
  treeStickyScrollBackground: void 0,
  treeStickyScrollBorder: void 0,
  treeStickyScrollShadow: te(ak),
  tableColumnsBorder: te(_B),
  tableOddRowsBackgroundColor: te(bB)
};
function Vg(s) {
  return az(s, Kd);
}
const fz = {
  selectBackground: te(Lb),
  selectListBackground: te(O8),
  selectForeground: te(hk),
  decoratorRightForeground: te($R),
  selectBorder: te(dk),
  focusBorder: te(Uo),
  listFocusBackground: te(Bv),
  listInactiveSelectionIconForeground: te(KR),
  listFocusForeground: te(Fv),
  listFocusOutline: qF(jt, Z.transparent.toString()),
  listHoverBackground: te(HR),
  listHoverForeground: te(zR),
  listHoverOutline: te(jt),
  selectListBorder: te(NR),
  listBackground: void 0,
  listActiveSelectionBackground: void 0,
  listActiveSelectionForeground: void 0,
  listActiveSelectionIconForeground: void 0,
  listFocusAndSelectionBackground: void 0,
  listDropOverBackground: void 0,
  listDropBetweenBackground: void 0,
  listInactiveSelectionBackground: void 0,
  listInactiveSelectionForeground: void 0,
  listInactiveFocusBackground: void 0,
  listInactiveFocusOutline: void 0,
  listSelectionOutline: void 0,
  listFocusAndSelectionForeground: void 0,
  listFocusAndSelectionOutline: void 0,
  listInactiveFocusForeground: void 0,
  tableColumnsBorder: void 0,
  tableOddRowsBackgroundColor: void 0,
  treeIndentGuidesStroke: void 0,
  treeInactiveIndentGuidesStroke: void 0,
  treeStickyScrollBackground: void 0,
  treeStickyScrollBorder: void 0,
  treeStickyScrollShadow: void 0
}, gz = {
  shadowColor: te(Rg),
  borderColor: te(CB),
  foregroundColor: te(wB),
  backgroundColor: te(vB),
  selectionForegroundColor: te(yB),
  selectionBackgroundColor: te(SB),
  selectionBorderColor: te(LB),
  separatorColor: te(kB),
  scrollbarShadow: te(ak),
  scrollbarSliderBackground: te(DR),
  scrollbarSliderHoverBackground: te(ER),
  scrollbarSliderActiveBackground: te(IR)
};
var Bb = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, pn = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
function mz(s, e, t, i) {
  let n, o, r;
  if (Array.isArray(s))
    r = s, n = e, o = t;
  else {
    const c = e;
    r = s.getActions(c), n = t, o = i;
  }
  const a = ka.getInstance(), l = a.keyStatus.altKey || (Fn || wn) && a.keyStatus.shiftKey;
  NA(r, n, l, o ? (c) => c === o : (c) => c === "navigation");
}
function pz(s, e, t, i, n, o) {
  let r, a, l, c, h;
  if (Array.isArray(s))
    h = s, r = e, a = t, l = i, c = n;
  else {
    const u = e;
    h = s.getActions(u), r = t, a = i, l = n, c = o;
  }
  NA(h, r, !1, typeof a == "string" ? (u) => u === a : a, l, c);
}
function NA(s, e, t, i = (r) => r === "navigation", n = () => !1, o = !1) {
  let r, a;
  Array.isArray(e) ? (r = e, a = e) : (r = e.primary, a = e.secondary);
  const l = /* @__PURE__ */ new Set();
  for (const [c, h] of s) {
    let d;
    i(c) ? (d = r, d.length > 0 && o && d.push(new Zi())) : (d = a, d.length > 0 && d.push(new Zi()));
    for (let u of h) {
      t && (u = u instanceof Ur && u.alt ? u.alt : u);
      const f = d.push(u);
      u instanceof lb && l.add({ group: c, action: u, index: f - 1 });
    }
  }
  for (const { group: c, action: h, index: d } of l) {
    const u = i(c) ? r : a, f = h.actions;
    n(h, c, u.length) && u.splice(d, 1, ...f);
  }
}
let Qf = class extends Ak {
  constructor(e, t, i, n, o, r, a, l) {
    super(void 0, e, { icon: !!(e.class || e.item.icon), label: !e.class && !e.item.icon, draggable: t == null ? void 0 : t.draggable, keybinding: t == null ? void 0 : t.keybinding, hoverDelegate: t == null ? void 0 : t.hoverDelegate }), this._options = t, this._keybindingService = i, this._notificationService = n, this._contextKeyService = o, this._themeService = r, this._contextMenuService = a, this._accessibilityService = l, this._wantsAltCommand = !1, this._itemClassDispose = this._register(new Zr()), this._altKey = ka.getInstance();
  }
  get _menuItemAction() {
    return this._action;
  }
  get _commandAction() {
    return this._wantsAltCommand && this._menuItemAction.alt || this._menuItemAction;
  }
  async onClick(e) {
    e.preventDefault(), e.stopPropagation();
    try {
      await this.actionRunner.run(this._commandAction, this._context);
    } catch (t) {
      this._notificationService.error(t);
    }
  }
  render(e) {
    if (super.render(e), e.classList.add("menu-entry"), this.options.icon && this._updateItemClass(this._menuItemAction.item), this._menuItemAction.alt) {
      let t = !1;
      const i = () => {
        var o;
        const n = !!((o = this._menuItemAction.alt) != null && o.enabled) && (!this._accessibilityService.isMotionReduced() || t) && (this._altKey.keyStatus.altKey || this._altKey.keyStatus.shiftKey && t);
        n !== this._wantsAltCommand && (this._wantsAltCommand = n, this.updateLabel(), this.updateTooltip(), this.updateClass());
      };
      this._register(this._altKey.event(i)), this._register($(e, "mouseleave", (n) => {
        t = !1, i();
      })), this._register($(e, "mouseenter", (n) => {
        t = !0, i();
      })), i();
    }
  }
  updateLabel() {
    this.options.label && this.label && (this.label.textContent = this._commandAction.label);
  }
  getTooltip() {
    var o;
    const e = this._keybindingService.lookupKeybinding(this._commandAction.id, this._contextKeyService), t = e && e.getLabel(), i = this._commandAction.tooltip || this._commandAction.label;
    let n = t ? p("titleAndKb", "{0} ({1})", i, t) : i;
    if (!this._wantsAltCommand && ((o = this._menuItemAction.alt) != null && o.enabled)) {
      const r = this._menuItemAction.alt.tooltip || this._menuItemAction.alt.label, a = this._keybindingService.lookupKeybinding(this._menuItemAction.alt.id, this._contextKeyService), l = a && a.getLabel(), c = l ? p("titleAndKb", "{0} ({1})", r, l) : r;
      n = p("titleAndKbAndAlt", `{0}
[{1}] {2}`, n, kk.modifierLabels[Es].altKey, c);
    }
    return n;
  }
  updateClass() {
    this.options.icon && (this._commandAction !== this._menuItemAction ? this._menuItemAction.alt && this._updateItemClass(this._menuItemAction.alt.item) : this._updateItemClass(this._menuItemAction.item));
  }
  _updateItemClass(e) {
    this._itemClassDispose.value = void 0;
    const { element: t, label: i } = this;
    if (!t || !i)
      return;
    const n = this._commandAction.checked && sz(e.toggled) && e.toggled.icon ? e.toggled.icon : e.icon;
    if (n)
      if (Ke.isThemeIcon(n)) {
        const o = Ke.asClassNameArray(n);
        i.classList.add(...o), this._itemClassDispose.value = ke(() => {
          i.classList.remove(...o);
        });
      } else
        i.style.backgroundImage = vb(this._themeService.getColorTheme().type) ? Qr(n.dark) : Qr(n.light), i.classList.add("icon"), this._itemClassDispose.value = Wo(ke(() => {
          i.style.backgroundImage = "", i.classList.remove("icon");
        }), this._themeService.onDidColorThemeChange(() => {
          this.updateClass();
        }));
  }
};
Qf = Bb([
  pn(2, Ai),
  pn(3, fo),
  pn(4, nt),
  pn(5, Ws),
  pn(6, ea),
  pn(7, go)
], Qf);
let uy = class extends o_ {
  constructor(e, t, i, n, o) {
    const r = {
      ...t,
      menuAsChild: (t == null ? void 0 : t.menuAsChild) ?? !1,
      classNames: (t == null ? void 0 : t.classNames) ?? (Ke.isThemeIcon(e.item.icon) ? Ke.asClassName(e.item.icon) : void 0),
      keybindingProvider: (t == null ? void 0 : t.keybindingProvider) ?? ((a) => i.lookupKeybinding(a.id))
    };
    super(e, { getActions: () => e.actions }, n, r), this._keybindingService = i, this._contextMenuService = n, this._themeService = o;
  }
  render(e) {
    super.render(e), Pa(this.element), e.classList.add("menu-entry");
    const t = this._action, { icon: i } = t.item;
    if (i && !Ke.isThemeIcon(i)) {
      this.element.classList.add("icon");
      const n = () => {
        this.element && (this.element.style.backgroundImage = vb(this._themeService.getColorTheme().type) ? Qr(i.dark) : Qr(i.light));
      };
      n(), this._register(this._themeService.onDidColorThemeChange(() => {
        n();
      }));
    }
  }
};
uy = Bb([
  pn(2, Ai),
  pn(3, ea),
  pn(4, Ws)
], uy);
let fy = class extends Js {
  constructor(e, t, i, n, o, r, a, l) {
    super(null, e), this._keybindingService = i, this._notificationService = n, this._contextMenuService = o, this._menuService = r, this._instaService = a, this._storageService = l, this._container = null, this._options = t, this._storageKey = `${e.item.submenu.id}_lastActionId`;
    let c;
    const h = t != null && t.persistLastActionId ? l.get(
      this._storageKey,
      1
      /* StorageScope.WORKSPACE */
    ) : void 0;
    h && (c = e.actions.find((u) => h === u.id)), c || (c = e.actions[0]), this._defaultAction = this._instaService.createInstance(Qf, c, { keybinding: this._getDefaultActionKeybindingLabel(c) });
    const d = {
      keybindingProvider: (u) => this._keybindingService.lookupKeybinding(u.id),
      ...t,
      menuAsChild: (t == null ? void 0 : t.menuAsChild) ?? !0,
      classNames: (t == null ? void 0 : t.classNames) ?? ["codicon", "codicon-chevron-down"],
      actionRunner: (t == null ? void 0 : t.actionRunner) ?? new _c()
    };
    this._dropdown = new o_(e, e.actions, this._contextMenuService, d), this._register(this._dropdown.actionRunner.onDidRun((u) => {
      u.action instanceof Ur && this.update(u.action);
    }));
  }
  update(e) {
    var t;
    (t = this._options) != null && t.persistLastActionId && this._storageService.store(
      this._storageKey,
      e.id,
      1,
      1
      /* StorageTarget.MACHINE */
    ), this._defaultAction.dispose(), this._defaultAction = this._instaService.createInstance(Qf, e, { keybinding: this._getDefaultActionKeybindingLabel(e) }), this._defaultAction.actionRunner = new class extends _c {
      async runAction(i, n) {
        await i.run(void 0);
      }
    }(), this._container && this._defaultAction.render($L(this._container, pe(".action-container")));
  }
  _getDefaultActionKeybindingLabel(e) {
    var i;
    let t;
    if ((i = this._options) != null && i.renderKeybindingWithDefaultActionLabel) {
      const n = this._keybindingService.lookupKeybinding(e.id);
      n && (t = `(${n.getLabel()})`);
    }
    return t;
  }
  setActionContext(e) {
    super.setActionContext(e), this._defaultAction.setActionContext(e), this._dropdown.setActionContext(e);
  }
  render(e) {
    this._container = e, super.render(this._container), this._container.classList.add("monaco-dropdown-with-default");
    const t = pe(".action-container");
    this._defaultAction.render(ae(this._container, t)), this._register($(t, ee.KEY_DOWN, (n) => {
      const o = new Lt(n);
      o.equals(
        17
        /* KeyCode.RightArrow */
      ) && (this._defaultAction.element.tabIndex = -1, this._dropdown.focus(), o.stopPropagation());
    }));
    const i = pe(".dropdown-action-container");
    this._dropdown.render(ae(this._container, i)), this._register($(i, ee.KEY_DOWN, (n) => {
      var r;
      const o = new Lt(n);
      o.equals(
        15
        /* KeyCode.LeftArrow */
      ) && (this._defaultAction.element.tabIndex = 0, this._dropdown.setFocusable(!1), (r = this._defaultAction.element) == null || r.focus(), o.stopPropagation());
    }));
  }
  focus(e) {
    e ? this._dropdown.focus() : (this._defaultAction.element.tabIndex = 0, this._defaultAction.element.focus());
  }
  blur() {
    this._defaultAction.element.tabIndex = -1, this._dropdown.blur(), this._container.blur();
  }
  setFocusable(e) {
    e ? this._defaultAction.element.tabIndex = 0 : (this._defaultAction.element.tabIndex = -1, this._dropdown.setFocusable(!1));
  }
  dispose() {
    this._defaultAction.dispose(), this._dropdown.dispose(), super.dispose();
  }
};
fy = Bb([
  pn(2, Ai),
  pn(3, fo),
  pn(4, ea),
  pn(5, Rc),
  pn(6, ot),
  pn(7, Fb)
], fy);
let gy = class extends tz {
  constructor(e, t) {
    super(null, e, e.actions.map((i) => ({
      text: i.id === Zi.ID ? "─────────" : i.label,
      isDisabled: !i.enabled
    })), 0, t, fz, { ariaLabel: e.tooltip, optionsAsChildren: !0 }), this.select(Math.max(0, e.actions.findIndex((i) => i.checked)));
  }
  render(e) {
    super.render(e), e.style.borderColor = te(dk);
  }
  runAction(e, t) {
    const i = this.action.actions[t];
    i && this.actionRunner.run(i);
  }
};
gy = Bb([
  pn(1, Pg)
], gy);
function _z(s, e, t) {
  return e instanceof Ur ? s.createInstance(Qf, e, t) : e instanceof zu ? e.item.isSelection ? s.createInstance(gy, e) : e.item.rememberDefaultAction ? s.createInstance(fy, e, { ...t, persistLastActionId: !0 }) : s.createInstance(uy, e, t) : void 0;
}
class Kr extends q {
  constructor(e, t = {}) {
    var o, r;
    super(), this._actionRunnerDisposables = this._register(new he()), this.viewItemDisposables = this._register(new yL()), this.triggerKeyDown = !1, this.focusable = !0, this._onDidBlur = this._register(new O()), this.onDidBlur = this._onDidBlur.event, this._onDidCancel = this._register(new O({ onWillAddFirstListener: () => this.cancelHasListener = !0 })), this.onDidCancel = this._onDidCancel.event, this.cancelHasListener = !1, this._onDidRun = this._register(new O()), this.onDidRun = this._onDidRun.event, this._onWillRun = this._register(new O()), this.onWillRun = this._onWillRun.event, this.options = t, this._context = t.context ?? null, this._orientation = this.options.orientation ?? 0, this._triggerKeys = {
      keyDown: ((o = this.options.triggerKeys) == null ? void 0 : o.keyDown) ?? !1,
      keys: ((r = this.options.triggerKeys) == null ? void 0 : r.keys) ?? [
        3,
        10
        /* KeyCode.Space */
      ]
    }, this._hoverDelegate = t.hoverDelegate ?? this._register(Rk()), this.options.actionRunner ? this._actionRunner = this.options.actionRunner : (this._actionRunner = new _c(), this._actionRunnerDisposables.add(this._actionRunner)), this._actionRunnerDisposables.add(this._actionRunner.onDidRun((a) => this._onDidRun.fire(a))), this._actionRunnerDisposables.add(this._actionRunner.onWillRun((a) => this._onWillRun.fire(a))), this.viewItems = [], this.focusedItem = void 0, this.domNode = document.createElement("div"), this.domNode.className = "monaco-action-bar";
    let i, n;
    switch (this._orientation) {
      case 0:
        i = [
          15
          /* KeyCode.LeftArrow */
        ], n = [
          17
          /* KeyCode.RightArrow */
        ];
        break;
      case 1:
        i = [
          16
          /* KeyCode.UpArrow */
        ], n = [
          18
          /* KeyCode.DownArrow */
        ], this.domNode.className += " vertical";
        break;
    }
    this._register($(this.domNode, ee.KEY_DOWN, (a) => {
      const l = new Lt(a);
      let c = !0;
      const h = typeof this.focusedItem == "number" ? this.viewItems[this.focusedItem] : void 0;
      i && (l.equals(i[0]) || l.equals(i[1])) ? c = this.focusPrevious() : n && (l.equals(n[0]) || l.equals(n[1])) ? c = this.focusNext() : l.equals(
        9
        /* KeyCode.Escape */
      ) && this.cancelHasListener ? this._onDidCancel.fire() : l.equals(
        14
        /* KeyCode.Home */
      ) ? c = this.focusFirst() : l.equals(
        13
        /* KeyCode.End */
      ) ? c = this.focusLast() : l.equals(
        2
        /* KeyCode.Tab */
      ) && h instanceof Js && h.trapsArrowNavigation ? c = this.focusNext(void 0, !0) : this.isTriggerKeyEvent(l) ? this._triggerKeys.keyDown ? this.doTrigger(l) : this.triggerKeyDown = !0 : c = !1, c && (l.preventDefault(), l.stopPropagation());
    })), this._register($(this.domNode, ee.KEY_UP, (a) => {
      const l = new Lt(a);
      this.isTriggerKeyEvent(l) ? (!this._triggerKeys.keyDown && this.triggerKeyDown && (this.triggerKeyDown = !1, this.doTrigger(l)), l.preventDefault(), l.stopPropagation()) : (l.equals(
        2
        /* KeyCode.Tab */
      ) || l.equals(
        1026
        /* KeyCode.Tab */
      ) || l.equals(
        16
        /* KeyCode.UpArrow */
      ) || l.equals(
        18
        /* KeyCode.DownArrow */
      ) || l.equals(
        15
        /* KeyCode.LeftArrow */
      ) || l.equals(
        17
        /* KeyCode.RightArrow */
      )) && this.updateFocusedItem();
    })), this.focusTracker = this._register(Ff(this.domNode)), this._register(this.focusTracker.onDidBlur(() => {
      (Gi() === this.domNode || !ui(Gi(), this.domNode)) && (this._onDidBlur.fire(), this.previouslyFocusedItem = this.focusedItem, this.focusedItem = void 0, this.triggerKeyDown = !1);
    })), this._register(this.focusTracker.onDidFocus(() => this.updateFocusedItem())), this.actionsList = document.createElement("ul"), this.actionsList.className = "actions-container", this.options.highlightToggledItems && this.actionsList.classList.add("highlight-toggled"), this.actionsList.setAttribute("role", this.options.ariaRole || "toolbar"), this.options.ariaLabel && this.actionsList.setAttribute("aria-label", this.options.ariaLabel), this.domNode.appendChild(this.actionsList), e.appendChild(this.domNode);
  }
  refreshRole() {
    this.length() >= 1 ? this.actionsList.setAttribute("role", this.options.ariaRole || "toolbar") : this.actionsList.setAttribute("role", "presentation");
  }
  // Some action bars should not be focusable at times
  // When an action bar is not focusable make sure to make all the elements inside it not focusable
  // When an action bar is focusable again, make sure the first item can be focused
  setFocusable(e) {
    if (this.focusable = e, this.focusable) {
      const t = this.viewItems.find((i) => i instanceof Js && i.isEnabled());
      t instanceof Js && t.setFocusable(!0);
    } else
      this.viewItems.forEach((t) => {
        t instanceof Js && t.setFocusable(!1);
      });
  }
  isTriggerKeyEvent(e) {
    let t = !1;
    return this._triggerKeys.keys.forEach((i) => {
      t = t || e.equals(i);
    }), t;
  }
  updateFocusedItem() {
    var e, t;
    for (let i = 0; i < this.actionsList.children.length; i++) {
      const n = this.actionsList.children[i];
      if (ui(Gi(), n)) {
        this.focusedItem = i, (t = (e = this.viewItems[this.focusedItem]) == null ? void 0 : e.showHover) == null || t.call(e);
        break;
      }
    }
  }
  get context() {
    return this._context;
  }
  set context(e) {
    this._context = e, this.viewItems.forEach((t) => t.setActionContext(e));
  }
  get actionRunner() {
    return this._actionRunner;
  }
  set actionRunner(e) {
    this._actionRunner = e, this._actionRunnerDisposables.clear(), this._actionRunnerDisposables.add(this._actionRunner.onDidRun((t) => this._onDidRun.fire(t))), this._actionRunnerDisposables.add(this._actionRunner.onWillRun((t) => this._onWillRun.fire(t))), this.viewItems.forEach((t) => t.actionRunner = e);
  }
  getContainer() {
    return this.domNode;
  }
  getAction(e) {
    var t;
    if (typeof e == "number")
      return (t = this.viewItems[e]) == null ? void 0 : t.action;
    if (yi(e)) {
      for (; e.parentElement !== this.actionsList; ) {
        if (!e.parentElement)
          return;
        e = e.parentElement;
      }
      for (let i = 0; i < this.actionsList.childNodes.length; i++)
        if (this.actionsList.childNodes[i] === e)
          return this.viewItems[i].action;
    }
  }
  push(e, t = {}) {
    const i = Array.isArray(e) ? e : [e];
    let n = Od(t.index) ? t.index : null;
    i.forEach((o) => {
      const r = document.createElement("li");
      r.className = "action-item", r.setAttribute("role", "presentation");
      let a;
      const l = { hoverDelegate: this._hoverDelegate, ...t, isTabList: this.options.ariaRole === "tablist" };
      this.options.actionViewItemProvider && (a = this.options.actionViewItemProvider(o, l)), a || (a = new Ak(this.context, o, l)), this.options.allowContextMenu || this.viewItemDisposables.set(a, $(r, ee.CONTEXT_MENU, (c) => {
        Be.stop(c, !0);
      })), a.actionRunner = this._actionRunner, a.setActionContext(this.context), a.render(r), this.focusable && a instanceof Js && this.viewItems.length === 0 && a.setFocusable(!0), n === null || n < 0 || n >= this.actionsList.children.length ? (this.actionsList.appendChild(r), this.viewItems.push(a)) : (this.actionsList.insertBefore(r, this.actionsList.children[n]), this.viewItems.splice(n, 0, a), n++);
    }), typeof this.focusedItem == "number" && this.focus(this.focusedItem), this.refreshRole();
  }
  clear() {
    this.isEmpty() || (this.viewItems = Ri(this.viewItems), this.viewItemDisposables.clearAndDisposeAll(), oo(this.actionsList), this.refreshRole());
  }
  length() {
    return this.viewItems.length;
  }
  isEmpty() {
    return this.viewItems.length === 0;
  }
  focus(e) {
    let t = !1, i;
    if (e === void 0 ? t = !0 : typeof e == "number" ? i = e : typeof e == "boolean" && (t = e), t && typeof this.focusedItem > "u") {
      const n = this.viewItems.findIndex((o) => o.isEnabled());
      this.focusedItem = n === -1 ? void 0 : n, this.updateFocus(void 0, void 0, !0);
    } else
      i !== void 0 && (this.focusedItem = i), this.updateFocus(void 0, void 0, !0);
  }
  focusFirst() {
    return this.focusedItem = this.length() - 1, this.focusNext(!0);
  }
  focusLast() {
    return this.focusedItem = 0, this.focusPrevious(!0);
  }
  focusNext(e, t) {
    if (typeof this.focusedItem > "u")
      this.focusedItem = this.viewItems.length - 1;
    else if (this.viewItems.length <= 1)
      return !1;
    const i = this.focusedItem;
    let n;
    do {
      if (!e && this.options.preventLoopNavigation && this.focusedItem + 1 >= this.viewItems.length)
        return this.focusedItem = i, !1;
      this.focusedItem = (this.focusedItem + 1) % this.viewItems.length, n = this.viewItems[this.focusedItem];
    } while (this.focusedItem !== i && (this.options.focusOnlyEnabledItems && !n.isEnabled() || n.action.id === Zi.ID));
    return this.updateFocus(void 0, void 0, t), !0;
  }
  focusPrevious(e) {
    if (typeof this.focusedItem > "u")
      this.focusedItem = 0;
    else if (this.viewItems.length <= 1)
      return !1;
    const t = this.focusedItem;
    let i;
    do {
      if (this.focusedItem = this.focusedItem - 1, this.focusedItem < 0) {
        if (!e && this.options.preventLoopNavigation)
          return this.focusedItem = t, !1;
        this.focusedItem = this.viewItems.length - 1;
      }
      i = this.viewItems[this.focusedItem];
    } while (this.focusedItem !== t && (this.options.focusOnlyEnabledItems && !i.isEnabled() || i.action.id === Zi.ID));
    return this.updateFocus(!0), !0;
  }
  updateFocus(e, t, i = !1) {
    var o, r;
    typeof this.focusedItem > "u" && this.actionsList.focus({ preventScroll: t }), this.previouslyFocusedItem !== void 0 && this.previouslyFocusedItem !== this.focusedItem && ((o = this.viewItems[this.previouslyFocusedItem]) == null || o.blur());
    const n = this.focusedItem !== void 0 ? this.viewItems[this.focusedItem] : void 0;
    if (n) {
      let a = !0;
      pp(n.focus) || (a = !1), this.options.focusOnlyEnabledItems && pp(n.isEnabled) && !n.isEnabled() && (a = !1), n.action.id === Zi.ID && (a = !1), a ? (i || this.previouslyFocusedItem !== this.focusedItem) && (n.focus(e), this.previouslyFocusedItem = this.focusedItem) : (this.actionsList.focus({ preventScroll: t }), this.previouslyFocusedItem = void 0), a && ((r = n.showHover) == null || r.call(n));
    }
  }
  doTrigger(e) {
    if (typeof this.focusedItem > "u")
      return;
    const t = this.viewItems[this.focusedItem];
    if (t instanceof Js) {
      const i = t._context === null || t._context === void 0 ? e : t._context;
      this.run(t._action, i);
    }
  }
  async run(e, t) {
    await this._actionRunner.run(e, t);
  }
  dispose() {
    this._context = void 0, this.viewItems = Ri(this.viewItems), this.getContainer().remove(), super.dispose();
  }
}
const my = /\(&([^\s&])\)|(^|[^&])&([^\s&])/, j0 = /(&amp;)?(&amp;)([^\s&])/g;
var r_;
(function(s) {
  s[s.Right = 0] = "Right", s[s.Left = 1] = "Left";
})(r_ || (r_ = {}));
var py;
(function(s) {
  s[s.Above = 0] = "Above", s[s.Below = 1] = "Below";
})(py || (py = {}));
class Jh extends Kr {
  constructor(e, t, i, n) {
    e.classList.add("monaco-menu-container"), e.setAttribute("role", "presentation");
    const o = document.createElement("div");
    o.classList.add("monaco-menu"), o.setAttribute("role", "presentation"), super(o, {
      orientation: 1,
      actionViewItemProvider: (c) => this.doGetActionViewItem(c, i, r),
      context: i.context,
      actionRunner: i.actionRunner,
      ariaLabel: i.ariaLabel,
      ariaRole: "menu",
      focusOnlyEnabledItems: !0,
      triggerKeys: { keys: [3, ...He || wn ? [
        10
        /* KeyCode.Space */
      ] : []], keyDown: !0 }
    }), this.menuStyles = n, this.menuElement = o, this.actionsList.tabIndex = 0, this.initializeOrUpdateStyleSheet(e, n), this._register(an.addTarget(o)), this._register($(o, ee.KEY_DOWN, (c) => {
      new Lt(c).equals(
        2
        /* KeyCode.Tab */
      ) && c.preventDefault();
    })), i.enableMnemonics && this._register($(o, ee.KEY_DOWN, (c) => {
      const h = c.key.toLocaleLowerCase();
      if (this.mnemonics.has(h)) {
        Be.stop(c, !0);
        const d = this.mnemonics.get(h);
        if (d.length === 1 && (d[0] instanceof KI && d[0].container && this.focusItemByElement(d[0].container), d[0].onClick(c)), d.length > 1) {
          const u = d.shift();
          u && u.container && (this.focusItemByElement(u.container), d.push(u)), this.mnemonics.set(h, d);
        }
      }
    })), wn && this._register($(o, ee.KEY_DOWN, (c) => {
      const h = new Lt(c);
      h.equals(
        14
        /* KeyCode.Home */
      ) || h.equals(
        11
        /* KeyCode.PageUp */
      ) ? (this.focusedItem = this.viewItems.length - 1, this.focusNext(), Be.stop(c, !0)) : (h.equals(
        13
        /* KeyCode.End */
      ) || h.equals(
        12
        /* KeyCode.PageDown */
      )) && (this.focusedItem = 0, this.focusPrevious(), Be.stop(c, !0));
    })), this._register($(this.domNode, ee.MOUSE_OUT, (c) => {
      const h = c.relatedTarget;
      ui(h, this.domNode) || (this.focusedItem = void 0, this.updateFocus(), c.stopPropagation());
    })), this._register($(this.actionsList, ee.MOUSE_OVER, (c) => {
      let h = c.target;
      if (!(!h || !ui(h, this.actionsList) || h === this.actionsList)) {
        for (; h.parentElement !== this.actionsList && h.parentElement !== null; )
          h = h.parentElement;
        if (h.classList.contains("action-item")) {
          const d = this.focusedItem;
          this.setFocusedItem(h), d !== this.focusedItem && this.updateFocus();
        }
      }
    })), this._register(an.addTarget(this.actionsList)), this._register($(this.actionsList, bt.Tap, (c) => {
      let h = c.initialTarget;
      if (!(!h || !ui(h, this.actionsList) || h === this.actionsList)) {
        for (; h.parentElement !== this.actionsList && h.parentElement !== null; )
          h = h.parentElement;
        if (h.classList.contains("action-item")) {
          const d = this.focusedItem;
          this.setFocusedItem(h), d !== this.focusedItem && this.updateFocus();
        }
      }
    }));
    const r = {
      parent: this
    };
    this.mnemonics = /* @__PURE__ */ new Map(), this.scrollableElement = this._register(new fk(o, {
      alwaysConsumeMouseWheel: !0,
      horizontal: 2,
      vertical: 3,
      verticalScrollbarSize: 7,
      handleMouseWheel: !0,
      useShadows: !0
    }));
    const a = this.scrollableElement.getDomNode();
    a.style.position = "", this.styleScrollElement(a, n), this._register($(o, bt.Change, (c) => {
      Be.stop(c, !0);
      const h = this.scrollableElement.getScrollPosition().scrollTop;
      this.scrollableElement.setScrollPosition({ scrollTop: h - c.translationY });
    })), this._register($(a, ee.MOUSE_UP, (c) => {
      c.preventDefault();
    }));
    const l = ue(e);
    o.style.maxHeight = `${Math.max(10, l.innerHeight - e.getBoundingClientRect().top - 35)}px`, t = t.filter((c, h) => {
      var d;
      return (d = i.submenuIds) != null && d.has(c.id) ? (console.warn(`Found submenu cycle: ${c.id}`), !1) : !(c instanceof Zi && (h === t.length - 1 || h === 0 || t[h - 1] instanceof Zi));
    }), this.push(t, { icon: !0, label: !0, isMenu: !0 }), e.appendChild(this.scrollableElement.getDomNode()), this.scrollableElement.scanDomNode(), this.viewItems.filter((c) => !(c instanceof qI)).forEach((c, h, d) => {
      c.updatePositionInSet(h + 1, d.length);
    });
  }
  initializeOrUpdateStyleSheet(e, t) {
    this.styleSheet || (Qw(e) ? this.styleSheet = Os(e) : (Jh.globalStyleSheet || (Jh.globalStyleSheet = Os()), this.styleSheet = Jh.globalStyleSheet)), this.styleSheet.textContent = Cz(t, Qw(e));
  }
  styleScrollElement(e, t) {
    const i = t.foregroundColor ?? "", n = t.backgroundColor ?? "", o = t.borderColor ? `1px solid ${t.borderColor}` : "", r = "5px", a = t.shadowColor ? `0 2px 8px ${t.shadowColor}` : "";
    e.style.outline = o, e.style.borderRadius = r, e.style.color = i, e.style.backgroundColor = n, e.style.boxShadow = a;
  }
  getContainer() {
    return this.scrollableElement.getDomNode();
  }
  get onScroll() {
    return this.scrollableElement.onScroll;
  }
  focusItemByElement(e) {
    const t = this.focusedItem;
    this.setFocusedItem(e), t !== this.focusedItem && this.updateFocus();
  }
  setFocusedItem(e) {
    for (let t = 0; t < this.actionsList.children.length; t++) {
      const i = this.actionsList.children[t];
      if (e === i) {
        this.focusedItem = t;
        break;
      }
    }
  }
  updateFocus(e) {
    super.updateFocus(e, !0, !0), typeof this.focusedItem < "u" && this.scrollableElement.setScrollPosition({
      scrollTop: Math.round(this.menuElement.scrollTop)
    });
  }
  doGetActionViewItem(e, t, i) {
    if (e instanceof Zi)
      return new qI(t.context, e, { icon: !0 }, this.menuStyles);
    if (e instanceof lb) {
      const n = new KI(e, e.actions, i, { ...t, submenuIds: /* @__PURE__ */ new Set([...t.submenuIds || [], e.id]) }, this.menuStyles);
      if (t.enableMnemonics) {
        const o = n.getMnemonic();
        if (o && n.isEnabled()) {
          let r = [];
          this.mnemonics.has(o) && (r = this.mnemonics.get(o)), r.push(n), this.mnemonics.set(o, r);
        }
      }
      return n;
    } else {
      const n = { enableMnemonics: t.enableMnemonics, useEventAsContext: t.useEventAsContext };
      if (t.getKeyBinding) {
        const r = t.getKeyBinding(e);
        if (r) {
          const a = r.getLabel();
          a && (n.keybinding = a);
        }
      }
      const o = new TA(t.context, e, n, this.menuStyles);
      if (t.enableMnemonics) {
        const r = o.getMnemonic();
        if (r && o.isEnabled()) {
          let a = [];
          this.mnemonics.has(r) && (a = this.mnemonics.get(r)), a.push(o), this.mnemonics.set(r, a);
        }
      }
      return o;
    }
  }
}
class TA extends Js {
  constructor(e, t, i, n) {
    if (i.isMenu = !0, super(t, t, i), this.menuStyle = n, this.options = i, this.options.icon = i.icon !== void 0 ? i.icon : !1, this.options.label = i.label !== void 0 ? i.label : !0, this.cssClass = "", this.options.label && i.enableMnemonics) {
      const o = this.action.label;
      if (o) {
        const r = my.exec(o);
        r && (this.mnemonic = (r[1] ? r[1] : r[3]).toLocaleLowerCase());
      }
    }
    this.runOnceToEnableMouseUp = new sn(() => {
      this.element && (this._register($(this.element, ee.MOUSE_UP, (o) => {
        if (Be.stop(o, !0), As) {
          if (new to(ue(this.element), o).rightButton)
            return;
          this.onClick(o);
        } else
          setTimeout(() => {
            this.onClick(o);
          }, 0);
      })), this._register($(this.element, ee.CONTEXT_MENU, (o) => {
        Be.stop(o, !0);
      })));
    }, 100), this._register(this.runOnceToEnableMouseUp);
  }
  render(e) {
    super.render(e), this.element && (this.container = e, this.item = ae(this.element, pe("a.action-menu-item")), this._action.id === Zi.ID ? this.item.setAttribute("role", "presentation") : (this.item.setAttribute("role", "menuitem"), this.mnemonic && this.item.setAttribute("aria-keyshortcuts", `${this.mnemonic}`)), this.check = ae(this.item, pe("span.menu-item-check" + Ke.asCSSSelector(re.menuSelection))), this.check.setAttribute("role", "none"), this.label = ae(this.item, pe("span.action-label")), this.options.label && this.options.keybinding && (ae(this.item, pe("span.keybinding")).textContent = this.options.keybinding), this.runOnceToEnableMouseUp.schedule(), this.updateClass(), this.updateLabel(), this.updateTooltip(), this.updateEnabled(), this.updateChecked(), this.applyStyle());
  }
  blur() {
    super.blur(), this.applyStyle();
  }
  focus() {
    var e;
    super.focus(), (e = this.item) == null || e.focus(), this.applyStyle();
  }
  updatePositionInSet(e, t) {
    this.item && (this.item.setAttribute("aria-posinset", `${e}`), this.item.setAttribute("aria-setsize", `${t}`));
  }
  updateLabel() {
    var e;
    if (this.label && this.options.label) {
      oo(this.label);
      let t = nA(this.action.label);
      if (t) {
        const i = bz(t);
        this.options.enableMnemonics || (t = i), this.label.setAttribute("aria-label", i.replace(/&&/g, "&"));
        const n = my.exec(t);
        if (n) {
          t = Fu(t), j0.lastIndex = 0;
          let o = j0.exec(t);
          for (; o && o[1]; )
            o = j0.exec(t);
          const r = (a) => a.replace(/&amp;&amp;/g, "&amp;");
          o ? this.label.append(ib(r(t.substr(0, o.index)), " "), pe("u", { "aria-hidden": "true" }, o[3]), ZO(r(t.substr(o.index + o[0].length)), " ")) : this.label.innerText = r(t).trim(), (e = this.item) == null || e.setAttribute("aria-keyshortcuts", (n[1] ? n[1] : n[3]).toLocaleLowerCase());
        } else
          this.label.innerText = t.replace(/&&/g, "&").trim();
      }
    }
  }
  updateTooltip() {
  }
  updateClass() {
    this.cssClass && this.item && this.item.classList.remove(...this.cssClass.split(" ")), this.options.icon && this.label ? (this.cssClass = this.action.class || "", this.label.classList.add("icon"), this.cssClass && this.label.classList.add(...this.cssClass.split(" ")), this.updateEnabled()) : this.label && this.label.classList.remove("icon");
  }
  updateEnabled() {
    this.action.enabled ? (this.element && (this.element.classList.remove("disabled"), this.element.removeAttribute("aria-disabled")), this.item && (this.item.classList.remove("disabled"), this.item.removeAttribute("aria-disabled"), this.item.tabIndex = 0)) : (this.element && (this.element.classList.add("disabled"), this.element.setAttribute("aria-disabled", "true")), this.item && (this.item.classList.add("disabled"), this.item.setAttribute("aria-disabled", "true")));
  }
  updateChecked() {
    if (!this.item)
      return;
    const e = this.action.checked;
    this.item.classList.toggle("checked", !!e), e !== void 0 ? (this.item.setAttribute("role", "menuitemcheckbox"), this.item.setAttribute("aria-checked", e ? "true" : "false")) : (this.item.setAttribute("role", "menuitem"), this.item.setAttribute("aria-checked", ""));
  }
  getMnemonic() {
    return this.mnemonic;
  }
  applyStyle() {
    const e = this.element && this.element.classList.contains("focused"), t = e && this.menuStyle.selectionForegroundColor ? this.menuStyle.selectionForegroundColor : this.menuStyle.foregroundColor, i = e && this.menuStyle.selectionBackgroundColor ? this.menuStyle.selectionBackgroundColor : void 0, n = e && this.menuStyle.selectionBorderColor ? `1px solid ${this.menuStyle.selectionBorderColor}` : "", o = e && this.menuStyle.selectionBorderColor ? "-1px" : "";
    this.item && (this.item.style.color = t ?? "", this.item.style.backgroundColor = i ?? "", this.item.style.outline = n, this.item.style.outlineOffset = o), this.check && (this.check.style.color = t ?? "");
  }
}
class KI extends TA {
  constructor(e, t, i, n, o) {
    super(e, e, n, o), this.submenuActions = t, this.parentData = i, this.submenuOptions = n, this.mysubmenu = null, this.submenuDisposables = this._register(new he()), this.mouseOver = !1, this.expandDirection = n && n.expandDirection !== void 0 ? n.expandDirection : { horizontal: r_.Right, vertical: py.Below }, this.showScheduler = new sn(() => {
      this.mouseOver && (this.cleanupExistingSubmenu(!1), this.createSubmenu(!1));
    }, 250), this.hideScheduler = new sn(() => {
      this.element && !ui(Gi(), this.element) && this.parentData.submenu === this.mysubmenu && (this.parentData.parent.focus(!1), this.cleanupExistingSubmenu(!0));
    }, 750);
  }
  render(e) {
    super.render(e), this.element && (this.item && (this.item.classList.add("monaco-submenu-item"), this.item.tabIndex = 0, this.item.setAttribute("aria-haspopup", "true"), this.updateAriaExpanded("false"), this.submenuIndicator = ae(this.item, pe("span.submenu-indicator" + Ke.asCSSSelector(re.menuSubmenu))), this.submenuIndicator.setAttribute("aria-hidden", "true")), this._register($(this.element, ee.KEY_UP, (t) => {
      const i = new Lt(t);
      (i.equals(
        17
        /* KeyCode.RightArrow */
      ) || i.equals(
        3
        /* KeyCode.Enter */
      )) && (Be.stop(t, !0), this.createSubmenu(!0));
    })), this._register($(this.element, ee.KEY_DOWN, (t) => {
      const i = new Lt(t);
      Gi() === this.item && (i.equals(
        17
        /* KeyCode.RightArrow */
      ) || i.equals(
        3
        /* KeyCode.Enter */
      )) && Be.stop(t, !0);
    })), this._register($(this.element, ee.MOUSE_OVER, (t) => {
      this.mouseOver || (this.mouseOver = !0, this.showScheduler.schedule());
    })), this._register($(this.element, ee.MOUSE_LEAVE, (t) => {
      this.mouseOver = !1;
    })), this._register($(this.element, ee.FOCUS_OUT, (t) => {
      this.element && !ui(Gi(), this.element) && this.hideScheduler.schedule();
    })), this._register(this.parentData.parent.onScroll(() => {
      this.parentData.submenu === this.mysubmenu && (this.parentData.parent.focus(!1), this.cleanupExistingSubmenu(!0));
    })));
  }
  updateEnabled() {
  }
  onClick(e) {
    Be.stop(e, !0), this.cleanupExistingSubmenu(!1), this.createSubmenu(!0);
  }
  cleanupExistingSubmenu(e) {
    if (this.parentData.submenu && (e || this.parentData.submenu !== this.mysubmenu)) {
      try {
        this.parentData.submenu.dispose();
      } catch {
      }
      this.parentData.submenu = void 0, this.updateAriaExpanded("false"), this.submenuContainer && (this.submenuDisposables.clear(), this.submenuContainer = void 0);
    }
  }
  calculateSubmenuMenuLayout(e, t, i, n) {
    const o = { top: 0, left: 0 };
    return o.left = bh(e.width, t.width, { position: n.horizontal === r_.Right ? 0 : 1, offset: i.left, size: i.width }), o.left >= i.left && o.left < i.left + i.width && (i.left + 10 + t.width <= e.width && (o.left = i.left + 10), i.top += 10, i.height = 0), o.top = bh(e.height, t.height, { position: 0, offset: i.top, size: 0 }), o.top + t.height === i.top && o.top + i.height + t.height <= e.height && (o.top += i.height), o;
  }
  createSubmenu(e = !0) {
    if (this.element)
      if (this.parentData.submenu)
        this.parentData.submenu.focus(!1);
      else {
        this.updateAriaExpanded("true"), this.submenuContainer = ae(this.element, pe("div.monaco-submenu")), this.submenuContainer.classList.add("menubar-menu-items-holder", "context-view");
        const t = ue(this.parentData.parent.domNode).getComputedStyle(this.parentData.parent.domNode), i = parseFloat(t.paddingTop || "0") || 0;
        this.submenuContainer.style.zIndex = "1", this.submenuContainer.style.position = "fixed", this.submenuContainer.style.top = "0", this.submenuContainer.style.left = "0", this.parentData.submenu = new Jh(this.submenuContainer, this.submenuActions.length ? this.submenuActions : [new tv()], this.submenuOptions, this.menuStyle);
        const n = this.element.getBoundingClientRect(), o = {
          top: n.top - i,
          left: n.left,
          height: n.height + 2 * i,
          width: n.width
        }, r = this.submenuContainer.getBoundingClientRect(), a = ue(this.element), { top: l, left: c } = this.calculateSubmenuMenuLayout(new kr(a.innerWidth, a.innerHeight), kr.lift(r), o, this.expandDirection);
        this.submenuContainer.style.left = `${c - r.left}px`, this.submenuContainer.style.top = `${l - r.top}px`, this.submenuDisposables.add($(this.submenuContainer, ee.KEY_UP, (h) => {
          new Lt(h).equals(
            15
            /* KeyCode.LeftArrow */
          ) && (Be.stop(h, !0), this.parentData.parent.focus(), this.cleanupExistingSubmenu(!0));
        })), this.submenuDisposables.add($(this.submenuContainer, ee.KEY_DOWN, (h) => {
          new Lt(h).equals(
            15
            /* KeyCode.LeftArrow */
          ) && Be.stop(h, !0);
        })), this.submenuDisposables.add(this.parentData.submenu.onDidCancel(() => {
          this.parentData.parent.focus(), this.cleanupExistingSubmenu(!0);
        })), this.parentData.submenu.focus(e), this.mysubmenu = this.parentData.submenu;
      }
  }
  updateAriaExpanded(e) {
    var t;
    this.item && ((t = this.item) == null || t.setAttribute("aria-expanded", e));
  }
  applyStyle() {
    super.applyStyle();
    const t = this.element && this.element.classList.contains("focused") && this.menuStyle.selectionForegroundColor ? this.menuStyle.selectionForegroundColor : this.menuStyle.foregroundColor;
    this.submenuIndicator && (this.submenuIndicator.style.color = t ?? "");
  }
  dispose() {
    super.dispose(), this.hideScheduler.dispose(), this.mysubmenu && (this.mysubmenu.dispose(), this.mysubmenu = null), this.submenuContainer && (this.submenuContainer = void 0);
  }
}
class qI extends Ak {
  constructor(e, t, i, n) {
    super(e, t, i), this.menuStyles = n;
  }
  render(e) {
    super.render(e), this.label && (this.label.style.borderBottomColor = this.menuStyles.separatorColor ? `${this.menuStyles.separatorColor}` : "");
  }
}
function bz(s) {
  const e = my, t = e.exec(s);
  if (!t)
    return s;
  const i = !t[1];
  return s.replace(e, i ? "$2$3" : "").trim();
}
function jI(s) {
  const e = q2()[s.id];
  return `.codicon-${s.id}:before { content: '\\${e.toString(16)}'; }`;
}
function Cz(s, e) {
  let t = (
    /* css */
    `
.monaco-menu {
	font-size: 13px;
	border-radius: 5px;
	min-width: 160px;
}

${jI(re.menuSelection)}
${jI(re.menuSubmenu)}

.monaco-menu .monaco-action-bar {
	text-align: right;
	overflow: hidden;
	white-space: nowrap;
}

.monaco-menu .monaco-action-bar .actions-container {
	display: flex;
	margin: 0 auto;
	padding: 0;
	width: 100%;
	justify-content: flex-end;
}

.monaco-menu .monaco-action-bar.vertical .actions-container {
	display: inline-block;
}

.monaco-menu .monaco-action-bar.reverse .actions-container {
	flex-direction: row-reverse;
}

.monaco-menu .monaco-action-bar .action-item {
	cursor: pointer;
	display: inline-block;
	transition: transform 50ms ease;
	position: relative;  /* DO NOT REMOVE - this is the key to preventing the ghosting icon bug in Chrome 42 */
}

.monaco-menu .monaco-action-bar .action-item.disabled {
	cursor: default;
}

.monaco-menu .monaco-action-bar .action-item .icon,
.monaco-menu .monaco-action-bar .action-item .codicon {
	display: inline-block;
}

.monaco-menu .monaco-action-bar .action-item .codicon {
	display: flex;
	align-items: center;
}

.monaco-menu .monaco-action-bar .action-label {
	font-size: 11px;
	margin-right: 4px;
}

.monaco-menu .monaco-action-bar .action-item.disabled .action-label,
.monaco-menu .monaco-action-bar .action-item.disabled .action-label:hover {
	color: var(--vscode-disabledForeground);
}

/* Vertical actions */

.monaco-menu .monaco-action-bar.vertical {
	text-align: left;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	display: block;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	display: block;
	border-bottom: 1px solid var(--vscode-menu-separatorBackground);
	padding-top: 1px;
	padding: 30px;
}

.monaco-menu .secondary-actions .monaco-action-bar .action-label {
	margin-left: 6px;
}

/* Action Items */
.monaco-menu .monaco-action-bar .action-item.select-container {
	overflow: hidden; /* somehow the dropdown overflows its container, we prevent it here to not push */
	flex: 1;
	max-width: 170px;
	min-width: 60px;
	display: flex;
	align-items: center;
	justify-content: center;
	margin-right: 10px;
}

.monaco-menu .monaco-action-bar.vertical {
	margin-left: 0;
	overflow: visible;
}

.monaco-menu .monaco-action-bar.vertical .actions-container {
	display: block;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	padding: 0;
	transform: none;
	display: flex;
}

.monaco-menu .monaco-action-bar.vertical .action-item.active {
	transform: none;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item {
	flex: 1 1 auto;
	display: flex;
	height: 2em;
	align-items: center;
	position: relative;
	margin: 0 4px;
	border-radius: 4px;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item:hover .keybinding,
.monaco-menu .monaco-action-bar.vertical .action-menu-item:focus .keybinding {
	opacity: unset;
}

.monaco-menu .monaco-action-bar.vertical .action-label {
	flex: 1 1 auto;
	text-decoration: none;
	padding: 0 1em;
	background: none;
	font-size: 12px;
	line-height: 1;
}

.monaco-menu .monaco-action-bar.vertical .keybinding,
.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	display: inline-block;
	flex: 2 1 auto;
	padding: 0 1em;
	text-align: right;
	font-size: 12px;
	line-height: 1;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	height: 100%;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator.codicon {
	font-size: 16px !important;
	display: flex;
	align-items: center;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator.codicon::before {
	margin-left: auto;
	margin-right: -20px;
}

.monaco-menu .monaco-action-bar.vertical .action-item.disabled .keybinding,
.monaco-menu .monaco-action-bar.vertical .action-item.disabled .submenu-indicator {
	opacity: 0.4;
}

.monaco-menu .monaco-action-bar.vertical .action-label:not(.separator) {
	display: inline-block;
	box-sizing: border-box;
	margin: 0;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	position: static;
	overflow: visible;
}

.monaco-menu .monaco-action-bar.vertical .action-item .monaco-submenu {
	position: absolute;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	width: 100%;
	height: 0px !important;
	opacity: 1;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator.text {
	padding: 0.7em 1em 0.1em 1em;
	font-weight: bold;
	opacity: 1;
}

.monaco-menu .monaco-action-bar.vertical .action-label:hover {
	color: inherit;
}

.monaco-menu .monaco-action-bar.vertical .menu-item-check {
	position: absolute;
	visibility: hidden;
	width: 1em;
	height: 100%;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item.checked .menu-item-check {
	visibility: visible;
	display: flex;
	align-items: center;
	justify-content: center;
}

/* Context Menu */

.context-view.monaco-menu-container {
	outline: 0;
	border: none;
	animation: fadeIn 0.083s linear;
	-webkit-app-region: no-drag;
}

.context-view.monaco-menu-container :focus,
.context-view.monaco-menu-container .monaco-action-bar.vertical:focus,
.context-view.monaco-menu-container .monaco-action-bar.vertical :focus {
	outline: 0;
}

.hc-black .context-view.monaco-menu-container,
.hc-light .context-view.monaco-menu-container,
:host-context(.hc-black) .context-view.monaco-menu-container,
:host-context(.hc-light) .context-view.monaco-menu-container {
	box-shadow: none;
}

.hc-black .monaco-menu .monaco-action-bar.vertical .action-item.focused,
.hc-light .monaco-menu .monaco-action-bar.vertical .action-item.focused,
:host-context(.hc-black) .monaco-menu .monaco-action-bar.vertical .action-item.focused,
:host-context(.hc-light) .monaco-menu .monaco-action-bar.vertical .action-item.focused {
	background: none;
}

/* Vertical Action Bar Styles */

.monaco-menu .monaco-action-bar.vertical {
	padding: 4px 0;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item {
	height: 2em;
}

.monaco-menu .monaco-action-bar.vertical .action-label:not(.separator),
.monaco-menu .monaco-action-bar.vertical .keybinding {
	font-size: inherit;
	padding: 0 2em;
	max-height: 100%;
}

.monaco-menu .monaco-action-bar.vertical .menu-item-check {
	font-size: inherit;
	width: 2em;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	font-size: inherit;
	margin: 5px 0 !important;
	padding: 0;
	border-radius: 0;
}

.linux .monaco-menu .monaco-action-bar.vertical .action-label.separator,
:host-context(.linux) .monaco-menu .monaco-action-bar.vertical .action-label.separator {
	margin-left: 0;
	margin-right: 0;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	font-size: 60%;
	padding: 0 1.8em;
}

.linux .monaco-menu .monaco-action-bar.vertical .submenu-indicator,
:host-context(.linux) .monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	height: 100%;
	mask-size: 10px 10px;
	-webkit-mask-size: 10px 10px;
}

.monaco-menu .action-item {
	cursor: default;
}`
  );
  if (e) {
    t += `
			/* Arrows */
			.monaco-scrollable-element > .scrollbar > .scra {
				cursor: pointer;
				font-size: 11px !important;
			}

			.monaco-scrollable-element > .visible {
				opacity: 1;

				/* Background rule added for IE9 - to allow clicks on dom node */
				background:rgba(0,0,0,0);

				transition: opacity 100ms linear;
			}
			.monaco-scrollable-element > .invisible {
				opacity: 0;
				pointer-events: none;
			}
			.monaco-scrollable-element > .invisible.fade {
				transition: opacity 800ms linear;
			}

			/* Scrollable Content Inset Shadow */
			.monaco-scrollable-element > .shadow {
				position: absolute;
				display: none;
			}
			.monaco-scrollable-element > .shadow.top {
				display: block;
				top: 0;
				left: 3px;
				height: 3px;
				width: 100%;
			}
			.monaco-scrollable-element > .shadow.left {
				display: block;
				top: 3px;
				left: 0;
				height: 100%;
				width: 3px;
			}
			.monaco-scrollable-element > .shadow.top-left-corner {
				display: block;
				top: 0;
				left: 0;
				height: 3px;
				width: 3px;
			}
		`;
    const i = s.scrollbarShadow;
    i && (t += `
				.monaco-scrollable-element > .shadow.top {
					box-shadow: ${i} 0 6px 6px -6px inset;
				}

				.monaco-scrollable-element > .shadow.left {
					box-shadow: ${i} 6px 0 6px -6px inset;
				}

				.monaco-scrollable-element > .shadow.top.left {
					box-shadow: ${i} 6px 6px 6px -6px inset;
				}
			`);
    const n = s.scrollbarSliderBackground;
    n && (t += `
				.monaco-scrollable-element > .scrollbar > .slider {
					background: ${n};
				}
			`);
    const o = s.scrollbarSliderHoverBackground;
    o && (t += `
				.monaco-scrollable-element > .scrollbar > .slider:hover {
					background: ${o};
				}
			`);
    const r = s.scrollbarSliderActiveBackground;
    r && (t += `
				.monaco-scrollable-element > .scrollbar > .slider.active {
					background: ${r};
				}
			`);
  }
  return t;
}
class wz {
  constructor(e, t, i, n) {
    this.contextViewService = e, this.telemetryService = t, this.notificationService = i, this.keybindingService = n, this.focusToReturn = null, this.lastContainer = null, this.block = null, this.blockDisposable = null, this.options = { blockMouse: !0 };
  }
  configure(e) {
    this.options = e;
  }
  showContextMenu(e) {
    const t = e.getActions();
    if (!t.length)
      return;
    this.focusToReturn = Gi();
    let i;
    const n = yi(e.domForShadowRoot) ? e.domForShadowRoot : void 0;
    this.contextViewService.showContextView({
      getAnchor: () => e.getAnchor(),
      canRelayout: !1,
      anchorAlignment: e.anchorAlignment,
      anchorAxisAlignment: e.anchorAxisAlignment,
      render: (o) => {
        var h;
        this.lastContainer = o;
        const r = e.getMenuClassName ? e.getMenuClassName() : "";
        r && (o.className += " " + r), this.options.blockMouse && (this.block = o.appendChild(pe(".context-view-block")), this.block.style.position = "fixed", this.block.style.cursor = "initial", this.block.style.left = "0", this.block.style.top = "0", this.block.style.width = "100%", this.block.style.height = "100%", this.block.style.zIndex = "-1", (h = this.blockDisposable) == null || h.dispose(), this.blockDisposable = $(this.block, ee.MOUSE_DOWN, (d) => d.stopPropagation()));
        const a = new he(), l = e.actionRunner || new _c();
        l.onWillRun((d) => this.onActionRun(d, !e.skipTelemetry), this, a), l.onDidRun(this.onDidActionRun, this, a), i = new Jh(o, t, {
          actionViewItemProvider: e.getActionViewItem,
          context: e.getActionsContext ? e.getActionsContext() : null,
          actionRunner: l,
          getKeyBinding: e.getKeyBinding ? e.getKeyBinding : (d) => this.keybindingService.lookupKeybinding(d.id)
        }, gz), i.onDidCancel(() => this.contextViewService.hideContextView(!0), null, a), i.onDidBlur(() => this.contextViewService.hideContextView(!0), null, a);
        const c = ue(o);
        return a.add($(c, ee.BLUR, () => this.contextViewService.hideContextView(!0))), a.add($(c, ee.MOUSE_DOWN, (d) => {
          if (d.defaultPrevented)
            return;
          const u = new to(c, d);
          let f = u.target;
          if (!u.rightButton) {
            for (; f; ) {
              if (f === o)
                return;
              f = f.parentElement;
            }
            this.contextViewService.hideContextView(!0);
          }
        })), Wo(a, i);
      },
      focus: () => {
        i == null || i.focus(!!e.autoSelectFirstItem);
      },
      onHide: (o) => {
        var r, a, l;
        (r = e.onHide) == null || r.call(e, !!o), this.block && (this.block.remove(), this.block = null), (a = this.blockDisposable) == null || a.dispose(), this.blockDisposable = null, this.lastContainer && (Gi() === this.lastContainer || ui(Gi(), this.lastContainer)) && ((l = this.focusToReturn) == null || l.focus()), this.lastContainer = null;
      }
    }, n, !!n);
  }
  onActionRun(e, t) {
    t && this.telemetryService.publicLog2("workbenchActionExecuted", { id: e.action.id, from: "contextMenu" }), this.contextViewService.hideContextView(!1);
  }
  onDidActionRun(e) {
    e.error && !wg(e.error) && this.notificationService.error(e.error);
  }
}
var vz = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, th = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let _y = class extends q {
  get contextMenuHandler() {
    return this._contextMenuHandler || (this._contextMenuHandler = new wz(this.contextViewService, this.telemetryService, this.notificationService, this.keybindingService)), this._contextMenuHandler;
  }
  constructor(e, t, i, n, o, r) {
    super(), this.telemetryService = e, this.notificationService = t, this.contextViewService = i, this.keybindingService = n, this.menuService = o, this.contextKeyService = r, this._contextMenuHandler = void 0, this._onDidShowContextMenu = this._store.add(new O()), this.onDidShowContextMenu = this._onDidShowContextMenu.event, this._onDidHideContextMenu = this._store.add(new O());
  }
  configure(e) {
    this.contextMenuHandler.configure(e);
  }
  // ContextMenu
  showContextMenu(e) {
    e = by.transform(e, this.menuService, this.contextKeyService), this.contextMenuHandler.showContextMenu({
      ...e,
      onHide: (t) => {
        var i;
        (i = e.onHide) == null || i.call(e, t), this._onDidHideContextMenu.fire();
      }
    }), ka.getInstance().resetKeyStatus(), this._onDidShowContextMenu.fire();
  }
};
_y = vz([
  th(0, Ac),
  th(1, fo),
  th(2, Pg),
  th(3, Ai),
  th(4, Rc),
  th(5, nt)
], _y);
var by;
(function(s) {
  function e(i) {
    return i && i.menuId instanceof Ti;
  }
  function t(i, n, o) {
    if (!e(i))
      return i;
    const { menuId: r, menuActionOptions: a, contextKeyService: l } = i;
    return {
      ...i,
      getActions: () => {
        const c = [];
        if (r) {
          const h = n.getMenuActions(r, l ?? o, a);
          mz(h, c);
        }
        return i.getActions ? Zi.join(i.getActions(), c) : c;
      }
    };
  }
  s.transform = t;
})(by || (by = {}));
var a_;
(function(s) {
  s[s.API = 0] = "API", s[s.USER = 1] = "USER";
})(a_ || (a_ = {}));
var Pk = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, l_ = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let Cy = class {
  constructor(e) {
    this._commandService = e;
  }
  async open(e, t) {
    if (!OL(e, Ne.command))
      return !1;
    if (!(t != null && t.allowCommands) || (typeof e == "string" && (e = Te.parse(e)), Array.isArray(t.allowCommands) && !t.allowCommands.includes(e.path)))
      return !0;
    let i = [];
    try {
      i = $v(decodeURIComponent(e.query));
    } catch {
      try {
        i = $v(e.query);
      } catch {
      }
    }
    return Array.isArray(i) || (i = [i]), await this._commandService.executeCommand(e.path, ...i), !0;
  }
};
Cy = Pk([
  l_(0, ss)
], Cy);
let wy = class {
  constructor(e) {
    this._editorService = e;
  }
  async open(e, t) {
    typeof e == "string" && (e = Te.parse(e));
    const { selection: i, uri: n } = GB(e);
    return e = n, e.scheme === Ne.file && (e = xW(e)), await this._editorService.openCodeEditor({
      resource: e,
      options: {
        selection: i,
        source: t != null && t.fromUserGesture ? a_.USER : a_.API,
        ...t == null ? void 0 : t.editorOptions
      }
    }, this._editorService.getFocusedCodeEditor(), t == null ? void 0 : t.openToSide), !0;
  }
};
wy = Pk([
  l_(0, ri)
], wy);
let vy = class {
  constructor(e, t) {
    this._openers = new An(), this._validators = new An(), this._resolvers = new An(), this._resolvedUriTargets = new ts((i) => i.with({ path: null, fragment: null, query: null }).toString()), this._externalOpeners = new An(), this._defaultExternalOpener = {
      openExternal: async (i) => (RD(i, Ne.http, Ne.https) ? DM(i) : ut.location.href = i, !0)
    }, this._openers.push({
      open: async (i, n) => n != null && n.openExternal || RD(i, Ne.mailto, Ne.http, Ne.https, Ne.vsls) ? (await this._doOpenExternal(i, n), !0) : !1
    }), this._openers.push(new Cy(t)), this._openers.push(new wy(e));
  }
  registerOpener(e) {
    return { dispose: this._openers.unshift(e) };
  }
  async open(e, t) {
    const i = typeof e == "string" ? Te.parse(e) : e, n = this._resolvedUriTargets.get(i) ?? e;
    for (const o of this._validators)
      if (!await o.shouldOpen(n, t))
        return !1;
    for (const o of this._openers)
      if (await o.open(e, t))
        return !0;
    return !1;
  }
  async resolveExternalUri(e, t) {
    for (const i of this._resolvers)
      try {
        const n = await i.resolveExternalUri(e, t);
        if (n)
          return this._resolvedUriTargets.has(n.resolved) || this._resolvedUriTargets.set(n.resolved, e), n;
      } catch {
      }
    throw new Error("Could not resolve external URI: " + e.toString());
  }
  async _doOpenExternal(e, t) {
    const i = typeof e == "string" ? Te.parse(e) : e;
    let n;
    try {
      n = (await this.resolveExternalUri(i, t)).resolved;
    } catch {
      n = i;
    }
    let o;
    if (typeof e == "string" && i.toString() === n.toString() ? o = e : o = encodeURI(n.toString(!0)), t != null && t.allowContributedOpeners) {
      const r = typeof (t == null ? void 0 : t.allowContributedOpeners) == "string" ? t == null ? void 0 : t.allowContributedOpeners : void 0;
      for (const a of this._externalOpeners)
        if (await a.openExternal(o, {
          sourceUri: i,
          preferredOpenerId: r
        }, Rs.None))
          return !0;
    }
    return this._defaultExternalOpener.openExternal(o, { sourceUri: i }, Rs.None);
  }
  dispose() {
    this._validators.clear();
  }
};
vy = Pk([
  l_(0, ri),
  l_(1, ss)
], vy);
const Hg = Ve("editorWorkerService");
var us;
(function(s) {
  s[s.Hint = 1] = "Hint", s[s.Info = 2] = "Info", s[s.Warning = 4] = "Warning", s[s.Error = 8] = "Error";
})(us || (us = {}));
(function(s) {
  function e(r, a) {
    return a - r;
  }
  s.compare = e;
  const t = /* @__PURE__ */ Object.create(null);
  t[s.Error] = p("sev.error", "Error"), t[s.Warning] = p("sev.warning", "Warning"), t[s.Info] = p("sev.info", "Info");
  function i(r) {
    return t[r] || "";
  }
  s.toString = i;
  function n(r) {
    switch (r) {
      case Jt.Error:
        return s.Error;
      case Jt.Warning:
        return s.Warning;
      case Jt.Info:
        return s.Info;
      case Jt.Ignore:
        return s.Hint;
    }
  }
  s.fromSeverity = n;
  function o(r) {
    switch (r) {
      case s.Error:
        return Jt.Error;
      case s.Warning:
        return Jt.Warning;
      case s.Info:
        return Jt.Info;
      case s.Hint:
        return Jt.Ignore;
    }
  }
  s.toSeverity = o;
})(us || (us = {}));
var GI;
(function(s) {
  function t(n) {
    return i(n, !0);
  }
  s.makeKey = t;
  function i(n, o) {
    const r = [""];
    return n.source ? r.push(n.source.replace("¦", "\\¦")) : r.push(""), n.code ? typeof n.code == "string" ? r.push(n.code.replace("¦", "\\¦")) : r.push(n.code.value.replace("¦", "\\¦")) : r.push(""), n.severity !== void 0 && n.severity !== null ? r.push(us.toString(n.severity)) : r.push(""), n.message && o ? r.push(n.message.replace("¦", "\\¦")) : r.push(""), n.startLineNumber !== void 0 && n.startLineNumber !== null ? r.push(n.startLineNumber.toString()) : r.push(""), n.startColumn !== void 0 && n.startColumn !== null ? r.push(n.startColumn.toString()) : r.push(""), n.endLineNumber !== void 0 && n.endLineNumber !== null ? r.push(n.endLineNumber.toString()) : r.push(""), n.endColumn !== void 0 && n.endColumn !== null ? r.push(n.endColumn.toString()) : r.push(""), r.push(""), r.join("¦");
  }
  s.makeKeyOptionalMessage = i;
})(GI || (GI = {}));
const Bc = Ve("markerService"), MA = N("editor.lineHighlightBackground", null, p("lineHighlight", "Background color for the highlight of line at the cursor position.")), ZI = N("editor.lineHighlightBorder", { dark: "#282828", light: "#eeeeee", hcDark: "#f38518", hcLight: Xe }, p("lineHighlightBorderBox", "Background color for the border around the line at the cursor position."));
N("editor.rangeHighlightBackground", { dark: "#ffffff0b", light: "#fdff0033", hcDark: null, hcLight: null }, p("rangeHighlight", "Background color of highlighted ranges, like by quick open and find features. The color must not be opaque so as not to hide underlying decorations."), !0);
N("editor.rangeHighlightBorder", { dark: null, light: null, hcDark: jt, hcLight: jt }, p("rangeHighlightBorder", "Background color of the border around highlighted ranges."));
N("editor.symbolHighlightBackground", { dark: xa, light: xa, hcDark: null, hcLight: null }, p("symbolHighlight", "Background color of highlighted symbol, like for go to definition or go next/previous symbol. The color must not be opaque so as not to hide underlying decorations."), !0);
N("editor.symbolHighlightBorder", { dark: null, light: null, hcDark: jt, hcLight: jt }, p("symbolHighlightBorder", "Background color of the border around highlighted symbols."));
const Wb = N("editorCursor.foreground", { dark: "#AEAFAD", light: Z.black, hcDark: Z.white, hcLight: "#0F4A85" }, p("caret", "Color of the editor cursor.")), Ok = N("editorCursor.background", null, p("editorCursorBackground", "The background color of the editor cursor. Allows customizing the color of a character overlapped by a block cursor.")), RA = N("editorMultiCursor.primary.foreground", Wb, p("editorMultiCursorPrimaryForeground", "Color of the primary editor cursor when multiple cursors are present.")), yz = N("editorMultiCursor.primary.background", Ok, p("editorMultiCursorPrimaryBackground", "The background color of the primary editor cursor when multiple cursors are present. Allows customizing the color of a character overlapped by a block cursor.")), AA = N("editorMultiCursor.secondary.foreground", Wb, p("editorMultiCursorSecondaryForeground", "Color of secondary editor cursors when multiple cursors are present.")), Sz = N("editorMultiCursor.secondary.background", Ok, p("editorMultiCursorSecondaryBackground", "The background color of secondary editor cursors when multiple cursors are present. Allows customizing the color of a character overlapped by a block cursor.")), Fk = N("editorWhitespace.foreground", { dark: "#e3e4e229", light: "#33333333", hcDark: "#e3e4e229", hcLight: "#CCCCCC" }, p("editorWhitespaces", "Color of whitespace characters in the editor.")), Lz = N("editorLineNumber.foreground", { dark: "#858585", light: "#237893", hcDark: Z.white, hcLight: "#292929" }, p("editorLineNumbers", "Color of editor line numbers.")), kz = N("editorIndentGuide.background", Fk, p("editorIndentGuides", "Color of the editor indentation guides."), !1, p("deprecatedEditorIndentGuides", "'editorIndentGuide.background' is deprecated. Use 'editorIndentGuide.background1' instead.")), xz = N("editorIndentGuide.activeBackground", Fk, p("editorActiveIndentGuide", "Color of the active editor indentation guides."), !1, p("deprecatedEditorActiveIndentGuide", "'editorIndentGuide.activeBackground' is deprecated. Use 'editorIndentGuide.activeBackground1' instead.")), zg = N("editorIndentGuide.background1", kz, p("editorIndentGuides1", "Color of the editor indentation guides (1).")), Dz = N("editorIndentGuide.background2", "#00000000", p("editorIndentGuides2", "Color of the editor indentation guides (2).")), Ez = N("editorIndentGuide.background3", "#00000000", p("editorIndentGuides3", "Color of the editor indentation guides (3).")), Iz = N("editorIndentGuide.background4", "#00000000", p("editorIndentGuides4", "Color of the editor indentation guides (4).")), Nz = N("editorIndentGuide.background5", "#00000000", p("editorIndentGuides5", "Color of the editor indentation guides (5).")), Tz = N("editorIndentGuide.background6", "#00000000", p("editorIndentGuides6", "Color of the editor indentation guides (6).")), Ug = N("editorIndentGuide.activeBackground1", xz, p("editorActiveIndentGuide1", "Color of the active editor indentation guides (1).")), Mz = N("editorIndentGuide.activeBackground2", "#00000000", p("editorActiveIndentGuide2", "Color of the active editor indentation guides (2).")), Rz = N("editorIndentGuide.activeBackground3", "#00000000", p("editorActiveIndentGuide3", "Color of the active editor indentation guides (3).")), Az = N("editorIndentGuide.activeBackground4", "#00000000", p("editorActiveIndentGuide4", "Color of the active editor indentation guides (4).")), Pz = N("editorIndentGuide.activeBackground5", "#00000000", p("editorActiveIndentGuide5", "Color of the active editor indentation guides (5).")), Oz = N("editorIndentGuide.activeBackground6", "#00000000", p("editorActiveIndentGuide6", "Color of the active editor indentation guides (6).")), Fz = N("editorActiveLineNumber.foreground", { dark: "#c6c6c6", light: "#0B216F", hcDark: jt, hcLight: jt }, p("editorActiveLineNumber", "Color of editor active line number"), !1, p("deprecatedEditorActiveLineNumber", "Id is deprecated. Use 'editorLineNumber.activeForeground' instead."));
N("editorLineNumber.activeForeground", Fz, p("editorActiveLineNumber", "Color of editor active line number"));
const Bz = N("editorLineNumber.dimmedForeground", null, p("editorDimmedLineNumber", "Color of the final editor line when editor.renderFinalNewline is set to dimmed."));
N("editorRuler.foreground", { dark: "#5A5A5A", light: Z.lightgrey, hcDark: Z.white, hcLight: "#292929" }, p("editorRuler", "Color of the editor rulers."));
N("editorCodeLens.foreground", { dark: "#999999", light: "#919191", hcDark: "#999999", hcLight: "#292929" }, p("editorCodeLensForeground", "Foreground color of editor CodeLens"));
N("editorBracketMatch.background", { dark: "#0064001a", light: "#0064001a", hcDark: "#0064001a", hcLight: "#0000" }, p("editorBracketMatchBackground", "Background color behind matching brackets"));
N("editorBracketMatch.border", { dark: "#888", light: "#B9B9B9", hcDark: Xe, hcLight: Xe }, p("editorBracketMatchBorder", "Color for matching brackets boxes"));
const Wz = N("editorOverviewRuler.border", { dark: "#7f7f7f4d", light: "#7f7f7f4d", hcDark: "#7f7f7f4d", hcLight: "#666666" }, p("editorOverviewRulerBorder", "Color of the overview ruler border.")), Vz = N("editorOverviewRuler.background", null, p("editorOverviewRulerBackground", "Background color of the editor overview ruler."));
N("editorGutter.background", ro, p("editorGutter", "Background color of the editor gutter. The gutter contains the glyph margins and the line numbers."));
N("editorUnnecessaryCode.border", { dark: null, light: null, hcDark: Z.fromHex("#fff").transparent(0.8), hcLight: Xe }, p("unnecessaryCodeBorder", "Border color of unnecessary (unused) source code in the editor."));
const Hz = N("editorUnnecessaryCode.opacity", { dark: Z.fromHex("#000a"), light: Z.fromHex("#0007"), hcDark: null, hcLight: null }, p("unnecessaryCodeOpacity", `Opacity of unnecessary (unused) source code in the editor. For example, "#000000c0" will render the code with 75% opacity. For high contrast themes, use the  'editorUnnecessaryCode.border' theme color to underline unnecessary code instead of fading it out.`));
N("editorGhostText.border", { dark: null, light: null, hcDark: Z.fromHex("#fff").transparent(0.8), hcLight: Z.fromHex("#292929").transparent(0.8) }, p("editorGhostTextBorder", "Border color of ghost text in the editor."));
N("editorGhostText.foreground", { dark: Z.fromHex("#ffffff56"), light: Z.fromHex("#0007"), hcDark: null, hcLight: null }, p("editorGhostTextForeground", "Foreground color of the ghost text in the editor."));
N("editorGhostText.background", null, p("editorGhostTextBackground", "Background color of the ghost text in the editor."));
const zz = new Z(new qe(0, 122, 204, 0.6));
N("editorOverviewRuler.rangeHighlightForeground", zz, p("overviewRulerRangeHighlight", "Overview ruler marker color for range highlights. The color must not be opaque so as not to hide underlying decorations."), !0);
const Uz = N("editorOverviewRuler.errorForeground", { dark: new Z(new qe(255, 18, 18, 0.7)), light: new Z(new qe(255, 18, 18, 0.7)), hcDark: new Z(new qe(255, 50, 50, 1)), hcLight: "#B5200D" }, p("overviewRuleError", "Overview ruler marker color for errors.")), $z = N("editorOverviewRuler.warningForeground", { dark: ja, light: ja, hcDark: $p, hcLight: $p }, p("overviewRuleWarning", "Overview ruler marker color for warnings.")), Kz = N("editorOverviewRuler.infoForeground", { dark: wc, light: wc, hcDark: Kp, hcLight: Kp }, p("overviewRuleInfo", "Overview ruler marker color for infos.")), PA = N("editorBracketHighlight.foreground1", { dark: "#FFD700", light: "#0431FAFF", hcDark: "#FFD700", hcLight: "#0431FAFF" }, p("editorBracketHighlightForeground1", "Foreground color of brackets (1). Requires enabling bracket pair colorization.")), OA = N("editorBracketHighlight.foreground2", { dark: "#DA70D6", light: "#319331FF", hcDark: "#DA70D6", hcLight: "#319331FF" }, p("editorBracketHighlightForeground2", "Foreground color of brackets (2). Requires enabling bracket pair colorization.")), FA = N("editorBracketHighlight.foreground3", { dark: "#179FFF", light: "#7B3814FF", hcDark: "#87CEFA", hcLight: "#7B3814FF" }, p("editorBracketHighlightForeground3", "Foreground color of brackets (3). Requires enabling bracket pair colorization.")), BA = N("editorBracketHighlight.foreground4", "#00000000", p("editorBracketHighlightForeground4", "Foreground color of brackets (4). Requires enabling bracket pair colorization.")), WA = N("editorBracketHighlight.foreground5", "#00000000", p("editorBracketHighlightForeground5", "Foreground color of brackets (5). Requires enabling bracket pair colorization.")), VA = N("editorBracketHighlight.foreground6", "#00000000", p("editorBracketHighlightForeground6", "Foreground color of brackets (6). Requires enabling bracket pair colorization.")), qz = N("editorBracketHighlight.unexpectedBracket.foreground", { dark: new Z(new qe(255, 18, 18, 0.8)), light: new Z(new qe(255, 18, 18, 0.8)), hcDark: "new Color(new RGBA(255, 50, 50, 1))", hcLight: "#B5200D" }, p("editorBracketHighlightUnexpectedBracketForeground", "Foreground color of unexpected brackets.")), jz = N("editorBracketPairGuide.background1", "#00000000", p("editorBracketPairGuide.background1", "Background color of inactive bracket pair guides (1). Requires enabling bracket pair guides.")), Gz = N("editorBracketPairGuide.background2", "#00000000", p("editorBracketPairGuide.background2", "Background color of inactive bracket pair guides (2). Requires enabling bracket pair guides.")), Zz = N("editorBracketPairGuide.background3", "#00000000", p("editorBracketPairGuide.background3", "Background color of inactive bracket pair guides (3). Requires enabling bracket pair guides.")), Yz = N("editorBracketPairGuide.background4", "#00000000", p("editorBracketPairGuide.background4", "Background color of inactive bracket pair guides (4). Requires enabling bracket pair guides.")), Qz = N("editorBracketPairGuide.background5", "#00000000", p("editorBracketPairGuide.background5", "Background color of inactive bracket pair guides (5). Requires enabling bracket pair guides.")), Xz = N("editorBracketPairGuide.background6", "#00000000", p("editorBracketPairGuide.background6", "Background color of inactive bracket pair guides (6). Requires enabling bracket pair guides.")), Jz = N("editorBracketPairGuide.activeBackground1", "#00000000", p("editorBracketPairGuide.activeBackground1", "Background color of active bracket pair guides (1). Requires enabling bracket pair guides.")), eU = N("editorBracketPairGuide.activeBackground2", "#00000000", p("editorBracketPairGuide.activeBackground2", "Background color of active bracket pair guides (2). Requires enabling bracket pair guides.")), tU = N("editorBracketPairGuide.activeBackground3", "#00000000", p("editorBracketPairGuide.activeBackground3", "Background color of active bracket pair guides (3). Requires enabling bracket pair guides.")), iU = N("editorBracketPairGuide.activeBackground4", "#00000000", p("editorBracketPairGuide.activeBackground4", "Background color of active bracket pair guides (4). Requires enabling bracket pair guides.")), nU = N("editorBracketPairGuide.activeBackground5", "#00000000", p("editorBracketPairGuide.activeBackground5", "Background color of active bracket pair guides (5). Requires enabling bracket pair guides.")), sU = N("editorBracketPairGuide.activeBackground6", "#00000000", p("editorBracketPairGuide.activeBackground6", "Background color of active bracket pair guides (6). Requires enabling bracket pair guides."));
N("editorUnicodeHighlight.border", ja, p("editorUnicodeHighlight.border", "Border color used to highlight unicode characters."));
N("editorUnicodeHighlight.background", t8, p("editorUnicodeHighlight.background", "Background color used to highlight unicode characters."));
Jr((s, e) => {
  const t = s.getColor(ro), i = s.getColor(MA), n = i && !i.isTransparent() ? i : t;
  n && e.addRule(`.monaco-editor .inputarea.ime-input { background-color: ${n}; }`);
});
function oU(s, e) {
  const t = [], i = [];
  for (const n of s)
    e.has(n) || t.push(n);
  for (const n of e)
    s.has(n) || i.push(n);
  return { removed: t, added: i };
}
function rU(s, e) {
  const t = /* @__PURE__ */ new Set();
  for (const i of e)
    s.has(i) && t.add(i);
  return t;
}
var aU = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, YI = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let yy = class extends q {
  constructor(e, t) {
    super(), this._markerService = t, this._onDidChangeMarker = this._register(new O()), this._markerDecorations = new ts(), e.getModels().forEach((i) => this._onModelAdded(i)), this._register(e.onModelAdded(this._onModelAdded, this)), this._register(e.onModelRemoved(this._onModelRemoved, this)), this._register(this._markerService.onMarkerChanged(this._handleMarkerChange, this));
  }
  dispose() {
    super.dispose(), this._markerDecorations.forEach((e) => e.dispose()), this._markerDecorations.clear();
  }
  getMarker(e, t) {
    const i = this._markerDecorations.get(e);
    return i && i.getMarker(t) || null;
  }
  _handleMarkerChange(e) {
    e.forEach((t) => {
      const i = this._markerDecorations.get(t);
      i && this._updateDecorations(i);
    });
  }
  _onModelAdded(e) {
    const t = new lU(e);
    this._markerDecorations.set(e.uri, t), this._updateDecorations(t);
  }
  _onModelRemoved(e) {
    var i;
    const t = this._markerDecorations.get(e.uri);
    t && (t.dispose(), this._markerDecorations.delete(e.uri)), (e.uri.scheme === Ne.inMemory || e.uri.scheme === Ne.internal || e.uri.scheme === Ne.vscode) && ((i = this._markerService) == null || i.read({ resource: e.uri }).map((n) => n.owner).forEach((n) => this._markerService.remove(n, [e.uri])));
  }
  _updateDecorations(e) {
    const t = this._markerService.read({ resource: e.model.uri, take: 500 });
    e.update(t) && this._onDidChangeMarker.fire(e.model);
  }
};
yy = aU([
  YI(0, cn),
  YI(1, Bc)
], yy);
class lU extends q {
  constructor(e) {
    super(), this.model = e, this._map = new n9(), this._register(ke(() => {
      this.model.deltaDecorations([...this._map.values()], []), this._map.clear();
    }));
  }
  update(e) {
    const { added: t, removed: i } = oU(new Set(this._map.keys()), new Set(e));
    if (t.length === 0 && i.length === 0)
      return !1;
    const n = i.map((a) => this._map.get(a)), o = t.map((a) => ({
      range: this._createDecorationRange(this.model, a),
      options: this._createDecorationOption(a)
    })), r = this.model.deltaDecorations(n, o);
    for (const a of i)
      this._map.delete(a);
    for (let a = 0; a < r.length; a++)
      this._map.set(t[a], r[a]);
    return !0;
  }
  getMarker(e) {
    return this._map.getKey(e.id);
  }
  _createDecorationRange(e, t) {
    let i = R.lift(t);
    if (t.severity === us.Hint && !this._hasMarkerTag(
      t,
      1
      /* MarkerTag.Unnecessary */
    ) && !this._hasMarkerTag(
      t,
      2
      /* MarkerTag.Deprecated */
    ) && (i = i.setEndPosition(i.startLineNumber, i.startColumn + 2)), i = e.validateRange(i), i.isEmpty()) {
      const n = e.getLineLastNonWhitespaceColumn(i.startLineNumber) || e.getLineMaxColumn(i.startLineNumber);
      if (n === 1 || i.endColumn >= n)
        return i;
      const o = e.getWordAtPosition(i.getStartPosition());
      o && (i = new R(i.startLineNumber, o.startColumn, i.endLineNumber, o.endColumn));
    } else if (t.endColumn === Number.MAX_VALUE && t.startColumn === 1 && i.startLineNumber === i.endLineNumber) {
      const n = e.getLineFirstNonWhitespaceColumn(t.startLineNumber);
      n < i.endColumn && (i = new R(i.startLineNumber, n, i.endLineNumber, i.endColumn), t.startColumn = n);
    }
    return i;
  }
  _createDecorationOption(e) {
    let t, i, n, o, r;
    switch (e.severity) {
      case us.Hint:
        this._hasMarkerTag(
          e,
          2
          /* MarkerTag.Deprecated */
        ) ? t = void 0 : this._hasMarkerTag(
          e,
          1
          /* MarkerTag.Unnecessary */
        ) ? t = "squiggly-unnecessary" : t = "squiggly-hint", n = 0;
        break;
      case us.Info:
        t = "squiggly-info", i = eh(Kz), n = 10, r = {
          color: eh(b8),
          position: 1
          /* MinimapPosition.Inline */
        };
        break;
      case us.Warning:
        t = "squiggly-warning", i = eh($z), n = 20, r = {
          color: eh(C8),
          position: 1
          /* MinimapPosition.Inline */
        };
        break;
      case us.Error:
      default:
        t = "squiggly-error", i = eh(Uz), n = 30, r = {
          color: eh(w8),
          position: 1
          /* MinimapPosition.Inline */
        };
        break;
    }
    return e.tags && (e.tags.indexOf(
      1
      /* MarkerTag.Unnecessary */
    ) !== -1 && (o = "squiggly-inline-unnecessary"), e.tags.indexOf(
      2
      /* MarkerTag.Deprecated */
    ) !== -1 && (o = "squiggly-inline-deprecated")), {
      description: "marker-decoration",
      stickiness: 1,
      className: t,
      showIfCollapsed: !0,
      overviewRuler: {
        color: i,
        position: Pp.Right
      },
      minimap: r,
      zIndex: n,
      inlineClassName: o
    };
  }
  _hasMarkerTag(e, t) {
    return e.tags ? e.tags.indexOf(t) >= 0 : !1;
  }
}
const HA = Ve("markerDecorationsService");
class ii {
  static _nextVisibleColumn(e, t, i) {
    return e === 9 ? ii.nextRenderTabStop(t, i) : za(e) || RL(e) ? t + 2 : t + 1;
  }
  /**
   * Returns a visible column from a column.
   * @see {@link CursorColumns}
   */
  static visibleColumnFromColumn(e, t, i) {
    const n = Math.min(t - 1, e.length), o = e.substring(0, n), r = new xp(o);
    let a = 0;
    for (; !r.eol(); ) {
      const l = kp(o, n, r.offset);
      r.nextGraphemeLength(), a = this._nextVisibleColumn(l, a, i);
    }
    return a;
  }
  /**
   * Returns a column from a visible column.
   * @see {@link CursorColumns}
   */
  static columnFromVisibleColumn(e, t, i) {
    if (t <= 0)
      return 1;
    const n = e.length, o = new xp(e);
    let r = 0, a = 1;
    for (; !o.eol(); ) {
      const l = kp(e, n, o.offset);
      o.nextGraphemeLength();
      const c = this._nextVisibleColumn(l, r, i), h = o.offset + 1;
      if (c >= t) {
        const d = t - r;
        return c - t < d ? h : a;
      }
      r = c, a = h;
    }
    return n + 1;
  }
  /**
   * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)
   * @see {@link CursorColumns}
   */
  static nextRenderTabStop(e, t) {
    return e + t - e % t;
  }
  /**
   * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)
   * @see {@link CursorColumns}
   */
  static nextIndentTabStop(e, t) {
    return e + t - e % t;
  }
  /**
   * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)
   * @see {@link CursorColumns}
   */
  static prevRenderTabStop(e, t) {
    return Math.max(0, e - 1 - (e - 1) % t);
  }
  /**
   * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)
   * @see {@link CursorColumns}
   */
  static prevIndentTabStop(e, t) {
    return Math.max(0, e - 1 - (e - 1) % t);
  }
}
function cU(s, e, t) {
  let i = 0;
  for (let o = 0; o < s.length; o++)
    s.charAt(o) === "	" ? i = ii.nextIndentTabStop(i, e) : i++;
  let n = "";
  if (!t) {
    const o = Math.floor(i / e);
    i = i % e;
    for (let r = 0; r < o; r++)
      n += "	";
  }
  for (let o = 0; o < i; o++)
    n += " ";
  return n;
}
function zA(s, e, t) {
  let i = On(s);
  return i === -1 && (i = s.length), cU(s.substring(0, i), e, t) + s.substring(i);
}
class QI {
  constructor(e, t, i, n) {
    this.range = e, this.nestingLevel = t, this.nestingLevelOfEqualBracketType = i, this.isInvalid = n;
  }
}
class hU {
  constructor(e, t, i, n, o, r) {
    this.range = e, this.openingBracketRange = t, this.closingBracketRange = i, this.nestingLevel = n, this.nestingLevelOfEqualBracketType = o, this.bracketPairNode = r;
  }
  get openingBracketInfo() {
    return this.bracketPairNode.openingBracket.bracketInfo;
  }
}
class dU extends hU {
  constructor(e, t, i, n, o, r, a) {
    super(e, t, i, n, o, r), this.minVisibleColumnIndentation = a;
  }
}
function uU(s, e, t, i) {
  return s !== t ? $t(t - s, i) : $t(0, i - e);
}
const Cn = 0;
function c_(s) {
  return s === 0;
}
const Xn = 2 ** 26;
function $t(s, e) {
  return s * Xn + e;
}
function ps(s) {
  const e = s, t = Math.floor(e / Xn), i = e - t * Xn;
  return new qa(t, i);
}
function fU(s) {
  return Math.floor(s / Xn);
}
function Qt(s, e) {
  let t = s + e;
  return e >= Xn && (t = t - s % Xn), t;
}
function gU(s, e) {
  return s.reduce((t, i) => Qt(t, e(i)), Cn);
}
function UA(s, e) {
  return s === e;
}
function Xf(s, e) {
  const t = s, i = e;
  if (i - t <= 0)
    return Cn;
  const o = Math.floor(t / Xn), r = Math.floor(i / Xn), a = i - r * Xn;
  if (o === r) {
    const l = t - o * Xn;
    return $t(0, a - l);
  } else
    return $t(r - o, a);
}
function ed(s, e) {
  return s < e;
}
function td(s, e) {
  return s <= e;
}
function Tu(s, e) {
  return s >= e;
}
function Sh(s) {
  return $t(s.lineNumber - 1, s.column - 1);
}
function Xl(s, e) {
  const t = s, i = Math.floor(t / Xn), n = t - i * Xn, o = e, r = Math.floor(o / Xn), a = o - r * Xn;
  return new R(i + 1, n + 1, r + 1, a + 1);
}
function mU(s) {
  const e = Vd(s);
  return $t(e.length - 1, e[e.length - 1].length);
}
class Ar {
  static fromModelContentChanges(e) {
    return e.map((i) => {
      const n = R.lift(i.range);
      return new Ar(Sh(n.getStartPosition()), Sh(n.getEndPosition()), mU(i.text));
    }).reverse();
  }
  constructor(e, t, i) {
    this.startOffset = e, this.endOffset = t, this.newLength = i;
  }
  toString() {
    return `[${ps(this.startOffset)}...${ps(this.endOffset)}) -> ${ps(this.newLength)}`;
  }
}
class pU {
  /**
   * @param edits Must be sorted by offset in ascending order.
  */
  constructor(e) {
    this.nextEditIdx = 0, this.deltaOldToNewLineCount = 0, this.deltaOldToNewColumnCount = 0, this.deltaLineIdxInOld = -1, this.edits = e.map((t) => Bk.from(t));
  }
  /**
   * @param offset Must be equal to or greater than the last offset this method has been called with.
  */
  getOffsetBeforeChange(e) {
    return this.adjustNextEdit(e), this.translateCurToOld(e);
  }
  /**
   * @param offset Must be equal to or greater than the last offset this method has been called with.
   * Returns null if there is no edit anymore.
  */
  getDistanceToNextChange(e) {
    this.adjustNextEdit(e);
    const t = this.edits[this.nextEditIdx], i = t ? this.translateOldToCur(t.offsetObj) : null;
    return i === null ? null : Xf(e, i);
  }
  translateOldToCur(e) {
    return e.lineCount === this.deltaLineIdxInOld ? $t(e.lineCount + this.deltaOldToNewLineCount, e.columnCount + this.deltaOldToNewColumnCount) : $t(e.lineCount + this.deltaOldToNewLineCount, e.columnCount);
  }
  translateCurToOld(e) {
    const t = ps(e);
    return t.lineCount - this.deltaOldToNewLineCount === this.deltaLineIdxInOld ? $t(t.lineCount - this.deltaOldToNewLineCount, t.columnCount - this.deltaOldToNewColumnCount) : $t(t.lineCount - this.deltaOldToNewLineCount, t.columnCount);
  }
  adjustNextEdit(e) {
    for (; this.nextEditIdx < this.edits.length; ) {
      const t = this.edits[this.nextEditIdx], i = this.translateOldToCur(t.endOffsetAfterObj);
      if (td(i, e)) {
        this.nextEditIdx++;
        const n = ps(i), o = ps(this.translateOldToCur(t.endOffsetBeforeObj)), r = n.lineCount - o.lineCount;
        this.deltaOldToNewLineCount += r;
        const a = this.deltaLineIdxInOld === t.endOffsetBeforeObj.lineCount ? this.deltaOldToNewColumnCount : 0, l = n.columnCount - o.columnCount;
        this.deltaOldToNewColumnCount = a + l, this.deltaLineIdxInOld = t.endOffsetBeforeObj.lineCount;
      } else
        break;
    }
  }
}
class Bk {
  static from(e) {
    return new Bk(e.startOffset, e.endOffset, e.newLength);
  }
  constructor(e, t, i) {
    this.endOffsetBeforeObj = ps(t), this.endOffsetAfterObj = ps(Qt(e, i)), this.offsetObj = ps(e);
  }
}
const Sm = [], ls = class ls {
  static create(e, t) {
    if (e <= 128 && t.length === 0) {
      let i = ls.cache[e];
      return i || (i = new ls(e, t), ls.cache[e] = i), i;
    }
    return new ls(e, t);
  }
  static getEmpty() {
    return this.empty;
  }
  constructor(e, t) {
    this.items = e, this.additionalItems = t;
  }
  add(e, t) {
    const i = t.getKey(e);
    let n = i >> 5;
    if (n === 0) {
      const r = 1 << i | this.items;
      return r === this.items ? this : ls.create(r, this.additionalItems);
    }
    n--;
    const o = this.additionalItems.slice(0);
    for (; o.length < n; )
      o.push(0);
    return o[n] |= 1 << (i & 31), ls.create(this.items, o);
  }
  merge(e) {
    const t = this.items | e.items;
    if (this.additionalItems === Sm && e.additionalItems === Sm)
      return t === this.items ? this : t === e.items ? e : ls.create(t, Sm);
    const i = [];
    for (let n = 0; n < Math.max(this.additionalItems.length, e.additionalItems.length); n++) {
      const o = this.additionalItems[n] || 0, r = e.additionalItems[n] || 0;
      i.push(o | r);
    }
    return ls.create(t, i);
  }
  intersects(e) {
    if ((this.items & e.items) !== 0)
      return !0;
    for (let t = 0; t < Math.min(this.additionalItems.length, e.additionalItems.length); t++)
      if ((this.additionalItems[t] & e.additionalItems[t]) !== 0)
        return !0;
    return !1;
  }
};
ls.cache = new Array(129), ls.empty = ls.create(0, Sm);
let Mn = ls;
const XI = {
  getKey(s) {
    return s;
  }
};
class _U {
  constructor() {
    this.items = /* @__PURE__ */ new Map();
  }
  getKey(e) {
    let t = this.items.get(e);
    return t === void 0 && (t = this.items.size, this.items.set(e, t)), t;
  }
}
class Wk {
  /**
   * The length of the entire node, which should equal the sum of lengths of all children.
  */
  get length() {
    return this._length;
  }
  constructor(e) {
    this._length = e;
  }
}
class Jf extends Wk {
  static create(e, t, i) {
    let n = e.length;
    return t && (n = Qt(n, t.length)), i && (n = Qt(n, i.length)), new Jf(n, e, t, i, t ? t.missingOpeningBracketIds : Mn.getEmpty());
  }
  get kind() {
    return 2;
  }
  get listHeight() {
    return 0;
  }
  get childrenLength() {
    return 3;
  }
  getChild(e) {
    switch (e) {
      case 0:
        return this.openingBracket;
      case 1:
        return this.child;
      case 2:
        return this.closingBracket;
    }
    throw new Error("Invalid child index");
  }
  /**
   * Avoid using this property, it allocates an array!
  */
  get children() {
    const e = [];
    return e.push(this.openingBracket), this.child && e.push(this.child), this.closingBracket && e.push(this.closingBracket), e;
  }
  constructor(e, t, i, n, o) {
    super(e), this.openingBracket = t, this.child = i, this.closingBracket = n, this.missingOpeningBracketIds = o;
  }
  canBeReused(e) {
    return !(this.closingBracket === null || e.intersects(this.missingOpeningBracketIds));
  }
  deepClone() {
    return new Jf(this.length, this.openingBracket.deepClone(), this.child && this.child.deepClone(), this.closingBracket && this.closingBracket.deepClone(), this.missingOpeningBracketIds);
  }
  computeMinIndentation(e, t) {
    return this.child ? this.child.computeMinIndentation(Qt(e, this.openingBracket.length), t) : Number.MAX_SAFE_INTEGER;
  }
}
class $o extends Wk {
  /**
   * This method uses more memory-efficient list nodes that can only store 2 or 3 children.
  */
  static create23(e, t, i, n = !1) {
    let o = e.length, r = e.missingOpeningBracketIds;
    if (e.listHeight !== t.listHeight)
      throw new Error("Invalid list heights");
    if (o = Qt(o, t.length), r = r.merge(t.missingOpeningBracketIds), i) {
      if (e.listHeight !== i.listHeight)
        throw new Error("Invalid list heights");
      o = Qt(o, i.length), r = r.merge(i.missingOpeningBracketIds);
    }
    return n ? new bU(o, e.listHeight + 1, e, t, i, r) : new eg(o, e.listHeight + 1, e, t, i, r);
  }
  static getEmpty() {
    return new CU(Cn, 0, [], Mn.getEmpty());
  }
  get kind() {
    return 4;
  }
  get missingOpeningBracketIds() {
    return this._missingOpeningBracketIds;
  }
  /**
   * Use ListAstNode.create.
  */
  constructor(e, t, i) {
    super(e), this.listHeight = t, this._missingOpeningBracketIds = i, this.cachedMinIndentation = -1;
  }
  throwIfImmutable() {
  }
  makeLastElementMutable() {
    this.throwIfImmutable();
    const e = this.childrenLength;
    if (e === 0)
      return;
    const t = this.getChild(e - 1), i = t.kind === 4 ? t.toMutable() : t;
    return t !== i && this.setChild(e - 1, i), i;
  }
  makeFirstElementMutable() {
    if (this.throwIfImmutable(), this.childrenLength === 0)
      return;
    const t = this.getChild(0), i = t.kind === 4 ? t.toMutable() : t;
    return t !== i && this.setChild(0, i), i;
  }
  canBeReused(e) {
    if (e.intersects(this.missingOpeningBracketIds) || this.childrenLength === 0)
      return !1;
    let t = this;
    for (; t.kind === 4; ) {
      const i = t.childrenLength;
      if (i === 0)
        throw new it();
      t = t.getChild(i - 1);
    }
    return t.canBeReused(e);
  }
  handleChildrenChanged() {
    this.throwIfImmutable();
    const e = this.childrenLength;
    let t = this.getChild(0).length, i = this.getChild(0).missingOpeningBracketIds;
    for (let n = 1; n < e; n++) {
      const o = this.getChild(n);
      t = Qt(t, o.length), i = i.merge(o.missingOpeningBracketIds);
    }
    this._length = t, this._missingOpeningBracketIds = i, this.cachedMinIndentation = -1;
  }
  computeMinIndentation(e, t) {
    if (this.cachedMinIndentation !== -1)
      return this.cachedMinIndentation;
    let i = Number.MAX_SAFE_INTEGER, n = e;
    for (let o = 0; o < this.childrenLength; o++) {
      const r = this.getChild(o);
      r && (i = Math.min(i, r.computeMinIndentation(n, t)), n = Qt(n, r.length));
    }
    return this.cachedMinIndentation = i, i;
  }
}
class eg extends $o {
  get childrenLength() {
    return this._item3 !== null ? 3 : 2;
  }
  getChild(e) {
    switch (e) {
      case 0:
        return this._item1;
      case 1:
        return this._item2;
      case 2:
        return this._item3;
    }
    throw new Error("Invalid child index");
  }
  setChild(e, t) {
    switch (e) {
      case 0:
        this._item1 = t;
        return;
      case 1:
        this._item2 = t;
        return;
      case 2:
        this._item3 = t;
        return;
    }
    throw new Error("Invalid child index");
  }
  get children() {
    return this._item3 ? [this._item1, this._item2, this._item3] : [this._item1, this._item2];
  }
  get item1() {
    return this._item1;
  }
  get item2() {
    return this._item2;
  }
  get item3() {
    return this._item3;
  }
  constructor(e, t, i, n, o, r) {
    super(e, t, r), this._item1 = i, this._item2 = n, this._item3 = o;
  }
  deepClone() {
    return new eg(this.length, this.listHeight, this._item1.deepClone(), this._item2.deepClone(), this._item3 ? this._item3.deepClone() : null, this.missingOpeningBracketIds);
  }
  appendChildOfSameHeight(e) {
    if (this._item3)
      throw new Error("Cannot append to a full (2,3) tree node");
    this.throwIfImmutable(), this._item3 = e, this.handleChildrenChanged();
  }
  unappendChild() {
    if (!this._item3)
      throw new Error("Cannot remove from a non-full (2,3) tree node");
    this.throwIfImmutable();
    const e = this._item3;
    return this._item3 = null, this.handleChildrenChanged(), e;
  }
  prependChildOfSameHeight(e) {
    if (this._item3)
      throw new Error("Cannot prepend to a full (2,3) tree node");
    this.throwIfImmutable(), this._item3 = this._item2, this._item2 = this._item1, this._item1 = e, this.handleChildrenChanged();
  }
  unprependChild() {
    if (!this._item3)
      throw new Error("Cannot remove from a non-full (2,3) tree node");
    this.throwIfImmutable();
    const e = this._item1;
    return this._item1 = this._item2, this._item2 = this._item3, this._item3 = null, this.handleChildrenChanged(), e;
  }
  toMutable() {
    return this;
  }
}
class bU extends eg {
  toMutable() {
    return new eg(this.length, this.listHeight, this.item1, this.item2, this.item3, this.missingOpeningBracketIds);
  }
  throwIfImmutable() {
    throw new Error("this instance is immutable");
  }
}
class h_ extends $o {
  get childrenLength() {
    return this._children.length;
  }
  getChild(e) {
    return this._children[e];
  }
  setChild(e, t) {
    this._children[e] = t;
  }
  get children() {
    return this._children;
  }
  constructor(e, t, i, n) {
    super(e, t, n), this._children = i;
  }
  deepClone() {
    const e = new Array(this._children.length);
    for (let t = 0; t < this._children.length; t++)
      e[t] = this._children[t].deepClone();
    return new h_(this.length, this.listHeight, e, this.missingOpeningBracketIds);
  }
  appendChildOfSameHeight(e) {
    this.throwIfImmutable(), this._children.push(e), this.handleChildrenChanged();
  }
  unappendChild() {
    this.throwIfImmutable();
    const e = this._children.pop();
    return this.handleChildrenChanged(), e;
  }
  prependChildOfSameHeight(e) {
    this.throwIfImmutable(), this._children.unshift(e), this.handleChildrenChanged();
  }
  unprependChild() {
    this.throwIfImmutable();
    const e = this._children.shift();
    return this.handleChildrenChanged(), e;
  }
  toMutable() {
    return this;
  }
}
class CU extends h_ {
  toMutable() {
    return new h_(this.length, this.listHeight, [...this.children], this.missingOpeningBracketIds);
  }
  throwIfImmutable() {
    throw new Error("this instance is immutable");
  }
}
const wU = [];
class Vk extends Wk {
  get listHeight() {
    return 0;
  }
  get childrenLength() {
    return 0;
  }
  getChild(e) {
    return null;
  }
  get children() {
    return wU;
  }
  deepClone() {
    return this;
  }
}
class Il extends Vk {
  get kind() {
    return 0;
  }
  get missingOpeningBracketIds() {
    return Mn.getEmpty();
  }
  canBeReused(e) {
    return !0;
  }
  computeMinIndentation(e, t) {
    const i = ps(e), n = (i.columnCount === 0 ? i.lineCount : i.lineCount + 1) + 1, o = fU(Qt(e, this.length)) + 1;
    let r = Number.MAX_SAFE_INTEGER;
    for (let a = n; a <= o; a++) {
      const l = t.getLineFirstNonWhitespaceColumn(a), c = t.getLineContent(a);
      if (l === 0)
        continue;
      const h = ii.visibleColumnFromColumn(c, l, t.getOptions().tabSize);
      r = Math.min(r, h);
    }
    return r;
  }
}
class d_ extends Vk {
  static create(e, t, i) {
    return new d_(e, t, i);
  }
  get kind() {
    return 1;
  }
  get missingOpeningBracketIds() {
    return Mn.getEmpty();
  }
  constructor(e, t, i) {
    super(e), this.bracketInfo = t, this.bracketIds = i;
  }
  get text() {
    return this.bracketInfo.bracketText;
  }
  get languageId() {
    return this.bracketInfo.languageId;
  }
  canBeReused(e) {
    return !1;
  }
  computeMinIndentation(e, t) {
    return Number.MAX_SAFE_INTEGER;
  }
}
class vU extends Vk {
  get kind() {
    return 3;
  }
  constructor(e, t) {
    super(t), this.missingOpeningBracketIds = e;
  }
  canBeReused(e) {
    return !e.intersects(this.missingOpeningBracketIds);
  }
  computeMinIndentation(e, t) {
    return Number.MAX_SAFE_INTEGER;
  }
}
let wa = class {
  constructor(e, t, i, n, o) {
    this.length = e, this.kind = t, this.bracketId = i, this.bracketIds = n, this.astNode = o;
  }
};
class yU {
  constructor(e, t) {
    this.textModel = e, this.bracketTokens = t, this.reader = new SU(this.textModel, this.bracketTokens), this._offset = Cn, this.didPeek = !1, this.peeked = null, this.textBufferLineCount = e.getLineCount(), this.textBufferLastLineLength = e.getLineLength(this.textBufferLineCount);
  }
  get offset() {
    return this._offset;
  }
  get length() {
    return $t(this.textBufferLineCount - 1, this.textBufferLastLineLength);
  }
  skip(e) {
    this.didPeek = !1, this._offset = Qt(this._offset, e);
    const t = ps(this._offset);
    this.reader.setPosition(t.lineCount, t.columnCount);
  }
  read() {
    let e;
    return this.peeked ? (this.didPeek = !1, e = this.peeked) : e = this.reader.read(), e && (this._offset = Qt(this._offset, e.length)), e;
  }
  peek() {
    return this.didPeek || (this.peeked = this.reader.read(), this.didPeek = !0), this.peeked;
  }
}
class SU {
  constructor(e, t) {
    this.textModel = e, this.bracketTokens = t, this.lineIdx = 0, this.line = null, this.lineCharOffset = 0, this.lineTokens = null, this.lineTokenOffset = 0, this.peekedToken = null, this.textBufferLineCount = e.getLineCount(), this.textBufferLastLineLength = e.getLineLength(this.textBufferLineCount);
  }
  setPosition(e, t) {
    e === this.lineIdx ? (this.lineCharOffset = t, this.line !== null && (this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset))) : (this.lineIdx = e, this.lineCharOffset = t, this.line = null), this.peekedToken = null;
  }
  read() {
    if (this.peekedToken) {
      const o = this.peekedToken;
      return this.peekedToken = null, this.lineCharOffset += o.length, o;
    }
    if (this.lineIdx > this.textBufferLineCount - 1 || this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength)
      return null;
    this.line === null && (this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1), this.line = this.lineTokens.getLineContent(), this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset));
    const e = this.lineIdx, t = this.lineCharOffset;
    let i = 0;
    for (; ; ) {
      const o = this.lineTokens, r = o.getCount();
      let a = null;
      if (this.lineTokenOffset < r) {
        const l = o.getMetadata(this.lineTokenOffset);
        for (; this.lineTokenOffset + 1 < r && l === o.getMetadata(this.lineTokenOffset + 1); )
          this.lineTokenOffset++;
        const c = Xs.getTokenType(l) === 0, h = Xs.containsBalancedBrackets(l), d = o.getEndOffset(this.lineTokenOffset);
        if (h && c && this.lineCharOffset < d) {
          const u = o.getLanguageId(this.lineTokenOffset), f = this.line.substring(this.lineCharOffset, d), g = this.bracketTokens.getSingleLanguageBracketTokens(u), m = g.regExpGlobal;
          if (m) {
            m.lastIndex = 0;
            const _ = m.exec(f);
            _ && (a = g.getToken(_[0]), a && (this.lineCharOffset += _.index));
          }
        }
        if (i += d - this.lineCharOffset, a)
          if (e !== this.lineIdx || t !== this.lineCharOffset) {
            this.peekedToken = a;
            break;
          } else
            return this.lineCharOffset += a.length, a;
        else
          this.lineTokenOffset++, this.lineCharOffset = d;
      } else if (this.lineIdx === this.textBufferLineCount - 1 || (this.lineIdx++, this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1), this.lineTokenOffset = 0, this.line = this.lineTokens.getLineContent(), this.lineCharOffset = 0, i += 33, i > 1e3))
        break;
      if (i > 1500)
        break;
    }
    const n = uU(e, t, this.lineIdx, this.lineCharOffset);
    return new wa(n, 0, -1, Mn.getEmpty(), new Il(n));
  }
}
class LU {
  constructor(e, t) {
    this.text = e, this._offset = Cn, this.idx = 0;
    const i = t.getRegExpStr(), n = i ? new RegExp(i + `|
`, "gi") : null, o = [];
    let r, a = 0, l = 0, c = 0, h = 0;
    const d = [];
    for (let g = 0; g < 60; g++)
      d.push(new wa($t(0, g), 0, -1, Mn.getEmpty(), new Il($t(0, g))));
    const u = [];
    for (let g = 0; g < 60; g++)
      u.push(new wa($t(1, g), 0, -1, Mn.getEmpty(), new Il($t(1, g))));
    if (n)
      for (n.lastIndex = 0; (r = n.exec(e)) !== null; ) {
        const g = r.index, m = r[0];
        if (m === `
`)
          a++, l = g + 1;
        else {
          if (c !== g) {
            let _;
            if (h === a) {
              const b = g - c;
              if (b < d.length)
                _ = d[b];
              else {
                const C = $t(0, b);
                _ = new wa(C, 0, -1, Mn.getEmpty(), new Il(C));
              }
            } else {
              const b = a - h, C = g - l;
              if (b === 1 && C < u.length)
                _ = u[C];
              else {
                const v = $t(b, C);
                _ = new wa(v, 0, -1, Mn.getEmpty(), new Il(v));
              }
            }
            o.push(_);
          }
          o.push(t.getToken(m)), c = g + m.length, h = a;
        }
      }
    const f = e.length;
    if (c !== f) {
      const g = h === a ? $t(0, f - c) : $t(a - h, f - l);
      o.push(new wa(g, 0, -1, Mn.getEmpty(), new Il(g)));
    }
    this.length = $t(a, f - l), this.tokens = o;
  }
  get offset() {
    return this._offset;
  }
  read() {
    return this.tokens[this.idx++] || null;
  }
  peek() {
    return this.tokens[this.idx] || null;
  }
  skip(e) {
    throw new nO();
  }
}
class Hk {
  static createFromLanguage(e, t) {
    function i(o) {
      return t.getKey(`${o.languageId}:::${o.bracketText}`);
    }
    const n = /* @__PURE__ */ new Map();
    for (const o of e.bracketsNew.openingBrackets) {
      const r = $t(0, o.bracketText.length), a = i(o), l = Mn.getEmpty().add(a, XI);
      n.set(o.bracketText, new wa(r, 1, a, l, d_.create(r, o, l)));
    }
    for (const o of e.bracketsNew.closingBrackets) {
      const r = $t(0, o.bracketText.length);
      let a = Mn.getEmpty();
      const l = o.getOpeningBrackets();
      for (const c of l)
        a = a.add(i(c), XI);
      n.set(o.bracketText, new wa(r, 2, i(l[0]), a, d_.create(r, o, a)));
    }
    return new Hk(n);
  }
  constructor(e) {
    this.map = e, this.hasRegExp = !1, this._regExpGlobal = null;
  }
  getRegExpStr() {
    if (this.isEmpty)
      return null;
    {
      const e = [...this.map.keys()];
      return e.sort(), e.reverse(), e.map((t) => kU(t)).join("|");
    }
  }
  /**
   * Returns null if there is no such regexp (because there are no brackets).
  */
  get regExpGlobal() {
    if (!this.hasRegExp) {
      const e = this.getRegExpStr();
      this._regExpGlobal = e ? new RegExp(e, "gi") : null, this.hasRegExp = !0;
    }
    return this._regExpGlobal;
  }
  getToken(e) {
    return this.map.get(e.toLowerCase());
  }
  findClosingTokenText(e) {
    for (const [t, i] of this.map)
      if (i.kind === 2 && i.bracketIds.intersects(e))
        return t;
  }
  get isEmpty() {
    return this.map.size === 0;
  }
}
function kU(s) {
  let e = Yr(s);
  return /^[\w ]+/.test(s) && (e = `\\b${e}`), /[\w ]+$/.test(s) && (e = `${e}\\b`), e;
}
class xU {
  constructor(e, t) {
    this.denseKeyProvider = e, this.getLanguageConfiguration = t, this.languageIdToBracketTokens = /* @__PURE__ */ new Map();
  }
  didLanguageChange(e) {
    return this.languageIdToBracketTokens.has(e);
  }
  getSingleLanguageBracketTokens(e) {
    let t = this.languageIdToBracketTokens.get(e);
    return t || (t = Hk.createFromLanguage(this.getLanguageConfiguration(e), this.denseKeyProvider), this.languageIdToBracketTokens.set(e, t)), t;
  }
}
function DU(s) {
  if (s.length === 0)
    return null;
  if (s.length === 1)
    return s[0];
  let e = 0;
  function t() {
    if (e >= s.length)
      return null;
    const r = e, a = s[r].listHeight;
    for (e++; e < s.length && s[e].listHeight === a; )
      e++;
    return e - r >= 2 ? $A(r === 0 && e === s.length ? s : s.slice(r, e), !1) : s[r];
  }
  let i = t(), n = t();
  if (!n)
    return i;
  for (let r = t(); r; r = t())
    JI(i, n) <= JI(n, r) ? (i = G0(i, n), n = r) : n = G0(n, r);
  return G0(i, n);
}
function $A(s, e = !1) {
  if (s.length === 0)
    return null;
  if (s.length === 1)
    return s[0];
  let t = s.length;
  for (; t > 3; ) {
    const i = t >> 1;
    for (let n = 0; n < i; n++) {
      const o = n << 1;
      s[n] = $o.create23(s[o], s[o + 1], o + 3 === t ? s[o + 2] : null, e);
    }
    t = i;
  }
  return $o.create23(s[0], s[1], t >= 3 ? s[2] : null, e);
}
function JI(s, e) {
  return Math.abs(s.listHeight - e.listHeight);
}
function G0(s, e) {
  return s.listHeight === e.listHeight ? $o.create23(s, e, null, !1) : s.listHeight > e.listHeight ? EU(s, e) : IU(e, s);
}
function EU(s, e) {
  s = s.toMutable();
  let t = s;
  const i = [];
  let n;
  for (; ; ) {
    if (e.listHeight === t.listHeight) {
      n = e;
      break;
    }
    if (t.kind !== 4)
      throw new Error("unexpected");
    i.push(t), t = t.makeLastElementMutable();
  }
  for (let o = i.length - 1; o >= 0; o--) {
    const r = i[o];
    n ? r.childrenLength >= 3 ? n = $o.create23(r.unappendChild(), n, null, !1) : (r.appendChildOfSameHeight(n), n = void 0) : r.handleChildrenChanged();
  }
  return n ? $o.create23(s, n, null, !1) : s;
}
function IU(s, e) {
  s = s.toMutable();
  let t = s;
  const i = [];
  for (; e.listHeight !== t.listHeight; ) {
    if (t.kind !== 4)
      throw new Error("unexpected");
    i.push(t), t = t.makeFirstElementMutable();
  }
  let n = e;
  for (let o = i.length - 1; o >= 0; o--) {
    const r = i[o];
    n ? r.childrenLength >= 3 ? n = $o.create23(n, r.unprependChild(), null, !1) : (r.prependChildOfSameHeight(n), n = void 0) : r.handleChildrenChanged();
  }
  return n ? $o.create23(n, s, null, !1) : s;
}
class NU {
  constructor(e) {
    this.lastOffset = Cn, this.nextNodes = [e], this.offsets = [Cn], this.idxs = [];
  }
  /**
   * Returns the longest node at `offset` that satisfies the predicate.
   * @param offset must be greater than or equal to the last offset this method has been called with!
  */
  readLongestNodeAt(e, t) {
    if (ed(e, this.lastOffset))
      throw new Error("Invalid offset");
    for (this.lastOffset = e; ; ) {
      const i = gu(this.nextNodes);
      if (!i)
        return;
      const n = gu(this.offsets);
      if (ed(e, n))
        return;
      if (ed(n, e))
        if (Qt(n, i.length) <= e)
          this.nextNodeAfterCurrent();
        else {
          const o = Z0(i);
          o !== -1 ? (this.nextNodes.push(i.getChild(o)), this.offsets.push(n), this.idxs.push(o)) : this.nextNodeAfterCurrent();
        }
      else {
        if (t(i))
          return this.nextNodeAfterCurrent(), i;
        {
          const o = Z0(i);
          if (o === -1) {
            this.nextNodeAfterCurrent();
            return;
          } else
            this.nextNodes.push(i.getChild(o)), this.offsets.push(n), this.idxs.push(o);
        }
      }
    }
  }
  // Navigates to the longest node that continues after the current node.
  nextNodeAfterCurrent() {
    for (; ; ) {
      const e = gu(this.offsets), t = gu(this.nextNodes);
      if (this.nextNodes.pop(), this.offsets.pop(), this.idxs.length === 0)
        break;
      const i = gu(this.nextNodes), n = Z0(i, this.idxs[this.idxs.length - 1]);
      if (n !== -1) {
        this.nextNodes.push(i.getChild(n)), this.offsets.push(Qt(e, t.length)), this.idxs[this.idxs.length - 1] = n;
        break;
      } else
        this.idxs.pop();
    }
  }
}
function Z0(s, e = -1) {
  for (; ; ) {
    if (e++, e >= s.childrenLength)
      return -1;
    if (s.getChild(e))
      return e;
  }
}
function gu(s) {
  return s.length > 0 ? s[s.length - 1] : void 0;
}
function eN(s, e, t, i) {
  return new TU(s, e, t, i).parseDocument();
}
class TU {
  constructor(e, t, i, n) {
    if (this.tokenizer = e, this.createImmutableLists = n, this._itemsConstructed = 0, this._itemsFromCache = 0, i && n)
      throw new Error("Not supported");
    this.oldNodeReader = i ? new NU(i) : void 0, this.positionMapper = new pU(t);
  }
  parseDocument() {
    this._itemsConstructed = 0, this._itemsFromCache = 0;
    let e = this.parseList(Mn.getEmpty(), 0);
    return e || (e = $o.getEmpty()), e;
  }
  parseList(e, t) {
    const i = [];
    for (; ; ) {
      let o = this.tryReadChildFromCache(e);
      if (!o) {
        const r = this.tokenizer.peek();
        if (!r || r.kind === 2 && r.bracketIds.intersects(e))
          break;
        o = this.parseChild(e, t + 1);
      }
      o.kind === 4 && o.childrenLength === 0 || i.push(o);
    }
    return this.oldNodeReader ? DU(i) : $A(i, this.createImmutableLists);
  }
  tryReadChildFromCache(e) {
    if (this.oldNodeReader) {
      const t = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);
      if (t === null || !c_(t)) {
        const i = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), (n) => t !== null && !ed(n.length, t) ? !1 : n.canBeReused(e));
        if (i)
          return this._itemsFromCache++, this.tokenizer.skip(i.length), i;
      }
    }
  }
  parseChild(e, t) {
    this._itemsConstructed++;
    const i = this.tokenizer.read();
    switch (i.kind) {
      case 2:
        return new vU(i.bracketIds, i.length);
      case 0:
        return i.astNode;
      case 1: {
        if (t > 300)
          return new Il(i.length);
        const n = e.merge(i.bracketIds), o = this.parseList(n, t + 1), r = this.tokenizer.peek();
        return r && r.kind === 2 && (r.bracketId === i.bracketId || r.bracketIds.intersects(i.bracketIds)) ? (this.tokenizer.read(), Jf.create(i.astNode, o, r.astNode)) : Jf.create(i.astNode, o, null);
      }
      default:
        throw new Error("unexpected");
    }
  }
}
function u_(s, e) {
  if (s.length === 0)
    return e;
  if (e.length === 0)
    return s;
  const t = new Gr(tN(s)), i = tN(e);
  i.push({ modified: !1, lengthBefore: void 0, lengthAfter: void 0 });
  let n = t.dequeue();
  function o(c) {
    if (c === void 0) {
      const d = t.takeWhile((u) => !0) || [];
      return n && d.unshift(n), d;
    }
    const h = [];
    for (; n && !c_(c); ) {
      const [d, u] = n.splitAt(c);
      h.push(d), c = Xf(d.lengthAfter, c), n = u ?? t.dequeue();
    }
    return c_(c) || h.push(new Ia(!1, c, c)), h;
  }
  const r = [];
  function a(c, h, d) {
    if (r.length > 0 && UA(r[r.length - 1].endOffset, c)) {
      const u = r[r.length - 1];
      r[r.length - 1] = new Ar(u.startOffset, h, Qt(u.newLength, d));
    } else
      r.push({ startOffset: c, endOffset: h, newLength: d });
  }
  let l = Cn;
  for (const c of i) {
    const h = o(c.lengthBefore);
    if (c.modified) {
      const d = gU(h, (f) => f.lengthBefore), u = Qt(l, d);
      a(l, u, c.lengthAfter), l = u;
    } else
      for (const d of h) {
        const u = l;
        l = Qt(l, d.lengthBefore), d.modified && a(u, l, d.lengthAfter);
      }
  }
  return r;
}
class Ia {
  constructor(e, t, i) {
    this.modified = e, this.lengthBefore = t, this.lengthAfter = i;
  }
  splitAt(e) {
    const t = Xf(e, this.lengthAfter);
    return UA(t, Cn) ? [this, void 0] : this.modified ? [
      new Ia(this.modified, this.lengthBefore, e),
      new Ia(this.modified, Cn, t)
    ] : [
      new Ia(this.modified, e, e),
      new Ia(this.modified, t, t)
    ];
  }
  toString() {
    return `${this.modified ? "M" : "U"}:${ps(this.lengthBefore)} -> ${ps(this.lengthAfter)}`;
  }
}
function tN(s) {
  const e = [];
  let t = Cn;
  for (const i of s) {
    const n = Xf(t, i.startOffset);
    c_(n) || e.push(new Ia(!1, n, n));
    const o = Xf(i.startOffset, i.endOffset);
    e.push(new Ia(!0, o, i.newLength)), t = i.endOffset;
  }
  return e;
}
class MU extends q {
  didLanguageChange(e) {
    return this.brackets.didLanguageChange(e);
  }
  constructor(e, t) {
    if (super(), this.textModel = e, this.getLanguageConfiguration = t, this.didChangeEmitter = new O(), this.denseKeyProvider = new _U(), this.brackets = new xU(this.denseKeyProvider, this.getLanguageConfiguration), this.onDidChange = this.didChangeEmitter.event, this.queuedTextEditsForInitialAstWithoutTokens = [], this.queuedTextEdits = [], e.tokenization.hasTokens)
      e.tokenization.backgroundTokenizationState === 2 ? (this.initialAstWithoutTokens = void 0, this.astWithTokens = this.parseDocumentFromTextBuffer([], void 0, !1)) : (this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], void 0, !0), this.astWithTokens = this.initialAstWithoutTokens);
    else {
      const i = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId()), n = new LU(this.textModel.getValue(), i);
      this.initialAstWithoutTokens = eN(n, [], void 0, !0), this.astWithTokens = this.initialAstWithoutTokens;
    }
  }
  //#region TextModel events
  handleDidChangeBackgroundTokenizationState() {
    if (this.textModel.tokenization.backgroundTokenizationState === 2) {
      const e = this.initialAstWithoutTokens === void 0;
      this.initialAstWithoutTokens = void 0, e || this.didChangeEmitter.fire();
    }
  }
  handleDidChangeTokens({ ranges: e }) {
    const t = e.map((i) => new Ar($t(i.fromLineNumber - 1, 0), $t(i.toLineNumber, 0), $t(i.toLineNumber - i.fromLineNumber + 1, 0)));
    this.handleEdits(t, !0), this.initialAstWithoutTokens || this.didChangeEmitter.fire();
  }
  handleContentChanged(e) {
    const t = Ar.fromModelContentChanges(e.changes);
    this.handleEdits(t, !1);
  }
  handleEdits(e, t) {
    const i = u_(this.queuedTextEdits, e);
    this.queuedTextEdits = i, this.initialAstWithoutTokens && !t && (this.queuedTextEditsForInitialAstWithoutTokens = u_(this.queuedTextEditsForInitialAstWithoutTokens, e));
  }
  //#endregion
  flushQueue() {
    this.queuedTextEdits.length > 0 && (this.astWithTokens = this.parseDocumentFromTextBuffer(this.queuedTextEdits, this.astWithTokens, !1), this.queuedTextEdits = []), this.queuedTextEditsForInitialAstWithoutTokens.length > 0 && (this.initialAstWithoutTokens && (this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(this.queuedTextEditsForInitialAstWithoutTokens, this.initialAstWithoutTokens, !1)), this.queuedTextEditsForInitialAstWithoutTokens = []);
  }
  /**
   * @pure (only if isPure = true)
  */
  parseDocumentFromTextBuffer(e, t, i) {
    const n = t, o = new yU(this.textModel, this.brackets);
    return eN(o, e, n, i);
  }
  getBracketsInRange(e, t) {
    this.flushQueue();
    const i = $t(e.startLineNumber - 1, e.startColumn - 1), n = $t(e.endLineNumber - 1, e.endColumn - 1);
    return new Gl((o) => {
      const r = this.initialAstWithoutTokens || this.astWithTokens;
      Sy(r, Cn, r.length, i, n, o, 0, 0, /* @__PURE__ */ new Map(), t);
    });
  }
  getBracketPairsInRange(e, t) {
    this.flushQueue();
    const i = Sh(e.getStartPosition()), n = Sh(e.getEndPosition());
    return new Gl((o) => {
      const r = this.initialAstWithoutTokens || this.astWithTokens, a = new RU(o, t, this.textModel);
      Ly(r, Cn, r.length, i, n, a, 0, /* @__PURE__ */ new Map());
    });
  }
  getFirstBracketAfter(e) {
    this.flushQueue();
    const t = this.initialAstWithoutTokens || this.astWithTokens;
    return qA(t, Cn, t.length, Sh(e));
  }
  getFirstBracketBefore(e) {
    this.flushQueue();
    const t = this.initialAstWithoutTokens || this.astWithTokens;
    return KA(t, Cn, t.length, Sh(e));
  }
}
function KA(s, e, t, i) {
  if (s.kind === 4 || s.kind === 2) {
    const n = [];
    for (const o of s.children)
      t = Qt(e, o.length), n.push({ nodeOffsetStart: e, nodeOffsetEnd: t }), e = t;
    for (let o = n.length - 1; o >= 0; o--) {
      const { nodeOffsetStart: r, nodeOffsetEnd: a } = n[o];
      if (ed(r, i)) {
        const l = KA(s.children[o], r, a, i);
        if (l)
          return l;
      }
    }
    return null;
  } else {
    if (s.kind === 3)
      return null;
    if (s.kind === 1) {
      const n = Xl(e, t);
      return {
        bracketInfo: s.bracketInfo,
        range: n
      };
    }
  }
  return null;
}
function qA(s, e, t, i) {
  if (s.kind === 4 || s.kind === 2) {
    for (const n of s.children) {
      if (t = Qt(e, n.length), ed(i, t)) {
        const o = qA(n, e, t, i);
        if (o)
          return o;
      }
      e = t;
    }
    return null;
  } else {
    if (s.kind === 3)
      return null;
    if (s.kind === 1) {
      const n = Xl(e, t);
      return {
        bracketInfo: s.bracketInfo,
        range: n
      };
    }
  }
  return null;
}
function Sy(s, e, t, i, n, o, r, a, l, c, h = !1) {
  if (r > 200)
    return !0;
  e: for (; ; )
    switch (s.kind) {
      case 4: {
        const d = s.childrenLength;
        for (let u = 0; u < d; u++) {
          const f = s.getChild(u);
          if (f) {
            if (t = Qt(e, f.length), td(e, n) && Tu(t, i)) {
              if (Tu(t, n)) {
                s = f;
                continue e;
              }
              if (!Sy(f, e, t, i, n, o, r, 0, l, c))
                return !1;
            }
            e = t;
          }
        }
        return !0;
      }
      case 2: {
        const d = !c || !s.closingBracket || s.closingBracket.bracketInfo.closesColorized(s.openingBracket.bracketInfo);
        let u = 0;
        if (l) {
          let g = l.get(s.openingBracket.text);
          g === void 0 && (g = 0), u = g, d && (g++, l.set(s.openingBracket.text, g));
        }
        const f = s.childrenLength;
        for (let g = 0; g < f; g++) {
          const m = s.getChild(g);
          if (m) {
            if (t = Qt(e, m.length), td(e, n) && Tu(t, i)) {
              if (Tu(t, n) && m.kind !== 1) {
                s = m, d ? (r++, a = u + 1) : a = u;
                continue e;
              }
              if ((d || m.kind !== 1 || !s.closingBracket) && !Sy(m, e, t, i, n, o, d ? r + 1 : r, d ? u + 1 : u, l, c, !s.closingBracket))
                return !1;
            }
            e = t;
          }
        }
        return l == null || l.set(s.openingBracket.text, u), !0;
      }
      case 3: {
        const d = Xl(e, t);
        return o(new QI(d, r - 1, 0, !0));
      }
      case 1: {
        const d = Xl(e, t);
        return o(new QI(d, r - 1, a - 1, h));
      }
      case 0:
        return !0;
    }
}
class RU {
  constructor(e, t, i) {
    this.push = e, this.includeMinIndentation = t, this.textModel = i;
  }
}
function Ly(s, e, t, i, n, o, r, a) {
  var c;
  if (r > 200)
    return !0;
  let l = !0;
  if (s.kind === 2) {
    let h = 0;
    if (a) {
      let f = a.get(s.openingBracket.text);
      f === void 0 && (f = 0), h = f, f++, a.set(s.openingBracket.text, f);
    }
    const d = Qt(e, s.openingBracket.length);
    let u = -1;
    if (o.includeMinIndentation && (u = s.computeMinIndentation(e, o.textModel)), l = o.push(new dU(Xl(e, t), Xl(e, d), s.closingBracket ? Xl(Qt(d, ((c = s.child) == null ? void 0 : c.length) || Cn), t) : void 0, r, h, s, u)), e = d, l && s.child) {
      const f = s.child;
      if (t = Qt(e, f.length), td(e, n) && Tu(t, i) && (l = Ly(f, e, t, i, n, o, r + 1, a), !l))
        return !1;
    }
    a == null || a.set(s.openingBracket.text, h);
  } else {
    let h = e;
    for (const d of s.children) {
      const u = h;
      if (h = Qt(h, d.length), td(u, n) && td(i, h) && (l = Ly(d, u, h, i, n, o, r, a), !l))
        return !1;
    }
  }
  return l;
}
class AU extends q {
  get canBuildAST() {
    return this.textModel.getValueLength() <= 5e6;
  }
  constructor(e, t) {
    super(), this.textModel = e, this.languageConfigurationService = t, this.bracketPairsTree = this._register(new Zr()), this.onDidChangeEmitter = new O(), this.onDidChange = this.onDidChangeEmitter.event, this.bracketsRequested = !1;
  }
  //#region TextModel events
  handleLanguageConfigurationServiceChange(e) {
    var t;
    (!e.languageId || (t = this.bracketPairsTree.value) != null && t.object.didLanguageChange(e.languageId)) && (this.bracketPairsTree.clear(), this.updateBracketPairsTree());
  }
  handleDidChangeOptions(e) {
    this.bracketPairsTree.clear(), this.updateBracketPairsTree();
  }
  handleDidChangeLanguage(e) {
    this.bracketPairsTree.clear(), this.updateBracketPairsTree();
  }
  handleDidChangeContent(e) {
    var t;
    (t = this.bracketPairsTree.value) == null || t.object.handleContentChanged(e);
  }
  handleDidChangeBackgroundTokenizationState() {
    var e;
    (e = this.bracketPairsTree.value) == null || e.object.handleDidChangeBackgroundTokenizationState();
  }
  handleDidChangeTokens(e) {
    var t;
    (t = this.bracketPairsTree.value) == null || t.object.handleDidChangeTokens(e);
  }
  //#endregion
  updateBracketPairsTree() {
    if (this.bracketsRequested && this.canBuildAST) {
      if (!this.bracketPairsTree.value) {
        const e = new he();
        this.bracketPairsTree.value = PU(e.add(new MU(this.textModel, (t) => this.languageConfigurationService.getLanguageConfiguration(t))), e), e.add(this.bracketPairsTree.value.object.onDidChange((t) => this.onDidChangeEmitter.fire(t))), this.onDidChangeEmitter.fire();
      }
    } else
      this.bracketPairsTree.value && (this.bracketPairsTree.clear(), this.onDidChangeEmitter.fire());
  }
  /**
   * Returns all bracket pairs that intersect the given range.
   * The result is sorted by the start position.
  */
  getBracketPairsInRange(e) {
    var t;
    return this.bracketsRequested = !0, this.updateBracketPairsTree(), ((t = this.bracketPairsTree.value) == null ? void 0 : t.object.getBracketPairsInRange(e, !1)) || Gl.empty;
  }
  getBracketPairsInRangeWithMinIndentation(e) {
    var t;
    return this.bracketsRequested = !0, this.updateBracketPairsTree(), ((t = this.bracketPairsTree.value) == null ? void 0 : t.object.getBracketPairsInRange(e, !0)) || Gl.empty;
  }
  getBracketsInRange(e, t = !1) {
    var i;
    return this.bracketsRequested = !0, this.updateBracketPairsTree(), ((i = this.bracketPairsTree.value) == null ? void 0 : i.object.getBracketsInRange(e, t)) || Gl.empty;
  }
  findMatchingBracketUp(e, t, i) {
    const n = this.textModel.validatePosition(t), o = this.textModel.getLanguageIdAtPosition(n.lineNumber, n.column);
    if (this.canBuildAST) {
      const r = this.languageConfigurationService.getLanguageConfiguration(o).bracketsNew.getClosingBracketInfo(e);
      if (!r)
        return null;
      const a = this.getBracketPairsInRange(R.fromPositions(t, t)).findLast((l) => r.closes(l.openingBracketInfo));
      return a ? a.openingBracketRange : null;
    } else {
      const r = e.toLowerCase(), a = this.languageConfigurationService.getLanguageConfiguration(o).brackets;
      if (!a)
        return null;
      const l = a.textIsBracket[r];
      return l ? Lm(this._findMatchingBracketUp(l, n, Y0(i))) : null;
    }
  }
  matchBracket(e, t) {
    if (this.canBuildAST) {
      const i = this.getBracketPairsInRange(R.fromPositions(e, e)).filter((n) => n.closingBracketRange !== void 0 && (n.openingBracketRange.containsPosition(e) || n.closingBracketRange.containsPosition(e))).findLastMaxBy(Ts((n) => n.openingBracketRange.containsPosition(e) ? n.openingBracketRange : n.closingBracketRange, R.compareRangesUsingStarts));
      return i ? [i.openingBracketRange, i.closingBracketRange] : null;
    } else {
      const i = Y0(t);
      return this._matchBracket(this.textModel.validatePosition(e), i);
    }
  }
  _establishBracketSearchOffsets(e, t, i, n) {
    const o = t.getCount(), r = t.getLanguageId(n);
    let a = Math.max(0, e.column - 1 - i.maxBracketLength);
    for (let c = n - 1; c >= 0; c--) {
      const h = t.getEndOffset(c);
      if (h <= a)
        break;
      if (Lo(t.getStandardTokenType(c)) || t.getLanguageId(c) !== r) {
        a = h;
        break;
      }
    }
    let l = Math.min(t.getLineContent().length, e.column - 1 + i.maxBracketLength);
    for (let c = n + 1; c < o; c++) {
      const h = t.getStartOffset(c);
      if (h >= l)
        break;
      if (Lo(t.getStandardTokenType(c)) || t.getLanguageId(c) !== r) {
        l = h;
        break;
      }
    }
    return { searchStartOffset: a, searchEndOffset: l };
  }
  _matchBracket(e, t) {
    const i = e.lineNumber, n = this.textModel.tokenization.getLineTokens(i), o = this.textModel.getLineContent(i), r = n.findTokenIndexAtOffset(e.column - 1);
    if (r < 0)
      return null;
    const a = this.languageConfigurationService.getLanguageConfiguration(n.getLanguageId(r)).brackets;
    if (a && !Lo(n.getStandardTokenType(r))) {
      let { searchStartOffset: l, searchEndOffset: c } = this._establishBracketSearchOffsets(e, n, a, r), h = null;
      for (; ; ) {
        const d = Ss.findNextBracketInRange(a.forwardRegex, i, o, l, c);
        if (!d)
          break;
        if (d.startColumn <= e.column && e.column <= d.endColumn) {
          const u = o.substring(d.startColumn - 1, d.endColumn - 1).toLowerCase(), f = this._matchFoundBracket(d, a.textIsBracket[u], a.textIsOpenBracket[u], t);
          if (f) {
            if (f instanceof vr)
              return null;
            h = f;
          }
        }
        l = d.endColumn - 1;
      }
      if (h)
        return h;
    }
    if (r > 0 && n.getStartOffset(r) === e.column - 1) {
      const l = r - 1, c = this.languageConfigurationService.getLanguageConfiguration(n.getLanguageId(l)).brackets;
      if (c && !Lo(n.getStandardTokenType(l))) {
        const { searchStartOffset: h, searchEndOffset: d } = this._establishBracketSearchOffsets(e, n, c, l), u = Ss.findPrevBracketInRange(c.reversedRegex, i, o, h, d);
        if (u && u.startColumn <= e.column && e.column <= u.endColumn) {
          const f = o.substring(u.startColumn - 1, u.endColumn - 1).toLowerCase(), g = this._matchFoundBracket(u, c.textIsBracket[f], c.textIsOpenBracket[f], t);
          if (g)
            return g instanceof vr ? null : g;
        }
      }
    }
    return null;
  }
  _matchFoundBracket(e, t, i, n) {
    if (!t)
      return null;
    const o = i ? this._findMatchingBracketDown(t, e.getEndPosition(), n) : this._findMatchingBracketUp(t, e.getStartPosition(), n);
    return o ? o instanceof vr ? o : [e, o] : null;
  }
  _findMatchingBracketUp(e, t, i) {
    const n = e.languageId, o = e.reversedRegex;
    let r = -1, a = 0;
    const l = (c, h, d, u) => {
      for (; ; ) {
        if (i && ++a % 100 === 0 && !i())
          return vr.INSTANCE;
        const f = Ss.findPrevBracketInRange(o, c, h, d, u);
        if (!f)
          break;
        const g = h.substring(f.startColumn - 1, f.endColumn - 1).toLowerCase();
        if (e.isOpen(g) ? r++ : e.isClose(g) && r--, r === 0)
          return f;
        u = f.startColumn - 1;
      }
      return null;
    };
    for (let c = t.lineNumber; c >= 1; c--) {
      const h = this.textModel.tokenization.getLineTokens(c), d = h.getCount(), u = this.textModel.getLineContent(c);
      let f = d - 1, g = u.length, m = u.length;
      c === t.lineNumber && (f = h.findTokenIndexAtOffset(t.column - 1), g = t.column - 1, m = t.column - 1);
      let _ = !0;
      for (; f >= 0; f--) {
        const b = h.getLanguageId(f) === n && !Lo(h.getStandardTokenType(f));
        if (b)
          _ ? g = h.getStartOffset(f) : (g = h.getStartOffset(f), m = h.getEndOffset(f));
        else if (_ && g !== m) {
          const C = l(c, u, g, m);
          if (C)
            return C;
        }
        _ = b;
      }
      if (_ && g !== m) {
        const b = l(c, u, g, m);
        if (b)
          return b;
      }
    }
    return null;
  }
  _findMatchingBracketDown(e, t, i) {
    const n = e.languageId, o = e.forwardRegex;
    let r = 1, a = 0;
    const l = (h, d, u, f) => {
      for (; ; ) {
        if (i && ++a % 100 === 0 && !i())
          return vr.INSTANCE;
        const g = Ss.findNextBracketInRange(o, h, d, u, f);
        if (!g)
          break;
        const m = d.substring(g.startColumn - 1, g.endColumn - 1).toLowerCase();
        if (e.isOpen(m) ? r++ : e.isClose(m) && r--, r === 0)
          return g;
        u = g.endColumn - 1;
      }
      return null;
    }, c = this.textModel.getLineCount();
    for (let h = t.lineNumber; h <= c; h++) {
      const d = this.textModel.tokenization.getLineTokens(h), u = d.getCount(), f = this.textModel.getLineContent(h);
      let g = 0, m = 0, _ = 0;
      h === t.lineNumber && (g = d.findTokenIndexAtOffset(t.column - 1), m = t.column - 1, _ = t.column - 1);
      let b = !0;
      for (; g < u; g++) {
        const C = d.getLanguageId(g) === n && !Lo(d.getStandardTokenType(g));
        if (C)
          b || (m = d.getStartOffset(g)), _ = d.getEndOffset(g);
        else if (b && m !== _) {
          const v = l(h, f, m, _);
          if (v)
            return v;
        }
        b = C;
      }
      if (b && m !== _) {
        const C = l(h, f, m, _);
        if (C)
          return C;
      }
    }
    return null;
  }
  findPrevBracket(e) {
    var r;
    const t = this.textModel.validatePosition(e);
    if (this.canBuildAST)
      return this.bracketsRequested = !0, this.updateBracketPairsTree(), ((r = this.bracketPairsTree.value) == null ? void 0 : r.object.getFirstBracketBefore(t)) || null;
    let i = null, n = null, o = null;
    for (let a = t.lineNumber; a >= 1; a--) {
      const l = this.textModel.tokenization.getLineTokens(a), c = l.getCount(), h = this.textModel.getLineContent(a);
      let d = c - 1, u = h.length, f = h.length;
      if (a === t.lineNumber) {
        d = l.findTokenIndexAtOffset(t.column - 1), u = t.column - 1, f = t.column - 1;
        const m = l.getLanguageId(d);
        i !== m && (i = m, n = this.languageConfigurationService.getLanguageConfiguration(i).brackets, o = this.languageConfigurationService.getLanguageConfiguration(i).bracketsNew);
      }
      let g = !0;
      for (; d >= 0; d--) {
        const m = l.getLanguageId(d);
        if (i !== m) {
          if (n && o && g && u !== f) {
            const b = Ss.findPrevBracketInRange(n.reversedRegex, a, h, u, f);
            if (b)
              return this._toFoundBracket(o, b);
            g = !1;
          }
          i = m, n = this.languageConfigurationService.getLanguageConfiguration(i).brackets, o = this.languageConfigurationService.getLanguageConfiguration(i).bracketsNew;
        }
        const _ = !!n && !Lo(l.getStandardTokenType(d));
        if (_)
          g ? u = l.getStartOffset(d) : (u = l.getStartOffset(d), f = l.getEndOffset(d));
        else if (o && n && g && u !== f) {
          const b = Ss.findPrevBracketInRange(n.reversedRegex, a, h, u, f);
          if (b)
            return this._toFoundBracket(o, b);
        }
        g = _;
      }
      if (o && n && g && u !== f) {
        const m = Ss.findPrevBracketInRange(n.reversedRegex, a, h, u, f);
        if (m)
          return this._toFoundBracket(o, m);
      }
    }
    return null;
  }
  findNextBracket(e) {
    var a;
    const t = this.textModel.validatePosition(e);
    if (this.canBuildAST)
      return this.bracketsRequested = !0, this.updateBracketPairsTree(), ((a = this.bracketPairsTree.value) == null ? void 0 : a.object.getFirstBracketAfter(t)) || null;
    const i = this.textModel.getLineCount();
    let n = null, o = null, r = null;
    for (let l = t.lineNumber; l <= i; l++) {
      const c = this.textModel.tokenization.getLineTokens(l), h = c.getCount(), d = this.textModel.getLineContent(l);
      let u = 0, f = 0, g = 0;
      if (l === t.lineNumber) {
        u = c.findTokenIndexAtOffset(t.column - 1), f = t.column - 1, g = t.column - 1;
        const _ = c.getLanguageId(u);
        n !== _ && (n = _, o = this.languageConfigurationService.getLanguageConfiguration(n).brackets, r = this.languageConfigurationService.getLanguageConfiguration(n).bracketsNew);
      }
      let m = !0;
      for (; u < h; u++) {
        const _ = c.getLanguageId(u);
        if (n !== _) {
          if (r && o && m && f !== g) {
            const C = Ss.findNextBracketInRange(o.forwardRegex, l, d, f, g);
            if (C)
              return this._toFoundBracket(r, C);
            m = !1;
          }
          n = _, o = this.languageConfigurationService.getLanguageConfiguration(n).brackets, r = this.languageConfigurationService.getLanguageConfiguration(n).bracketsNew;
        }
        const b = !!o && !Lo(c.getStandardTokenType(u));
        if (b)
          m || (f = c.getStartOffset(u)), g = c.getEndOffset(u);
        else if (r && o && m && f !== g) {
          const C = Ss.findNextBracketInRange(o.forwardRegex, l, d, f, g);
          if (C)
            return this._toFoundBracket(r, C);
        }
        m = b;
      }
      if (r && o && m && f !== g) {
        const _ = Ss.findNextBracketInRange(o.forwardRegex, l, d, f, g);
        if (_)
          return this._toFoundBracket(r, _);
      }
    }
    return null;
  }
  findEnclosingBrackets(e, t) {
    const i = this.textModel.validatePosition(e);
    if (this.canBuildAST) {
      const f = R.fromPositions(i), g = this.getBracketPairsInRange(R.fromPositions(i, i)).findLast((m) => m.closingBracketRange !== void 0 && m.range.strictContainsRange(f));
      return g ? [g.openingBracketRange, g.closingBracketRange] : null;
    }
    const n = Y0(t), o = this.textModel.getLineCount(), r = /* @__PURE__ */ new Map();
    let a = [];
    const l = (f, g) => {
      if (!r.has(f)) {
        const m = [];
        for (let _ = 0, b = g ? g.brackets.length : 0; _ < b; _++)
          m[_] = 0;
        r.set(f, m);
      }
      a = r.get(f);
    };
    let c = 0;
    const h = (f, g, m, _, b) => {
      for (; ; ) {
        if (n && ++c % 100 === 0 && !n())
          return vr.INSTANCE;
        const C = Ss.findNextBracketInRange(f.forwardRegex, g, m, _, b);
        if (!C)
          break;
        const v = m.substring(C.startColumn - 1, C.endColumn - 1).toLowerCase(), w = f.textIsBracket[v];
        if (w && (w.isOpen(v) ? a[w.index]++ : w.isClose(v) && a[w.index]--, a[w.index] === -1))
          return this._matchFoundBracket(C, w, !1, n);
        _ = C.endColumn - 1;
      }
      return null;
    };
    let d = null, u = null;
    for (let f = i.lineNumber; f <= o; f++) {
      const g = this.textModel.tokenization.getLineTokens(f), m = g.getCount(), _ = this.textModel.getLineContent(f);
      let b = 0, C = 0, v = 0;
      if (f === i.lineNumber) {
        b = g.findTokenIndexAtOffset(i.column - 1), C = i.column - 1, v = i.column - 1;
        const S = g.getLanguageId(b);
        d !== S && (d = S, u = this.languageConfigurationService.getLanguageConfiguration(d).brackets, l(d, u));
      }
      let w = !0;
      for (; b < m; b++) {
        const S = g.getLanguageId(b);
        if (d !== S) {
          if (u && w && C !== v) {
            const k = h(u, f, _, C, v);
            if (k)
              return Lm(k);
            w = !1;
          }
          d = S, u = this.languageConfigurationService.getLanguageConfiguration(d).brackets, l(d, u);
        }
        const L = !!u && !Lo(g.getStandardTokenType(b));
        if (L)
          w || (C = g.getStartOffset(b)), v = g.getEndOffset(b);
        else if (u && w && C !== v) {
          const k = h(u, f, _, C, v);
          if (k)
            return Lm(k);
        }
        w = L;
      }
      if (u && w && C !== v) {
        const S = h(u, f, _, C, v);
        if (S)
          return Lm(S);
      }
    }
    return null;
  }
  _toFoundBracket(e, t) {
    if (!t)
      return null;
    let i = this.textModel.getValueInRange(t);
    i = i.toLowerCase();
    const n = e.getBracketInfo(i);
    return n ? {
      range: t,
      bracketInfo: n
    } : null;
  }
}
function PU(s, e) {
  return {
    object: s,
    dispose: () => e == null ? void 0 : e.dispose()
  };
}
function Y0(s) {
  if (typeof s > "u")
    return () => !0;
  {
    const e = Date.now();
    return () => Date.now() - e <= s;
  }
}
const S1 = class S1 {
  constructor() {
    this._searchCanceledBrand = void 0;
  }
};
S1.INSTANCE = new S1();
let vr = S1;
function Lm(s) {
  return s instanceof vr ? null : s;
}
class OU extends q {
  constructor(e) {
    super(), this.textModel = e, this.colorProvider = new jA(), this.onDidChangeEmitter = new O(), this.onDidChange = this.onDidChangeEmitter.event, this.colorizationOptions = e.getOptions().bracketPairColorizationOptions, this._register(e.bracketPairs.onDidChange((t) => {
      this.onDidChangeEmitter.fire();
    }));
  }
  //#region TextModel events
  handleDidChangeOptions(e) {
    this.colorizationOptions = this.textModel.getOptions().bracketPairColorizationOptions;
  }
  //#endregion
  getDecorationsInRange(e, t, i, n) {
    return n ? [] : t === void 0 ? [] : this.colorizationOptions.enabled ? this.textModel.bracketPairs.getBracketsInRange(e, !0).map((r) => ({
      id: `bracket${r.range.toString()}-${r.nestingLevel}`,
      options: {
        description: "BracketPairColorization",
        inlineClassName: this.colorProvider.getInlineClassName(r, this.colorizationOptions.independentColorPoolPerBracketType)
      },
      ownerId: 0,
      range: r.range
    })).toArray() : [];
  }
  getAllDecorations(e, t) {
    return e === void 0 ? [] : this.colorizationOptions.enabled ? this.getDecorationsInRange(new R(1, 1, this.textModel.getLineCount(), 1), e, t) : [];
  }
}
class jA {
  constructor() {
    this.unexpectedClosingBracketClassName = "unexpected-closing-bracket";
  }
  getInlineClassName(e, t) {
    return e.isInvalid ? this.unexpectedClosingBracketClassName : this.getInlineClassNameOfLevel(t ? e.nestingLevelOfEqualBracketType : e.nestingLevel);
  }
  getInlineClassNameOfLevel(e) {
    return `bracket-highlighting-${e % 30}`;
  }
}
Jr((s, e) => {
  const t = [
    PA,
    OA,
    FA,
    BA,
    WA,
    VA
  ], i = new jA();
  e.addRule(`.monaco-editor .${i.unexpectedClosingBracketClassName} { color: ${s.getColor(qz)}; }`);
  const n = t.map((o) => s.getColor(o)).filter((o) => !!o).filter((o) => !o.isTransparent());
  for (let o = 0; o < 30; o++) {
    const r = n[o % n.length];
    e.addRule(`.monaco-editor .${i.getInlineClassNameOfLevel(o)} { color: ${r}; }`);
  }
});
function km(s) {
  return s.replace(/\n/g, "\\n").replace(/\r/g, "\\r");
}
class Ni {
  get oldLength() {
    return this.oldText.length;
  }
  get oldEnd() {
    return this.oldPosition + this.oldText.length;
  }
  get newLength() {
    return this.newText.length;
  }
  get newEnd() {
    return this.newPosition + this.newText.length;
  }
  constructor(e, t, i, n) {
    this.oldPosition = e, this.oldText = t, this.newPosition = i, this.newText = n;
  }
  toString() {
    return this.oldText.length === 0 ? `(insert@${this.oldPosition} "${km(this.newText)}")` : this.newText.length === 0 ? `(delete@${this.oldPosition} "${km(this.oldText)}")` : `(replace@${this.oldPosition} "${km(this.oldText)}" with "${km(this.newText)}")`;
  }
  static _writeStringSize(e) {
    return 4 + 2 * e.length;
  }
  static _writeString(e, t, i) {
    const n = t.length;
    Ys(e, n, i), i += 4;
    for (let o = 0; o < n; o++)
      g3(e, t.charCodeAt(o), i), i += 2;
    return i;
  }
  static _readString(e, t) {
    const i = Zs(e, t);
    return t += 4, p3(e, t, i);
  }
  writeSize() {
    return 8 + Ni._writeStringSize(this.oldText) + Ni._writeStringSize(this.newText);
  }
  write(e, t) {
    return Ys(e, this.oldPosition, t), t += 4, Ys(e, this.newPosition, t), t += 4, t = Ni._writeString(e, this.oldText, t), t = Ni._writeString(e, this.newText, t), t;
  }
  static read(e, t, i) {
    const n = Zs(e, t);
    t += 4;
    const o = Zs(e, t);
    t += 4;
    const r = Ni._readString(e, t);
    t += Ni._writeStringSize(r);
    const a = Ni._readString(e, t);
    return t += Ni._writeStringSize(a), i.push(new Ni(n, r, o, a)), t;
  }
}
function FU(s, e) {
  return s === null || s.length === 0 ? e : new xo(s, e).compress();
}
class xo {
  constructor(e, t) {
    this._prevEdits = e, this._currEdits = t, this._result = [], this._resultLen = 0, this._prevLen = this._prevEdits.length, this._prevDeltaOffset = 0, this._currLen = this._currEdits.length, this._currDeltaOffset = 0;
  }
  compress() {
    let e = 0, t = 0, i = this._getPrev(e), n = this._getCurr(t);
    for (; e < this._prevLen || t < this._currLen; ) {
      if (i === null) {
        this._acceptCurr(n), n = this._getCurr(++t);
        continue;
      }
      if (n === null) {
        this._acceptPrev(i), i = this._getPrev(++e);
        continue;
      }
      if (n.oldEnd <= i.newPosition) {
        this._acceptCurr(n), n = this._getCurr(++t);
        continue;
      }
      if (i.newEnd <= n.oldPosition) {
        this._acceptPrev(i), i = this._getPrev(++e);
        continue;
      }
      if (n.oldPosition < i.newPosition) {
        const [c, h] = xo._splitCurr(n, i.newPosition - n.oldPosition);
        this._acceptCurr(c), n = h;
        continue;
      }
      if (i.newPosition < n.oldPosition) {
        const [c, h] = xo._splitPrev(i, n.oldPosition - i.newPosition);
        this._acceptPrev(c), i = h;
        continue;
      }
      let a, l;
      if (n.oldEnd === i.newEnd)
        a = i, l = n, i = this._getPrev(++e), n = this._getCurr(++t);
      else if (n.oldEnd < i.newEnd) {
        const [c, h] = xo._splitPrev(i, n.oldLength);
        a = c, l = n, i = h, n = this._getCurr(++t);
      } else {
        const [c, h] = xo._splitCurr(n, i.newLength);
        a = i, l = c, i = this._getPrev(++e), n = h;
      }
      this._result[this._resultLen++] = new Ni(a.oldPosition, a.oldText, l.newPosition, l.newText), this._prevDeltaOffset += a.newLength - a.oldLength, this._currDeltaOffset += l.newLength - l.oldLength;
    }
    const o = xo._merge(this._result);
    return xo._removeNoOps(o);
  }
  _acceptCurr(e) {
    this._result[this._resultLen++] = xo._rebaseCurr(this._prevDeltaOffset, e), this._currDeltaOffset += e.newLength - e.oldLength;
  }
  _getCurr(e) {
    return e < this._currLen ? this._currEdits[e] : null;
  }
  _acceptPrev(e) {
    this._result[this._resultLen++] = xo._rebasePrev(this._currDeltaOffset, e), this._prevDeltaOffset += e.newLength - e.oldLength;
  }
  _getPrev(e) {
    return e < this._prevLen ? this._prevEdits[e] : null;
  }
  static _rebaseCurr(e, t) {
    return new Ni(t.oldPosition - e, t.oldText, t.newPosition, t.newText);
  }
  static _rebasePrev(e, t) {
    return new Ni(t.oldPosition, t.oldText, t.newPosition + e, t.newText);
  }
  static _splitPrev(e, t) {
    const i = e.newText.substr(0, t), n = e.newText.substr(t);
    return [
      new Ni(e.oldPosition, e.oldText, e.newPosition, i),
      new Ni(e.oldEnd, "", e.newPosition + t, n)
    ];
  }
  static _splitCurr(e, t) {
    const i = e.oldText.substr(0, t), n = e.oldText.substr(t);
    return [
      new Ni(e.oldPosition, i, e.newPosition, e.newText),
      new Ni(e.oldPosition + t, n, e.newEnd, "")
    ];
  }
  static _merge(e) {
    if (e.length === 0)
      return e;
    const t = [];
    let i = 0, n = e[0];
    for (let o = 1; o < e.length; o++) {
      const r = e[o];
      n.oldEnd === r.oldPosition ? n = new Ni(n.oldPosition, n.oldText + r.oldText, n.newPosition, n.newText + r.newText) : (t[i++] = n, n = r);
    }
    return t[i++] = n, t;
  }
  static _removeNoOps(e) {
    if (e.length === 0)
      return e;
    const t = [];
    let i = 0;
    for (let n = 0; n < e.length; n++) {
      const o = e[n];
      o.oldText !== o.newText && (t[i++] = o);
    }
    return t;
  }
}
function ih(s) {
  return s.toString();
}
class li {
  static create(e, t) {
    const i = e.getAlternativeVersionId(), n = ky(e);
    return new li(i, i, n, n, t, t, []);
  }
  constructor(e, t, i, n, o, r, a) {
    this.beforeVersionId = e, this.afterVersionId = t, this.beforeEOL = i, this.afterEOL = n, this.beforeCursorState = o, this.afterCursorState = r, this.changes = a;
  }
  append(e, t, i, n, o) {
    t.length > 0 && (this.changes = FU(this.changes, t)), this.afterEOL = i, this.afterVersionId = n, this.afterCursorState = o;
  }
  static _writeSelectionsSize(e) {
    return 4 + 16 * (e ? e.length : 0);
  }
  static _writeSelections(e, t, i) {
    if (Ys(e, t ? t.length : 0, i), i += 4, t)
      for (const n of t)
        Ys(e, n.selectionStartLineNumber, i), i += 4, Ys(e, n.selectionStartColumn, i), i += 4, Ys(e, n.positionLineNumber, i), i += 4, Ys(e, n.positionColumn, i), i += 4;
    return i;
  }
  static _readSelections(e, t, i) {
    const n = Zs(e, t);
    t += 4;
    for (let o = 0; o < n; o++) {
      const r = Zs(e, t);
      t += 4;
      const a = Zs(e, t);
      t += 4;
      const l = Zs(e, t);
      t += 4;
      const c = Zs(e, t);
      t += 4, i.push(new ft(r, a, l, c));
    }
    return t;
  }
  serialize() {
    let e = 10 + li._writeSelectionsSize(this.beforeCursorState) + li._writeSelectionsSize(this.afterCursorState) + 4;
    for (const n of this.changes)
      e += n.writeSize();
    const t = new Uint8Array(e);
    let i = 0;
    Ys(t, this.beforeVersionId, i), i += 4, Ys(t, this.afterVersionId, i), i += 4, YD(t, this.beforeEOL, i), i += 1, YD(t, this.afterEOL, i), i += 1, i = li._writeSelections(t, this.beforeCursorState, i), i = li._writeSelections(t, this.afterCursorState, i), Ys(t, this.changes.length, i), i += 4;
    for (const n of this.changes)
      i = n.write(t, i);
    return t.buffer;
  }
  static deserialize(e) {
    const t = new Uint8Array(e);
    let i = 0;
    const n = Zs(t, i);
    i += 4;
    const o = Zs(t, i);
    i += 4;
    const r = ZD(t, i);
    i += 1;
    const a = ZD(t, i);
    i += 1;
    const l = [];
    i = li._readSelections(t, i, l);
    const c = [];
    i = li._readSelections(t, i, c);
    const h = Zs(t, i);
    i += 4;
    const d = [];
    for (let u = 0; u < h; u++)
      i = Ni.read(t, i, d);
    return new li(n, o, r, a, l, c, d);
  }
}
class GA {
  get type() {
    return 0;
  }
  get resource() {
    return Te.isUri(this.model) ? this.model : this.model.uri;
  }
  constructor(e, t, i, n) {
    this.label = e, this.code = t, this.model = i, this._data = li.create(i, n);
  }
  toString() {
    return (this._data instanceof li ? this._data : li.deserialize(this._data)).changes.map((t) => t.toString()).join(", ");
  }
  matchesResource(e) {
    return (Te.isUri(this.model) ? this.model : this.model.uri).toString() === e.toString();
  }
  setModel(e) {
    this.model = e;
  }
  canAppend(e) {
    return this.model === e && this._data instanceof li;
  }
  append(e, t, i, n, o) {
    this._data instanceof li && this._data.append(e, t, i, n, o);
  }
  close() {
    this._data instanceof li && (this._data = this._data.serialize());
  }
  open() {
    this._data instanceof li || (this._data = li.deserialize(this._data));
  }
  undo() {
    if (Te.isUri(this.model))
      throw new Error("Invalid SingleModelEditStackElement");
    this._data instanceof li && (this._data = this._data.serialize());
    const e = li.deserialize(this._data);
    this.model._applyUndo(e.changes, e.beforeEOL, e.beforeVersionId, e.beforeCursorState);
  }
  redo() {
    if (Te.isUri(this.model))
      throw new Error("Invalid SingleModelEditStackElement");
    this._data instanceof li && (this._data = this._data.serialize());
    const e = li.deserialize(this._data);
    this.model._applyRedo(e.changes, e.afterEOL, e.afterVersionId, e.afterCursorState);
  }
  heapSize() {
    return this._data instanceof li && (this._data = this._data.serialize()), this._data.byteLength + 168;
  }
}
class BU {
  get resources() {
    return this._editStackElementsArr.map((e) => e.resource);
  }
  constructor(e, t, i) {
    this.label = e, this.code = t, this.type = 1, this._isOpen = !0, this._editStackElementsArr = i.slice(0), this._editStackElementsMap = /* @__PURE__ */ new Map();
    for (const n of this._editStackElementsArr) {
      const o = ih(n.resource);
      this._editStackElementsMap.set(o, n);
    }
    this._delegate = null;
  }
  prepareUndoRedo() {
    if (this._delegate)
      return this._delegate.prepareUndoRedo(this);
  }
  matchesResource(e) {
    const t = ih(e);
    return this._editStackElementsMap.has(t);
  }
  setModel(e) {
    const t = ih(Te.isUri(e) ? e : e.uri);
    this._editStackElementsMap.has(t) && this._editStackElementsMap.get(t).setModel(e);
  }
  canAppend(e) {
    if (!this._isOpen)
      return !1;
    const t = ih(e.uri);
    return this._editStackElementsMap.has(t) ? this._editStackElementsMap.get(t).canAppend(e) : !1;
  }
  append(e, t, i, n, o) {
    const r = ih(e.uri);
    this._editStackElementsMap.get(r).append(e, t, i, n, o);
  }
  close() {
    this._isOpen = !1;
  }
  open() {
  }
  undo() {
    this._isOpen = !1;
    for (const e of this._editStackElementsArr)
      e.undo();
  }
  redo() {
    for (const e of this._editStackElementsArr)
      e.redo();
  }
  heapSize(e) {
    const t = ih(e);
    return this._editStackElementsMap.has(t) ? this._editStackElementsMap.get(t).heapSize() : 0;
  }
  split() {
    return this._editStackElementsArr;
  }
  toString() {
    const e = [];
    for (const t of this._editStackElementsArr)
      e.push(`${wk(t.resource)}: ${t}`);
    return `{${e.join(", ")}}`;
  }
}
function ky(s) {
  return s.getEOL() === `
` ? 0 : 1;
}
function yr(s) {
  return s ? s instanceof GA || s instanceof BU : !1;
}
class zk {
  constructor(e, t) {
    this._model = e, this._undoRedoService = t;
  }
  pushStackElement() {
    const e = this._undoRedoService.getLastElement(this._model.uri);
    yr(e) && e.close();
  }
  popStackElement() {
    const e = this._undoRedoService.getLastElement(this._model.uri);
    yr(e) && e.open();
  }
  clear() {
    this._undoRedoService.removeElements(this._model.uri);
  }
  _getOrCreateEditStackElement(e, t) {
    const i = this._undoRedoService.getLastElement(this._model.uri);
    if (yr(i) && i.canAppend(this._model))
      return i;
    const n = new GA(p("edit", "Typing"), "undoredo.textBufferEdit", this._model, e);
    return this._undoRedoService.pushElement(n, t), n;
  }
  pushEOL(e) {
    const t = this._getOrCreateEditStackElement(null, void 0);
    this._model.setEOL(e), t.append(this._model, [], ky(this._model), this._model.getAlternativeVersionId(), null);
  }
  pushEditOperation(e, t, i, n) {
    const o = this._getOrCreateEditStackElement(e, n), r = this._model.applyEdits(t, !0), a = zk._computeCursorState(i, r), l = r.map((c, h) => ({ index: h, textChange: c.textChange }));
    return l.sort((c, h) => c.textChange.oldPosition === h.textChange.oldPosition ? c.index - h.index : c.textChange.oldPosition - h.textChange.oldPosition), o.append(this._model, l.map((c) => c.textChange), ky(this._model), this._model.getAlternativeVersionId(), a), a;
  }
  static _computeCursorState(e, t) {
    try {
      return e ? e(t) : null;
    } catch (i) {
      return ht(i), null;
    }
  }
}
class ZA extends q {
  constructor() {
    super(...arguments), this._isDisposed = !1;
  }
  dispose() {
    super.dispose(), this._isDisposed = !0;
  }
  assertNotDisposed() {
    if (this._isDisposed)
      throw new Error("TextModelPart is disposed!");
  }
}
function WU(s, e) {
  let t = 0, i = 0;
  const n = s.length;
  for (; i < n; ) {
    const o = s.charCodeAt(i);
    if (o === 32)
      t++;
    else if (o === 9)
      t = t - t % e + e;
    else
      break;
    i++;
  }
  return i === n ? -1 : t;
}
var Jl;
(function(s) {
  s[s.Disabled = 0] = "Disabled", s[s.EnabledForActive = 1] = "EnabledForActive", s[s.Enabled = 2] = "Enabled";
})(Jl || (Jl = {}));
class Kl {
  constructor(e, t, i, n, o, r) {
    if (this.visibleColumn = e, this.column = t, this.className = i, this.horizontalLine = n, this.forWrappedLinesAfterColumn = o, this.forWrappedLinesBeforeOrAtColumn = r, e !== -1 == (t !== -1))
      throw new Error();
  }
}
class Zu {
  constructor(e, t) {
    this.top = e, this.endColumn = t;
  }
}
class VU extends ZA {
  constructor(e, t) {
    super(), this.textModel = e, this.languageConfigurationService = t;
  }
  getLanguageConfiguration(e) {
    return this.languageConfigurationService.getLanguageConfiguration(e);
  }
  _computeIndentLevel(e) {
    return WU(this.textModel.getLineContent(e + 1), this.textModel.getOptions().tabSize);
  }
  getActiveIndentGuide(e, t, i) {
    this.assertNotDisposed();
    const n = this.textModel.getLineCount();
    if (e < 1 || e > n)
      throw new it("Illegal value for lineNumber");
    const o = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules, r = !!(o && o.offSide);
    let a = -2, l = -1, c = -2, h = -1;
    const d = (k) => {
      if (a !== -1 && (a === -2 || a > k - 1)) {
        a = -1, l = -1;
        for (let D = k - 2; D >= 0; D--) {
          const E = this._computeIndentLevel(D);
          if (E >= 0) {
            a = D, l = E;
            break;
          }
        }
      }
      if (c === -2) {
        c = -1, h = -1;
        for (let D = k; D < n; D++) {
          const E = this._computeIndentLevel(D);
          if (E >= 0) {
            c = D, h = E;
            break;
          }
        }
      }
    };
    let u = -2, f = -1, g = -2, m = -1;
    const _ = (k) => {
      if (u === -2) {
        u = -1, f = -1;
        for (let D = k - 2; D >= 0; D--) {
          const E = this._computeIndentLevel(D);
          if (E >= 0) {
            u = D, f = E;
            break;
          }
        }
      }
      if (g !== -1 && (g === -2 || g < k - 1)) {
        g = -1, m = -1;
        for (let D = k; D < n; D++) {
          const E = this._computeIndentLevel(D);
          if (E >= 0) {
            g = D, m = E;
            break;
          }
        }
      }
    };
    let b = 0, C = !0, v = 0, w = !0, S = 0, L = 0;
    for (let k = 0; C || w; k++) {
      const D = e - k, E = e + k;
      k > 1 && (D < 1 || D < t) && (C = !1), k > 1 && (E > n || E > i) && (w = !1), k > 5e4 && (C = !1, w = !1);
      let U = -1;
      if (C && D >= 1) {
        const B = this._computeIndentLevel(D - 1);
        B >= 0 ? (c = D - 1, h = B, U = Math.ceil(B / this.textModel.getOptions().indentSize)) : (d(D), U = this._getIndentLevelForWhitespaceLine(r, l, h));
      }
      let P = -1;
      if (w && E <= n) {
        const B = this._computeIndentLevel(E - 1);
        B >= 0 ? (u = E - 1, f = B, P = Math.ceil(B / this.textModel.getOptions().indentSize)) : (_(E), P = this._getIndentLevelForWhitespaceLine(r, f, m));
      }
      if (k === 0) {
        L = U;
        continue;
      }
      if (k === 1) {
        if (E <= n && P >= 0 && L + 1 === P) {
          C = !1, b = E, v = E, S = P;
          continue;
        }
        if (D >= 1 && U >= 0 && U - 1 === L) {
          w = !1, b = D, v = D, S = U;
          continue;
        }
        if (b = e, v = e, S = L, S === 0)
          return { startLineNumber: b, endLineNumber: v, indent: S };
      }
      C && (U >= S ? b = D : C = !1), w && (P >= S ? v = E : w = !1);
    }
    return { startLineNumber: b, endLineNumber: v, indent: S };
  }
  getLinesBracketGuides(e, t, i, n) {
    var d;
    const o = [];
    for (let u = e; u <= t; u++)
      o.push([]);
    const r = !0, a = this.textModel.bracketPairs.getBracketPairsInRangeWithMinIndentation(new R(e, 1, t, this.textModel.getLineMaxColumn(t))).toArray();
    let l;
    if (i && a.length > 0) {
      const u = (e <= i.lineNumber && i.lineNumber <= t ? a : this.textModel.bracketPairs.getBracketPairsInRange(R.fromPositions(i)).toArray()).filter((f) => R.strictContainsPosition(f.range, i));
      l = (d = Op(u, (f) => r)) == null ? void 0 : d.range;
    }
    const c = this.textModel.getOptions().bracketPairColorizationOptions.independentColorPoolPerBracketType, h = new YA();
    for (const u of a) {
      if (!u.closingBracketRange)
        continue;
      const f = l && u.range.equalsRange(l);
      if (!f && !n.includeInactive)
        continue;
      const g = h.getInlineClassName(u.nestingLevel, u.nestingLevelOfEqualBracketType, c) + (n.highlightActive && f ? " " + h.activeClassName : ""), m = u.openingBracketRange.getStartPosition(), _ = u.closingBracketRange.getStartPosition(), b = n.horizontalGuides === Jl.Enabled || n.horizontalGuides === Jl.EnabledForActive && f;
      if (u.range.startLineNumber === u.range.endLineNumber) {
        b && o[u.range.startLineNumber - e].push(new Kl(-1, u.openingBracketRange.getEndPosition().column, g, new Zu(!1, _.column), -1, -1));
        continue;
      }
      const C = this.getVisibleColumnFromPosition(_), v = this.getVisibleColumnFromPosition(u.openingBracketRange.getStartPosition()), w = Math.min(v, C, u.minVisibleColumnIndentation + 1);
      let S = !1;
      On(this.textModel.getLineContent(u.closingBracketRange.startLineNumber)) < u.closingBracketRange.startColumn - 1 && (S = !0);
      const D = Math.max(m.lineNumber, e), E = Math.min(_.lineNumber, t), U = S ? 1 : 0;
      for (let P = D; P < E + U; P++)
        o[P - e].push(new Kl(w, -1, g, null, P === m.lineNumber ? m.column : -1, P === _.lineNumber ? _.column : -1));
      b && (m.lineNumber >= e && v > w && o[m.lineNumber - e].push(new Kl(w, -1, g, new Zu(!1, m.column), -1, -1)), _.lineNumber <= t && C > w && o[_.lineNumber - e].push(new Kl(w, -1, g, new Zu(!S, _.column), -1, -1)));
    }
    for (const u of o)
      u.sort((f, g) => f.visibleColumn - g.visibleColumn);
    return o;
  }
  getVisibleColumnFromPosition(e) {
    return ii.visibleColumnFromColumn(this.textModel.getLineContent(e.lineNumber), e.column, this.textModel.getOptions().tabSize) + 1;
  }
  getLinesIndentGuides(e, t) {
    this.assertNotDisposed();
    const i = this.textModel.getLineCount();
    if (e < 1 || e > i)
      throw new Error("Illegal value for startLineNumber");
    if (t < 1 || t > i)
      throw new Error("Illegal value for endLineNumber");
    const n = this.textModel.getOptions(), o = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules, r = !!(o && o.offSide), a = new Array(t - e + 1);
    let l = -2, c = -1, h = -2, d = -1;
    for (let u = e; u <= t; u++) {
      const f = u - e, g = this._computeIndentLevel(u - 1);
      if (g >= 0) {
        l = u - 1, c = g, a[f] = Math.ceil(g / n.indentSize);
        continue;
      }
      if (l === -2) {
        l = -1, c = -1;
        for (let m = u - 2; m >= 0; m--) {
          const _ = this._computeIndentLevel(m);
          if (_ >= 0) {
            l = m, c = _;
            break;
          }
        }
      }
      if (h !== -1 && (h === -2 || h < u - 1)) {
        h = -1, d = -1;
        for (let m = u; m < i; m++) {
          const _ = this._computeIndentLevel(m);
          if (_ >= 0) {
            h = m, d = _;
            break;
          }
        }
      }
      a[f] = this._getIndentLevelForWhitespaceLine(r, c, d);
    }
    return a;
  }
  _getIndentLevelForWhitespaceLine(e, t, i) {
    const n = this.textModel.getOptions();
    return t === -1 || i === -1 ? 0 : t < i ? 1 + Math.floor(t / n.indentSize) : t === i || e ? Math.ceil(i / n.indentSize) : 1 + Math.floor(i / n.indentSize);
  }
}
class YA {
  constructor() {
    this.activeClassName = "indent-active";
  }
  getInlineClassName(e, t, i) {
    return this.getInlineClassNameOfLevel(i ? t : e);
  }
  getInlineClassNameOfLevel(e) {
    return `bracket-indent-guide lvl-${e % 30}`;
  }
}
class HU {
  constructor() {
    this.spacesDiff = 0, this.looksLikeAlignment = !1;
  }
}
function zU(s, e, t, i, n) {
  n.spacesDiff = 0, n.looksLikeAlignment = !1;
  let o;
  for (o = 0; o < e && o < i; o++) {
    const u = s.charCodeAt(o), f = t.charCodeAt(o);
    if (u !== f)
      break;
  }
  let r = 0, a = 0;
  for (let u = o; u < e; u++)
    s.charCodeAt(u) === 32 ? r++ : a++;
  let l = 0, c = 0;
  for (let u = o; u < i; u++)
    t.charCodeAt(u) === 32 ? l++ : c++;
  if (r > 0 && a > 0 || l > 0 && c > 0)
    return;
  const h = Math.abs(a - c), d = Math.abs(r - l);
  if (h === 0) {
    n.spacesDiff = d, d > 0 && 0 <= l - 1 && l - 1 < s.length && l < t.length && t.charCodeAt(l) !== 32 && s.charCodeAt(l - 1) === 32 && s.charCodeAt(s.length - 1) === 44 && (n.looksLikeAlignment = !0);
    return;
  }
  if (d % h === 0) {
    n.spacesDiff = d / h;
    return;
  }
}
function iN(s, e, t) {
  const i = Math.min(s.getLineCount(), 1e4);
  let n = 0, o = 0, r = "", a = 0;
  const l = [2, 4, 6, 8, 3, 5, 7], c = 8, h = [0, 0, 0, 0, 0, 0, 0, 0, 0], d = new HU();
  for (let g = 1; g <= i; g++) {
    const m = s.getLineLength(g), _ = s.getLineContent(g), b = m <= 65536;
    let C = !1, v = 0, w = 0, S = 0;
    for (let k = 0, D = m; k < D; k++) {
      const E = b ? _.charCodeAt(k) : s.getLineCharCode(g, k);
      if (E === 9)
        S++;
      else if (E === 32)
        w++;
      else {
        C = !0, v = k;
        break;
      }
    }
    if (!C || (S > 0 ? n++ : w > 1 && o++, zU(r, a, _, v, d), d.looksLikeAlignment && !(t && e === d.spacesDiff)))
      continue;
    const L = d.spacesDiff;
    L <= c && h[L]++, r = _, a = v;
  }
  let u = t;
  n !== o && (u = n < o);
  let f = e;
  if (u) {
    let g = u ? 0 : 0.1 * i;
    l.forEach((m) => {
      const _ = h[m];
      _ > g && (g = _, f = m);
    }), f === 4 && h[4] > 0 && h[2] > 0 && h[2] >= h[4] / 2 && (f = 2);
  }
  return {
    insertSpaces: u,
    tabSize: f
  };
}
function un(s) {
  return (s.metadata & 1) >>> 0;
}
function yt(s, e) {
  s.metadata = s.metadata & 254 | e << 0;
}
function Mi(s) {
  return (s.metadata & 2) >>> 1 === 1;
}
function Ct(s, e) {
  s.metadata = s.metadata & 253 | (e ? 1 : 0) << 1;
}
function QA(s) {
  return (s.metadata & 4) >>> 2 === 1;
}
function nN(s, e) {
  s.metadata = s.metadata & 251 | (e ? 1 : 0) << 2;
}
function XA(s) {
  return (s.metadata & 64) >>> 6 === 1;
}
function sN(s, e) {
  s.metadata = s.metadata & 191 | (e ? 1 : 0) << 6;
}
function UU(s) {
  return (s.metadata & 24) >>> 3;
}
function oN(s, e) {
  s.metadata = s.metadata & 231 | e << 3;
}
function $U(s) {
  return (s.metadata & 32) >>> 5 === 1;
}
function rN(s, e) {
  s.metadata = s.metadata & 223 | (e ? 1 : 0) << 5;
}
class JA {
  constructor(e, t, i) {
    this.metadata = 0, this.parent = this, this.left = this, this.right = this, yt(
      this,
      1
      /* NodeColor.Red */
    ), this.start = t, this.end = i, this.delta = 0, this.maxEnd = i, this.id = e, this.ownerId = 0, this.options = null, nN(this, !1), sN(this, !1), oN(
      this,
      1
      /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
    ), rN(this, !1), this.cachedVersionId = 0, this.cachedAbsoluteStart = t, this.cachedAbsoluteEnd = i, this.range = null, Ct(this, !1);
  }
  reset(e, t, i, n) {
    this.start = t, this.end = i, this.maxEnd = i, this.cachedVersionId = e, this.cachedAbsoluteStart = t, this.cachedAbsoluteEnd = i, this.range = n;
  }
  setOptions(e) {
    this.options = e;
    const t = this.options.className;
    nN(this, t === "squiggly-error" || t === "squiggly-warning" || t === "squiggly-info"), sN(this, this.options.glyphMarginClassName !== null), oN(this, this.options.stickiness), rN(this, this.options.collapseOnReplaceEdit);
  }
  setCachedOffsets(e, t, i) {
    this.cachedVersionId !== i && (this.range = null), this.cachedVersionId = i, this.cachedAbsoluteStart = e, this.cachedAbsoluteEnd = t;
  }
  detach() {
    this.parent = null, this.left = null, this.right = null;
  }
}
const Ie = new JA(null, 0, 0);
Ie.parent = Ie;
Ie.left = Ie;
Ie.right = Ie;
yt(
  Ie,
  0
  /* NodeColor.Black */
);
class Q0 {
  constructor() {
    this.root = Ie, this.requestNormalizeDelta = !1;
  }
  intervalSearch(e, t, i, n, o, r) {
    return this.root === Ie ? [] : XU(this, e, t, i, n, o, r);
  }
  search(e, t, i, n) {
    return this.root === Ie ? [] : QU(this, e, t, i, n);
  }
  /**
   * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!
   */
  collectNodesFromOwner(e) {
    return ZU(this, e);
  }
  /**
   * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!
   */
  collectNodesPostOrder() {
    return YU(this);
  }
  insert(e) {
    aN(this, e), this._normalizeDeltaIfNecessary();
  }
  delete(e) {
    lN(this, e), this._normalizeDeltaIfNecessary();
  }
  resolveNode(e, t) {
    const i = e;
    let n = 0;
    for (; e !== this.root; )
      e === e.parent.right && (n += e.parent.delta), e = e.parent;
    const o = i.start + n, r = i.end + n;
    i.setCachedOffsets(o, r, t);
  }
  acceptReplace(e, t, i, n) {
    const o = jU(this, e, e + t);
    for (let r = 0, a = o.length; r < a; r++) {
      const l = o[r];
      lN(this, l);
    }
    this._normalizeDeltaIfNecessary(), GU(this, e, e + t, i), this._normalizeDeltaIfNecessary();
    for (let r = 0, a = o.length; r < a; r++) {
      const l = o[r];
      l.start = l.cachedAbsoluteStart, l.end = l.cachedAbsoluteEnd, qU(l, e, e + t, i, n), l.maxEnd = l.end, aN(this, l);
    }
    this._normalizeDeltaIfNecessary();
  }
  _normalizeDeltaIfNecessary() {
    this.requestNormalizeDelta && (this.requestNormalizeDelta = !1, KU(this));
  }
}
function KU(s) {
  let e = s.root, t = 0;
  for (; e !== Ie; ) {
    if (e.left !== Ie && !Mi(e.left)) {
      e = e.left;
      continue;
    }
    if (e.right !== Ie && !Mi(e.right)) {
      t += e.delta, e = e.right;
      continue;
    }
    e.start = t + e.start, e.end = t + e.end, e.delta = 0, Ga(e), Ct(e, !0), Ct(e.left, !1), Ct(e.right, !1), e === e.parent.right && (t -= e.parent.delta), e = e.parent;
  }
  Ct(s.root, !1);
}
function nh(s, e, t, i) {
  return s < t ? !0 : s > t || i === 1 ? !1 : i === 2 ? !0 : e;
}
function qU(s, e, t, i, n) {
  const o = UU(s), r = o === 0 || o === 2, a = o === 1 || o === 2, l = t - e, c = i, h = Math.min(l, c), d = s.start;
  let u = !1;
  const f = s.end;
  let g = !1;
  e <= d && f <= t && $U(s) && (s.start = e, u = !0, s.end = e, g = !0);
  {
    const _ = n ? 1 : l > 0 ? 2 : 0;
    !u && nh(d, r, e, _) && (u = !0), !g && nh(f, a, e, _) && (g = !0);
  }
  if (h > 0 && !n) {
    const _ = l > c ? 2 : 0;
    !u && nh(d, r, e + h, _) && (u = !0), !g && nh(f, a, e + h, _) && (g = !0);
  }
  {
    const _ = n ? 1 : 0;
    !u && nh(d, r, t, _) && (s.start = e + c, u = !0), !g && nh(f, a, t, _) && (s.end = e + c, g = !0);
  }
  const m = c - l;
  u || (s.start = Math.max(0, d + m)), g || (s.end = Math.max(0, f + m)), s.start > s.end && (s.end = s.start);
}
function jU(s, e, t) {
  let i = s.root, n = 0, o = 0, r = 0, a = 0;
  const l = [];
  let c = 0;
  for (; i !== Ie; ) {
    if (Mi(i)) {
      Ct(i.left, !1), Ct(i.right, !1), i === i.parent.right && (n -= i.parent.delta), i = i.parent;
      continue;
    }
    if (!Mi(i.left)) {
      if (o = n + i.maxEnd, o < e) {
        Ct(i, !0);
        continue;
      }
      if (i.left !== Ie) {
        i = i.left;
        continue;
      }
    }
    if (r = n + i.start, r > t) {
      Ct(i, !0);
      continue;
    }
    if (a = n + i.end, a >= e && (i.setCachedOffsets(r, a, 0), l[c++] = i), Ct(i, !0), i.right !== Ie && !Mi(i.right)) {
      n += i.delta, i = i.right;
      continue;
    }
  }
  return Ct(s.root, !1), l;
}
function GU(s, e, t, i) {
  let n = s.root, o = 0, r = 0, a = 0;
  const l = i - (t - e);
  for (; n !== Ie; ) {
    if (Mi(n)) {
      Ct(n.left, !1), Ct(n.right, !1), n === n.parent.right && (o -= n.parent.delta), Ga(n), n = n.parent;
      continue;
    }
    if (!Mi(n.left)) {
      if (r = o + n.maxEnd, r < e) {
        Ct(n, !0);
        continue;
      }
      if (n.left !== Ie) {
        n = n.left;
        continue;
      }
    }
    if (a = o + n.start, a > t) {
      n.start += l, n.end += l, n.delta += l, (n.delta < -1073741824 || n.delta > 1073741824) && (s.requestNormalizeDelta = !0), Ct(n, !0);
      continue;
    }
    if (Ct(n, !0), n.right !== Ie && !Mi(n.right)) {
      o += n.delta, n = n.right;
      continue;
    }
  }
  Ct(s.root, !1);
}
function ZU(s, e) {
  let t = s.root;
  const i = [];
  let n = 0;
  for (; t !== Ie; ) {
    if (Mi(t)) {
      Ct(t.left, !1), Ct(t.right, !1), t = t.parent;
      continue;
    }
    if (t.left !== Ie && !Mi(t.left)) {
      t = t.left;
      continue;
    }
    if (t.ownerId === e && (i[n++] = t), Ct(t, !0), t.right !== Ie && !Mi(t.right)) {
      t = t.right;
      continue;
    }
  }
  return Ct(s.root, !1), i;
}
function YU(s) {
  let e = s.root;
  const t = [];
  let i = 0;
  for (; e !== Ie; ) {
    if (Mi(e)) {
      Ct(e.left, !1), Ct(e.right, !1), e = e.parent;
      continue;
    }
    if (e.left !== Ie && !Mi(e.left)) {
      e = e.left;
      continue;
    }
    if (e.right !== Ie && !Mi(e.right)) {
      e = e.right;
      continue;
    }
    t[i++] = e, Ct(e, !0);
  }
  return Ct(s.root, !1), t;
}
function QU(s, e, t, i, n) {
  let o = s.root, r = 0, a = 0, l = 0;
  const c = [];
  let h = 0;
  for (; o !== Ie; ) {
    if (Mi(o)) {
      Ct(o.left, !1), Ct(o.right, !1), o === o.parent.right && (r -= o.parent.delta), o = o.parent;
      continue;
    }
    if (o.left !== Ie && !Mi(o.left)) {
      o = o.left;
      continue;
    }
    a = r + o.start, l = r + o.end, o.setCachedOffsets(a, l, i);
    let d = !0;
    if (e && o.ownerId && o.ownerId !== e && (d = !1), t && QA(o) && (d = !1), n && !XA(o) && (d = !1), d && (c[h++] = o), Ct(o, !0), o.right !== Ie && !Mi(o.right)) {
      r += o.delta, o = o.right;
      continue;
    }
  }
  return Ct(s.root, !1), c;
}
function XU(s, e, t, i, n, o, r) {
  let a = s.root, l = 0, c = 0, h = 0, d = 0;
  const u = [];
  let f = 0;
  for (; a !== Ie; ) {
    if (Mi(a)) {
      Ct(a.left, !1), Ct(a.right, !1), a === a.parent.right && (l -= a.parent.delta), a = a.parent;
      continue;
    }
    if (!Mi(a.left)) {
      if (c = l + a.maxEnd, c < e) {
        Ct(a, !0);
        continue;
      }
      if (a.left !== Ie) {
        a = a.left;
        continue;
      }
    }
    if (h = l + a.start, h > t) {
      Ct(a, !0);
      continue;
    }
    if (d = l + a.end, d >= e) {
      a.setCachedOffsets(h, d, o);
      let g = !0;
      i && a.ownerId && a.ownerId !== i && (g = !1), n && QA(a) && (g = !1), r && !XA(a) && (g = !1), g && (u[f++] = a);
    }
    if (Ct(a, !0), a.right !== Ie && !Mi(a.right)) {
      l += a.delta, a = a.right;
      continue;
    }
  }
  return Ct(s.root, !1), u;
}
function aN(s, e) {
  if (s.root === Ie)
    return e.parent = Ie, e.left = Ie, e.right = Ie, yt(
      e,
      0
      /* NodeColor.Black */
    ), s.root = e, s.root;
  JU(s, e), da(e.parent);
  let t = e;
  for (; t !== s.root && un(t.parent) === 1; )
    if (t.parent === t.parent.parent.left) {
      const i = t.parent.parent.right;
      un(i) === 1 ? (yt(
        t.parent,
        0
        /* NodeColor.Black */
      ), yt(
        i,
        0
        /* NodeColor.Black */
      ), yt(
        t.parent.parent,
        1
        /* NodeColor.Red */
      ), t = t.parent.parent) : (t === t.parent.right && (t = t.parent, Yu(s, t)), yt(
        t.parent,
        0
        /* NodeColor.Black */
      ), yt(
        t.parent.parent,
        1
        /* NodeColor.Red */
      ), Qu(s, t.parent.parent));
    } else {
      const i = t.parent.parent.left;
      un(i) === 1 ? (yt(
        t.parent,
        0
        /* NodeColor.Black */
      ), yt(
        i,
        0
        /* NodeColor.Black */
      ), yt(
        t.parent.parent,
        1
        /* NodeColor.Red */
      ), t = t.parent.parent) : (t === t.parent.left && (t = t.parent, Qu(s, t)), yt(
        t.parent,
        0
        /* NodeColor.Black */
      ), yt(
        t.parent.parent,
        1
        /* NodeColor.Red */
      ), Yu(s, t.parent.parent));
    }
  return yt(
    s.root,
    0
    /* NodeColor.Black */
  ), e;
}
function JU(s, e) {
  let t = 0, i = s.root;
  const n = e.start, o = e.end;
  for (; ; )
    if (t$(n, o, i.start + t, i.end + t) < 0)
      if (i.left === Ie) {
        e.start -= t, e.end -= t, e.maxEnd -= t, i.left = e;
        break;
      } else
        i = i.left;
    else if (i.right === Ie) {
      e.start -= t + i.delta, e.end -= t + i.delta, e.maxEnd -= t + i.delta, i.right = e;
      break;
    } else
      t += i.delta, i = i.right;
  e.parent = i, e.left = Ie, e.right = Ie, yt(
    e,
    1
    /* NodeColor.Red */
  );
}
function lN(s, e) {
  let t, i;
  if (e.left === Ie ? (t = e.right, i = e, t.delta += e.delta, (t.delta < -1073741824 || t.delta > 1073741824) && (s.requestNormalizeDelta = !0), t.start += e.delta, t.end += e.delta) : e.right === Ie ? (t = e.left, i = e) : (i = e$(e.right), t = i.right, t.start += i.delta, t.end += i.delta, t.delta += i.delta, (t.delta < -1073741824 || t.delta > 1073741824) && (s.requestNormalizeDelta = !0), i.start += e.delta, i.end += e.delta, i.delta = e.delta, (i.delta < -1073741824 || i.delta > 1073741824) && (s.requestNormalizeDelta = !0)), i === s.root) {
    s.root = t, yt(
      t,
      0
      /* NodeColor.Black */
    ), e.detach(), X0(), Ga(t), s.root.parent = Ie;
    return;
  }
  const n = un(i) === 1;
  if (i === i.parent.left ? i.parent.left = t : i.parent.right = t, i === e ? t.parent = i.parent : (i.parent === e ? t.parent = i : t.parent = i.parent, i.left = e.left, i.right = e.right, i.parent = e.parent, yt(i, un(e)), e === s.root ? s.root = i : e === e.parent.left ? e.parent.left = i : e.parent.right = i, i.left !== Ie && (i.left.parent = i), i.right !== Ie && (i.right.parent = i)), e.detach(), n) {
    da(t.parent), i !== e && (da(i), da(i.parent)), X0();
    return;
  }
  da(t), da(t.parent), i !== e && (da(i), da(i.parent));
  let o;
  for (; t !== s.root && un(t) === 0; )
    t === t.parent.left ? (o = t.parent.right, un(o) === 1 && (yt(
      o,
      0
      /* NodeColor.Black */
    ), yt(
      t.parent,
      1
      /* NodeColor.Red */
    ), Yu(s, t.parent), o = t.parent.right), un(o.left) === 0 && un(o.right) === 0 ? (yt(
      o,
      1
      /* NodeColor.Red */
    ), t = t.parent) : (un(o.right) === 0 && (yt(
      o.left,
      0
      /* NodeColor.Black */
    ), yt(
      o,
      1
      /* NodeColor.Red */
    ), Qu(s, o), o = t.parent.right), yt(o, un(t.parent)), yt(
      t.parent,
      0
      /* NodeColor.Black */
    ), yt(
      o.right,
      0
      /* NodeColor.Black */
    ), Yu(s, t.parent), t = s.root)) : (o = t.parent.left, un(o) === 1 && (yt(
      o,
      0
      /* NodeColor.Black */
    ), yt(
      t.parent,
      1
      /* NodeColor.Red */
    ), Qu(s, t.parent), o = t.parent.left), un(o.left) === 0 && un(o.right) === 0 ? (yt(
      o,
      1
      /* NodeColor.Red */
    ), t = t.parent) : (un(o.left) === 0 && (yt(
      o.right,
      0
      /* NodeColor.Black */
    ), yt(
      o,
      1
      /* NodeColor.Red */
    ), Yu(s, o), o = t.parent.left), yt(o, un(t.parent)), yt(
      t.parent,
      0
      /* NodeColor.Black */
    ), yt(
      o.left,
      0
      /* NodeColor.Black */
    ), Qu(s, t.parent), t = s.root));
  yt(
    t,
    0
    /* NodeColor.Black */
  ), X0();
}
function e$(s) {
  for (; s.left !== Ie; )
    s = s.left;
  return s;
}
function X0() {
  Ie.parent = Ie, Ie.delta = 0, Ie.start = 0, Ie.end = 0;
}
function Yu(s, e) {
  const t = e.right;
  t.delta += e.delta, (t.delta < -1073741824 || t.delta > 1073741824) && (s.requestNormalizeDelta = !0), t.start += e.delta, t.end += e.delta, e.right = t.left, t.left !== Ie && (t.left.parent = e), t.parent = e.parent, e.parent === Ie ? s.root = t : e === e.parent.left ? e.parent.left = t : e.parent.right = t, t.left = e, e.parent = t, Ga(e), Ga(t);
}
function Qu(s, e) {
  const t = e.left;
  e.delta -= t.delta, (e.delta < -1073741824 || e.delta > 1073741824) && (s.requestNormalizeDelta = !0), e.start -= t.delta, e.end -= t.delta, e.left = t.right, t.right !== Ie && (t.right.parent = e), t.parent = e.parent, e.parent === Ie ? s.root = t : e === e.parent.right ? e.parent.right = t : e.parent.left = t, t.right = e, e.parent = t, Ga(e), Ga(t);
}
function e4(s) {
  let e = s.end;
  if (s.left !== Ie) {
    const t = s.left.maxEnd;
    t > e && (e = t);
  }
  if (s.right !== Ie) {
    const t = s.right.maxEnd + s.delta;
    t > e && (e = t);
  }
  return e;
}
function Ga(s) {
  s.maxEnd = e4(s);
}
function da(s) {
  for (; s !== Ie; ) {
    const e = e4(s);
    if (s.maxEnd === e)
      return;
    s.maxEnd = e, s = s.parent;
  }
}
function t$(s, e, t, i) {
  return s === t ? e - i : s - t;
}
class xy {
  constructor(e, t) {
    this.piece = e, this.color = t, this.size_left = 0, this.lf_left = 0, this.parent = this, this.left = this, this.right = this;
  }
  next() {
    if (this.right !== Ce)
      return Uk(this.right);
    let e = this;
    for (; e.parent !== Ce && e.parent.left !== e; )
      e = e.parent;
    return e.parent === Ce ? Ce : e.parent;
  }
  prev() {
    if (this.left !== Ce)
      return t4(this.left);
    let e = this;
    for (; e.parent !== Ce && e.parent.right !== e; )
      e = e.parent;
    return e.parent === Ce ? Ce : e.parent;
  }
  detach() {
    this.parent = null, this.left = null, this.right = null;
  }
}
const Ce = new xy(
  null,
  0
  /* NodeColor.Black */
);
Ce.parent = Ce;
Ce.left = Ce;
Ce.right = Ce;
Ce.color = 0;
function Uk(s) {
  for (; s.left !== Ce; )
    s = s.left;
  return s;
}
function t4(s) {
  for (; s.right !== Ce; )
    s = s.right;
  return s;
}
function $k(s) {
  return s === Ce ? 0 : s.size_left + s.piece.length + $k(s.right);
}
function Kk(s) {
  return s === Ce ? 0 : s.lf_left + s.piece.lineFeedCnt + Kk(s.right);
}
function J0() {
  Ce.parent = Ce;
}
function Xu(s, e) {
  const t = e.right;
  t.size_left += e.size_left + (e.piece ? e.piece.length : 0), t.lf_left += e.lf_left + (e.piece ? e.piece.lineFeedCnt : 0), e.right = t.left, t.left !== Ce && (t.left.parent = e), t.parent = e.parent, e.parent === Ce ? s.root = t : e.parent.left === e ? e.parent.left = t : e.parent.right = t, t.left = e, e.parent = t;
}
function Ju(s, e) {
  const t = e.left;
  e.left = t.right, t.right !== Ce && (t.right.parent = e), t.parent = e.parent, e.size_left -= t.size_left + (t.piece ? t.piece.length : 0), e.lf_left -= t.lf_left + (t.piece ? t.piece.lineFeedCnt : 0), e.parent === Ce ? s.root = t : e === e.parent.right ? e.parent.right = t : e.parent.left = t, t.right = e, e.parent = t;
}
function xm(s, e) {
  let t, i;
  if (e.left === Ce ? (i = e, t = i.right) : e.right === Ce ? (i = e, t = i.left) : (i = Uk(e.right), t = i.right), i === s.root) {
    s.root = t, t.color = 0, e.detach(), J0(), s.root.parent = Ce;
    return;
  }
  const n = i.color === 1;
  if (i === i.parent.left ? i.parent.left = t : i.parent.right = t, i === e ? (t.parent = i.parent, Mu(s, t)) : (i.parent === e ? t.parent = i : t.parent = i.parent, Mu(s, t), i.left = e.left, i.right = e.right, i.parent = e.parent, i.color = e.color, e === s.root ? s.root = i : e === e.parent.left ? e.parent.left = i : e.parent.right = i, i.left !== Ce && (i.left.parent = i), i.right !== Ce && (i.right.parent = i), i.size_left = e.size_left, i.lf_left = e.lf_left, Mu(s, i)), e.detach(), t.parent.left === t) {
    const r = $k(t), a = Kk(t);
    if (r !== t.parent.size_left || a !== t.parent.lf_left) {
      const l = r - t.parent.size_left, c = a - t.parent.lf_left;
      t.parent.size_left = r, t.parent.lf_left = a, cr(s, t.parent, l, c);
    }
  }
  if (Mu(s, t.parent), n) {
    J0();
    return;
  }
  let o;
  for (; t !== s.root && t.color === 0; )
    t === t.parent.left ? (o = t.parent.right, o.color === 1 && (o.color = 0, t.parent.color = 1, Xu(s, t.parent), o = t.parent.right), o.left.color === 0 && o.right.color === 0 ? (o.color = 1, t = t.parent) : (o.right.color === 0 && (o.left.color = 0, o.color = 1, Ju(s, o), o = t.parent.right), o.color = t.parent.color, t.parent.color = 0, o.right.color = 0, Xu(s, t.parent), t = s.root)) : (o = t.parent.left, o.color === 1 && (o.color = 0, t.parent.color = 1, Ju(s, t.parent), o = t.parent.left), o.left.color === 0 && o.right.color === 0 ? (o.color = 1, t = t.parent) : (o.left.color === 0 && (o.right.color = 0, o.color = 1, Xu(s, o), o = t.parent.left), o.color = t.parent.color, t.parent.color = 0, o.left.color = 0, Ju(s, t.parent), t = s.root));
  t.color = 0, J0();
}
function cN(s, e) {
  for (Mu(s, e); e !== s.root && e.parent.color === 1; )
    if (e.parent === e.parent.parent.left) {
      const t = e.parent.parent.right;
      t.color === 1 ? (e.parent.color = 0, t.color = 0, e.parent.parent.color = 1, e = e.parent.parent) : (e === e.parent.right && (e = e.parent, Xu(s, e)), e.parent.color = 0, e.parent.parent.color = 1, Ju(s, e.parent.parent));
    } else {
      const t = e.parent.parent.left;
      t.color === 1 ? (e.parent.color = 0, t.color = 0, e.parent.parent.color = 1, e = e.parent.parent) : (e === e.parent.left && (e = e.parent, Ju(s, e)), e.parent.color = 0, e.parent.parent.color = 1, Xu(s, e.parent.parent));
    }
  s.root.color = 0;
}
function cr(s, e, t, i) {
  for (; e !== s.root && e !== Ce; )
    e.parent.left === e && (e.parent.size_left += t, e.parent.lf_left += i), e = e.parent;
}
function Mu(s, e) {
  let t = 0, i = 0;
  if (e !== s.root) {
    for (; e !== s.root && e === e.parent.right; )
      e = e.parent;
    if (e !== s.root)
      for (e = e.parent, t = $k(e.left) - e.size_left, i = Kk(e.left) - e.lf_left, e.size_left += t, e.lf_left += i; e !== s.root && (t !== 0 || i !== 0); )
        e.parent.left === e && (e.parent.size_left += t, e.parent.lf_left += i), e = e.parent;
  }
}
const or = 65535;
function i4(s) {
  let e;
  return s[s.length - 1] < 65536 ? e = new Uint16Array(s.length) : e = new Uint32Array(s.length), e.set(s, 0), e;
}
class i$ {
  constructor(e, t, i, n, o) {
    this.lineStarts = e, this.cr = t, this.lf = i, this.crlf = n, this.isBasicASCII = o;
  }
}
function dr(s, e = !0) {
  const t = [0];
  let i = 1;
  for (let n = 0, o = s.length; n < o; n++) {
    const r = s.charCodeAt(n);
    r === 13 ? n + 1 < o && s.charCodeAt(n + 1) === 10 ? (t[i++] = n + 2, n++) : t[i++] = n + 1 : r === 10 && (t[i++] = n + 1);
  }
  return e ? i4(t) : t;
}
function n$(s, e) {
  s.length = 0, s[0] = 0;
  let t = 1, i = 0, n = 0, o = 0, r = !0;
  for (let l = 0, c = e.length; l < c; l++) {
    const h = e.charCodeAt(l);
    h === 13 ? l + 1 < c && e.charCodeAt(l + 1) === 10 ? (o++, s[t++] = l + 2, l++) : (i++, s[t++] = l + 1) : h === 10 ? (n++, s[t++] = l + 1) : r && h !== 9 && (h < 32 || h > 126) && (r = !1);
  }
  const a = new i$(i4(s), i, n, o, r);
  return s.length = 0, a;
}
class Dn {
  constructor(e, t, i, n, o) {
    this.bufferIndex = e, this.start = t, this.end = i, this.lineFeedCnt = n, this.length = o;
  }
}
class Nl {
  constructor(e, t) {
    this.buffer = e, this.lineStarts = t;
  }
}
class s$ {
  constructor(e, t) {
    this._pieces = [], this._tree = e, this._BOM = t, this._index = 0, e.root !== Ce && e.iterate(e.root, (i) => (i !== Ce && this._pieces.push(i.piece), !0));
  }
  read() {
    return this._pieces.length === 0 ? this._index === 0 ? (this._index++, this._BOM) : null : this._index > this._pieces.length - 1 ? null : this._index === 0 ? this._BOM + this._tree.getPieceContent(this._pieces[this._index++]) : this._tree.getPieceContent(this._pieces[this._index++]);
  }
}
class o$ {
  constructor(e) {
    this._limit = e, this._cache = [];
  }
  get(e) {
    for (let t = this._cache.length - 1; t >= 0; t--) {
      const i = this._cache[t];
      if (i.nodeStartOffset <= e && i.nodeStartOffset + i.node.piece.length >= e)
        return i;
    }
    return null;
  }
  get2(e) {
    for (let t = this._cache.length - 1; t >= 0; t--) {
      const i = this._cache[t];
      if (i.nodeStartLineNumber && i.nodeStartLineNumber < e && i.nodeStartLineNumber + i.node.piece.lineFeedCnt >= e)
        return i;
    }
    return null;
  }
  set(e) {
    this._cache.length >= this._limit && this._cache.shift(), this._cache.push(e);
  }
  validate(e) {
    let t = !1;
    const i = this._cache;
    for (let n = 0; n < i.length; n++) {
      const o = i[n];
      if (o.node.parent === null || o.nodeStartOffset >= e) {
        i[n] = null, t = !0;
        continue;
      }
    }
    if (t) {
      const n = [];
      for (const o of i)
        o !== null && n.push(o);
      this._cache = n;
    }
  }
}
class r$ {
  constructor(e, t, i) {
    this.create(e, t, i);
  }
  create(e, t, i) {
    this._buffers = [
      new Nl("", [0])
    ], this._lastChangeBufferPos = { line: 0, column: 0 }, this.root = Ce, this._lineCnt = 1, this._length = 0, this._EOL = t, this._EOLLength = t.length, this._EOLNormalized = i;
    let n = null;
    for (let o = 0, r = e.length; o < r; o++)
      if (e[o].buffer.length > 0) {
        e[o].lineStarts || (e[o].lineStarts = dr(e[o].buffer));
        const a = new Dn(o + 1, { line: 0, column: 0 }, { line: e[o].lineStarts.length - 1, column: e[o].buffer.length - e[o].lineStarts[e[o].lineStarts.length - 1] }, e[o].lineStarts.length - 1, e[o].buffer.length);
        this._buffers.push(e[o]), n = this.rbInsertRight(n, a);
      }
    this._searchCache = new o$(1), this._lastVisitedLine = { lineNumber: 0, value: "" }, this.computeBufferMetadata();
  }
  normalizeEOL(e) {
    const t = or, i = t - Math.floor(t / 3), n = i * 2;
    let o = "", r = 0;
    const a = [];
    if (this.iterate(this.root, (l) => {
      const c = this.getNodeContent(l), h = c.length;
      if (r <= i || r + h < n)
        return o += c, r += h, !0;
      const d = o.replace(/\r\n|\r|\n/g, e);
      return a.push(new Nl(d, dr(d))), o = c, r = h, !0;
    }), r > 0) {
      const l = o.replace(/\r\n|\r|\n/g, e);
      a.push(new Nl(l, dr(l)));
    }
    this.create(a, e, !0);
  }
  // #region Buffer API
  getEOL() {
    return this._EOL;
  }
  setEOL(e) {
    this._EOL = e, this._EOLLength = this._EOL.length, this.normalizeEOL(e);
  }
  createSnapshot(e) {
    return new s$(this, e);
  }
  getOffsetAt(e, t) {
    let i = 0, n = this.root;
    for (; n !== Ce; )
      if (n.left !== Ce && n.lf_left + 1 >= e)
        n = n.left;
      else if (n.lf_left + n.piece.lineFeedCnt + 1 >= e) {
        i += n.size_left;
        const o = this.getAccumulatedValue(n, e - n.lf_left - 2);
        return i += o + t - 1;
      } else
        e -= n.lf_left + n.piece.lineFeedCnt, i += n.size_left + n.piece.length, n = n.right;
    return i;
  }
  getPositionAt(e) {
    e = Math.floor(e), e = Math.max(0, e);
    let t = this.root, i = 0;
    const n = e;
    for (; t !== Ce; )
      if (t.size_left !== 0 && t.size_left >= e)
        t = t.left;
      else if (t.size_left + t.piece.length >= e) {
        const o = this.getIndexOf(t, e - t.size_left);
        if (i += t.lf_left + o.index, o.index === 0) {
          const r = this.getOffsetAt(i + 1, 1), a = n - r;
          return new V(i + 1, a + 1);
        }
        return new V(i + 1, o.remainder + 1);
      } else if (e -= t.size_left + t.piece.length, i += t.lf_left + t.piece.lineFeedCnt, t.right === Ce) {
        const o = this.getOffsetAt(i + 1, 1), r = n - e - o;
        return new V(i + 1, r + 1);
      } else
        t = t.right;
    return new V(1, 1);
  }
  getValueInRange(e, t) {
    if (e.startLineNumber === e.endLineNumber && e.startColumn === e.endColumn)
      return "";
    const i = this.nodeAt2(e.startLineNumber, e.startColumn), n = this.nodeAt2(e.endLineNumber, e.endColumn), o = this.getValueInRange2(i, n);
    return t ? t !== this._EOL || !this._EOLNormalized ? o.replace(/\r\n|\r|\n/g, t) : t === this.getEOL() && this._EOLNormalized ? o : o.replace(/\r\n|\r|\n/g, t) : o;
  }
  getValueInRange2(e, t) {
    if (e.node === t.node) {
      const a = e.node, l = this._buffers[a.piece.bufferIndex].buffer, c = this.offsetInBuffer(a.piece.bufferIndex, a.piece.start);
      return l.substring(c + e.remainder, c + t.remainder);
    }
    let i = e.node;
    const n = this._buffers[i.piece.bufferIndex].buffer, o = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
    let r = n.substring(o + e.remainder, o + i.piece.length);
    for (i = i.next(); i !== Ce; ) {
      const a = this._buffers[i.piece.bufferIndex].buffer, l = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
      if (i === t.node) {
        r += a.substring(l, l + t.remainder);
        break;
      } else
        r += a.substr(l, i.piece.length);
      i = i.next();
    }
    return r;
  }
  getLinesContent() {
    const e = [];
    let t = 0, i = "", n = !1;
    return this.iterate(this.root, (o) => {
      if (o === Ce)
        return !0;
      const r = o.piece;
      let a = r.length;
      if (a === 0)
        return !0;
      const l = this._buffers[r.bufferIndex].buffer, c = this._buffers[r.bufferIndex].lineStarts, h = r.start.line, d = r.end.line;
      let u = c[h] + r.start.column;
      if (n && (l.charCodeAt(u) === 10 && (u++, a--), e[t++] = i, i = "", n = !1, a === 0))
        return !0;
      if (h === d)
        return !this._EOLNormalized && l.charCodeAt(u + a - 1) === 13 ? (n = !0, i += l.substr(u, a - 1)) : i += l.substr(u, a), !0;
      i += this._EOLNormalized ? l.substring(u, Math.max(u, c[h + 1] - this._EOLLength)) : l.substring(u, c[h + 1]).replace(/(\r\n|\r|\n)$/, ""), e[t++] = i;
      for (let f = h + 1; f < d; f++)
        i = this._EOLNormalized ? l.substring(c[f], c[f + 1] - this._EOLLength) : l.substring(c[f], c[f + 1]).replace(/(\r\n|\r|\n)$/, ""), e[t++] = i;
      return !this._EOLNormalized && l.charCodeAt(c[d] + r.end.column - 1) === 13 ? (n = !0, r.end.column === 0 ? t-- : i = l.substr(c[d], r.end.column - 1)) : i = l.substr(c[d], r.end.column), !0;
    }), n && (e[t++] = i, i = ""), e[t++] = i, e;
  }
  getLength() {
    return this._length;
  }
  getLineCount() {
    return this._lineCnt;
  }
  getLineContent(e) {
    return this._lastVisitedLine.lineNumber === e ? this._lastVisitedLine.value : (this._lastVisitedLine.lineNumber = e, e === this._lineCnt ? this._lastVisitedLine.value = this.getLineRawContent(e) : this._EOLNormalized ? this._lastVisitedLine.value = this.getLineRawContent(e, this._EOLLength) : this._lastVisitedLine.value = this.getLineRawContent(e).replace(/(\r\n|\r|\n)$/, ""), this._lastVisitedLine.value);
  }
  _getCharCode(e) {
    if (e.remainder === e.node.piece.length) {
      const t = e.node.next();
      if (!t)
        return 0;
      const i = this._buffers[t.piece.bufferIndex], n = this.offsetInBuffer(t.piece.bufferIndex, t.piece.start);
      return i.buffer.charCodeAt(n);
    } else {
      const t = this._buffers[e.node.piece.bufferIndex], n = this.offsetInBuffer(e.node.piece.bufferIndex, e.node.piece.start) + e.remainder;
      return t.buffer.charCodeAt(n);
    }
  }
  getLineCharCode(e, t) {
    const i = this.nodeAt2(e, t + 1);
    return this._getCharCode(i);
  }
  getLineLength(e) {
    if (e === this.getLineCount()) {
      const t = this.getOffsetAt(e, 1);
      return this.getLength() - t;
    }
    return this.getOffsetAt(e + 1, 1) - this.getOffsetAt(e, 1) - this._EOLLength;
  }
  findMatchesInNode(e, t, i, n, o, r, a, l, c, h, d) {
    const u = this._buffers[e.piece.bufferIndex], f = this.offsetInBuffer(e.piece.bufferIndex, e.piece.start), g = this.offsetInBuffer(e.piece.bufferIndex, o), m = this.offsetInBuffer(e.piece.bufferIndex, r);
    let _;
    const b = { line: 0, column: 0 };
    let C, v;
    t._wordSeparators ? (C = u.buffer.substring(g, m), v = (w) => w + g, t.reset(0)) : (C = u.buffer, v = (w) => w, t.reset(g));
    do
      if (_ = t.next(C), _) {
        if (v(_.index) >= m)
          return h;
        this.positionInBuffer(e, v(_.index) - f, b);
        const w = this.getLineFeedCnt(e.piece.bufferIndex, o, b), S = b.line === o.line ? b.column - o.column + n : b.column + 1, L = S + _[0].length;
        if (d[h++] = Ll(new R(i + w, S, i + w, L), _, l), v(_.index) + _[0].length >= m || h >= c)
          return h;
      }
    while (_);
    return h;
  }
  findMatchesLineByLine(e, t, i, n) {
    const o = [];
    let r = 0;
    const a = new gh(t.wordSeparators, t.regex);
    let l = this.nodeAt2(e.startLineNumber, e.startColumn);
    if (l === null)
      return [];
    const c = this.nodeAt2(e.endLineNumber, e.endColumn);
    if (c === null)
      return [];
    let h = this.positionInBuffer(l.node, l.remainder);
    const d = this.positionInBuffer(c.node, c.remainder);
    if (l.node === c.node)
      return this.findMatchesInNode(l.node, a, e.startLineNumber, e.startColumn, h, d, t, i, n, r, o), o;
    let u = e.startLineNumber, f = l.node;
    for (; f !== c.node; ) {
      const m = this.getLineFeedCnt(f.piece.bufferIndex, h, f.piece.end);
      if (m >= 1) {
        const b = this._buffers[f.piece.bufferIndex].lineStarts, C = this.offsetInBuffer(f.piece.bufferIndex, f.piece.start), v = b[h.line + m], w = u === e.startLineNumber ? e.startColumn : 1;
        if (r = this.findMatchesInNode(f, a, u, w, h, this.positionInBuffer(f, v - C), t, i, n, r, o), r >= n)
          return o;
        u += m;
      }
      const _ = u === e.startLineNumber ? e.startColumn - 1 : 0;
      if (u === e.endLineNumber) {
        const b = this.getLineContent(u).substring(_, e.endColumn - 1);
        return r = this._findMatchesInLine(t, a, b, e.endLineNumber, _, r, o, i, n), o;
      }
      if (r = this._findMatchesInLine(t, a, this.getLineContent(u).substr(_), u, _, r, o, i, n), r >= n)
        return o;
      u++, l = this.nodeAt2(u, 1), f = l.node, h = this.positionInBuffer(l.node, l.remainder);
    }
    if (u === e.endLineNumber) {
      const m = u === e.startLineNumber ? e.startColumn - 1 : 0, _ = this.getLineContent(u).substring(m, e.endColumn - 1);
      return r = this._findMatchesInLine(t, a, _, e.endLineNumber, m, r, o, i, n), o;
    }
    const g = u === e.startLineNumber ? e.startColumn : 1;
    return r = this.findMatchesInNode(c.node, a, u, g, h, d, t, i, n, r, o), o;
  }
  _findMatchesInLine(e, t, i, n, o, r, a, l, c) {
    const h = e.wordSeparators;
    if (!l && e.simpleSearch) {
      const u = e.simpleSearch, f = u.length, g = i.length;
      let m = -f;
      for (; (m = i.indexOf(u, m + f)) !== -1; )
        if ((!h || JL(h, i, g, m, f)) && (a[r++] = new Vf(new R(n, m + 1 + o, n, m + 1 + f + o), null), r >= c))
          return r;
      return r;
    }
    let d;
    t.reset(0);
    do
      if (d = t.next(i), d && (a[r++] = Ll(new R(n, d.index + 1 + o, n, d.index + 1 + d[0].length + o), d, l), r >= c))
        return r;
    while (d);
    return r;
  }
  // #endregion
  // #region Piece Table
  insert(e, t, i = !1) {
    if (this._EOLNormalized = this._EOLNormalized && i, this._lastVisitedLine.lineNumber = 0, this._lastVisitedLine.value = "", this.root !== Ce) {
      const { node: n, remainder: o, nodeStartOffset: r } = this.nodeAt(e), a = n.piece, l = a.bufferIndex, c = this.positionInBuffer(n, o);
      if (n.piece.bufferIndex === 0 && a.end.line === this._lastChangeBufferPos.line && a.end.column === this._lastChangeBufferPos.column && r + a.length === e && t.length < or) {
        this.appendToNode(n, t), this.computeBufferMetadata();
        return;
      }
      if (r === e)
        this.insertContentToNodeLeft(t, n), this._searchCache.validate(e);
      else if (r + n.piece.length > e) {
        const h = [];
        let d = new Dn(a.bufferIndex, c, a.end, this.getLineFeedCnt(a.bufferIndex, c, a.end), this.offsetInBuffer(l, a.end) - this.offsetInBuffer(l, c));
        if (this.shouldCheckCRLF() && this.endWithCR(t) && this.nodeCharCodeAt(n, o) === 10) {
          const m = { line: d.start.line + 1, column: 0 };
          d = new Dn(d.bufferIndex, m, d.end, this.getLineFeedCnt(d.bufferIndex, m, d.end), d.length - 1), t += `
`;
        }
        if (this.shouldCheckCRLF() && this.startWithLF(t))
          if (this.nodeCharCodeAt(n, o - 1) === 13) {
            const m = this.positionInBuffer(n, o - 1);
            this.deleteNodeTail(n, m), t = "\r" + t, n.piece.length === 0 && h.push(n);
          } else
            this.deleteNodeTail(n, c);
        else
          this.deleteNodeTail(n, c);
        const u = this.createNewPieces(t);
        d.length > 0 && this.rbInsertRight(n, d);
        let f = n;
        for (let g = 0; g < u.length; g++)
          f = this.rbInsertRight(f, u[g]);
        this.deleteNodes(h);
      } else
        this.insertContentToNodeRight(t, n);
    } else {
      const n = this.createNewPieces(t);
      let o = this.rbInsertLeft(null, n[0]);
      for (let r = 1; r < n.length; r++)
        o = this.rbInsertRight(o, n[r]);
    }
    this.computeBufferMetadata();
  }
  delete(e, t) {
    if (this._lastVisitedLine.lineNumber = 0, this._lastVisitedLine.value = "", t <= 0 || this.root === Ce)
      return;
    const i = this.nodeAt(e), n = this.nodeAt(e + t), o = i.node, r = n.node;
    if (o === r) {
      const u = this.positionInBuffer(o, i.remainder), f = this.positionInBuffer(o, n.remainder);
      if (i.nodeStartOffset === e) {
        if (t === o.piece.length) {
          const g = o.next();
          xm(this, o), this.validateCRLFWithPrevNode(g), this.computeBufferMetadata();
          return;
        }
        this.deleteNodeHead(o, f), this._searchCache.validate(e), this.validateCRLFWithPrevNode(o), this.computeBufferMetadata();
        return;
      }
      if (i.nodeStartOffset + o.piece.length === e + t) {
        this.deleteNodeTail(o, u), this.validateCRLFWithNextNode(o), this.computeBufferMetadata();
        return;
      }
      this.shrinkNode(o, u, f), this.computeBufferMetadata();
      return;
    }
    const a = [], l = this.positionInBuffer(o, i.remainder);
    this.deleteNodeTail(o, l), this._searchCache.validate(e), o.piece.length === 0 && a.push(o);
    const c = this.positionInBuffer(r, n.remainder);
    this.deleteNodeHead(r, c), r.piece.length === 0 && a.push(r);
    const h = o.next();
    for (let u = h; u !== Ce && u !== r; u = u.next())
      a.push(u);
    const d = o.piece.length === 0 ? o.prev() : o;
    this.deleteNodes(a), this.validateCRLFWithNextNode(d), this.computeBufferMetadata();
  }
  insertContentToNodeLeft(e, t) {
    const i = [];
    if (this.shouldCheckCRLF() && this.endWithCR(e) && this.startWithLF(t)) {
      const r = t.piece, a = { line: r.start.line + 1, column: 0 }, l = new Dn(r.bufferIndex, a, r.end, this.getLineFeedCnt(r.bufferIndex, a, r.end), r.length - 1);
      t.piece = l, e += `
`, cr(this, t, -1, -1), t.piece.length === 0 && i.push(t);
    }
    const n = this.createNewPieces(e);
    let o = this.rbInsertLeft(t, n[n.length - 1]);
    for (let r = n.length - 2; r >= 0; r--)
      o = this.rbInsertLeft(o, n[r]);
    this.validateCRLFWithPrevNode(o), this.deleteNodes(i);
  }
  insertContentToNodeRight(e, t) {
    this.adjustCarriageReturnFromNext(e, t) && (e += `
`);
    const i = this.createNewPieces(e), n = this.rbInsertRight(t, i[0]);
    let o = n;
    for (let r = 1; r < i.length; r++)
      o = this.rbInsertRight(o, i[r]);
    this.validateCRLFWithPrevNode(n);
  }
  positionInBuffer(e, t, i) {
    const n = e.piece, o = e.piece.bufferIndex, r = this._buffers[o].lineStarts, l = r[n.start.line] + n.start.column + t;
    let c = n.start.line, h = n.end.line, d = 0, u = 0, f = 0;
    for (; c <= h && (d = c + (h - c) / 2 | 0, f = r[d], d !== h); )
      if (u = r[d + 1], l < f)
        h = d - 1;
      else if (l >= u)
        c = d + 1;
      else
        break;
    return i ? (i.line = d, i.column = l - f, null) : {
      line: d,
      column: l - f
    };
  }
  getLineFeedCnt(e, t, i) {
    if (i.column === 0)
      return i.line - t.line;
    const n = this._buffers[e].lineStarts;
    if (i.line === n.length - 1)
      return i.line - t.line;
    const o = n[i.line + 1], r = n[i.line] + i.column;
    if (o > r + 1)
      return i.line - t.line;
    const a = r - 1;
    return this._buffers[e].buffer.charCodeAt(a) === 13 ? i.line - t.line + 1 : i.line - t.line;
  }
  offsetInBuffer(e, t) {
    return this._buffers[e].lineStarts[t.line] + t.column;
  }
  deleteNodes(e) {
    for (let t = 0; t < e.length; t++)
      xm(this, e[t]);
  }
  createNewPieces(e) {
    if (e.length > or) {
      const h = [];
      for (; e.length > or; ) {
        const u = e.charCodeAt(or - 1);
        let f;
        u === 13 || u >= 55296 && u <= 56319 ? (f = e.substring(0, or - 1), e = e.substring(or - 1)) : (f = e.substring(0, or), e = e.substring(or));
        const g = dr(f);
        h.push(new Dn(
          this._buffers.length,
          /* buffer index */
          { line: 0, column: 0 },
          { line: g.length - 1, column: f.length - g[g.length - 1] },
          g.length - 1,
          f.length
        )), this._buffers.push(new Nl(f, g));
      }
      const d = dr(e);
      return h.push(new Dn(
        this._buffers.length,
        /* buffer index */
        { line: 0, column: 0 },
        { line: d.length - 1, column: e.length - d[d.length - 1] },
        d.length - 1,
        e.length
      )), this._buffers.push(new Nl(e, d)), h;
    }
    let t = this._buffers[0].buffer.length;
    const i = dr(e, !1);
    let n = this._lastChangeBufferPos;
    if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === t && t !== 0 && this.startWithLF(e) && this.endWithCR(this._buffers[0].buffer)) {
      this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 }, n = this._lastChangeBufferPos;
      for (let h = 0; h < i.length; h++)
        i[h] += t + 1;
      this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(i.slice(1)), this._buffers[0].buffer += "_" + e, t += 1;
    } else {
      if (t !== 0)
        for (let h = 0; h < i.length; h++)
          i[h] += t;
      this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(i.slice(1)), this._buffers[0].buffer += e;
    }
    const o = this._buffers[0].buffer.length, r = this._buffers[0].lineStarts.length - 1, a = o - this._buffers[0].lineStarts[r], l = { line: r, column: a }, c = new Dn(
      0,
      /** todo@peng */
      n,
      l,
      this.getLineFeedCnt(0, n, l),
      o - t
    );
    return this._lastChangeBufferPos = l, [c];
  }
  getLineRawContent(e, t = 0) {
    let i = this.root, n = "";
    const o = this._searchCache.get2(e);
    if (o) {
      i = o.node;
      const r = this.getAccumulatedValue(i, e - o.nodeStartLineNumber - 1), a = this._buffers[i.piece.bufferIndex].buffer, l = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
      if (o.nodeStartLineNumber + i.piece.lineFeedCnt === e)
        n = a.substring(l + r, l + i.piece.length);
      else {
        const c = this.getAccumulatedValue(i, e - o.nodeStartLineNumber);
        return a.substring(l + r, l + c - t);
      }
    } else {
      let r = 0;
      const a = e;
      for (; i !== Ce; )
        if (i.left !== Ce && i.lf_left >= e - 1)
          i = i.left;
        else if (i.lf_left + i.piece.lineFeedCnt > e - 1) {
          const l = this.getAccumulatedValue(i, e - i.lf_left - 2), c = this.getAccumulatedValue(i, e - i.lf_left - 1), h = this._buffers[i.piece.bufferIndex].buffer, d = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
          return r += i.size_left, this._searchCache.set({
            node: i,
            nodeStartOffset: r,
            nodeStartLineNumber: a - (e - 1 - i.lf_left)
          }), h.substring(d + l, d + c - t);
        } else if (i.lf_left + i.piece.lineFeedCnt === e - 1) {
          const l = this.getAccumulatedValue(i, e - i.lf_left - 2), c = this._buffers[i.piece.bufferIndex].buffer, h = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
          n = c.substring(h + l, h + i.piece.length);
          break;
        } else
          e -= i.lf_left + i.piece.lineFeedCnt, r += i.size_left + i.piece.length, i = i.right;
    }
    for (i = i.next(); i !== Ce; ) {
      const r = this._buffers[i.piece.bufferIndex].buffer;
      if (i.piece.lineFeedCnt > 0) {
        const a = this.getAccumulatedValue(i, 0), l = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
        return n += r.substring(l, l + a - t), n;
      } else {
        const a = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
        n += r.substr(a, i.piece.length);
      }
      i = i.next();
    }
    return n;
  }
  computeBufferMetadata() {
    let e = this.root, t = 1, i = 0;
    for (; e !== Ce; )
      t += e.lf_left + e.piece.lineFeedCnt, i += e.size_left + e.piece.length, e = e.right;
    this._lineCnt = t, this._length = i, this._searchCache.validate(this._length);
  }
  // #region node operations
  getIndexOf(e, t) {
    const i = e.piece, n = this.positionInBuffer(e, t), o = n.line - i.start.line;
    if (this.offsetInBuffer(i.bufferIndex, i.end) - this.offsetInBuffer(i.bufferIndex, i.start) === t) {
      const r = this.getLineFeedCnt(e.piece.bufferIndex, i.start, n);
      if (r !== o)
        return { index: r, remainder: 0 };
    }
    return { index: o, remainder: n.column };
  }
  getAccumulatedValue(e, t) {
    if (t < 0)
      return 0;
    const i = e.piece, n = this._buffers[i.bufferIndex].lineStarts, o = i.start.line + t + 1;
    return o > i.end.line ? n[i.end.line] + i.end.column - n[i.start.line] - i.start.column : n[o] - n[i.start.line] - i.start.column;
  }
  deleteNodeTail(e, t) {
    const i = e.piece, n = i.lineFeedCnt, o = this.offsetInBuffer(i.bufferIndex, i.end), r = t, a = this.offsetInBuffer(i.bufferIndex, r), l = this.getLineFeedCnt(i.bufferIndex, i.start, r), c = l - n, h = a - o, d = i.length + h;
    e.piece = new Dn(i.bufferIndex, i.start, r, l, d), cr(this, e, h, c);
  }
  deleteNodeHead(e, t) {
    const i = e.piece, n = i.lineFeedCnt, o = this.offsetInBuffer(i.bufferIndex, i.start), r = t, a = this.getLineFeedCnt(i.bufferIndex, r, i.end), l = this.offsetInBuffer(i.bufferIndex, r), c = a - n, h = o - l, d = i.length + h;
    e.piece = new Dn(i.bufferIndex, r, i.end, a, d), cr(this, e, h, c);
  }
  shrinkNode(e, t, i) {
    const n = e.piece, o = n.start, r = n.end, a = n.length, l = n.lineFeedCnt, c = t, h = this.getLineFeedCnt(n.bufferIndex, n.start, c), d = this.offsetInBuffer(n.bufferIndex, t) - this.offsetInBuffer(n.bufferIndex, o);
    e.piece = new Dn(n.bufferIndex, n.start, c, h, d), cr(this, e, d - a, h - l);
    const u = new Dn(n.bufferIndex, i, r, this.getLineFeedCnt(n.bufferIndex, i, r), this.offsetInBuffer(n.bufferIndex, r) - this.offsetInBuffer(n.bufferIndex, i)), f = this.rbInsertRight(e, u);
    this.validateCRLFWithPrevNode(f);
  }
  appendToNode(e, t) {
    this.adjustCarriageReturnFromNext(t, e) && (t += `
`);
    const i = this.shouldCheckCRLF() && this.startWithLF(t) && this.endWithCR(e), n = this._buffers[0].buffer.length;
    this._buffers[0].buffer += t;
    const o = dr(t, !1);
    for (let f = 0; f < o.length; f++)
      o[f] += n;
    if (i) {
      const f = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];
      this._buffers[0].lineStarts.pop(), this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: n - f };
    }
    this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(o.slice(1));
    const r = this._buffers[0].lineStarts.length - 1, a = this._buffers[0].buffer.length - this._buffers[0].lineStarts[r], l = { line: r, column: a }, c = e.piece.length + t.length, h = e.piece.lineFeedCnt, d = this.getLineFeedCnt(0, e.piece.start, l), u = d - h;
    e.piece = new Dn(e.piece.bufferIndex, e.piece.start, l, d, c), this._lastChangeBufferPos = l, cr(this, e, t.length, u);
  }
  nodeAt(e) {
    let t = this.root;
    const i = this._searchCache.get(e);
    if (i)
      return {
        node: i.node,
        nodeStartOffset: i.nodeStartOffset,
        remainder: e - i.nodeStartOffset
      };
    let n = 0;
    for (; t !== Ce; )
      if (t.size_left > e)
        t = t.left;
      else if (t.size_left + t.piece.length >= e) {
        n += t.size_left;
        const o = {
          node: t,
          remainder: e - t.size_left,
          nodeStartOffset: n
        };
        return this._searchCache.set(o), o;
      } else
        e -= t.size_left + t.piece.length, n += t.size_left + t.piece.length, t = t.right;
    return null;
  }
  nodeAt2(e, t) {
    let i = this.root, n = 0;
    for (; i !== Ce; )
      if (i.left !== Ce && i.lf_left >= e - 1)
        i = i.left;
      else if (i.lf_left + i.piece.lineFeedCnt > e - 1) {
        const o = this.getAccumulatedValue(i, e - i.lf_left - 2), r = this.getAccumulatedValue(i, e - i.lf_left - 1);
        return n += i.size_left, {
          node: i,
          remainder: Math.min(o + t - 1, r),
          nodeStartOffset: n
        };
      } else if (i.lf_left + i.piece.lineFeedCnt === e - 1) {
        const o = this.getAccumulatedValue(i, e - i.lf_left - 2);
        if (o + t - 1 <= i.piece.length)
          return {
            node: i,
            remainder: o + t - 1,
            nodeStartOffset: n
          };
        t -= i.piece.length - o;
        break;
      } else
        e -= i.lf_left + i.piece.lineFeedCnt, n += i.size_left + i.piece.length, i = i.right;
    for (i = i.next(); i !== Ce; ) {
      if (i.piece.lineFeedCnt > 0) {
        const o = this.getAccumulatedValue(i, 0), r = this.offsetOfNode(i);
        return {
          node: i,
          remainder: Math.min(t - 1, o),
          nodeStartOffset: r
        };
      } else if (i.piece.length >= t - 1) {
        const o = this.offsetOfNode(i);
        return {
          node: i,
          remainder: t - 1,
          nodeStartOffset: o
        };
      } else
        t -= i.piece.length;
      i = i.next();
    }
    return null;
  }
  nodeCharCodeAt(e, t) {
    if (e.piece.lineFeedCnt < 1)
      return -1;
    const i = this._buffers[e.piece.bufferIndex], n = this.offsetInBuffer(e.piece.bufferIndex, e.piece.start) + t;
    return i.buffer.charCodeAt(n);
  }
  offsetOfNode(e) {
    if (!e)
      return 0;
    let t = e.size_left;
    for (; e !== this.root; )
      e.parent.right === e && (t += e.parent.size_left + e.parent.piece.length), e = e.parent;
    return t;
  }
  // #endregion
  // #region CRLF
  shouldCheckCRLF() {
    return !(this._EOLNormalized && this._EOL === `
`);
  }
  startWithLF(e) {
    if (typeof e == "string")
      return e.charCodeAt(0) === 10;
    if (e === Ce || e.piece.lineFeedCnt === 0)
      return !1;
    const t = e.piece, i = this._buffers[t.bufferIndex].lineStarts, n = t.start.line, o = i[n] + t.start.column;
    return n === i.length - 1 || i[n + 1] > o + 1 ? !1 : this._buffers[t.bufferIndex].buffer.charCodeAt(o) === 10;
  }
  endWithCR(e) {
    return typeof e == "string" ? e.charCodeAt(e.length - 1) === 13 : e === Ce || e.piece.lineFeedCnt === 0 ? !1 : this.nodeCharCodeAt(e, e.piece.length - 1) === 13;
  }
  validateCRLFWithPrevNode(e) {
    if (this.shouldCheckCRLF() && this.startWithLF(e)) {
      const t = e.prev();
      this.endWithCR(t) && this.fixCRLF(t, e);
    }
  }
  validateCRLFWithNextNode(e) {
    if (this.shouldCheckCRLF() && this.endWithCR(e)) {
      const t = e.next();
      this.startWithLF(t) && this.fixCRLF(e, t);
    }
  }
  fixCRLF(e, t) {
    const i = [], n = this._buffers[e.piece.bufferIndex].lineStarts;
    let o;
    e.piece.end.column === 0 ? o = { line: e.piece.end.line - 1, column: n[e.piece.end.line] - n[e.piece.end.line - 1] - 1 } : o = { line: e.piece.end.line, column: e.piece.end.column - 1 };
    const r = e.piece.length - 1, a = e.piece.lineFeedCnt - 1;
    e.piece = new Dn(e.piece.bufferIndex, e.piece.start, o, a, r), cr(this, e, -1, -1), e.piece.length === 0 && i.push(e);
    const l = { line: t.piece.start.line + 1, column: 0 }, c = t.piece.length - 1, h = this.getLineFeedCnt(t.piece.bufferIndex, l, t.piece.end);
    t.piece = new Dn(t.piece.bufferIndex, l, t.piece.end, h, c), cr(this, t, -1, -1), t.piece.length === 0 && i.push(t);
    const d = this.createNewPieces(`\r
`);
    this.rbInsertRight(e, d[0]);
    for (let u = 0; u < i.length; u++)
      xm(this, i[u]);
  }
  adjustCarriageReturnFromNext(e, t) {
    if (this.shouldCheckCRLF() && this.endWithCR(e)) {
      const i = t.next();
      if (this.startWithLF(i)) {
        if (e += `
`, i.piece.length === 1)
          xm(this, i);
        else {
          const n = i.piece, o = { line: n.start.line + 1, column: 0 }, r = n.length - 1, a = this.getLineFeedCnt(n.bufferIndex, o, n.end);
          i.piece = new Dn(n.bufferIndex, o, n.end, a, r), cr(this, i, -1, -1);
        }
        return !0;
      }
    }
    return !1;
  }
  // #endregion
  // #endregion
  // #region Tree operations
  iterate(e, t) {
    if (e === Ce)
      return t(Ce);
    const i = this.iterate(e.left, t);
    return i && t(e) && this.iterate(e.right, t);
  }
  getNodeContent(e) {
    if (e === Ce)
      return "";
    const t = this._buffers[e.piece.bufferIndex], i = e.piece, n = this.offsetInBuffer(i.bufferIndex, i.start), o = this.offsetInBuffer(i.bufferIndex, i.end);
    return t.buffer.substring(n, o);
  }
  getPieceContent(e) {
    const t = this._buffers[e.bufferIndex], i = this.offsetInBuffer(e.bufferIndex, e.start), n = this.offsetInBuffer(e.bufferIndex, e.end);
    return t.buffer.substring(i, n);
  }
  /**
   *      node              node
   *     /  \              /  \
   *    a   b    <----   a    b
   *                         /
   *                        z
   */
  rbInsertRight(e, t) {
    const i = new xy(
      t,
      1
      /* NodeColor.Red */
    );
    if (i.left = Ce, i.right = Ce, i.parent = Ce, i.size_left = 0, i.lf_left = 0, this.root === Ce)
      this.root = i, i.color = 0;
    else if (e.right === Ce)
      e.right = i, i.parent = e;
    else {
      const o = Uk(e.right);
      o.left = i, i.parent = o;
    }
    return cN(this, i), i;
  }
  /**
   *      node              node
   *     /  \              /  \
   *    a   b     ---->   a    b
   *                       \
   *                        z
   */
  rbInsertLeft(e, t) {
    const i = new xy(
      t,
      1
      /* NodeColor.Red */
    );
    if (i.left = Ce, i.right = Ce, i.parent = Ce, i.size_left = 0, i.lf_left = 0, this.root === Ce)
      this.root = i, i.color = 0;
    else if (e.left === Ce)
      e.left = i, i.parent = e;
    else {
      const n = t4(e.left);
      n.right = i, i.parent = n;
    }
    return cN(this, i), i;
  }
}
class id extends q {
  constructor(e, t, i, n, o, r, a) {
    super(), this._onDidChangeContent = this._register(new O()), this._BOM = t, this._mightContainNonBasicASCII = !r, this._mightContainRTL = n, this._mightContainUnusualLineTerminators = o, this._pieceTree = new r$(e, i, a);
  }
  mightContainRTL() {
    return this._mightContainRTL;
  }
  mightContainUnusualLineTerminators() {
    return this._mightContainUnusualLineTerminators;
  }
  resetMightContainUnusualLineTerminators() {
    this._mightContainUnusualLineTerminators = !1;
  }
  mightContainNonBasicASCII() {
    return this._mightContainNonBasicASCII;
  }
  getBOM() {
    return this._BOM;
  }
  getEOL() {
    return this._pieceTree.getEOL();
  }
  createSnapshot(e) {
    return this._pieceTree.createSnapshot(e ? this._BOM : "");
  }
  getOffsetAt(e, t) {
    return this._pieceTree.getOffsetAt(e, t);
  }
  getPositionAt(e) {
    return this._pieceTree.getPositionAt(e);
  }
  getRangeAt(e, t) {
    const i = e + t, n = this.getPositionAt(e), o = this.getPositionAt(i);
    return new R(n.lineNumber, n.column, o.lineNumber, o.column);
  }
  getValueInRange(e, t = 0) {
    if (e.isEmpty())
      return "";
    const i = this._getEndOfLine(t);
    return this._pieceTree.getValueInRange(e, i);
  }
  getValueLengthInRange(e, t = 0) {
    if (e.isEmpty())
      return 0;
    if (e.startLineNumber === e.endLineNumber)
      return e.endColumn - e.startColumn;
    const i = this.getOffsetAt(e.startLineNumber, e.startColumn), n = this.getOffsetAt(e.endLineNumber, e.endColumn);
    let o = 0;
    const r = this._getEndOfLine(t), a = this.getEOL();
    if (r.length !== a.length) {
      const l = r.length - a.length, c = e.endLineNumber - e.startLineNumber;
      o = l * c;
    }
    return n - i + o;
  }
  getCharacterCountInRange(e, t = 0) {
    if (this._mightContainNonBasicASCII) {
      let i = 0;
      const n = e.startLineNumber, o = e.endLineNumber;
      for (let r = n; r <= o; r++) {
        const a = this.getLineContent(r), l = r === n ? e.startColumn - 1 : 0, c = r === o ? e.endColumn - 1 : a.length;
        for (let h = l; h < c; h++)
          hi(a.charCodeAt(h)) ? (i = i + 1, h = h + 1) : i = i + 1;
      }
      return i += this._getEndOfLine(t).length * (o - n), i;
    }
    return this.getValueLengthInRange(e, t);
  }
  getLength() {
    return this._pieceTree.getLength();
  }
  getLineCount() {
    return this._pieceTree.getLineCount();
  }
  getLinesContent() {
    return this._pieceTree.getLinesContent();
  }
  getLineContent(e) {
    return this._pieceTree.getLineContent(e);
  }
  getLineCharCode(e, t) {
    return this._pieceTree.getLineCharCode(e, t);
  }
  getLineLength(e) {
    return this._pieceTree.getLineLength(e);
  }
  getLineFirstNonWhitespaceColumn(e) {
    const t = On(this.getLineContent(e));
    return t === -1 ? 0 : t + 1;
  }
  getLineLastNonWhitespaceColumn(e) {
    const t = Ec(this.getLineContent(e));
    return t === -1 ? 0 : t + 2;
  }
  _getEndOfLine(e) {
    switch (e) {
      case 1:
        return `
`;
      case 2:
        return `\r
`;
      case 0:
        return this.getEOL();
      default:
        throw new Error("Unknown EOL preference");
    }
  }
  setEOL(e) {
    this._pieceTree.setEOL(e);
  }
  applyEdits(e, t, i) {
    let n = this._mightContainRTL, o = this._mightContainUnusualLineTerminators, r = this._mightContainNonBasicASCII, a = !0, l = [];
    for (let m = 0; m < e.length; m++) {
      const _ = e[m];
      a && _._isTracked && (a = !1);
      const b = _.range;
      if (_.text) {
        let L = !0;
        r || (L = !ML(_.text), r = L), !n && L && (n = Af(_.text)), !o && L && (o = J2(_.text));
      }
      let C = "", v = 0, w = 0, S = 0;
      if (_.text) {
        let L;
        [v, w, S, L] = Ld(_.text);
        const k = this.getEOL();
        L === 0 || L === (k === `\r
` ? 2 : 1) ? C = _.text : C = _.text.replace(/\r\n|\r|\n/g, k);
      }
      l[m] = {
        sortIndex: m,
        identifier: _.identifier || null,
        range: b,
        rangeOffset: this.getOffsetAt(b.startLineNumber, b.startColumn),
        rangeLength: this.getValueLengthInRange(b),
        text: C,
        eolCount: v,
        firstLineLength: w,
        lastLineLength: S,
        forceMoveMarkers: !!_.forceMoveMarkers,
        isAutoWhitespaceEdit: _.isAutoWhitespaceEdit || !1
      };
    }
    l.sort(id._sortOpsAscending);
    let c = !1;
    for (let m = 0, _ = l.length - 1; m < _; m++) {
      const b = l[m].range.getEndPosition(), C = l[m + 1].range.getStartPosition();
      if (C.isBeforeOrEqual(b)) {
        if (C.isBefore(b))
          throw new Error("Overlapping ranges are not allowed!");
        c = !0;
      }
    }
    a && (l = this._reduceOperations(l));
    const h = i || t ? id._getInverseEditRanges(l) : [], d = [];
    if (t)
      for (let m = 0; m < l.length; m++) {
        const _ = l[m], b = h[m];
        if (_.isAutoWhitespaceEdit && _.range.isEmpty())
          for (let C = b.startLineNumber; C <= b.endLineNumber; C++) {
            let v = "";
            C === b.startLineNumber && (v = this.getLineContent(_.range.startLineNumber), On(v) !== -1) || d.push({ lineNumber: C, oldContent: v });
          }
      }
    let u = null;
    if (i) {
      let m = 0;
      u = [];
      for (let _ = 0; _ < l.length; _++) {
        const b = l[_], C = h[_], v = this.getValueInRange(b.range), w = b.rangeOffset + m;
        m += b.text.length - v.length, u[_] = {
          sortIndex: b.sortIndex,
          identifier: b.identifier,
          range: C,
          text: v,
          textChange: new Ni(b.rangeOffset, v, w, b.text)
        };
      }
      c || u.sort((_, b) => _.sortIndex - b.sortIndex);
    }
    this._mightContainRTL = n, this._mightContainUnusualLineTerminators = o, this._mightContainNonBasicASCII = r;
    const f = this._doApplyEdits(l);
    let g = null;
    if (t && d.length > 0) {
      d.sort((m, _) => _.lineNumber - m.lineNumber), g = [];
      for (let m = 0, _ = d.length; m < _; m++) {
        const b = d[m].lineNumber;
        if (m > 0 && d[m - 1].lineNumber === b)
          continue;
        const C = d[m].oldContent, v = this.getLineContent(b);
        v.length === 0 || v === C || On(v) !== -1 || g.push(b);
      }
    }
    return this._onDidChangeContent.fire(), new a9(u, f, g);
  }
  /**
   * Transform operations such that they represent the same logic edit,
   * but that they also do not cause OOM crashes.
   */
  _reduceOperations(e) {
    return e.length < 1e3 ? e : [this._toSingleEditOperation(e)];
  }
  _toSingleEditOperation(e) {
    let t = !1;
    const i = e[0].range, n = e[e.length - 1].range, o = new R(i.startLineNumber, i.startColumn, n.endLineNumber, n.endColumn);
    let r = i.startLineNumber, a = i.startColumn;
    const l = [];
    for (let f = 0, g = e.length; f < g; f++) {
      const m = e[f], _ = m.range;
      t = t || m.forceMoveMarkers, l.push(this.getValueInRange(new R(r, a, _.startLineNumber, _.startColumn))), m.text.length > 0 && l.push(m.text), r = _.endLineNumber, a = _.endColumn;
    }
    const c = l.join(""), [h, d, u] = Ld(c);
    return {
      sortIndex: 0,
      identifier: e[0].identifier,
      range: o,
      rangeOffset: this.getOffsetAt(o.startLineNumber, o.startColumn),
      rangeLength: this.getValueLengthInRange(
        o,
        0
        /* EndOfLinePreference.TextDefined */
      ),
      text: c,
      eolCount: h,
      firstLineLength: d,
      lastLineLength: u,
      forceMoveMarkers: t,
      isAutoWhitespaceEdit: !1
    };
  }
  _doApplyEdits(e) {
    e.sort(id._sortOpsDescending);
    const t = [];
    for (let i = 0; i < e.length; i++) {
      const n = e[i], o = n.range.startLineNumber, r = n.range.startColumn, a = n.range.endLineNumber, l = n.range.endColumn;
      if (o === a && r === l && n.text.length === 0)
        continue;
      n.text ? (this._pieceTree.delete(n.rangeOffset, n.rangeLength), this._pieceTree.insert(n.rangeOffset, n.text, !0)) : this._pieceTree.delete(n.rangeOffset, n.rangeLength);
      const c = new R(o, r, a, l);
      t.push({
        range: c,
        rangeLength: n.rangeLength,
        text: n.text,
        rangeOffset: n.rangeOffset,
        forceMoveMarkers: n.forceMoveMarkers
      });
    }
    return t;
  }
  findMatchesLineByLine(e, t, i, n) {
    return this._pieceTree.findMatchesLineByLine(e, t, i, n);
  }
  /**
   * Assumes `operations` are validated and sorted ascending
   */
  static _getInverseEditRanges(e) {
    const t = [];
    let i = 0, n = 0, o = null;
    for (let r = 0, a = e.length; r < a; r++) {
      const l = e[r];
      let c, h;
      o ? o.range.endLineNumber === l.range.startLineNumber ? (c = i, h = n + (l.range.startColumn - o.range.endColumn)) : (c = i + (l.range.startLineNumber - o.range.endLineNumber), h = l.range.startColumn) : (c = l.range.startLineNumber, h = l.range.startColumn);
      let d;
      if (l.text.length > 0) {
        const u = l.eolCount + 1;
        u === 1 ? d = new R(c, h, c, h + l.firstLineLength) : d = new R(c, h, c + u - 1, l.lastLineLength + 1);
      } else
        d = new R(c, h, c, h);
      i = d.endLineNumber, n = d.endColumn, t.push(d), o = l;
    }
    return t;
  }
  static _sortOpsAscending(e, t) {
    const i = R.compareRangesUsingEnds(e.range, t.range);
    return i === 0 ? e.sortIndex - t.sortIndex : i;
  }
  static _sortOpsDescending(e, t) {
    const i = R.compareRangesUsingEnds(e.range, t.range);
    return i === 0 ? t.sortIndex - e.sortIndex : -i;
  }
}
class a$ {
  constructor(e, t, i, n, o, r, a, l, c) {
    this._chunks = e, this._bom = t, this._cr = i, this._lf = n, this._crlf = o, this._containsRTL = r, this._containsUnusualLineTerminators = a, this._isBasicASCII = l, this._normalizeEOL = c;
  }
  _getEOL(e) {
    const t = this._cr + this._lf + this._crlf, i = this._cr + this._crlf;
    return t === 0 ? e === 1 ? `
` : `\r
` : i > t / 2 ? `\r
` : `
`;
  }
  create(e) {
    const t = this._getEOL(e), i = this._chunks;
    if (this._normalizeEOL && (t === `\r
` && (this._cr > 0 || this._lf > 0) || t === `
` && (this._cr > 0 || this._crlf > 0)))
      for (let o = 0, r = i.length; o < r; o++) {
        const a = i[o].buffer.replace(/\r\n|\r|\n/g, t), l = dr(a);
        i[o] = new Nl(a, l);
      }
    const n = new id(i, this._bom, t, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);
    return { textBuffer: n, disposable: n };
  }
}
class n4 {
  constructor() {
    this.chunks = [], this.BOM = "", this._hasPreviousChar = !1, this._previousChar = 0, this._tmpLineStarts = [], this.cr = 0, this.lf = 0, this.crlf = 0, this.containsRTL = !1, this.containsUnusualLineTerminators = !1, this.isBasicASCII = !0;
  }
  acceptChunk(e) {
    if (e.length === 0)
      return;
    this.chunks.length === 0 && AL(e) && (this.BOM = i6, e = e.substr(1));
    const t = e.charCodeAt(e.length - 1);
    t === 13 || t >= 55296 && t <= 56319 ? (this._acceptChunk1(e.substr(0, e.length - 1), !1), this._hasPreviousChar = !0, this._previousChar = t) : (this._acceptChunk1(e, !1), this._hasPreviousChar = !1, this._previousChar = t);
  }
  _acceptChunk1(e, t) {
    !t && e.length === 0 || (this._hasPreviousChar ? this._acceptChunk2(String.fromCharCode(this._previousChar) + e) : this._acceptChunk2(e));
  }
  _acceptChunk2(e) {
    const t = n$(this._tmpLineStarts, e);
    this.chunks.push(new Nl(e, t.lineStarts)), this.cr += t.cr, this.lf += t.lf, this.crlf += t.crlf, t.isBasicASCII || (this.isBasicASCII = !1, this.containsRTL || (this.containsRTL = Af(e)), this.containsUnusualLineTerminators || (this.containsUnusualLineTerminators = J2(e)));
  }
  finish(e = !0) {
    return this._finish(), new a$(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, e);
  }
  _finish() {
    if (this.chunks.length === 0 && this._acceptChunk1("", !0), this._hasPreviousChar) {
      this._hasPreviousChar = !1;
      const e = this.chunks[this.chunks.length - 1];
      e.buffer += String.fromCharCode(this._previousChar);
      const t = dr(e.buffer);
      e.lineStarts = t, this._previousChar === 13 && this.cr++;
    }
  }
}
class l$ {
  constructor(e) {
    this._default = e, this._store = [];
  }
  get(e) {
    return e < this._store.length ? this._store[e] : this._default;
  }
  set(e, t) {
    for (; e >= this._store.length; )
      this._store[this._store.length] = this._default;
    this._store[e] = t;
  }
  replace(e, t, i) {
    if (e >= this._store.length)
      return;
    if (t === 0) {
      this.insert(e, i);
      return;
    } else if (i === 0) {
      this.delete(e, t);
      return;
    }
    const n = this._store.slice(0, e), o = this._store.slice(e + t), r = c$(i, this._default);
    this._store = n.concat(r, o);
  }
  delete(e, t) {
    t === 0 || e >= this._store.length || this._store.splice(e, t);
  }
  insert(e, t) {
    if (t === 0 || e >= this._store.length)
      return;
    const i = [];
    for (let n = 0; n < t; n++)
      i[n] = this._default;
    this._store = X1(this._store, e, i);
  }
}
function c$(s, e) {
  const t = [];
  for (let i = 0; i < s; i++)
    t[i] = e;
  return t;
}
class h$ {
  /**
   * (Inclusive) start line number for these tokens.
   */
  get startLineNumber() {
    return this._startLineNumber;
  }
  /**
   * (Inclusive) end line number for these tokens.
   */
  get endLineNumber() {
    return this._startLineNumber + this._tokens.length - 1;
  }
  constructor(e, t) {
    this._startLineNumber = e, this._tokens = t;
  }
  /**
   * @see {@link _tokens}
   */
  getLineTokens(e) {
    return this._tokens[e - this._startLineNumber];
  }
  appendLineTokens(e) {
    this._tokens.push(e);
  }
}
class Dy {
  constructor() {
    this._tokens = [];
  }
  add(e, t) {
    if (this._tokens.length > 0) {
      const i = this._tokens[this._tokens.length - 1];
      if (i.endLineNumber + 1 === e) {
        i.appendLineTokens(t);
        return;
      }
    }
    this._tokens.push(new h$(e, [t]));
  }
  finalize() {
    return this._tokens;
  }
}
class d$ {
  constructor(e, t) {
    this.tokenizationSupport = t, this.initialState = this.tokenizationSupport.getInitialState(), this.store = new Ey(e);
  }
  getStartState(e) {
    return this.store.getStartState(e, this.initialState);
  }
  getFirstInvalidLine() {
    return this.store.getFirstInvalidLine(this.initialState);
  }
}
class u$ extends d$ {
  constructor(e, t, i, n) {
    super(e, t), this._textModel = i, this._languageIdCodec = n;
  }
  updateTokensUntilLine(e, t) {
    const i = this._textModel.getLanguageId();
    for (; ; ) {
      const n = this.getFirstInvalidLine();
      if (!n || n.lineNumber > t)
        break;
      const o = this._textModel.getLineContent(n.lineNumber), r = mu(this._languageIdCodec, i, this.tokenizationSupport, o, !0, n.startState);
      e.add(n.lineNumber, r.tokens), this.store.setEndState(n.lineNumber, r.endState);
    }
  }
  /** assumes state is up to date */
  getTokenTypeIfInsertingCharacter(e, t) {
    const i = this.getStartState(e.lineNumber);
    if (!i)
      return 0;
    const n = this._textModel.getLanguageId(), o = this._textModel.getLineContent(e.lineNumber), r = o.substring(0, e.column - 1) + t + o.substring(e.column - 1), a = mu(this._languageIdCodec, n, this.tokenizationSupport, r, !0, i), l = new Si(a.tokens, r, this._languageIdCodec);
    if (l.getCount() === 0)
      return 0;
    const c = l.findTokenIndexAtOffset(e.column - 1);
    return l.getStandardTokenType(c);
  }
  /** assumes state is up to date */
  tokenizeLineWithEdit(e, t, i) {
    const n = e.lineNumber, o = e.column, r = this.getStartState(n);
    if (!r)
      return null;
    const a = this._textModel.getLineContent(n), l = a.substring(0, o - 1) + i + a.substring(o - 1 + t), c = this._textModel.getLanguageIdAtPosition(n, 0), h = mu(this._languageIdCodec, c, this.tokenizationSupport, l, !0, r);
    return new Si(h.tokens, l, this._languageIdCodec);
  }
  hasAccurateTokensForLine(e) {
    const t = this.store.getFirstInvalidEndStateLineNumberOrMax();
    return e < t;
  }
  isCheapToTokenize(e) {
    const t = this.store.getFirstInvalidEndStateLineNumberOrMax();
    return e < t || e === t && this._textModel.getLineLength(e) < 2048;
  }
  /**
   * The result is not cached.
   */
  tokenizeHeuristically(e, t, i) {
    if (i <= this.store.getFirstInvalidEndStateLineNumberOrMax())
      return { heuristicTokens: !1 };
    if (t <= this.store.getFirstInvalidEndStateLineNumberOrMax())
      return this.updateTokensUntilLine(e, i), { heuristicTokens: !1 };
    let n = this.guessStartState(t);
    const o = this._textModel.getLanguageId();
    for (let r = t; r <= i; r++) {
      const a = this._textModel.getLineContent(r), l = mu(this._languageIdCodec, o, this.tokenizationSupport, a, !0, n);
      e.add(r, l.tokens), n = l.endState;
    }
    return { heuristicTokens: !0 };
  }
  guessStartState(e) {
    let t = this._textModel.getLineFirstNonWhitespaceColumn(e);
    const i = [];
    let n = null;
    for (let a = e - 1; t > 1 && a >= 1; a--) {
      const l = this._textModel.getLineFirstNonWhitespaceColumn(a);
      if (l !== 0 && l < t && (i.push(this._textModel.getLineContent(a)), t = l, n = this.getStartState(a), n))
        break;
    }
    n || (n = this.tokenizationSupport.getInitialState()), i.reverse();
    const o = this._textModel.getLanguageId();
    let r = n;
    for (const a of i)
      r = mu(this._languageIdCodec, o, this.tokenizationSupport, a, !1, r).endState;
    return r;
  }
}
class Ey {
  constructor(e) {
    this.lineCount = e, this._tokenizationStateStore = new f$(), this._invalidEndStatesLineNumbers = new g$(), this._invalidEndStatesLineNumbers.addRange(new xe(1, e + 1));
  }
  getEndState(e) {
    return this._tokenizationStateStore.getEndState(e);
  }
  /**
   * @returns if the end state has changed.
   */
  setEndState(e, t) {
    if (!t)
      throw new it("Cannot set null/undefined state");
    this._invalidEndStatesLineNumbers.delete(e);
    const i = this._tokenizationStateStore.setEndState(e, t);
    return i && e < this.lineCount && this._invalidEndStatesLineNumbers.addRange(new xe(e + 1, e + 2)), i;
  }
  acceptChange(e, t) {
    this.lineCount += t - e.length, this._tokenizationStateStore.acceptChange(e, t), this._invalidEndStatesLineNumbers.addRangeAndResize(new xe(e.startLineNumber, e.endLineNumberExclusive), t);
  }
  acceptChanges(e) {
    for (const t of e) {
      const [i] = Ld(t.text);
      this.acceptChange(new we(t.range.startLineNumber, t.range.endLineNumber + 1), i + 1);
    }
  }
  invalidateEndStateRange(e) {
    this._invalidEndStatesLineNumbers.addRange(new xe(e.startLineNumber, e.endLineNumberExclusive));
  }
  getFirstInvalidEndStateLineNumber() {
    return this._invalidEndStatesLineNumbers.min;
  }
  getFirstInvalidEndStateLineNumberOrMax() {
    return this.getFirstInvalidEndStateLineNumber() || Number.MAX_SAFE_INTEGER;
  }
  allStatesValid() {
    return this._invalidEndStatesLineNumbers.min === null;
  }
  getStartState(e, t) {
    return e === 1 ? t : this.getEndState(e - 1);
  }
  getFirstInvalidLine(e) {
    const t = this.getFirstInvalidEndStateLineNumber();
    if (t === null)
      return null;
    const i = this.getStartState(t, e);
    if (!i)
      throw new it("Start state must be defined");
    return { lineNumber: t, startState: i };
  }
}
class f$ {
  constructor() {
    this._lineEndStates = new l$(null);
  }
  getEndState(e) {
    return this._lineEndStates.get(e);
  }
  setEndState(e, t) {
    const i = this._lineEndStates.get(e);
    return i && i.equals(t) ? !1 : (this._lineEndStates.set(e, t), !0);
  }
  acceptChange(e, t) {
    let i = e.length;
    t > 0 && i > 0 && (i--, t--), this._lineEndStates.replace(e.startLineNumber, i, t);
  }
}
class g$ {
  constructor() {
    this._ranges = [];
  }
  get min() {
    return this._ranges.length === 0 ? null : this._ranges[0].start;
  }
  delete(e) {
    const t = this._ranges.findIndex((i) => i.contains(e));
    if (t !== -1) {
      const i = this._ranges[t];
      i.start === e ? i.endExclusive === e + 1 ? this._ranges.splice(t, 1) : this._ranges[t] = new xe(e + 1, i.endExclusive) : i.endExclusive === e + 1 ? this._ranges[t] = new xe(i.start, e) : this._ranges.splice(t, 1, new xe(i.start, e), new xe(e + 1, i.endExclusive));
    }
  }
  addRange(e) {
    xe.addRange(e, this._ranges);
  }
  addRangeAndResize(e, t) {
    let i = 0;
    for (; !(i >= this._ranges.length || e.start <= this._ranges[i].endExclusive); )
      i++;
    let n = i;
    for (; !(n >= this._ranges.length || e.endExclusive < this._ranges[n].start); )
      n++;
    const o = t - e.length;
    for (let r = n; r < this._ranges.length; r++)
      this._ranges[r] = this._ranges[r].delta(o);
    if (i === n) {
      const r = new xe(e.start, e.start + t);
      r.isEmpty || this._ranges.splice(i, 0, r);
    } else {
      const r = Math.min(e.start, this._ranges[i].start), a = Math.max(e.endExclusive, this._ranges[n - 1].endExclusive), l = new xe(r, a + o);
      l.isEmpty ? this._ranges.splice(i, n - i) : this._ranges.splice(i, n - i, l);
    }
  }
  toString() {
    return this._ranges.map((e) => e.toString()).join(" + ");
  }
}
function mu(s, e, t, i, n, o) {
  let r = null;
  if (t)
    try {
      r = t.tokenizeEncoded(i, n, o.clone());
    } catch (a) {
      ht(a);
    }
  return r || (r = Sk(s.encodeLanguageId(e), o)), Si.convertToEndOffset(r.tokens, i.length), r;
}
class m$ {
  constructor(e, t) {
    this._tokenizerWithStateStore = e, this._backgroundTokenStore = t, this._isDisposed = !1, this._isScheduled = !1;
  }
  dispose() {
    this._isDisposed = !0;
  }
  handleChanges() {
    this._beginBackgroundTokenization();
  }
  _beginBackgroundTokenization() {
    this._isScheduled || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize() || (this._isScheduled = !0, aM((e) => {
      this._isScheduled = !1, this._backgroundTokenizeWithDeadline(e);
    }));
  }
  /**
   * Tokenize until the deadline occurs, but try to yield every 1-2ms.
   */
  _backgroundTokenizeWithDeadline(e) {
    const t = Date.now() + e.timeRemaining(), i = () => {
      this._isDisposed || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize() || (this._backgroundTokenizeForAtLeast1ms(), Date.now() < t ? D2(i) : this._beginBackgroundTokenization());
    };
    i();
  }
  /**
   * Tokenize for at least 1ms.
   */
  _backgroundTokenizeForAtLeast1ms() {
    const e = this._tokenizerWithStateStore._textModel.getLineCount(), t = new Dy(), i = Dc.create(!1);
    do
      if (i.elapsed() > 1 || this._tokenizeOneInvalidLine(t) >= e)
        break;
    while (this._hasLinesToTokenize());
    this._backgroundTokenStore.setTokens(t.finalize()), this.checkFinished();
  }
  _hasLinesToTokenize() {
    return this._tokenizerWithStateStore ? !this._tokenizerWithStateStore.store.allStatesValid() : !1;
  }
  _tokenizeOneInvalidLine(e) {
    var i;
    const t = (i = this._tokenizerWithStateStore) == null ? void 0 : i.getFirstInvalidLine();
    return t ? (this._tokenizerWithStateStore.updateTokensUntilLine(e, t.lineNumber), t.lineNumber) : this._tokenizerWithStateStore._textModel.getLineCount() + 1;
  }
  checkFinished() {
    this._isDisposed || this._tokenizerWithStateStore.store.allStatesValid() && this._backgroundTokenStore.backgroundTokenizationFinished();
  }
  requestTokens(e, t) {
    this._tokenizerWithStateStore.store.invalidateEndStateRange(new we(e, t));
  }
}
class p$ {
  constructor() {
    this._onDidChangeVisibleRanges = new O(), this.onDidChangeVisibleRanges = this._onDidChangeVisibleRanges.event, this._views = /* @__PURE__ */ new Set();
  }
  attachView() {
    const e = new _$((t) => {
      this._onDidChangeVisibleRanges.fire({ view: e, state: t });
    });
    return this._views.add(e), e;
  }
  detachView(e) {
    this._views.delete(e), this._onDidChangeVisibleRanges.fire({ view: e, state: void 0 });
  }
}
class _$ {
  constructor(e) {
    this.handleStateChange = e;
  }
  setVisibleLines(e, t) {
    const i = e.map((n) => new we(n.startLineNumber, n.endLineNumber + 1));
    this.handleStateChange({ visibleLineRanges: i, stabilized: t });
  }
}
class b$ extends q {
  get lineRanges() {
    return this._lineRanges;
  }
  constructor(e) {
    super(), this._refreshTokens = e, this.runner = this._register(new sn(() => this.update(), 50)), this._computedLineRanges = [], this._lineRanges = [];
  }
  update() {
    oi(this._computedLineRanges, this._lineRanges, (e, t) => e.equals(t)) || (this._computedLineRanges = this._lineRanges, this._refreshTokens());
  }
  handleStateChange(e) {
    this._lineRanges = e.visibleLineRanges, e.stabilized ? (this.runner.cancel(), this.update()) : this.runner.schedule();
  }
}
class s4 extends q {
  get backgroundTokenizationState() {
    return this._backgroundTokenizationState;
  }
  constructor(e, t, i) {
    super(), this._languageIdCodec = e, this._textModel = t, this.getLanguageId = i, this._backgroundTokenizationState = 1, this._onDidChangeBackgroundTokenizationState = this._register(new O()), this.onDidChangeBackgroundTokenizationState = this._onDidChangeBackgroundTokenizationState.event, this._onDidChangeTokens = this._register(new O()), this.onDidChangeTokens = this._onDidChangeTokens.event;
  }
  tokenizeIfCheap(e) {
    this.isCheapToTokenize(e) && this.forceTokenization(e);
  }
}
class hN extends s4 {
  constructor(e, t, i, n) {
    super(t, i, n), this._treeSitterService = e, this._tokenizationSupport = null, this._initialize();
  }
  _initialize() {
    const e = this.getLanguageId();
    (!this._tokenizationSupport || this._lastLanguageId !== e) && (this._lastLanguageId = e, this._tokenizationSupport = zC.get(e));
  }
  getLineTokens(e) {
    const t = this._textModel.getLineContent(e);
    if (this._tokenizationSupport) {
      const i = this._tokenizationSupport.tokenizeEncoded(e, this._textModel);
      if (i)
        return new Si(i, t, this._languageIdCodec);
    }
    return Si.createEmpty(t, this._languageIdCodec);
  }
  resetTokenization(e = !0) {
    e && this._onDidChangeTokens.fire({
      semanticTokensApplied: !1,
      ranges: [
        {
          fromLineNumber: 1,
          toLineNumber: this._textModel.getLineCount()
        }
      ]
    }), this._initialize();
  }
  handleDidChangeAttached() {
  }
  handleDidChangeContent(e) {
    e.isFlush && this.resetTokenization(!1);
  }
  forceTokenization(e) {
  }
  hasAccurateTokensForLine(e) {
    return !0;
  }
  isCheapToTokenize(e) {
    return !0;
  }
  getTokenTypeIfInsertingCharacter(e, t, i) {
    return 0;
  }
  tokenizeLineWithEdit(e, t, i) {
    return null;
  }
  get hasTokens() {
    return this._treeSitterService.getParseResult(this._textModel) !== void 0;
  }
}
const o4 = Ve("treeSitterParserService"), ur = new Uint32Array(0).buffer;
class No {
  static deleteBeginning(e, t) {
    return e === null || e === ur ? e : No.delete(e, 0, t);
  }
  static deleteEnding(e, t) {
    if (e === null || e === ur)
      return e;
    const i = Ir(e), n = i[i.length - 2];
    return No.delete(e, t, n);
  }
  static delete(e, t, i) {
    if (e === null || e === ur || t === i)
      return e;
    const n = Ir(e), o = n.length >>> 1;
    if (t === 0 && n[n.length - 2] === i)
      return ur;
    const r = Si.findIndexInTokensArray(n, t), a = r > 0 ? n[r - 1 << 1] : 0, l = n[r << 1];
    if (i < l) {
      const f = i - t;
      for (let g = r; g < o; g++)
        n[g << 1] -= f;
      return e;
    }
    let c, h;
    a !== t ? (n[r << 1] = t, c = r + 1 << 1, h = t) : (c = r << 1, h = a);
    const d = i - t;
    for (let f = r + 1; f < o; f++) {
      const g = n[f << 1] - d;
      g > h && (n[c++] = g, n[c++] = n[(f << 1) + 1], h = g);
    }
    if (c === n.length)
      return e;
    const u = new Uint32Array(c);
    return u.set(n.subarray(0, c), 0), u.buffer;
  }
  static append(e, t) {
    if (t === ur)
      return e;
    if (e === ur)
      return t;
    if (e === null)
      return e;
    if (t === null)
      return null;
    const i = Ir(e), n = Ir(t), o = n.length >>> 1, r = new Uint32Array(i.length + n.length);
    r.set(i, 0);
    let a = i.length;
    const l = i[i.length - 2];
    for (let c = 0; c < o; c++)
      r[a++] = n[c << 1] + l, r[a++] = n[(c << 1) + 1];
    return r.buffer;
  }
  static insert(e, t, i) {
    if (e === null || e === ur)
      return e;
    const n = Ir(e), o = n.length >>> 1;
    let r = Si.findIndexInTokensArray(n, t);
    r > 0 && n[r - 1 << 1] === t && r--;
    for (let a = r; a < o; a++)
      n[a << 1] += i;
    return e;
  }
}
function Ir(s) {
  return s instanceof Uint32Array ? s : new Uint32Array(s);
}
class tg {
  constructor(e) {
    this._lineTokens = [], this._len = 0, this._languageIdCodec = e;
  }
  flush() {
    this._lineTokens = [], this._len = 0;
  }
  get hasTokens() {
    return this._lineTokens.length > 0;
  }
  getTokens(e, t, i) {
    let n = null;
    if (t < this._len && (n = this._lineTokens[t]), n !== null && n !== ur)
      return new Si(Ir(n), i, this._languageIdCodec);
    const o = new Uint32Array(2);
    return o[0] = i.length, o[1] = dN(this._languageIdCodec.encodeLanguageId(e)), new Si(o, i, this._languageIdCodec);
  }
  static _massageTokens(e, t, i) {
    const n = i ? Ir(i) : null;
    if (t === 0) {
      let o = !1;
      if (n && n.length > 1 && (o = Xs.getLanguageId(n[1]) !== e), !o)
        return ur;
    }
    if (!n || n.length === 0) {
      const o = new Uint32Array(2);
      return o[0] = t, o[1] = dN(e), o.buffer;
    }
    return n[n.length - 2] = t, n.byteOffset === 0 && n.byteLength === n.buffer.byteLength ? n.buffer : n;
  }
  _ensureLine(e) {
    for (; e >= this._len; )
      this._lineTokens[this._len] = null, this._len++;
  }
  _deleteLines(e, t) {
    t !== 0 && (e + t > this._len && (t = this._len - e), this._lineTokens.splice(e, t), this._len -= t);
  }
  _insertLines(e, t) {
    if (t === 0)
      return;
    const i = [];
    for (let n = 0; n < t; n++)
      i[n] = null;
    this._lineTokens = X1(this._lineTokens, e, i), this._len += t;
  }
  setTokens(e, t, i, n, o) {
    const r = tg._massageTokens(this._languageIdCodec.encodeLanguageId(e), i, n);
    this._ensureLine(t);
    const a = this._lineTokens[t];
    return this._lineTokens[t] = r, o ? !tg._equals(a, r) : !1;
  }
  static _equals(e, t) {
    if (!e || !t)
      return !e && !t;
    const i = Ir(e), n = Ir(t);
    if (i.length !== n.length)
      return !1;
    for (let o = 0, r = i.length; o < r; o++)
      if (i[o] !== n[o])
        return !1;
    return !0;
  }
  //#region Editing
  acceptEdit(e, t, i) {
    this._acceptDeleteRange(e), this._acceptInsertText(new V(e.startLineNumber, e.startColumn), t, i);
  }
  _acceptDeleteRange(e) {
    const t = e.startLineNumber - 1;
    if (t >= this._len)
      return;
    if (e.startLineNumber === e.endLineNumber) {
      if (e.startColumn === e.endColumn)
        return;
      this._lineTokens[t] = No.delete(this._lineTokens[t], e.startColumn - 1, e.endColumn - 1);
      return;
    }
    this._lineTokens[t] = No.deleteEnding(this._lineTokens[t], e.startColumn - 1);
    const i = e.endLineNumber - 1;
    let n = null;
    i < this._len && (n = No.deleteBeginning(this._lineTokens[i], e.endColumn - 1)), this._lineTokens[t] = No.append(this._lineTokens[t], n), this._deleteLines(e.startLineNumber, e.endLineNumber - e.startLineNumber);
  }
  _acceptInsertText(e, t, i) {
    if (t === 0 && i === 0)
      return;
    const n = e.lineNumber - 1;
    if (!(n >= this._len)) {
      if (t === 0) {
        this._lineTokens[n] = No.insert(this._lineTokens[n], e.column - 1, i);
        return;
      }
      this._lineTokens[n] = No.deleteEnding(this._lineTokens[n], e.column - 1), this._lineTokens[n] = No.insert(this._lineTokens[n], e.column - 1, i), this._insertLines(e.lineNumber, t);
    }
  }
  //#endregion
  setMultilineTokens(e, t) {
    if (e.length === 0)
      return { changes: [] };
    const i = [];
    for (let n = 0, o = e.length; n < o; n++) {
      const r = e[n];
      let a = 0, l = 0, c = !1;
      for (let h = r.startLineNumber; h <= r.endLineNumber; h++)
        c ? (this.setTokens(t.getLanguageId(), h - 1, t.getLineLength(h), r.getLineTokens(h), !1), l = h) : this.setTokens(t.getLanguageId(), h - 1, t.getLineLength(h), r.getLineTokens(h), !0) && (c = !0, a = h, l = h);
      c && i.push({ fromLineNumber: a, toLineNumber: l });
    }
    return { changes: i };
  }
}
function dN(s) {
  return (s << 0 | 0 | 0 | 32768 | 2 << 24 | 1024) >>> 0;
}
class qk {
  constructor(e) {
    this._pieces = [], this._isComplete = !1, this._languageIdCodec = e;
  }
  flush() {
    this._pieces = [], this._isComplete = !1;
  }
  isEmpty() {
    return this._pieces.length === 0;
  }
  set(e, t) {
    this._pieces = e || [], this._isComplete = t;
  }
  setPartial(e, t) {
    let i = e;
    if (t.length > 0) {
      const o = t[0].getRange(), r = t[t.length - 1].getRange();
      if (!o || !r)
        return e;
      i = e.plusRange(o).plusRange(r);
    }
    let n = null;
    for (let o = 0, r = this._pieces.length; o < r; o++) {
      const a = this._pieces[o];
      if (a.endLineNumber < i.startLineNumber)
        continue;
      if (a.startLineNumber > i.endLineNumber) {
        n = n || { index: o };
        break;
      }
      if (a.removeTokens(i), a.isEmpty()) {
        this._pieces.splice(o, 1), o--, r--;
        continue;
      }
      if (a.endLineNumber < i.startLineNumber)
        continue;
      if (a.startLineNumber > i.endLineNumber) {
        n = n || { index: o };
        continue;
      }
      const [l, c] = a.split(i);
      if (l.isEmpty()) {
        n = n || { index: o };
        continue;
      }
      c.isEmpty() || (this._pieces.splice(o, 1, l, c), o++, r++, n = n || { index: o });
    }
    return n = n || { index: this._pieces.length }, t.length > 0 && (this._pieces = X1(this._pieces, n.index, t)), i;
  }
  isComplete() {
    return this._isComplete;
  }
  addSparseTokens(e, t) {
    if (t.getLineContent().length === 0)
      return t;
    const i = this._pieces;
    if (i.length === 0)
      return t;
    const n = qk._findFirstPieceWithLine(i, e), o = i[n].getLineTokens(e);
    if (!o)
      return t;
    const r = t.getCount(), a = o.getCount();
    let l = 0;
    const c = [];
    let h = 0, d = 0;
    const u = (f, g) => {
      f !== d && (d = f, c[h++] = f, c[h++] = g);
    };
    for (let f = 0; f < a; f++) {
      const g = o.getStartCharacter(f), m = o.getEndCharacter(f), _ = o.getMetadata(f), b = ((_ & 1 ? 2048 : 0) | (_ & 2 ? 4096 : 0) | (_ & 4 ? 8192 : 0) | (_ & 8 ? 16384 : 0) | (_ & 16 ? 16744448 : 0) | (_ & 32 ? 4278190080 : 0)) >>> 0, C = ~b >>> 0;
      for (; l < r && t.getEndOffset(l) <= g; )
        u(t.getEndOffset(l), t.getMetadata(l)), l++;
      for (l < r && t.getStartOffset(l) < g && u(g, t.getMetadata(l)); l < r && t.getEndOffset(l) < m; )
        u(t.getEndOffset(l), t.getMetadata(l) & C | _ & b), l++;
      if (l < r)
        u(m, t.getMetadata(l) & C | _ & b), t.getEndOffset(l) === m && l++;
      else {
        const v = Math.min(Math.max(0, l - 1), r - 1);
        u(m, t.getMetadata(v) & C | _ & b);
      }
    }
    for (; l < r; )
      u(t.getEndOffset(l), t.getMetadata(l)), l++;
    return new Si(new Uint32Array(c), t.getLineContent(), this._languageIdCodec);
  }
  static _findFirstPieceWithLine(e, t) {
    let i = 0, n = e.length - 1;
    for (; i < n; ) {
      let o = i + Math.floor((n - i) / 2);
      if (e[o].endLineNumber < t)
        i = o + 1;
      else if (e[o].startLineNumber > t)
        n = o - 1;
      else {
        for (; o > i && e[o - 1].startLineNumber <= t && t <= e[o - 1].endLineNumber; )
          o--;
        return o;
      }
    }
    return i;
  }
  acceptEdit(e, t, i, n, o) {
    for (const r of this._pieces)
      r.acceptEdit(e, t, i, n, o);
  }
}
var C$ = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, eC = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, sp;
let Iy = sp = class extends ZA {
  constructor(e, t, i, n, o, r, a) {
    super(), this._textModel = e, this._bracketPairsTextModelPart = t, this._languageId = i, this._attachedViews = n, this._languageService = o, this._languageConfigurationService = r, this._treeSitterService = a, this._semanticTokens = new qk(this._languageService.languageIdCodec), this._onDidChangeLanguage = this._register(new O()), this.onDidChangeLanguage = this._onDidChangeLanguage.event, this._onDidChangeLanguageConfiguration = this._register(new O()), this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event, this._onDidChangeTokens = this._register(new O()), this.onDidChangeTokens = this._onDidChangeTokens.event, this._tokensDisposables = this._register(new he()), this._register(this._languageConfigurationService.onDidChange((l) => {
      l.affects(this._languageId) && this._onDidChangeLanguageConfiguration.fire({});
    })), this._register(J.filter(zC.onDidChange, (l) => l.changedLanguages.includes(this._languageId))(() => {
      this.createPreferredTokenProvider();
    })), this.createPreferredTokenProvider();
  }
  createGrammarTokens() {
    return this._register(new uN(this._languageService.languageIdCodec, this._textModel, () => this._languageId, this._attachedViews));
  }
  createTreeSitterTokens() {
    return this._register(new hN(this._treeSitterService, this._languageService.languageIdCodec, this._textModel, () => this._languageId));
  }
  createTokens(e) {
    var i;
    const t = this._tokens !== void 0;
    (i = this._tokens) == null || i.dispose(), this._tokens = e ? this.createTreeSitterTokens() : this.createGrammarTokens(), this._tokensDisposables.clear(), this._tokensDisposables.add(this._tokens.onDidChangeTokens((n) => {
      this._emitModelTokensChangedEvent(n);
    })), this._tokensDisposables.add(this._tokens.onDidChangeBackgroundTokenizationState((n) => {
      this._bracketPairsTextModelPart.handleDidChangeBackgroundTokenizationState();
    })), t && this._tokens.resetTokenization();
  }
  createPreferredTokenProvider() {
    zC.get(this._languageId) ? this._tokens instanceof hN || this.createTokens(!0) : this._tokens instanceof uN || this.createTokens(!1);
  }
  handleLanguageConfigurationServiceChange(e) {
    e.affects(this._languageId) && this._onDidChangeLanguageConfiguration.fire({});
  }
  handleDidChangeContent(e) {
    if (e.isFlush)
      this._semanticTokens.flush();
    else if (!e.isEolChange)
      for (const t of e.changes) {
        const [i, n, o] = Ld(t.text);
        this._semanticTokens.acceptEdit(
          t.range,
          i,
          n,
          o,
          t.text.length > 0 ? t.text.charCodeAt(0) : 0
          /* CharCode.Null */
        );
      }
    this._tokens.handleDidChangeContent(e);
  }
  handleDidChangeAttached() {
    this._tokens.handleDidChangeAttached();
  }
  /**
   * Includes grammar and semantic tokens.
   */
  getLineTokens(e) {
    this.validateLineNumber(e);
    const t = this._tokens.getLineTokens(e);
    return this._semanticTokens.addSparseTokens(e, t);
  }
  _emitModelTokensChangedEvent(e) {
    this._textModel._isDisposing() || (this._bracketPairsTextModelPart.handleDidChangeTokens(e), this._onDidChangeTokens.fire(e));
  }
  // #region Grammar Tokens
  validateLineNumber(e) {
    if (e < 1 || e > this._textModel.getLineCount())
      throw new it("Illegal value for lineNumber");
  }
  get hasTokens() {
    return this._tokens.hasTokens;
  }
  resetTokenization() {
    this._tokens.resetTokenization();
  }
  get backgroundTokenizationState() {
    return this._tokens.backgroundTokenizationState;
  }
  forceTokenization(e) {
    this.validateLineNumber(e), this._tokens.forceTokenization(e);
  }
  hasAccurateTokensForLine(e) {
    return this.validateLineNumber(e), this._tokens.hasAccurateTokensForLine(e);
  }
  isCheapToTokenize(e) {
    return this.validateLineNumber(e), this._tokens.isCheapToTokenize(e);
  }
  tokenizeIfCheap(e) {
    this.validateLineNumber(e), this._tokens.tokenizeIfCheap(e);
  }
  getTokenTypeIfInsertingCharacter(e, t, i) {
    return this._tokens.getTokenTypeIfInsertingCharacter(e, t, i);
  }
  tokenizeLineWithEdit(e, t, i) {
    return this._tokens.tokenizeLineWithEdit(e, t, i);
  }
  // #endregion
  // #region Semantic Tokens
  setSemanticTokens(e, t) {
    this._semanticTokens.set(e, t), this._emitModelTokensChangedEvent({
      semanticTokensApplied: e !== null,
      ranges: [{ fromLineNumber: 1, toLineNumber: this._textModel.getLineCount() }]
    });
  }
  hasCompleteSemanticTokens() {
    return this._semanticTokens.isComplete();
  }
  hasSomeSemanticTokens() {
    return !this._semanticTokens.isEmpty();
  }
  setPartialSemanticTokens(e, t) {
    if (this.hasCompleteSemanticTokens())
      return;
    const i = this._textModel.validateRange(this._semanticTokens.setPartial(e, t));
    this._emitModelTokensChangedEvent({
      semanticTokensApplied: !0,
      ranges: [
        {
          fromLineNumber: i.startLineNumber,
          toLineNumber: i.endLineNumber
        }
      ]
    });
  }
  // #endregion
  // #region Utility Methods
  getWordAtPosition(e) {
    this.assertNotDisposed();
    const t = this._textModel.validatePosition(e), i = this._textModel.getLineContent(t.lineNumber), n = this.getLineTokens(t.lineNumber), o = n.findTokenIndexAtOffset(t.column - 1), [r, a] = sp._findLanguageBoundaries(n, o), l = Nf(t.column, this.getLanguageConfiguration(n.getLanguageId(o)).getWordDefinition(), i.substring(r, a), r);
    if (l && l.startColumn <= e.column && e.column <= l.endColumn)
      return l;
    if (o > 0 && r === t.column - 1) {
      const [c, h] = sp._findLanguageBoundaries(n, o - 1), d = Nf(t.column, this.getLanguageConfiguration(n.getLanguageId(o - 1)).getWordDefinition(), i.substring(c, h), c);
      if (d && d.startColumn <= e.column && e.column <= d.endColumn)
        return d;
    }
    return null;
  }
  getLanguageConfiguration(e) {
    return this._languageConfigurationService.getLanguageConfiguration(e);
  }
  static _findLanguageBoundaries(e, t) {
    const i = e.getLanguageId(t);
    let n = 0;
    for (let r = t; r >= 0 && e.getLanguageId(r) === i; r--)
      n = e.getStartOffset(r);
    let o = e.getLineContent().length;
    for (let r = t, a = e.getCount(); r < a && e.getLanguageId(r) === i; r++)
      o = e.getEndOffset(r);
    return [n, o];
  }
  getWordUntilPosition(e) {
    const t = this.getWordAtPosition(e);
    return t ? {
      word: t.word.substr(0, e.column - t.startColumn),
      startColumn: t.startColumn,
      endColumn: e.column
    } : { word: "", startColumn: e.column, endColumn: e.column };
  }
  // #endregion
  // #region Language Id handling
  getLanguageId() {
    return this._languageId;
  }
  getLanguageIdAtPosition(e, t) {
    const i = this._textModel.validatePosition(new V(e, t)), n = this.getLineTokens(i.lineNumber);
    return n.getLanguageId(n.findTokenIndexAtOffset(i.column - 1));
  }
  setLanguageId(e, t = "api") {
    if (this._languageId === e)
      return;
    const i = {
      oldLanguage: this._languageId,
      newLanguage: e,
      source: t
    };
    this._languageId = e, this._bracketPairsTextModelPart.handleDidChangeLanguage(i), this._tokens.resetTokenization(), this.createPreferredTokenProvider(), this._onDidChangeLanguage.fire(i), this._onDidChangeLanguageConfiguration.fire({});
  }
};
Iy = sp = C$([
  eC(4, gi),
  eC(5, Zo),
  eC(6, o4)
], Iy);
class uN extends s4 {
  constructor(e, t, i, n) {
    super(e, t, i), this._tokenizer = null, this._defaultBackgroundTokenizer = null, this._backgroundTokenizer = this._register(new Zr()), this._tokens = new tg(this._languageIdCodec), this._debugBackgroundTokenizer = this._register(new Zr()), this._attachedViewStates = this._register(new yL()), this._register(Yt.onDidChange((o) => {
      const r = this.getLanguageId();
      o.changedLanguages.indexOf(r) !== -1 && this.resetTokenization();
    })), this.resetTokenization(), this._register(n.onDidChangeVisibleRanges(({ view: o, state: r }) => {
      if (r) {
        let a = this._attachedViewStates.get(o);
        a || (a = new b$(() => this.refreshRanges(a.lineRanges)), this._attachedViewStates.set(o, a)), a.handleStateChange(r);
      } else
        this._attachedViewStates.deleteAndDispose(o);
    }));
  }
  resetTokenization(e = !0) {
    var o;
    this._tokens.flush(), (o = this._debugBackgroundTokens) == null || o.flush(), this._debugBackgroundStates && (this._debugBackgroundStates = new Ey(this._textModel.getLineCount())), e && this._onDidChangeTokens.fire({
      semanticTokensApplied: !1,
      ranges: [
        {
          fromLineNumber: 1,
          toLineNumber: this._textModel.getLineCount()
        }
      ]
    });
    const t = () => {
      if (this._textModel.isTooLargeForTokenization())
        return [null, null];
      const r = Yt.get(this.getLanguageId());
      if (!r)
        return [null, null];
      let a;
      try {
        a = r.getInitialState();
      } catch (l) {
        return ht(l), [null, null];
      }
      return [r, a];
    }, [i, n] = t();
    if (i && n ? this._tokenizer = new u$(this._textModel.getLineCount(), i, this._textModel, this._languageIdCodec) : this._tokenizer = null, this._backgroundTokenizer.clear(), this._defaultBackgroundTokenizer = null, this._tokenizer) {
      const r = {
        setTokens: (a) => {
          this.setTokens(a);
        },
        backgroundTokenizationFinished: () => {
          if (this._backgroundTokenizationState === 2)
            return;
          const a = 2;
          this._backgroundTokenizationState = a, this._onDidChangeBackgroundTokenizationState.fire();
        },
        setEndState: (a, l) => {
          var h;
          if (!this._tokenizer)
            return;
          const c = this._tokenizer.store.getFirstInvalidEndStateLineNumber();
          c !== null && a >= c && ((h = this._tokenizer) == null || h.store.setEndState(a, l));
        }
      };
      i && i.createBackgroundTokenizer && !i.backgroundTokenizerShouldOnlyVerifyTokens && (this._backgroundTokenizer.value = i.createBackgroundTokenizer(this._textModel, r)), !this._backgroundTokenizer.value && !this._textModel.isTooLargeForTokenization() && (this._backgroundTokenizer.value = this._defaultBackgroundTokenizer = new m$(this._tokenizer, r), this._defaultBackgroundTokenizer.handleChanges()), i != null && i.backgroundTokenizerShouldOnlyVerifyTokens && i.createBackgroundTokenizer ? (this._debugBackgroundTokens = new tg(this._languageIdCodec), this._debugBackgroundStates = new Ey(this._textModel.getLineCount()), this._debugBackgroundTokenizer.clear(), this._debugBackgroundTokenizer.value = i.createBackgroundTokenizer(this._textModel, {
        setTokens: (a) => {
          var l;
          (l = this._debugBackgroundTokens) == null || l.setMultilineTokens(a, this._textModel);
        },
        backgroundTokenizationFinished() {
        },
        setEndState: (a, l) => {
          var c;
          (c = this._debugBackgroundStates) == null || c.setEndState(a, l);
        }
      })) : (this._debugBackgroundTokens = void 0, this._debugBackgroundStates = void 0, this._debugBackgroundTokenizer.value = void 0);
    }
    this.refreshAllVisibleLineTokens();
  }
  handleDidChangeAttached() {
    var e;
    (e = this._defaultBackgroundTokenizer) == null || e.handleChanges();
  }
  handleDidChangeContent(e) {
    var t, i, n;
    if (e.isFlush)
      this.resetTokenization(!1);
    else if (!e.isEolChange) {
      for (const o of e.changes) {
        const [r, a] = Ld(o.text);
        this._tokens.acceptEdit(o.range, r, a), (t = this._debugBackgroundTokens) == null || t.acceptEdit(o.range, r, a);
      }
      (i = this._debugBackgroundStates) == null || i.acceptChanges(e.changes), this._tokenizer && this._tokenizer.store.acceptChanges(e.changes), (n = this._defaultBackgroundTokenizer) == null || n.handleChanges();
    }
  }
  setTokens(e) {
    const { changes: t } = this._tokens.setMultilineTokens(e, this._textModel);
    return t.length > 0 && this._onDidChangeTokens.fire({ semanticTokensApplied: !1, ranges: t }), { changes: t };
  }
  refreshAllVisibleLineTokens() {
    const e = we.joinMany([...this._attachedViewStates].map(([t, i]) => i.lineRanges));
    this.refreshRanges(e);
  }
  refreshRanges(e) {
    for (const t of e)
      this.refreshRange(t.startLineNumber, t.endLineNumberExclusive - 1);
  }
  refreshRange(e, t) {
    var r, a;
    if (!this._tokenizer)
      return;
    e = Math.max(1, Math.min(this._textModel.getLineCount(), e)), t = Math.min(this._textModel.getLineCount(), t);
    const i = new Dy(), { heuristicTokens: n } = this._tokenizer.tokenizeHeuristically(i, e, t), o = this.setTokens(i.finalize());
    if (n)
      for (const l of o.changes)
        (r = this._backgroundTokenizer.value) == null || r.requestTokens(l.fromLineNumber, l.toLineNumber + 1);
    (a = this._defaultBackgroundTokenizer) == null || a.checkFinished();
  }
  forceTokenization(e) {
    var i, n;
    const t = new Dy();
    (i = this._tokenizer) == null || i.updateTokensUntilLine(t, e), this.setTokens(t.finalize()), (n = this._defaultBackgroundTokenizer) == null || n.checkFinished();
  }
  hasAccurateTokensForLine(e) {
    return this._tokenizer ? this._tokenizer.hasAccurateTokensForLine(e) : !0;
  }
  isCheapToTokenize(e) {
    return this._tokenizer ? this._tokenizer.isCheapToTokenize(e) : !0;
  }
  getLineTokens(e) {
    var n;
    const t = this._textModel.getLineContent(e), i = this._tokens.getTokens(this._textModel.getLanguageId(), e - 1, t);
    if (this._debugBackgroundTokens && this._debugBackgroundStates && this._tokenizer && this._debugBackgroundStates.getFirstInvalidEndStateLineNumberOrMax() > e && this._tokenizer.store.getFirstInvalidEndStateLineNumberOrMax() > e) {
      const o = this._debugBackgroundTokens.getTokens(this._textModel.getLanguageId(), e - 1, t);
      !i.equals(o) && ((n = this._debugBackgroundTokenizer.value) != null && n.reportMismatchingTokens) && this._debugBackgroundTokenizer.value.reportMismatchingTokens(e);
    }
    return i;
  }
  getTokenTypeIfInsertingCharacter(e, t, i) {
    if (!this._tokenizer)
      return 0;
    const n = this._textModel.validatePosition(new V(e, t));
    return this.forceTokenization(n.lineNumber), this._tokenizer.getTokenTypeIfInsertingCharacter(n, i);
  }
  tokenizeLineWithEdit(e, t, i) {
    if (!this._tokenizer)
      return null;
    const n = this._textModel.validatePosition(e);
    return this.forceTokenization(n.lineNumber), this._tokenizer.tokenizeLineWithEdit(n, t, i);
  }
  get hasTokens() {
    return this._tokens.hasTokens;
  }
}
class w$ {
  constructor() {
    this.changeType = 1;
  }
}
class ao {
  static applyInjectedText(e, t) {
    if (!t || t.length === 0)
      return e;
    let i = "", n = 0;
    for (const o of t)
      i += e.substring(n, o.column - 1), n = o.column - 1, i += o.options.content;
    return i += e.substring(n), i;
  }
  static fromDecorations(e) {
    const t = [];
    for (const i of e)
      i.options.before && i.options.before.content.length > 0 && t.push(new ao(i.ownerId, i.range.startLineNumber, i.range.startColumn, i.options.before, 0)), i.options.after && i.options.after.content.length > 0 && t.push(new ao(i.ownerId, i.range.endLineNumber, i.range.endColumn, i.options.after, 1));
    return t.sort((i, n) => i.lineNumber === n.lineNumber ? i.column === n.column ? i.order - n.order : i.column - n.column : i.lineNumber - n.lineNumber), t;
  }
  constructor(e, t, i, n, o) {
    this.ownerId = e, this.lineNumber = t, this.column = i, this.options = n, this.order = o;
  }
}
class fN {
  constructor(e, t, i) {
    this.changeType = 2, this.lineNumber = e, this.detail = t, this.injectedText = i;
  }
}
class v$ {
  constructor(e, t) {
    this.changeType = 3, this.fromLineNumber = e, this.toLineNumber = t;
  }
}
class y$ {
  constructor(e, t, i, n) {
    this.changeType = 4, this.injectedTexts = n, this.fromLineNumber = e, this.toLineNumber = t, this.detail = i;
  }
}
class S$ {
  constructor() {
    this.changeType = 5;
  }
}
class nd {
  constructor(e, t, i, n) {
    this.changes = e, this.versionId = t, this.isUndoing = i, this.isRedoing = n, this.resultingSelection = null;
  }
  containsEvent(e) {
    for (let t = 0, i = this.changes.length; t < i; t++)
      if (this.changes[t].changeType === e)
        return !0;
    return !1;
  }
  static merge(e, t) {
    const i = [].concat(e.changes).concat(t.changes), n = t.versionId, o = e.isUndoing || t.isUndoing, r = e.isRedoing || t.isRedoing;
    return new nd(i, n, o, r);
  }
}
class r4 {
  constructor(e) {
    this.changes = e;
  }
}
class ec {
  constructor(e, t) {
    this.rawContentChangedEvent = e, this.contentChangedEvent = t;
  }
  merge(e) {
    const t = nd.merge(this.rawContentChangedEvent, e.rawContentChangedEvent), i = ec._mergeChangeEvents(this.contentChangedEvent, e.contentChangedEvent);
    return new ec(t, i);
  }
  static _mergeChangeEvents(e, t) {
    const i = [].concat(e.changes).concat(t.changes), n = t.eol, o = t.versionId, r = e.isUndoing || t.isUndoing, a = e.isRedoing || t.isRedoing, l = e.isFlush || t.isFlush, c = e.isEolChange && t.isEolChange;
    return {
      changes: i,
      eol: n,
      isEolChange: c,
      versionId: o,
      isUndoing: r,
      isRedoing: a,
      isFlush: l
    };
  }
}
var L$ = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Dm = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, _l;
function k$(s) {
  const e = new n4();
  return e.acceptChunk(s), e.finish();
}
function x$(s) {
  const e = new n4();
  let t;
  for (; typeof (t = s.read()) == "string"; )
    e.acceptChunk(t);
  return e.finish();
}
function gN(s, e) {
  let t;
  return typeof s == "string" ? t = k$(s) : o9(s) ? t = x$(s) : t = s, t.create(e);
}
let Em = 0;
const D$ = 999, E$ = 1e4;
class I$ {
  constructor(e) {
    this._source = e, this._eos = !1;
  }
  read() {
    if (this._eos)
      return null;
    const e = [];
    let t = 0, i = 0;
    do {
      const n = this._source.read();
      if (n === null)
        return this._eos = !0, t === 0 ? null : e.join("");
      if (n.length > 0 && (e[t++] = n, i += n.length), i >= 64 * 1024)
        return e.join("");
    } while (!0);
  }
}
const pu = () => {
  throw new Error("Invalid change accessor");
};
var eo;
let Ny = (eo = class extends q {
  static resolveOptions(e, t) {
    if (t.detectIndentation) {
      const i = iN(e, t.tabSize, t.insertSpaces);
      return new Gm({
        tabSize: i.tabSize,
        indentSize: "tabSize",
        // TODO@Alex: guess indentSize independent of tabSize
        insertSpaces: i.insertSpaces,
        trimAutoWhitespace: t.trimAutoWhitespace,
        defaultEOL: t.defaultEOL,
        bracketPairColorizationOptions: t.bracketPairColorizationOptions
      });
    }
    return new Gm(t);
  }
  get onDidChangeLanguage() {
    return this._tokenizationTextModelPart.onDidChangeLanguage;
  }
  get onDidChangeLanguageConfiguration() {
    return this._tokenizationTextModelPart.onDidChangeLanguageConfiguration;
  }
  get onDidChangeTokens() {
    return this._tokenizationTextModelPart.onDidChangeTokens;
  }
  onDidChangeContent(e) {
    return this._eventEmitter.slowEvent((t) => e(t.contentChangedEvent));
  }
  onDidChangeContentOrInjectedText(e) {
    return Wo(this._eventEmitter.fastEvent((t) => e(t)), this._onDidChangeInjectedText.event((t) => e(t)));
  }
  _isDisposing() {
    return this.__isDisposing;
  }
  get tokenization() {
    return this._tokenizationTextModelPart;
  }
  get bracketPairs() {
    return this._bracketPairs;
  }
  get guides() {
    return this._guidesTextModelPart;
  }
  constructor(e, t, i, n = null, o, r, a, l) {
    super(), this._undoRedoService = o, this._languageService = r, this._languageConfigurationService = a, this.instantiationService = l, this._onWillDispose = this._register(new O()), this.onWillDispose = this._onWillDispose.event, this._onDidChangeDecorations = this._register(new P$((g) => this.handleBeforeFireDecorationsChangedEvent(g))), this.onDidChangeDecorations = this._onDidChangeDecorations.event, this._onDidChangeOptions = this._register(new O()), this.onDidChangeOptions = this._onDidChangeOptions.event, this._onDidChangeAttached = this._register(new O()), this.onDidChangeAttached = this._onDidChangeAttached.event, this._onDidChangeInjectedText = this._register(new O()), this._eventEmitter = this._register(new O$()), this._languageSelectionListener = this._register(new Zr()), this._deltaDecorationCallCnt = 0, this._attachedViews = new p$(), Em++, this.id = "$model" + Em, this.isForSimpleWidget = i.isForSimpleWidget, typeof n > "u" || n === null ? this._associatedResource = Te.parse("inmemory://model/" + Em) : this._associatedResource = n, this._attachedEditorCount = 0;
    const { textBuffer: c, disposable: h } = gN(e, i.defaultEOL);
    this._buffer = c, this._bufferDisposable = h, this._options = _l.resolveOptions(this._buffer, i);
    const d = typeof t == "string" ? t : t.languageId;
    typeof t != "string" && (this._languageSelectionListener.value = t.onDidChange(() => this._setLanguage(t.languageId))), this._bracketPairs = this._register(new AU(this, this._languageConfigurationService)), this._guidesTextModelPart = this._register(new VU(this, this._languageConfigurationService)), this._decorationProvider = this._register(new OU(this)), this._tokenizationTextModelPart = this.instantiationService.createInstance(Iy, this, this._bracketPairs, d, this._attachedViews);
    const u = this._buffer.getLineCount(), f = this._buffer.getValueLengthInRange(
      new R(1, 1, u, this._buffer.getLineLength(u) + 1),
      0
      /* model.EndOfLinePreference.TextDefined */
    );
    i.largeFileOptimizations ? (this._isTooLargeForTokenization = f > _l.LARGE_FILE_SIZE_THRESHOLD || u > _l.LARGE_FILE_LINE_COUNT_THRESHOLD, this._isTooLargeForHeapOperation = f > _l.LARGE_FILE_HEAP_OPERATION_THRESHOLD) : (this._isTooLargeForTokenization = !1, this._isTooLargeForHeapOperation = !1), this._isTooLargeForSyncing = f > _l._MODEL_SYNC_LIMIT, this._versionId = 1, this._alternativeVersionId = 1, this._initialUndoRedoSnapshot = null, this._isDisposed = !1, this.__isDisposing = !1, this._instanceId = eM(Em), this._lastDecorationId = 0, this._decorations = /* @__PURE__ */ Object.create(null), this._decorationsTree = new mN(), this._commandManager = new zk(this, this._undoRedoService), this._isUndoing = !1, this._isRedoing = !1, this._trimAutoWhitespaceLines = null, this._register(this._decorationProvider.onDidChange(() => {
      this._onDidChangeDecorations.beginDeferredEmit(), this._onDidChangeDecorations.fire(), this._onDidChangeDecorations.endDeferredEmit();
    })), this._languageService.requestRichLanguageFeatures(d), this._register(this._languageConfigurationService.onDidChange((g) => {
      this._bracketPairs.handleLanguageConfigurationServiceChange(g), this._tokenizationTextModelPart.handleLanguageConfigurationServiceChange(g);
    }));
  }
  dispose() {
    this.__isDisposing = !0, this._onWillDispose.fire(), this._tokenizationTextModelPart.dispose(), this._isDisposed = !0, super.dispose(), this._bufferDisposable.dispose(), this.__isDisposing = !1;
    const e = new id([], "", `
`, !1, !1, !0, !0);
    e.dispose(), this._buffer = e, this._bufferDisposable = q.None;
  }
  _assertNotDisposed() {
    if (this._isDisposed)
      throw new it("Model is disposed!");
  }
  _emitContentChangedEvent(e, t) {
    this.__isDisposing || (this._tokenizationTextModelPart.handleDidChangeContent(t), this._bracketPairs.handleDidChangeContent(t), this._eventEmitter.fire(new ec(e, t)));
  }
  setValue(e) {
    if (this._assertNotDisposed(), e == null)
      throw eb();
    const { textBuffer: t, disposable: i } = gN(e, this._options.defaultEOL);
    this._setValueFromTextBuffer(t, i);
  }
  _createContentChanged2(e, t, i, n, o, r, a, l) {
    return {
      changes: [{
        range: e,
        rangeOffset: t,
        rangeLength: i,
        text: n
      }],
      eol: this._buffer.getEOL(),
      isEolChange: l,
      versionId: this.getVersionId(),
      isUndoing: o,
      isRedoing: r,
      isFlush: a
    };
  }
  _setValueFromTextBuffer(e, t) {
    this._assertNotDisposed();
    const i = this.getFullModelRange(), n = this.getValueLengthInRange(i), o = this.getLineCount(), r = this.getLineMaxColumn(o);
    this._buffer = e, this._bufferDisposable.dispose(), this._bufferDisposable = t, this._increaseVersionId(), this._decorations = /* @__PURE__ */ Object.create(null), this._decorationsTree = new mN(), this._commandManager.clear(), this._trimAutoWhitespaceLines = null, this._emitContentChangedEvent(new nd([
      new w$()
    ], this._versionId, !1, !1), this._createContentChanged2(new R(1, 1, o, r), 0, n, this.getValue(), !1, !1, !0, !1));
  }
  setEOL(e) {
    this._assertNotDisposed();
    const t = e === 1 ? `\r
` : `
`;
    if (this._buffer.getEOL() === t)
      return;
    const i = this.getFullModelRange(), n = this.getValueLengthInRange(i), o = this.getLineCount(), r = this.getLineMaxColumn(o);
    this._onBeforeEOLChange(), this._buffer.setEOL(t), this._increaseVersionId(), this._onAfterEOLChange(), this._emitContentChangedEvent(new nd([
      new S$()
    ], this._versionId, !1, !1), this._createContentChanged2(new R(1, 1, o, r), 0, n, this.getValue(), !1, !1, !1, !0));
  }
  _onBeforeEOLChange() {
    this._decorationsTree.ensureAllNodesHaveRanges(this);
  }
  _onAfterEOLChange() {
    const e = this.getVersionId(), t = this._decorationsTree.collectNodesPostOrder();
    for (let i = 0, n = t.length; i < n; i++) {
      const o = t[i], r = o.range, a = o.cachedAbsoluteStart - o.start, l = this._buffer.getOffsetAt(r.startLineNumber, r.startColumn), c = this._buffer.getOffsetAt(r.endLineNumber, r.endColumn);
      o.cachedAbsoluteStart = l, o.cachedAbsoluteEnd = c, o.cachedVersionId = e, o.start = l - a, o.end = c - a, Ga(o);
    }
  }
  onBeforeAttached() {
    return this._attachedEditorCount++, this._attachedEditorCount === 1 && (this._tokenizationTextModelPart.handleDidChangeAttached(), this._onDidChangeAttached.fire(void 0)), this._attachedViews.attachView();
  }
  onBeforeDetached(e) {
    this._attachedEditorCount--, this._attachedEditorCount === 0 && (this._tokenizationTextModelPart.handleDidChangeAttached(), this._onDidChangeAttached.fire(void 0)), this._attachedViews.detachView(e);
  }
  isAttachedToEditor() {
    return this._attachedEditorCount > 0;
  }
  getAttachedEditorCount() {
    return this._attachedEditorCount;
  }
  isTooLargeForSyncing() {
    return this._isTooLargeForSyncing;
  }
  isTooLargeForTokenization() {
    return this._isTooLargeForTokenization;
  }
  isTooLargeForHeapOperation() {
    return this._isTooLargeForHeapOperation;
  }
  isDisposed() {
    return this._isDisposed;
  }
  isDominatedByLongLines() {
    if (this._assertNotDisposed(), this.isTooLargeForTokenization())
      return !1;
    let e = 0, t = 0;
    const i = this._buffer.getLineCount();
    for (let n = 1; n <= i; n++) {
      const o = this._buffer.getLineLength(n);
      o >= E$ ? t += o : e += o;
    }
    return t > e;
  }
  get uri() {
    return this._associatedResource;
  }
  //#region Options
  getOptions() {
    return this._assertNotDisposed(), this._options;
  }
  getFormattingOptions() {
    return {
      tabSize: this._options.indentSize,
      insertSpaces: this._options.insertSpaces
    };
  }
  updateOptions(e) {
    this._assertNotDisposed();
    const t = typeof e.tabSize < "u" ? e.tabSize : this._options.tabSize, i = typeof e.indentSize < "u" ? e.indentSize : this._options.originalIndentSize, n = typeof e.insertSpaces < "u" ? e.insertSpaces : this._options.insertSpaces, o = typeof e.trimAutoWhitespace < "u" ? e.trimAutoWhitespace : this._options.trimAutoWhitespace, r = typeof e.bracketColorizationOptions < "u" ? e.bracketColorizationOptions : this._options.bracketPairColorizationOptions, a = new Gm({
      tabSize: t,
      indentSize: i,
      insertSpaces: n,
      defaultEOL: this._options.defaultEOL,
      trimAutoWhitespace: o,
      bracketPairColorizationOptions: r
    });
    if (this._options.equals(a))
      return;
    const l = this._options.createChangeEvent(a);
    this._options = a, this._bracketPairs.handleDidChangeOptions(l), this._decorationProvider.handleDidChangeOptions(l), this._onDidChangeOptions.fire(l);
  }
  detectIndentation(e, t) {
    this._assertNotDisposed();
    const i = iN(this._buffer, t, e);
    this.updateOptions({
      insertSpaces: i.insertSpaces,
      tabSize: i.tabSize,
      indentSize: i.tabSize
      // TODO@Alex: guess indentSize independent of tabSize
    });
  }
  normalizeIndentation(e) {
    return this._assertNotDisposed(), zA(e, this._options.indentSize, this._options.insertSpaces);
  }
  //#endregion
  //#region Reading
  getVersionId() {
    return this._assertNotDisposed(), this._versionId;
  }
  mightContainRTL() {
    return this._buffer.mightContainRTL();
  }
  mightContainUnusualLineTerminators() {
    return this._buffer.mightContainUnusualLineTerminators();
  }
  removeUnusualLineTerminators(e = null) {
    const t = this.findMatches(
      X2.source,
      !1,
      !0,
      !1,
      null,
      !1,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    );
    this._buffer.resetMightContainUnusualLineTerminators(), this.pushEditOperations(e, t.map((i) => ({ range: i.range, text: null })), () => null);
  }
  mightContainNonBasicASCII() {
    return this._buffer.mightContainNonBasicASCII();
  }
  getAlternativeVersionId() {
    return this._assertNotDisposed(), this._alternativeVersionId;
  }
  getInitialUndoRedoSnapshot() {
    return this._assertNotDisposed(), this._initialUndoRedoSnapshot;
  }
  getOffsetAt(e) {
    this._assertNotDisposed();
    const t = this._validatePosition(
      e.lineNumber,
      e.column,
      0
      /* StringOffsetValidationType.Relaxed */
    );
    return this._buffer.getOffsetAt(t.lineNumber, t.column);
  }
  getPositionAt(e) {
    this._assertNotDisposed();
    const t = Math.min(this._buffer.getLength(), Math.max(0, e));
    return this._buffer.getPositionAt(t);
  }
  _increaseVersionId() {
    this._versionId = this._versionId + 1, this._alternativeVersionId = this._versionId;
  }
  _overwriteVersionId(e) {
    this._versionId = e;
  }
  _overwriteAlternativeVersionId(e) {
    this._alternativeVersionId = e;
  }
  _overwriteInitialUndoRedoSnapshot(e) {
    this._initialUndoRedoSnapshot = e;
  }
  getValue(e, t = !1) {
    if (this._assertNotDisposed(), this.isTooLargeForHeapOperation())
      throw new it("Operation would exceed heap memory limits");
    const i = this.getFullModelRange(), n = this.getValueInRange(i, e);
    return t ? this._buffer.getBOM() + n : n;
  }
  createSnapshot(e = !1) {
    return new I$(this._buffer.createSnapshot(e));
  }
  getValueLength(e, t = !1) {
    this._assertNotDisposed();
    const i = this.getFullModelRange(), n = this.getValueLengthInRange(i, e);
    return t ? this._buffer.getBOM().length + n : n;
  }
  getValueInRange(e, t = 0) {
    return this._assertNotDisposed(), this._buffer.getValueInRange(this.validateRange(e), t);
  }
  getValueLengthInRange(e, t = 0) {
    return this._assertNotDisposed(), this._buffer.getValueLengthInRange(this.validateRange(e), t);
  }
  getCharacterCountInRange(e, t = 0) {
    return this._assertNotDisposed(), this._buffer.getCharacterCountInRange(this.validateRange(e), t);
  }
  getLineCount() {
    return this._assertNotDisposed(), this._buffer.getLineCount();
  }
  getLineContent(e) {
    if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
      throw new it("Illegal value for lineNumber");
    return this._buffer.getLineContent(e);
  }
  getLineLength(e) {
    if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
      throw new it("Illegal value for lineNumber");
    return this._buffer.getLineLength(e);
  }
  getLinesContent() {
    if (this._assertNotDisposed(), this.isTooLargeForHeapOperation())
      throw new it("Operation would exceed heap memory limits");
    return this._buffer.getLinesContent();
  }
  getEOL() {
    return this._assertNotDisposed(), this._buffer.getEOL();
  }
  getEndOfLineSequence() {
    return this._assertNotDisposed(), this._buffer.getEOL() === `
` ? 0 : 1;
  }
  getLineMinColumn(e) {
    return this._assertNotDisposed(), 1;
  }
  getLineMaxColumn(e) {
    if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
      throw new it("Illegal value for lineNumber");
    return this._buffer.getLineLength(e) + 1;
  }
  getLineFirstNonWhitespaceColumn(e) {
    if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
      throw new it("Illegal value for lineNumber");
    return this._buffer.getLineFirstNonWhitespaceColumn(e);
  }
  getLineLastNonWhitespaceColumn(e) {
    if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
      throw new it("Illegal value for lineNumber");
    return this._buffer.getLineLastNonWhitespaceColumn(e);
  }
  /**
   * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.
   * Will try to not allocate if possible.
   */
  _validateRangeRelaxedNoAllocations(e) {
    const t = this._buffer.getLineCount(), i = e.startLineNumber, n = e.startColumn;
    let o = Math.floor(typeof i == "number" && !isNaN(i) ? i : 1), r = Math.floor(typeof n == "number" && !isNaN(n) ? n : 1);
    if (o < 1)
      o = 1, r = 1;
    else if (o > t)
      o = t, r = this.getLineMaxColumn(o);
    else if (r <= 1)
      r = 1;
    else {
      const d = this.getLineMaxColumn(o);
      r >= d && (r = d);
    }
    const a = e.endLineNumber, l = e.endColumn;
    let c = Math.floor(typeof a == "number" && !isNaN(a) ? a : 1), h = Math.floor(typeof l == "number" && !isNaN(l) ? l : 1);
    if (c < 1)
      c = 1, h = 1;
    else if (c > t)
      c = t, h = this.getLineMaxColumn(c);
    else if (h <= 1)
      h = 1;
    else {
      const d = this.getLineMaxColumn(c);
      h >= d && (h = d);
    }
    return i === o && n === r && a === c && l === h && e instanceof R && !(e instanceof ft) ? e : new R(o, r, c, h);
  }
  _isValidPosition(e, t, i) {
    if (typeof e != "number" || typeof t != "number" || isNaN(e) || isNaN(t) || e < 1 || t < 1 || (e | 0) !== e || (t | 0) !== t)
      return !1;
    const n = this._buffer.getLineCount();
    if (e > n)
      return !1;
    if (t === 1)
      return !0;
    const o = this.getLineMaxColumn(e);
    if (t > o)
      return !1;
    if (i === 1) {
      const r = this._buffer.getLineCharCode(e, t - 2);
      if (hi(r))
        return !1;
    }
    return !0;
  }
  _validatePosition(e, t, i) {
    const n = Math.floor(typeof e == "number" && !isNaN(e) ? e : 1), o = Math.floor(typeof t == "number" && !isNaN(t) ? t : 1), r = this._buffer.getLineCount();
    if (n < 1)
      return new V(1, 1);
    if (n > r)
      return new V(r, this.getLineMaxColumn(r));
    if (o <= 1)
      return new V(n, 1);
    const a = this.getLineMaxColumn(n);
    if (o >= a)
      return new V(n, a);
    if (i === 1) {
      const l = this._buffer.getLineCharCode(n, o - 2);
      if (hi(l))
        return new V(n, o - 1);
    }
    return new V(n, o);
  }
  validatePosition(e) {
    return this._assertNotDisposed(), e instanceof V && this._isValidPosition(e.lineNumber, e.column, 1) ? e : this._validatePosition(e.lineNumber, e.column, 1);
  }
  _isValidRange(e, t) {
    const i = e.startLineNumber, n = e.startColumn, o = e.endLineNumber, r = e.endColumn;
    if (!this._isValidPosition(
      i,
      n,
      0
      /* StringOffsetValidationType.Relaxed */
    ) || !this._isValidPosition(
      o,
      r,
      0
      /* StringOffsetValidationType.Relaxed */
    ))
      return !1;
    if (t === 1) {
      const a = n > 1 ? this._buffer.getLineCharCode(i, n - 2) : 0, l = r > 1 && r <= this._buffer.getLineLength(o) ? this._buffer.getLineCharCode(o, r - 2) : 0, c = hi(a), h = hi(l);
      return !c && !h;
    }
    return !0;
  }
  validateRange(e) {
    if (this._assertNotDisposed(), e instanceof R && !(e instanceof ft) && this._isValidRange(e, 1))
      return e;
    const i = this._validatePosition(
      e.startLineNumber,
      e.startColumn,
      0
      /* StringOffsetValidationType.Relaxed */
    ), n = this._validatePosition(
      e.endLineNumber,
      e.endColumn,
      0
      /* StringOffsetValidationType.Relaxed */
    ), o = i.lineNumber, r = i.column, a = n.lineNumber, l = n.column;
    {
      const c = r > 1 ? this._buffer.getLineCharCode(o, r - 2) : 0, h = l > 1 && l <= this._buffer.getLineLength(a) ? this._buffer.getLineCharCode(a, l - 2) : 0, d = hi(c), u = hi(h);
      return !d && !u ? new R(o, r, a, l) : o === a && r === l ? new R(o, r - 1, a, l - 1) : d && u ? new R(o, r - 1, a, l + 1) : d ? new R(o, r - 1, a, l) : new R(o, r, a, l + 1);
    }
  }
  modifyPosition(e, t) {
    this._assertNotDisposed();
    const i = this.getOffsetAt(e) + t;
    return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, i)));
  }
  getFullModelRange() {
    this._assertNotDisposed();
    const e = this.getLineCount();
    return new R(1, 1, e, this.getLineMaxColumn(e));
  }
  findMatchesLineByLine(e, t, i, n) {
    return this._buffer.findMatchesLineByLine(e, t, i, n);
  }
  findMatches(e, t, i, n, o, r, a = D$) {
    this._assertNotDisposed();
    let l = null;
    t !== null && (Array.isArray(t) || (t = [t]), t.every((d) => R.isIRange(d)) && (l = t.map((d) => this.validateRange(d)))), l === null && (l = [this.getFullModelRange()]), l = l.sort((d, u) => d.startLineNumber - u.startLineNumber || d.startColumn - u.startColumn);
    const c = [];
    c.push(l.reduce((d, u) => R.areIntersecting(d, u) ? d.plusRange(u) : (c.push(d), u)));
    let h;
    if (!i && e.indexOf(`
`) < 0) {
      const u = new Xc(e, i, n, o).parseSearchRequest();
      if (!u)
        return [];
      h = (f) => this.findMatchesLineByLine(f, u, r, a);
    } else
      h = (d) => am.findMatches(this, new Xc(e, i, n, o), d, r, a);
    return c.map(h).reduce((d, u) => d.concat(u), []);
  }
  findNextMatch(e, t, i, n, o, r) {
    this._assertNotDisposed();
    const a = this.validatePosition(t);
    if (!i && e.indexOf(`
`) < 0) {
      const c = new Xc(e, i, n, o).parseSearchRequest();
      if (!c)
        return null;
      const h = this.getLineCount();
      let d = new R(a.lineNumber, a.column, h, this.getLineMaxColumn(h)), u = this.findMatchesLineByLine(d, c, r, 1);
      return am.findNextMatch(this, new Xc(e, i, n, o), a, r), u.length > 0 || (d = new R(1, 1, a.lineNumber, this.getLineMaxColumn(a.lineNumber)), u = this.findMatchesLineByLine(d, c, r, 1), u.length > 0) ? u[0] : null;
    }
    return am.findNextMatch(this, new Xc(e, i, n, o), a, r);
  }
  findPreviousMatch(e, t, i, n, o, r) {
    this._assertNotDisposed();
    const a = this.validatePosition(t);
    return am.findPreviousMatch(this, new Xc(e, i, n, o), a, r);
  }
  //#endregion
  //#region Editing
  pushStackElement() {
    this._commandManager.pushStackElement();
  }
  popStackElement() {
    this._commandManager.popStackElement();
  }
  pushEOL(e) {
    if ((this.getEOL() === `
` ? 0 : 1) !== e)
      try {
        this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit(), this._initialUndoRedoSnapshot === null && (this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri)), this._commandManager.pushEOL(e);
      } finally {
        this._eventEmitter.endDeferredEmit(), this._onDidChangeDecorations.endDeferredEmit();
      }
  }
  _validateEditOperation(e) {
    return e instanceof M0 ? e : new M0(e.identifier || null, this.validateRange(e.range), e.text, e.forceMoveMarkers || !1, e.isAutoWhitespaceEdit || !1, e._isTracked || !1);
  }
  _validateEditOperations(e) {
    const t = [];
    for (let i = 0, n = e.length; i < n; i++)
      t[i] = this._validateEditOperation(e[i]);
    return t;
  }
  pushEditOperations(e, t, i, n) {
    try {
      return this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit(), this._pushEditOperations(e, this._validateEditOperations(t), i, n);
    } finally {
      this._eventEmitter.endDeferredEmit(), this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  _pushEditOperations(e, t, i, n) {
    if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {
      const o = t.map((a) => ({
        range: this.validateRange(a.range),
        text: a.text
      }));
      let r = !0;
      if (e)
        for (let a = 0, l = e.length; a < l; a++) {
          const c = e[a];
          let h = !1;
          for (let d = 0, u = o.length; d < u; d++) {
            const f = o[d].range, g = f.startLineNumber > c.endLineNumber, m = c.startLineNumber > f.endLineNumber;
            if (!g && !m) {
              h = !0;
              break;
            }
          }
          if (!h) {
            r = !1;
            break;
          }
        }
      if (r)
        for (let a = 0, l = this._trimAutoWhitespaceLines.length; a < l; a++) {
          const c = this._trimAutoWhitespaceLines[a], h = this.getLineMaxColumn(c);
          let d = !0;
          for (let u = 0, f = o.length; u < f; u++) {
            const g = o[u].range, m = o[u].text;
            if (!(c < g.startLineNumber || c > g.endLineNumber) && !(c === g.startLineNumber && g.startColumn === h && g.isEmpty() && m && m.length > 0 && m.charAt(0) === `
`) && !(c === g.startLineNumber && g.startColumn === 1 && g.isEmpty() && m && m.length > 0 && m.charAt(m.length - 1) === `
`)) {
              d = !1;
              break;
            }
          }
          if (d) {
            const u = new R(c, 1, c, h);
            t.push(new M0(null, u, null, !1, !1, !1));
          }
        }
      this._trimAutoWhitespaceLines = null;
    }
    return this._initialUndoRedoSnapshot === null && (this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri)), this._commandManager.pushEditOperation(e, t, i, n);
  }
  _applyUndo(e, t, i, n) {
    const o = e.map((r) => {
      const a = this.getPositionAt(r.newPosition), l = this.getPositionAt(r.newEnd);
      return {
        range: new R(a.lineNumber, a.column, l.lineNumber, l.column),
        text: r.oldText
      };
    });
    this._applyUndoRedoEdits(o, t, !0, !1, i, n);
  }
  _applyRedo(e, t, i, n) {
    const o = e.map((r) => {
      const a = this.getPositionAt(r.oldPosition), l = this.getPositionAt(r.oldEnd);
      return {
        range: new R(a.lineNumber, a.column, l.lineNumber, l.column),
        text: r.newText
      };
    });
    this._applyUndoRedoEdits(o, t, !1, !0, i, n);
  }
  _applyUndoRedoEdits(e, t, i, n, o, r) {
    try {
      this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit(), this._isUndoing = i, this._isRedoing = n, this.applyEdits(e, !1), this.setEOL(t), this._overwriteAlternativeVersionId(o);
    } finally {
      this._isUndoing = !1, this._isRedoing = !1, this._eventEmitter.endDeferredEmit(r), this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  applyEdits(e, t = !1) {
    try {
      this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit();
      const i = this._validateEditOperations(e);
      return this._doApplyEdits(i, t);
    } finally {
      this._eventEmitter.endDeferredEmit(), this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  _doApplyEdits(e, t) {
    const i = this._buffer.getLineCount(), n = this._buffer.applyEdits(e, this._options.trimAutoWhitespace, t), o = this._buffer.getLineCount(), r = n.changes;
    if (this._trimAutoWhitespaceLines = n.trimAutoWhitespaceLineNumbers, r.length !== 0) {
      for (let c = 0, h = r.length; c < h; c++) {
        const d = r[c];
        this._decorationsTree.acceptReplace(d.rangeOffset, d.rangeLength, d.text.length, d.forceMoveMarkers);
      }
      const a = [];
      this._increaseVersionId();
      let l = i;
      for (let c = 0, h = r.length; c < h; c++) {
        const d = r[c], [u] = Ld(d.text);
        this._onDidChangeDecorations.fire();
        const f = d.range.startLineNumber, g = d.range.endLineNumber, m = g - f, _ = u, b = Math.min(m, _), C = _ - m, v = o - l - C + f, w = v, S = v + _, L = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new V(w, 1)), this.getOffsetAt(new V(S, this.getLineMaxColumn(S))), 0), k = ao.fromDecorations(L), D = new Gr(k);
        for (let E = b; E >= 0; E--) {
          const U = f + E, P = v + E;
          D.takeFromEndWhile((W) => W.lineNumber > P);
          const B = D.takeFromEndWhile((W) => W.lineNumber === P);
          a.push(new fN(U, this.getLineContent(P), B));
        }
        if (b < m) {
          const E = f + b;
          a.push(new v$(E + 1, g));
        }
        if (b < _) {
          const E = new Gr(k), U = f + b, P = _ - b, B = o - l - P + U + 1, W = [], A = [];
          for (let K = 0; K < P; K++) {
            const Y = B + K;
            A[K] = this.getLineContent(Y), E.takeWhile((Q) => Q.lineNumber < Y), W[K] = E.takeWhile((Q) => Q.lineNumber === Y);
          }
          a.push(new y$(U + 1, f + _, A, W));
        }
        l += C;
      }
      this._emitContentChangedEvent(new nd(a, this.getVersionId(), this._isUndoing, this._isRedoing), {
        changes: r,
        eol: this._buffer.getEOL(),
        isEolChange: !1,
        versionId: this.getVersionId(),
        isUndoing: this._isUndoing,
        isRedoing: this._isRedoing,
        isFlush: !1
      });
    }
    return n.reverseEdits === null ? void 0 : n.reverseEdits;
  }
  undo() {
    return this._undoRedoService.undo(this.uri);
  }
  canUndo() {
    return this._undoRedoService.canUndo(this.uri);
  }
  redo() {
    return this._undoRedoService.redo(this.uri);
  }
  canRedo() {
    return this._undoRedoService.canRedo(this.uri);
  }
  //#endregion
  //#region Decorations
  handleBeforeFireDecorationsChangedEvent(e) {
    if (e === null || e.size === 0)
      return;
    const i = Array.from(e).map((n) => new fN(n, this.getLineContent(n), this._getInjectedTextInLine(n)));
    this._onDidChangeInjectedText.fire(new r4(i));
  }
  changeDecorations(e, t = 0) {
    this._assertNotDisposed();
    try {
      return this._onDidChangeDecorations.beginDeferredEmit(), this._changeDecorations(t, e);
    } finally {
      this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  _changeDecorations(e, t) {
    const i = {
      addDecoration: (o, r) => this._deltaDecorationsImpl(e, [], [{ range: o, options: r }])[0],
      changeDecoration: (o, r) => {
        this._changeDecorationImpl(o, r);
      },
      changeDecorationOptions: (o, r) => {
        this._changeDecorationOptionsImpl(o, _N(r));
      },
      removeDecoration: (o) => {
        this._deltaDecorationsImpl(e, [o], []);
      },
      deltaDecorations: (o, r) => o.length === 0 && r.length === 0 ? [] : this._deltaDecorationsImpl(e, o, r)
    };
    let n = null;
    try {
      n = t(i);
    } catch (o) {
      ht(o);
    }
    return i.addDecoration = pu, i.changeDecoration = pu, i.changeDecorationOptions = pu, i.removeDecoration = pu, i.deltaDecorations = pu, n;
  }
  deltaDecorations(e, t, i = 0) {
    if (this._assertNotDisposed(), e || (e = []), e.length === 0 && t.length === 0)
      return [];
    try {
      return this._deltaDecorationCallCnt++, this._deltaDecorationCallCnt > 1 && (console.warn("Invoking deltaDecorations recursively could lead to leaking decorations."), ht(new Error("Invoking deltaDecorations recursively could lead to leaking decorations."))), this._onDidChangeDecorations.beginDeferredEmit(), this._deltaDecorationsImpl(i, e, t);
    } finally {
      this._onDidChangeDecorations.endDeferredEmit(), this._deltaDecorationCallCnt--;
    }
  }
  _getTrackedRange(e) {
    return this.getDecorationRange(e);
  }
  _setTrackedRange(e, t, i) {
    const n = e ? this._decorations[e] : null;
    if (!n)
      return t ? this._deltaDecorationsImpl(0, [], [{ range: t, options: pN[i] }], !0)[0] : null;
    if (!t)
      return this._decorationsTree.delete(n), delete this._decorations[n.id], null;
    const o = this._validateRangeRelaxedNoAllocations(t), r = this._buffer.getOffsetAt(o.startLineNumber, o.startColumn), a = this._buffer.getOffsetAt(o.endLineNumber, o.endColumn);
    return this._decorationsTree.delete(n), n.reset(this.getVersionId(), r, a, o), n.setOptions(pN[i]), this._decorationsTree.insert(n), n.id;
  }
  removeAllDecorationsWithOwnerId(e) {
    if (this._isDisposed)
      return;
    const t = this._decorationsTree.collectNodesFromOwner(e);
    for (let i = 0, n = t.length; i < n; i++) {
      const o = t[i];
      this._decorationsTree.delete(o), delete this._decorations[o.id];
    }
  }
  getDecorationOptions(e) {
    const t = this._decorations[e];
    return t ? t.options : null;
  }
  getDecorationRange(e) {
    const t = this._decorations[e];
    return t ? this._decorationsTree.getNodeRange(this, t) : null;
  }
  getLineDecorations(e, t = 0, i = !1) {
    return e < 1 || e > this.getLineCount() ? [] : this.getLinesDecorations(e, e, t, i);
  }
  getLinesDecorations(e, t, i = 0, n = !1, o = !1) {
    const r = this.getLineCount(), a = Math.min(r, Math.max(1, e)), l = Math.min(r, Math.max(1, t)), c = this.getLineMaxColumn(l), h = new R(a, 1, l, c), d = this._getDecorationsInRange(h, i, n, o);
    return EC(d, this._decorationProvider.getDecorationsInRange(h, i, n)), d;
  }
  getDecorationsInRange(e, t = 0, i = !1, n = !1, o = !1) {
    const r = this.validateRange(e), a = this._getDecorationsInRange(r, t, i, o);
    return EC(a, this._decorationProvider.getDecorationsInRange(r, t, i, n)), a;
  }
  getOverviewRulerDecorations(e = 0, t = !1) {
    return this._decorationsTree.getAll(this, e, t, !0, !1);
  }
  getInjectedTextDecorations(e = 0) {
    return this._decorationsTree.getAllInjectedText(this, e);
  }
  _getInjectedTextInLine(e) {
    const t = this._buffer.getOffsetAt(e, 1), i = t + this._buffer.getLineLength(e), n = this._decorationsTree.getInjectedTextInInterval(this, t, i, 0);
    return ao.fromDecorations(n).filter((o) => o.lineNumber === e);
  }
  getAllDecorations(e = 0, t = !1) {
    let i = this._decorationsTree.getAll(this, e, t, !1, !1);
    return i = i.concat(this._decorationProvider.getAllDecorations(e, t)), i;
  }
  getAllMarginDecorations(e = 0) {
    return this._decorationsTree.getAll(this, e, !1, !1, !0);
  }
  _getDecorationsInRange(e, t, i, n) {
    const o = this._buffer.getOffsetAt(e.startLineNumber, e.startColumn), r = this._buffer.getOffsetAt(e.endLineNumber, e.endColumn);
    return this._decorationsTree.getAllInInterval(this, o, r, t, i, n);
  }
  getRangeAt(e, t) {
    return this._buffer.getRangeAt(e, t - e);
  }
  _changeDecorationImpl(e, t) {
    const i = this._decorations[e];
    if (!i)
      return;
    if (i.options.after) {
      const a = this.getDecorationRange(e);
      this._onDidChangeDecorations.recordLineAffectedByInjectedText(a.endLineNumber);
    }
    if (i.options.before) {
      const a = this.getDecorationRange(e);
      this._onDidChangeDecorations.recordLineAffectedByInjectedText(a.startLineNumber);
    }
    const n = this._validateRangeRelaxedNoAllocations(t), o = this._buffer.getOffsetAt(n.startLineNumber, n.startColumn), r = this._buffer.getOffsetAt(n.endLineNumber, n.endColumn);
    this._decorationsTree.delete(i), i.reset(this.getVersionId(), o, r, n), this._decorationsTree.insert(i), this._onDidChangeDecorations.checkAffectedAndFire(i.options), i.options.after && this._onDidChangeDecorations.recordLineAffectedByInjectedText(n.endLineNumber), i.options.before && this._onDidChangeDecorations.recordLineAffectedByInjectedText(n.startLineNumber);
  }
  _changeDecorationOptionsImpl(e, t) {
    const i = this._decorations[e];
    if (!i)
      return;
    const n = !!(i.options.overviewRuler && i.options.overviewRuler.color), o = !!(t.overviewRuler && t.overviewRuler.color);
    if (this._onDidChangeDecorations.checkAffectedAndFire(i.options), this._onDidChangeDecorations.checkAffectedAndFire(t), i.options.after || t.after) {
      const l = this._decorationsTree.getNodeRange(this, i);
      this._onDidChangeDecorations.recordLineAffectedByInjectedText(l.endLineNumber);
    }
    if (i.options.before || t.before) {
      const l = this._decorationsTree.getNodeRange(this, i);
      this._onDidChangeDecorations.recordLineAffectedByInjectedText(l.startLineNumber);
    }
    const r = n !== o, a = T$(t) !== op(i);
    r || a ? (this._decorationsTree.delete(i), i.setOptions(t), this._decorationsTree.insert(i)) : i.setOptions(t);
  }
  _deltaDecorationsImpl(e, t, i, n = !1) {
    const o = this.getVersionId(), r = t.length;
    let a = 0;
    const l = i.length;
    let c = 0;
    this._onDidChangeDecorations.beginDeferredEmit();
    try {
      const h = new Array(l);
      for (; a < r || c < l; ) {
        let d = null;
        if (a < r) {
          do
            d = this._decorations[t[a++]];
          while (!d && a < r);
          if (d) {
            if (d.options.after) {
              const u = this._decorationsTree.getNodeRange(this, d);
              this._onDidChangeDecorations.recordLineAffectedByInjectedText(u.endLineNumber);
            }
            if (d.options.before) {
              const u = this._decorationsTree.getNodeRange(this, d);
              this._onDidChangeDecorations.recordLineAffectedByInjectedText(u.startLineNumber);
            }
            this._decorationsTree.delete(d), n || this._onDidChangeDecorations.checkAffectedAndFire(d.options);
          }
        }
        if (c < l) {
          if (!d) {
            const b = ++this._lastDecorationId, C = `${this._instanceId};${b}`;
            d = new JA(C, 0, 0), this._decorations[C] = d;
          }
          const u = i[c], f = this._validateRangeRelaxedNoAllocations(u.range), g = _N(u.options), m = this._buffer.getOffsetAt(f.startLineNumber, f.startColumn), _ = this._buffer.getOffsetAt(f.endLineNumber, f.endColumn);
          d.ownerId = e, d.reset(o, m, _, f), d.setOptions(g), d.options.after && this._onDidChangeDecorations.recordLineAffectedByInjectedText(f.endLineNumber), d.options.before && this._onDidChangeDecorations.recordLineAffectedByInjectedText(f.startLineNumber), n || this._onDidChangeDecorations.checkAffectedAndFire(g), this._decorationsTree.insert(d), h[c] = d.id, c++;
        } else
          d && delete this._decorations[d.id];
      }
      return h;
    } finally {
      this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  //#endregion
  //#region Tokenization
  // TODO move them to the tokenization part.
  getLanguageId() {
    return this.tokenization.getLanguageId();
  }
  setLanguage(e, t) {
    typeof e == "string" ? (this._languageSelectionListener.clear(), this._setLanguage(e, t)) : (this._languageSelectionListener.value = e.onDidChange(() => this._setLanguage(e.languageId, t)), this._setLanguage(e.languageId, t));
  }
  _setLanguage(e, t) {
    this.tokenization.setLanguageId(e, t), this._languageService.requestRichLanguageFeatures(e);
  }
  getLanguageIdAtPosition(e, t) {
    return this.tokenization.getLanguageIdAtPosition(e, t);
  }
  getWordAtPosition(e) {
    return this._tokenizationTextModelPart.getWordAtPosition(e);
  }
  getWordUntilPosition(e) {
    return this._tokenizationTextModelPart.getWordUntilPosition(e);
  }
  //#endregion
  normalizePosition(e, t) {
    return e;
  }
  /**
   * Gets the column at which indentation stops at a given line.
   * @internal
  */
  getLineIndentColumn(e) {
    return N$(this.getLineContent(e)) + 1;
  }
}, _l = eo, eo._MODEL_SYNC_LIMIT = 50 * 1024 * 1024, eo.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024, eo.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1e3, eo.LARGE_FILE_HEAP_OPERATION_THRESHOLD = 256 * 1024 * 1024, eo.DEFAULT_CREATION_OPTIONS = {
  isForSimpleWidget: !1,
  tabSize: Oi.tabSize,
  indentSize: Oi.indentSize,
  insertSpaces: Oi.insertSpaces,
  detectIndentation: !1,
  defaultEOL: 1,
  trimAutoWhitespace: Oi.trimAutoWhitespace,
  largeFileOptimizations: Oi.largeFileOptimizations,
  bracketPairColorizationOptions: Oi.bracketPairColorizationOptions
}, eo);
Ny = _l = L$([
  Dm(4, sk),
  Dm(5, gi),
  Dm(6, Zo),
  Dm(7, ot)
], Ny);
function N$(s) {
  let e = 0;
  for (const t of s)
    if (t === " " || t === "	")
      e++;
    else
      break;
  return e;
}
function tC(s) {
  return !!(s.options.overviewRuler && s.options.overviewRuler.color);
}
function T$(s) {
  return !!s.after || !!s.before;
}
function op(s) {
  return !!s.options.after || !!s.options.before;
}
class mN {
  constructor() {
    this._decorationsTree0 = new Q0(), this._decorationsTree1 = new Q0(), this._injectedTextDecorationsTree = new Q0();
  }
  ensureAllNodesHaveRanges(e) {
    this.getAll(e, 0, !1, !1, !1);
  }
  _ensureNodesHaveRanges(e, t) {
    for (const i of t)
      i.range === null && (i.range = e.getRangeAt(i.cachedAbsoluteStart, i.cachedAbsoluteEnd));
    return t;
  }
  getAllInInterval(e, t, i, n, o, r) {
    const a = e.getVersionId(), l = this._intervalSearch(t, i, n, o, a, r);
    return this._ensureNodesHaveRanges(e, l);
  }
  _intervalSearch(e, t, i, n, o, r) {
    const a = this._decorationsTree0.intervalSearch(e, t, i, n, o, r), l = this._decorationsTree1.intervalSearch(e, t, i, n, o, r), c = this._injectedTextDecorationsTree.intervalSearch(e, t, i, n, o, r);
    return a.concat(l).concat(c);
  }
  getInjectedTextInInterval(e, t, i, n) {
    const o = e.getVersionId(), r = this._injectedTextDecorationsTree.intervalSearch(t, i, n, !1, o, !1);
    return this._ensureNodesHaveRanges(e, r).filter((a) => a.options.showIfCollapsed || !a.range.isEmpty());
  }
  getAllInjectedText(e, t) {
    const i = e.getVersionId(), n = this._injectedTextDecorationsTree.search(t, !1, i, !1);
    return this._ensureNodesHaveRanges(e, n).filter((o) => o.options.showIfCollapsed || !o.range.isEmpty());
  }
  getAll(e, t, i, n, o) {
    const r = e.getVersionId(), a = this._search(t, i, n, r, o);
    return this._ensureNodesHaveRanges(e, a);
  }
  _search(e, t, i, n, o) {
    if (i)
      return this._decorationsTree1.search(e, t, n, o);
    {
      const r = this._decorationsTree0.search(e, t, n, o), a = this._decorationsTree1.search(e, t, n, o), l = this._injectedTextDecorationsTree.search(e, t, n, o);
      return r.concat(a).concat(l);
    }
  }
  collectNodesFromOwner(e) {
    const t = this._decorationsTree0.collectNodesFromOwner(e), i = this._decorationsTree1.collectNodesFromOwner(e), n = this._injectedTextDecorationsTree.collectNodesFromOwner(e);
    return t.concat(i).concat(n);
  }
  collectNodesPostOrder() {
    const e = this._decorationsTree0.collectNodesPostOrder(), t = this._decorationsTree1.collectNodesPostOrder(), i = this._injectedTextDecorationsTree.collectNodesPostOrder();
    return e.concat(t).concat(i);
  }
  insert(e) {
    op(e) ? this._injectedTextDecorationsTree.insert(e) : tC(e) ? this._decorationsTree1.insert(e) : this._decorationsTree0.insert(e);
  }
  delete(e) {
    op(e) ? this._injectedTextDecorationsTree.delete(e) : tC(e) ? this._decorationsTree1.delete(e) : this._decorationsTree0.delete(e);
  }
  getNodeRange(e, t) {
    const i = e.getVersionId();
    return t.cachedVersionId !== i && this._resolveNode(t, i), t.range === null && (t.range = e.getRangeAt(t.cachedAbsoluteStart, t.cachedAbsoluteEnd)), t.range;
  }
  _resolveNode(e, t) {
    op(e) ? this._injectedTextDecorationsTree.resolveNode(e, t) : tC(e) ? this._decorationsTree1.resolveNode(e, t) : this._decorationsTree0.resolveNode(e, t);
  }
  acceptReplace(e, t, i, n) {
    this._decorationsTree0.acceptReplace(e, t, i, n), this._decorationsTree1.acceptReplace(e, t, i, n), this._injectedTextDecorationsTree.acceptReplace(e, t, i, n);
  }
}
function yo(s) {
  return s.replace(/[^a-z0-9\-_]/gi, " ");
}
class a4 {
  constructor(e) {
    this.color = e.color || "", this.darkColor = e.darkColor || "";
  }
}
class M$ extends a4 {
  constructor(e) {
    super(e), this._resolvedColor = null, this.position = typeof e.position == "number" ? e.position : Pp.Center;
  }
  getColor(e) {
    return this._resolvedColor || (e.type !== "light" && this.darkColor ? this._resolvedColor = this._resolveColor(this.darkColor, e) : this._resolvedColor = this._resolveColor(this.color, e)), this._resolvedColor;
  }
  invalidateCachedColor() {
    this._resolvedColor = null;
  }
  _resolveColor(e, t) {
    if (typeof e == "string")
      return e;
    const i = e ? t.getColor(e.id) : null;
    return i ? i.toString() : "";
  }
}
class R$ {
  constructor(e) {
    this.position = (e == null ? void 0 : e.position) ?? Ka.Center, this.persistLane = e == null ? void 0 : e.persistLane;
  }
}
class A$ extends a4 {
  constructor(e) {
    super(e), this.position = e.position, this.sectionHeaderStyle = e.sectionHeaderStyle ?? null, this.sectionHeaderText = e.sectionHeaderText ?? null;
  }
  getColor(e) {
    return this._resolvedColor || (e.type !== "light" && this.darkColor ? this._resolvedColor = this._resolveColor(this.darkColor, e) : this._resolvedColor = this._resolveColor(this.color, e)), this._resolvedColor;
  }
  invalidateCachedColor() {
    this._resolvedColor = void 0;
  }
  _resolveColor(e, t) {
    return typeof e == "string" ? Z.fromHex(e) : t.getColor(e.id);
  }
}
class ig {
  static from(e) {
    return e instanceof ig ? e : new ig(e);
  }
  constructor(e) {
    this.content = e.content || "", this.inlineClassName = e.inlineClassName || null, this.inlineClassNameAffectsLetterSpacing = e.inlineClassNameAffectsLetterSpacing || !1, this.attachedData = e.attachedData || null, this.cursorStops = e.cursorStops || null;
  }
}
class si {
  static register(e) {
    return new si(e);
  }
  static createDynamic(e) {
    return new si(e);
  }
  constructor(e) {
    this.description = e.description, this.blockClassName = e.blockClassName ? yo(e.blockClassName) : null, this.blockDoesNotCollapse = e.blockDoesNotCollapse ?? null, this.blockIsAfterEnd = e.blockIsAfterEnd ?? null, this.blockPadding = e.blockPadding ?? null, this.stickiness = e.stickiness || 0, this.zIndex = e.zIndex || 0, this.className = e.className ? yo(e.className) : null, this.shouldFillLineOnLineBreak = e.shouldFillLineOnLineBreak ?? null, this.hoverMessage = e.hoverMessage || null, this.glyphMarginHoverMessage = e.glyphMarginHoverMessage || null, this.lineNumberHoverMessage = e.lineNumberHoverMessage || null, this.isWholeLine = e.isWholeLine || !1, this.showIfCollapsed = e.showIfCollapsed || !1, this.collapseOnReplaceEdit = e.collapseOnReplaceEdit || !1, this.overviewRuler = e.overviewRuler ? new M$(e.overviewRuler) : null, this.minimap = e.minimap ? new A$(e.minimap) : null, this.glyphMargin = e.glyphMarginClassName ? new R$(e.glyphMargin) : null, this.glyphMarginClassName = e.glyphMarginClassName ? yo(e.glyphMarginClassName) : null, this.linesDecorationsClassName = e.linesDecorationsClassName ? yo(e.linesDecorationsClassName) : null, this.lineNumberClassName = e.lineNumberClassName ? yo(e.lineNumberClassName) : null, this.linesDecorationsTooltip = e.linesDecorationsTooltip ? GO(e.linesDecorationsTooltip) : null, this.firstLineDecorationClassName = e.firstLineDecorationClassName ? yo(e.firstLineDecorationClassName) : null, this.marginClassName = e.marginClassName ? yo(e.marginClassName) : null, this.inlineClassName = e.inlineClassName ? yo(e.inlineClassName) : null, this.inlineClassNameAffectsLetterSpacing = e.inlineClassNameAffectsLetterSpacing || !1, this.beforeContentClassName = e.beforeContentClassName ? yo(e.beforeContentClassName) : null, this.afterContentClassName = e.afterContentClassName ? yo(e.afterContentClassName) : null, this.after = e.after ? ig.from(e.after) : null, this.before = e.before ? ig.from(e.before) : null, this.hideInCommentTokens = e.hideInCommentTokens ?? !1, this.hideInStringTokens = e.hideInStringTokens ?? !1;
  }
}
si.EMPTY = si.register({ description: "empty" });
const pN = [
  si.register({
    description: "tracked-range-always-grows-when-typing-at-edges",
    stickiness: 0
    /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */
  }),
  si.register({
    description: "tracked-range-never-grows-when-typing-at-edges",
    stickiness: 1
    /* model.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
  }),
  si.register({
    description: "tracked-range-grows-only-when-typing-before",
    stickiness: 2
    /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */
  }),
  si.register({
    description: "tracked-range-grows-only-when-typing-after",
    stickiness: 3
    /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */
  })
];
function _N(s) {
  return s instanceof si ? s : si.createDynamic(s);
}
class P$ extends q {
  constructor(e) {
    super(), this.handleBeforeFire = e, this._actual = this._register(new O()), this.event = this._actual.event, this._affectedInjectedTextLines = null, this._deferredCnt = 0, this._shouldFireDeferred = !1, this._affectsMinimap = !1, this._affectsOverviewRuler = !1, this._affectsGlyphMargin = !1, this._affectsLineNumber = !1;
  }
  beginDeferredEmit() {
    this._deferredCnt++;
  }
  endDeferredEmit() {
    var e;
    this._deferredCnt--, this._deferredCnt === 0 && (this._shouldFireDeferred && this.doFire(), (e = this._affectedInjectedTextLines) == null || e.clear(), this._affectedInjectedTextLines = null);
  }
  recordLineAffectedByInjectedText(e) {
    this._affectedInjectedTextLines || (this._affectedInjectedTextLines = /* @__PURE__ */ new Set()), this._affectedInjectedTextLines.add(e);
  }
  checkAffectedAndFire(e) {
    var t, i;
    this._affectsMinimap || (this._affectsMinimap = !!((t = e.minimap) != null && t.position)), this._affectsOverviewRuler || (this._affectsOverviewRuler = !!((i = e.overviewRuler) != null && i.color)), this._affectsGlyphMargin || (this._affectsGlyphMargin = !!e.glyphMarginClassName), this._affectsLineNumber || (this._affectsLineNumber = !!e.lineNumberClassName), this.tryFire();
  }
  fire() {
    this._affectsMinimap = !0, this._affectsOverviewRuler = !0, this._affectsGlyphMargin = !0, this.tryFire();
  }
  tryFire() {
    this._deferredCnt === 0 ? this.doFire() : this._shouldFireDeferred = !0;
  }
  doFire() {
    this.handleBeforeFire(this._affectedInjectedTextLines);
    const e = {
      affectsMinimap: this._affectsMinimap,
      affectsOverviewRuler: this._affectsOverviewRuler,
      affectsGlyphMargin: this._affectsGlyphMargin,
      affectsLineNumber: this._affectsLineNumber
    };
    this._shouldFireDeferred = !1, this._affectsMinimap = !1, this._affectsOverviewRuler = !1, this._affectsGlyphMargin = !1, this._actual.fire(e);
  }
}
class O$ extends q {
  constructor() {
    super(), this._fastEmitter = this._register(new O()), this.fastEvent = this._fastEmitter.event, this._slowEmitter = this._register(new O()), this.slowEvent = this._slowEmitter.event, this._deferredCnt = 0, this._deferredEvent = null;
  }
  beginDeferredEmit() {
    this._deferredCnt++;
  }
  endDeferredEmit(e = null) {
    if (this._deferredCnt--, this._deferredCnt === 0 && this._deferredEvent !== null) {
      this._deferredEvent.rawContentChangedEvent.resultingSelection = e;
      const t = this._deferredEvent;
      this._deferredEvent = null, this._fastEmitter.fire(t), this._slowEmitter.fire(t);
    }
  }
  fire(e) {
    if (this._deferredCnt > 0) {
      this._deferredEvent ? this._deferredEvent = this._deferredEvent.merge(e) : this._deferredEvent = e;
      return;
    }
    this._fastEmitter.fire(e), this._slowEmitter.fire(e);
  }
}
var F$ = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Im = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, rh;
function hl(s) {
  return s.toString();
}
let B$ = class {
  constructor(e, t, i) {
    this.model = e, this._modelEventListeners = new he(), this.model = e, this._modelEventListeners.add(e.onWillDispose(() => t(e))), this._modelEventListeners.add(e.onDidChangeLanguage((n) => i(e, n)));
  }
  dispose() {
    this._modelEventListeners.dispose();
  }
};
const W$ = wn || He ? 1 : 2;
class V$ {
  constructor(e, t, i, n, o, r, a, l) {
    this.uri = e, this.initialUndoRedoSnapshot = t, this.time = i, this.sharesUndoRedoStack = n, this.heapSize = o, this.sha1 = r, this.versionId = a, this.alternativeVersionId = l;
  }
}
var sc;
let Ty = (sc = class extends q {
  constructor(e, t, i, n) {
    super(), this._configurationService = e, this._resourcePropertiesService = t, this._undoRedoService = i, this._instantiationService = n, this._onModelAdded = this._register(new O()), this.onModelAdded = this._onModelAdded.event, this._onModelRemoved = this._register(new O()), this.onModelRemoved = this._onModelRemoved.event, this._onModelModeChanged = this._register(new O()), this.onModelLanguageChanged = this._onModelModeChanged.event, this._modelCreationOptionsByLanguageAndResource = /* @__PURE__ */ Object.create(null), this._models = {}, this._disposedModels = /* @__PURE__ */ new Map(), this._disposedModelsHeapSize = 0, this._register(this._configurationService.onDidChangeConfiguration((o) => this._updateModelOptions(o))), this._updateModelOptions(void 0);
  }
  static _readModelOptions(e, t) {
    var u;
    let i = Oi.tabSize;
    if (e.editor && typeof e.editor.tabSize < "u") {
      const f = parseInt(e.editor.tabSize, 10);
      isNaN(f) || (i = f), i < 1 && (i = 1);
    }
    let n = "tabSize";
    if (e.editor && typeof e.editor.indentSize < "u" && e.editor.indentSize !== "tabSize") {
      const f = parseInt(e.editor.indentSize, 10);
      isNaN(f) || (n = Math.max(f, 1));
    }
    let o = Oi.insertSpaces;
    e.editor && typeof e.editor.insertSpaces < "u" && (o = e.editor.insertSpaces === "false" ? !1 : !!e.editor.insertSpaces);
    let r = W$;
    const a = e.eol;
    a === `\r
` ? r = 2 : a === `
` && (r = 1);
    let l = Oi.trimAutoWhitespace;
    e.editor && typeof e.editor.trimAutoWhitespace < "u" && (l = e.editor.trimAutoWhitespace === "false" ? !1 : !!e.editor.trimAutoWhitespace);
    let c = Oi.detectIndentation;
    e.editor && typeof e.editor.detectIndentation < "u" && (c = e.editor.detectIndentation === "false" ? !1 : !!e.editor.detectIndentation);
    let h = Oi.largeFileOptimizations;
    e.editor && typeof e.editor.largeFileOptimizations < "u" && (h = e.editor.largeFileOptimizations === "false" ? !1 : !!e.editor.largeFileOptimizations);
    let d = Oi.bracketPairColorizationOptions;
    return (u = e.editor) != null && u.bracketPairColorization && typeof e.editor.bracketPairColorization == "object" && (d = {
      enabled: !!e.editor.bracketPairColorization.enabled,
      independentColorPoolPerBracketType: !!e.editor.bracketPairColorization.independentColorPoolPerBracketType
    }), {
      isForSimpleWidget: t,
      tabSize: i,
      indentSize: n,
      insertSpaces: o,
      detectIndentation: c,
      defaultEOL: r,
      trimAutoWhitespace: l,
      largeFileOptimizations: h,
      bracketPairColorizationOptions: d
    };
  }
  _getEOL(e, t) {
    if (e)
      return this._resourcePropertiesService.getEOL(e, t);
    const i = this._configurationService.getValue("files.eol", { overrideIdentifier: t });
    return i && typeof i == "string" && i !== "auto" ? i : Es === 3 || Es === 2 ? `
` : `\r
`;
  }
  _shouldRestoreUndoStack() {
    const e = this._configurationService.getValue("files.restoreUndoStack");
    return typeof e == "boolean" ? e : !0;
  }
  getCreationOptions(e, t, i) {
    const n = typeof e == "string" ? e : e.languageId;
    let o = this._modelCreationOptionsByLanguageAndResource[n + t];
    if (!o) {
      const r = this._configurationService.getValue("editor", { overrideIdentifier: n, resource: t }), a = this._getEOL(t, n);
      o = rh._readModelOptions({ editor: r, eol: a }, i), this._modelCreationOptionsByLanguageAndResource[n + t] = o;
    }
    return o;
  }
  _updateModelOptions(e) {
    const t = this._modelCreationOptionsByLanguageAndResource;
    this._modelCreationOptionsByLanguageAndResource = /* @__PURE__ */ Object.create(null);
    const i = Object.keys(this._models);
    for (let n = 0, o = i.length; n < o; n++) {
      const r = i[n], a = this._models[r], l = a.model.getLanguageId(), c = a.model.uri;
      if (e && !e.affectsConfiguration("editor", { overrideIdentifier: l, resource: c }) && !e.affectsConfiguration("files.eol", { overrideIdentifier: l, resource: c }))
        continue;
      const h = t[l + c], d = this.getCreationOptions(l, c, a.model.isForSimpleWidget);
      rh._setModelOptionsForModel(a.model, d, h);
    }
  }
  static _setModelOptionsForModel(e, t, i) {
    i && i.defaultEOL !== t.defaultEOL && e.getLineCount() === 1 && e.setEOL(
      t.defaultEOL === 1 ? 0 : 1
      /* EndOfLineSequence.CRLF */
    ), !(i && i.detectIndentation === t.detectIndentation && i.insertSpaces === t.insertSpaces && i.tabSize === t.tabSize && i.indentSize === t.indentSize && i.trimAutoWhitespace === t.trimAutoWhitespace && Pn(i.bracketPairColorizationOptions, t.bracketPairColorizationOptions)) && (t.detectIndentation ? (e.detectIndentation(t.insertSpaces, t.tabSize), e.updateOptions({
      trimAutoWhitespace: t.trimAutoWhitespace,
      bracketColorizationOptions: t.bracketPairColorizationOptions
    })) : e.updateOptions({
      insertSpaces: t.insertSpaces,
      tabSize: t.tabSize,
      indentSize: t.indentSize,
      trimAutoWhitespace: t.trimAutoWhitespace,
      bracketColorizationOptions: t.bracketPairColorizationOptions
    }));
  }
  // --- begin IModelService
  _insertDisposedModel(e) {
    this._disposedModels.set(hl(e.uri), e), this._disposedModelsHeapSize += e.heapSize;
  }
  _removeDisposedModel(e) {
    const t = this._disposedModels.get(hl(e));
    return t && (this._disposedModelsHeapSize -= t.heapSize), this._disposedModels.delete(hl(e)), t;
  }
  _ensureDisposedModelsHeapSize(e) {
    if (this._disposedModelsHeapSize > e) {
      const t = [];
      for (this._disposedModels.forEach((i) => {
        i.sharesUndoRedoStack || t.push(i);
      }), t.sort((i, n) => i.time - n.time); t.length > 0 && this._disposedModelsHeapSize > e; ) {
        const i = t.shift();
        this._removeDisposedModel(i.uri), i.initialUndoRedoSnapshot !== null && this._undoRedoService.restoreSnapshot(i.initialUndoRedoSnapshot);
      }
    }
  }
  _createModelData(e, t, i, n) {
    const o = this.getCreationOptions(t, i, n), r = this._instantiationService.createInstance(Ny, e, t, o, i);
    if (i && this._disposedModels.has(hl(i))) {
      const c = this._removeDisposedModel(i), h = this._undoRedoService.getElements(i), d = this._getSHA1Computer(), u = d.canComputeSHA1(r) ? d.computeSHA1(r) === c.sha1 : !1;
      if (u || c.sharesUndoRedoStack) {
        for (const f of h.past)
          yr(f) && f.matchesResource(i) && f.setModel(r);
        for (const f of h.future)
          yr(f) && f.matchesResource(i) && f.setModel(r);
        this._undoRedoService.setElementsValidFlag(i, !0, (f) => yr(f) && f.matchesResource(i)), u && (r._overwriteVersionId(c.versionId), r._overwriteAlternativeVersionId(c.alternativeVersionId), r._overwriteInitialUndoRedoSnapshot(c.initialUndoRedoSnapshot));
      } else
        c.initialUndoRedoSnapshot !== null && this._undoRedoService.restoreSnapshot(c.initialUndoRedoSnapshot);
    }
    const a = hl(r.uri);
    if (this._models[a])
      throw new Error("ModelService: Cannot add model because it already exists!");
    const l = new B$(r, (c) => this._onWillDispose(c), (c, h) => this._onDidChangeLanguage(c, h));
    return this._models[a] = l, l;
  }
  createModel(e, t, i, n = !1) {
    let o;
    return t ? o = this._createModelData(e, t, i, n) : o = this._createModelData(e, Ms, i, n), this._onModelAdded.fire(o.model), o.model;
  }
  getModels() {
    const e = [], t = Object.keys(this._models);
    for (let i = 0, n = t.length; i < n; i++) {
      const o = t[i];
      e.push(this._models[o].model);
    }
    return e;
  }
  getModel(e) {
    const t = hl(e), i = this._models[t];
    return i ? i.model : null;
  }
  // --- end IModelService
  _schemaShouldMaintainUndoRedoElements(e) {
    return e.scheme === Ne.file || e.scheme === Ne.vscodeRemote || e.scheme === Ne.vscodeUserData || e.scheme === Ne.vscodeNotebookCell || e.scheme === "fake-fs";
  }
  _onWillDispose(e) {
    const t = hl(e.uri), i = this._models[t], n = this._undoRedoService.getUriComparisonKey(e.uri) !== e.uri.toString();
    let o = !1, r = 0;
    if (n || this._shouldRestoreUndoStack() && this._schemaShouldMaintainUndoRedoElements(e.uri)) {
      const c = this._undoRedoService.getElements(e.uri);
      if (c.past.length > 0 || c.future.length > 0) {
        for (const h of c.past)
          yr(h) && h.matchesResource(e.uri) && (o = !0, r += h.heapSize(e.uri), h.setModel(e.uri));
        for (const h of c.future)
          yr(h) && h.matchesResource(e.uri) && (o = !0, r += h.heapSize(e.uri), h.setModel(e.uri));
      }
    }
    const a = rh.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK, l = this._getSHA1Computer();
    if (o)
      if (!n && (r > a || !l.canComputeSHA1(e))) {
        const c = i.model.getInitialUndoRedoSnapshot();
        c !== null && this._undoRedoService.restoreSnapshot(c);
      } else
        this._ensureDisposedModelsHeapSize(a - r), this._undoRedoService.setElementsValidFlag(e.uri, !1, (c) => yr(c) && c.matchesResource(e.uri)), this._insertDisposedModel(new V$(e.uri, i.model.getInitialUndoRedoSnapshot(), Date.now(), n, r, l.computeSHA1(e), e.getVersionId(), e.getAlternativeVersionId()));
    else if (!n) {
      const c = i.model.getInitialUndoRedoSnapshot();
      c !== null && this._undoRedoService.restoreSnapshot(c);
    }
    delete this._models[t], i.dispose(), delete this._modelCreationOptionsByLanguageAndResource[e.getLanguageId() + e.uri], this._onModelRemoved.fire(e);
  }
  _onDidChangeLanguage(e, t) {
    const i = t.oldLanguage, n = e.getLanguageId(), o = this.getCreationOptions(i, e.uri, e.isForSimpleWidget), r = this.getCreationOptions(n, e.uri, e.isForSimpleWidget);
    rh._setModelOptionsForModel(e, r, o), this._onModelModeChanged.fire({ model: e, oldLanguageId: i });
  }
  _getSHA1Computer() {
    return new My();
  }
}, rh = sc, sc.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK = 20 * 1024 * 1024, sc);
Ty = rh = F$([
  Im(0, Vt),
  Im(1, rR),
  Im(2, sk),
  Im(3, ot)
], Ty);
const L1 = class L1 {
  // takes 200ms to compute a sha1 on a 10MB model on a new machine
  canComputeSHA1(e) {
    return e.getValueLength() <= L1.MAX_MODEL_SIZE;
  }
  computeSHA1(e) {
    const t = new Gw(), i = e.createSnapshot();
    let n;
    for (; n = i.read(); )
      t.update(n);
    return t.digest();
  }
};
L1.MAX_MODEL_SIZE = 10 * 1024 * 1024;
let My = L1;
var Ry;
(function(s) {
  s[s.PRESERVE = 0] = "PRESERVE", s[s.LAST = 1] = "LAST";
})(Ry || (Ry = {}));
const l4 = {
  Quickaccess: "workbench.contributions.quickaccess"
};
class H$ {
  constructor() {
    this.providers = [], this.defaultProvider = void 0;
  }
  registerQuickAccessProvider(e) {
    return e.prefix.length === 0 ? this.defaultProvider = e : this.providers.push(e), this.providers.sort((t, i) => i.prefix.length - t.prefix.length), ke(() => {
      this.providers.splice(this.providers.indexOf(e), 1), this.defaultProvider === e && (this.defaultProvider = void 0);
    });
  }
  getQuickAccessProviders() {
    return fL([this.defaultProvider, ...this.providers]);
  }
  getQuickAccessProvider(e) {
    return e && this.providers.find((i) => e.startsWith(i.prefix)) || void 0 || this.defaultProvider;
  }
}
Li.add(l4.Quickaccess, new H$());
const z$ = { ctrlCmd: !1, alt: !1 };
var Td;
(function(s) {
  s[s.Blur = 1] = "Blur", s[s.Gesture = 2] = "Gesture", s[s.Other = 3] = "Other";
})(Td || (Td = {}));
var To;
(function(s) {
  s[s.NONE = 0] = "NONE", s[s.FIRST = 1] = "FIRST", s[s.SECOND = 2] = "SECOND", s[s.LAST = 3] = "LAST";
})(To || (To = {}));
var _t;
(function(s) {
  s[s.First = 1] = "First", s[s.Second = 2] = "Second", s[s.Last = 3] = "Last", s[s.Next = 4] = "Next", s[s.Previous = 5] = "Previous", s[s.NextPage = 6] = "NextPage", s[s.PreviousPage = 7] = "PreviousPage", s[s.NextSeparator = 8] = "NextSeparator", s[s.PreviousSeparator = 9] = "PreviousSeparator";
})(_t || (_t = {}));
var f_;
(function(s) {
  s[s.Title = 1] = "Title", s[s.Inline = 2] = "Inline";
})(f_ || (f_ = {}));
const Vb = Ve("quickInputService");
var U$ = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, bN = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let Ay = class extends q {
  constructor(e, t) {
    super(), this.quickInputService = e, this.instantiationService = t, this.registry = Li.as(l4.Quickaccess), this.mapProviderToDescriptor = /* @__PURE__ */ new Map(), this.lastAcceptedPickerValues = /* @__PURE__ */ new Map(), this.visibleQuickAccess = void 0;
  }
  show(e = "", t) {
    this.doShowOrPick(e, !1, t);
  }
  doShowOrPick(e, t, i) {
    var g, m;
    const [n, o] = this.getOrInstantiateProvider(e, i == null ? void 0 : i.enabledProviderPrefixes), r = this.visibleQuickAccess, a = r == null ? void 0 : r.descriptor;
    if (r && o && a === o) {
      e !== o.prefix && !(i != null && i.preserveValue) && (r.picker.value = e), this.adjustValueSelection(r.picker, o, i);
      return;
    }
    if (o && !(i != null && i.preserveValue)) {
      let _;
      if (r && a && a !== o) {
        const b = r.value.substr(a.prefix.length);
        b && (_ = `${o.prefix}${b}`);
      }
      if (!_) {
        const b = n == null ? void 0 : n.defaultFilterValue;
        b === Ry.LAST ? _ = this.lastAcceptedPickerValues.get(o) : typeof b == "string" && (_ = `${o.prefix}${b}`);
      }
      typeof _ == "string" && (e = _);
    }
    const l = (g = r == null ? void 0 : r.picker) == null ? void 0 : g.valueSelection, c = (m = r == null ? void 0 : r.picker) == null ? void 0 : m.value, h = new he(), d = h.add(this.quickInputService.createQuickPick({ useSeparators: !0 }));
    d.value = e, this.adjustValueSelection(d, o, i), d.placeholder = (i == null ? void 0 : i.placeholder) ?? (o == null ? void 0 : o.placeholder), d.quickNavigate = i == null ? void 0 : i.quickNavigateConfiguration, d.hideInput = !!d.quickNavigate && !r, (typeof (i == null ? void 0 : i.itemActivation) == "number" || i != null && i.quickNavigateConfiguration) && (d.itemActivation = (i == null ? void 0 : i.itemActivation) ?? To.SECOND), d.contextKey = o == null ? void 0 : o.contextKey, d.filterValue = (_) => _.substring(o ? o.prefix.length : 0);
    let u;
    t && (u = new lM(), h.add(J.once(d.onWillAccept)((_) => {
      _.veto(), d.hide();
    }))), h.add(this.registerPickerListeners(d, n, o, e, i));
    const f = h.add(new Wd());
    if (n && h.add(n.provide(d, f.token, i == null ? void 0 : i.providerOptions)), J.once(d.onDidHide)(() => {
      d.selectedItems.length === 0 && f.cancel(), h.dispose(), u == null || u.complete(d.selectedItems.slice(0));
    }), d.show(), l && c === e && (d.valueSelection = l), t)
      return u == null ? void 0 : u.p;
  }
  adjustValueSelection(e, t, i) {
    let n;
    i != null && i.preserveValue ? n = [e.value.length, e.value.length] : n = [(t == null ? void 0 : t.prefix.length) ?? 0, e.value.length], e.valueSelection = n;
  }
  registerPickerListeners(e, t, i, n, o) {
    const r = new he(), a = this.visibleQuickAccess = { picker: e, descriptor: i, value: n };
    return r.add(ke(() => {
      a === this.visibleQuickAccess && (this.visibleQuickAccess = void 0);
    })), r.add(e.onDidChangeValue((l) => {
      const [c] = this.getOrInstantiateProvider(l, o == null ? void 0 : o.enabledProviderPrefixes);
      c !== t ? this.show(l, {
        enabledProviderPrefixes: o == null ? void 0 : o.enabledProviderPrefixes,
        // do not rewrite value from user typing!
        preserveValue: !0,
        // persist the value of the providerOptions from the original showing
        providerOptions: o == null ? void 0 : o.providerOptions
      }) : a.value = l;
    })), i && r.add(e.onDidAccept(() => {
      this.lastAcceptedPickerValues.set(i, e.value);
    })), r;
  }
  getOrInstantiateProvider(e, t) {
    const i = this.registry.getQuickAccessProvider(e);
    if (!i || t && !(t != null && t.includes(i.prefix)))
      return [void 0, void 0];
    let n = this.mapProviderToDescriptor.get(i);
    return n || (n = this.instantiationService.createInstance(i.ctor), this.mapProviderToDescriptor.set(i, n)), [n, i];
  }
};
Ay = U$([
  bN(0, Vb),
  bN(1, ot)
], Ay);
class Hb extends ta {
  constructor(e) {
    super(), this._onChange = this._register(new O()), this.onChange = this._onChange.event, this._onKeyDown = this._register(new O()), this.onKeyDown = this._onKeyDown.event, this._opts = e, this._checked = this._opts.isChecked;
    const t = ["monaco-custom-toggle"];
    this._opts.icon && (this._icon = this._opts.icon, t.push(...Ke.asClassNameArray(this._icon))), this._opts.actionClassName && t.push(...this._opts.actionClassName.split(" ")), this._checked && t.push("checked"), this.domNode = document.createElement("div"), this._hover = this._register(Yo().setupManagedHover(e.hoverDelegate ?? Cs("mouse"), this.domNode, this._opts.title)), this.domNode.classList.add(...t), this._opts.notFocusable || (this.domNode.tabIndex = 0), this.domNode.setAttribute("role", "checkbox"), this.domNode.setAttribute("aria-checked", String(this._checked)), this.domNode.setAttribute("aria-label", this._opts.title), this.applyStyles(), this.onclick(this.domNode, (i) => {
      this.enabled && (this.checked = !this._checked, this._onChange.fire(!1), i.preventDefault());
    }), this._register(this.ignoreGesture(this.domNode)), this.onkeydown(this.domNode, (i) => {
      if (i.keyCode === 10 || i.keyCode === 3) {
        this.checked = !this._checked, this._onChange.fire(!0), i.preventDefault(), i.stopPropagation();
        return;
      }
      this._onKeyDown.fire(i);
    });
  }
  get enabled() {
    return this.domNode.getAttribute("aria-disabled") !== "true";
  }
  focus() {
    this.domNode.focus();
  }
  get checked() {
    return this._checked;
  }
  set checked(e) {
    this._checked = e, this.domNode.setAttribute("aria-checked", String(this._checked)), this.domNode.classList.toggle("checked", this._checked), this.applyStyles();
  }
  width() {
    return 22;
  }
  applyStyles() {
    this.domNode && (this.domNode.style.borderColor = this._checked && this._opts.inputActiveOptionBorder || "", this.domNode.style.color = this._checked && this._opts.inputActiveOptionForeground || "inherit", this.domNode.style.backgroundColor = this._checked && this._opts.inputActiveOptionBackground || "");
  }
  enable() {
    this.domNode.setAttribute("aria-disabled", String(!1));
  }
  disable() {
    this.domNode.setAttribute("aria-disabled", String(!0));
  }
}
var $$ = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
};
class c4 {
  constructor(e) {
    this.nodes = e;
  }
  toString() {
    return this.nodes.map((e) => typeof e == "string" ? e : e.label).join("");
  }
}
$$([
  Ht
], c4.prototype, "toString", null);
const K$ = /\[([^\]]+)\]\(((?:https?:\/\/|command:|file:)[^\)\s]+)(?: (["'])(.+?)(\3))?\)/gi;
function q$(s) {
  const e = [];
  let t = 0, i;
  for (; i = K$.exec(s); ) {
    i.index - t > 0 && e.push(s.substring(t, i.index));
    const [, n, o, , r] = i;
    r ? e.push({ label: n, href: o, title: r }) : e.push({ label: n, href: o }), t = i.index + i[0].length;
  }
  return t < s.length && e.push(s.substring(t)), new c4(e);
}
const iC = {}, j$ = new oA("quick-input-button-icon-");
function G$(s) {
  if (!s)
    return;
  let e;
  const t = s.dark.toString();
  return iC[t] ? e = iC[t] : (e = j$.nextId(), Xw(`.${e}, .hc-light .${e}`, `background-image: ${Qr(s.light || s.dark)}`), Xw(`.vs-dark .${e}, .hc-black .${e}`, `background-image: ${Qr(s.dark)}`), iC[t] = e), e;
}
function ef(s, e, t) {
  let i = s.iconClass || G$(s.iconPath);
  return s.alwaysVisible && (i = i ? `${i} always-visible` : "always-visible"), {
    id: e,
    label: "",
    tooltip: s.tooltip || "",
    class: i,
    enabled: !0,
    run: t
  };
}
function Z$(s, e, t) {
  on(e);
  const i = q$(s);
  let n = 0;
  for (const o of i.nodes)
    if (typeof o == "string")
      e.append(...Yl(o));
    else {
      let r = o.title;
      !r && o.href.startsWith("command:") ? r = p("executeCommand", "Click to execute command '{0}'", o.href.substring(8)) : r || (r = o.href);
      const a = pe("a", { href: o.href, title: r, tabIndex: n++ }, o.label);
      a.style.textDecoration = "underline";
      const l = (f) => {
        l7(f) && Be.stop(f, !0), t.callback(o.href);
      }, c = t.disposables.add(new Re(a, ee.CLICK)).event, h = t.disposables.add(new Re(a, ee.KEY_DOWN)).event, d = J.chain(h, (f) => f.filter((g) => {
        const m = new Lt(g);
        return m.equals(
          10
          /* KeyCode.Space */
        ) || m.equals(
          3
          /* KeyCode.Enter */
        );
      }));
      t.disposables.add(an.addTarget(a));
      const u = t.disposables.add(new Re(a, bt.Tap)).event;
      J.any(c, u, d)(l, null, t.disposables), e.appendChild(a);
    }
}
var Y$ = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, CN = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const h4 = "inQuickInput", Q$ = new de(h4, !1, p("inQuickInput", "Whether keyboard focus is inside the quick input control")), X$ = et.has(h4), d4 = "quickInputType", J$ = new de(d4, void 0, p("quickInputType", "The type of the currently visible quick input")), u4 = "cursorAtEndOfQuickInputBox", eK = new de(u4, !1, p("cursorAtEndOfQuickInputBox", "Whether the cursor in the quick input is at the end of the input box")), tK = et.has(u4), Py = {
  iconClass: Ke.asClassName(re.quickInputBack),
  tooltip: p("quickInput.back", "Back")
}, k1 = class k1 extends q {
  constructor(e) {
    super(), this.ui = e, this._widgetUpdated = !1, this.visible = !1, this._enabled = !0, this._busy = !1, this._ignoreFocusOut = !1, this._leftButtons = [], this._rightButtons = [], this._inlineButtons = [], this.buttonsUpdated = !1, this._toggles = [], this.togglesUpdated = !1, this.noValidationMessage = k1.noPromptMessage, this._severity = Jt.Ignore, this.onDidTriggerButtonEmitter = this._register(new O()), this.onDidHideEmitter = this._register(new O()), this.onWillHideEmitter = this._register(new O()), this.onDisposeEmitter = this._register(new O()), this.visibleDisposables = this._register(new he()), this.onDidHide = this.onDidHideEmitter.event;
  }
  get title() {
    return this._title;
  }
  set title(e) {
    this._title = e, this.update();
  }
  get description() {
    return this._description;
  }
  set description(e) {
    this._description = e, this.update();
  }
  get step() {
    return this._steps;
  }
  set step(e) {
    this._steps = e, this.update();
  }
  get totalSteps() {
    return this._totalSteps;
  }
  set totalSteps(e) {
    this._totalSteps = e, this.update();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    this._enabled = e, this.update();
  }
  get contextKey() {
    return this._contextKey;
  }
  set contextKey(e) {
    this._contextKey = e, this.update();
  }
  get busy() {
    return this._busy;
  }
  set busy(e) {
    this._busy = e, this.update();
  }
  get ignoreFocusOut() {
    return this._ignoreFocusOut;
  }
  set ignoreFocusOut(e) {
    const t = this._ignoreFocusOut !== e && !fc;
    this._ignoreFocusOut = e && !fc, t && this.update();
  }
  get titleButtons() {
    return this._leftButtons.length ? [...this._leftButtons, this._rightButtons] : this._rightButtons;
  }
  get buttons() {
    return [
      ...this._leftButtons,
      ...this._rightButtons,
      ...this._inlineButtons
    ];
  }
  set buttons(e) {
    this._leftButtons = e.filter((t) => t === Py), this._rightButtons = e.filter((t) => t !== Py && t.location !== f_.Inline), this._inlineButtons = e.filter((t) => t.location === f_.Inline), this.buttonsUpdated = !0, this.update();
  }
  get toggles() {
    return this._toggles;
  }
  set toggles(e) {
    this._toggles = e ?? [], this.togglesUpdated = !0, this.update();
  }
  get validationMessage() {
    return this._validationMessage;
  }
  set validationMessage(e) {
    this._validationMessage = e, this.update();
  }
  get severity() {
    return this._severity;
  }
  set severity(e) {
    this._severity = e, this.update();
  }
  show() {
    this.visible || (this.visibleDisposables.add(this.ui.onDidTriggerButton((e) => {
      this.buttons.indexOf(e) !== -1 && this.onDidTriggerButtonEmitter.fire(e);
    })), this.ui.show(this), this.visible = !0, this._lastValidationMessage = void 0, this._lastSeverity = void 0, this.buttons.length && (this.buttonsUpdated = !0), this.toggles.length && (this.togglesUpdated = !0), this.update());
  }
  hide() {
    this.visible && this.ui.hide();
  }
  didHide(e = Td.Other) {
    this.visible = !1, this.visibleDisposables.clear(), this.onDidHideEmitter.fire({ reason: e });
  }
  willHide(e = Td.Other) {
    this.onWillHideEmitter.fire({ reason: e });
  }
  update() {
    var n;
    if (!this.visible)
      return;
    const e = this.getTitle();
    e && this.ui.title.textContent !== e ? this.ui.title.textContent = e : !e && this.ui.title.innerHTML !== "&nbsp;" && (this.ui.title.innerText = " ");
    const t = this.getDescription();
    if (this.ui.description1.textContent !== t && (this.ui.description1.textContent = t), this.ui.description2.textContent !== t && (this.ui.description2.textContent = t), this._widgetUpdated && (this._widgetUpdated = !1, this._widget ? on(this.ui.widget, this._widget) : on(this.ui.widget)), this.busy && !this.busyDelay && (this.busyDelay = new Ic(), this.busyDelay.setIfNotSet(() => {
      this.visible && this.ui.progressBar.infinite();
    }, 800)), !this.busy && this.busyDelay && (this.ui.progressBar.stop(), this.busyDelay.cancel(), this.busyDelay = void 0), this.buttonsUpdated) {
      this.buttonsUpdated = !1, this.ui.leftActionBar.clear();
      const o = this._leftButtons.map((l, c) => ef(l, `id-${c}`, async () => this.onDidTriggerButtonEmitter.fire(l)));
      this.ui.leftActionBar.push(o, { icon: !0, label: !1 }), this.ui.rightActionBar.clear();
      const r = this._rightButtons.map((l, c) => ef(l, `id-${c}`, async () => this.onDidTriggerButtonEmitter.fire(l)));
      this.ui.rightActionBar.push(r, { icon: !0, label: !1 }), this.ui.inlineActionBar.clear();
      const a = this._inlineButtons.map((l, c) => ef(l, `id-${c}`, async () => this.onDidTriggerButtonEmitter.fire(l)));
      this.ui.inlineActionBar.push(a, { icon: !0, label: !1 });
    }
    if (this.togglesUpdated) {
      this.togglesUpdated = !1;
      const o = ((n = this.toggles) == null ? void 0 : n.filter((r) => r instanceof Hb)) ?? [];
      this.ui.inputBox.toggles = o;
    }
    this.ui.ignoreFocusOut = this.ignoreFocusOut, this.ui.setEnabled(this.enabled), this.ui.setContextKey(this.contextKey);
    const i = this.validationMessage || this.noValidationMessage;
    this._lastValidationMessage !== i && (this._lastValidationMessage = i, on(this.ui.message), Z$(i, this.ui.message, {
      callback: (o) => {
        this.ui.linkOpenerDelegate(o);
      },
      disposables: this.visibleDisposables
    })), this._lastSeverity !== this.severity && (this._lastSeverity = this.severity, this.showMessageDecoration(this.severity));
  }
  getTitle() {
    return this.title && this.step ? `${this.title} (${this.getSteps()})` : this.title ? this.title : this.step ? this.getSteps() : "";
  }
  getDescription() {
    return this.description || "";
  }
  getSteps() {
    return this.step && this.totalSteps ? p("quickInput.steps", "{0}/{1}", this.step, this.totalSteps) : this.step ? String(this.step) : "";
  }
  showMessageDecoration(e) {
    if (this.ui.inputBox.showDecoration(e), e !== Jt.Ignore) {
      const t = this.ui.inputBox.stylesForType(e);
      this.ui.message.style.color = t.foreground ? `${t.foreground}` : "", this.ui.message.style.backgroundColor = t.background ? `${t.background}` : "", this.ui.message.style.border = t.border ? `1px solid ${t.border}` : "", this.ui.message.style.marginBottom = "-2px";
    } else
      this.ui.message.style.color = "", this.ui.message.style.backgroundColor = "", this.ui.message.style.border = "", this.ui.message.style.marginBottom = "";
  }
  dispose() {
    this.hide(), this.onDisposeEmitter.fire(), super.dispose();
  }
};
k1.noPromptMessage = p("inputModeEntry", "Press 'Enter' to confirm your input or 'Escape' to cancel");
let g_ = k1;
const x1 = class x1 extends g_ {
  constructor() {
    super(...arguments), this._value = "", this.onDidChangeValueEmitter = this._register(new O()), this.onWillAcceptEmitter = this._register(new O()), this.onDidAcceptEmitter = this._register(new O()), this.onDidCustomEmitter = this._register(new O()), this._items = [], this.itemsUpdated = !1, this._canSelectMany = !1, this._canAcceptInBackground = !1, this._matchOnDescription = !1, this._matchOnDetail = !1, this._matchOnLabel = !0, this._matchOnLabelMode = "fuzzy", this._sortByLabel = !0, this._keepScrollPosition = !1, this._itemActivation = To.FIRST, this._activeItems = [], this.activeItemsUpdated = !1, this.activeItemsToConfirm = [], this.onDidChangeActiveEmitter = this._register(new O()), this._selectedItems = [], this.selectedItemsUpdated = !1, this.selectedItemsToConfirm = [], this.onDidChangeSelectionEmitter = this._register(new O()), this.onDidTriggerItemButtonEmitter = this._register(new O()), this.onDidTriggerSeparatorButtonEmitter = this._register(new O()), this.valueSelectionUpdated = !0, this._ok = "default", this._customButton = !1, this._focusEventBufferer = new yg(), this.type = "quickPick", this.filterValue = (e) => e, this.onDidChangeValue = this.onDidChangeValueEmitter.event, this.onWillAccept = this.onWillAcceptEmitter.event, this.onDidAccept = this.onDidAcceptEmitter.event, this.onDidChangeActive = this.onDidChangeActiveEmitter.event, this.onDidChangeSelection = this.onDidChangeSelectionEmitter.event, this.onDidTriggerItemButton = this.onDidTriggerItemButtonEmitter.event, this.onDidTriggerSeparatorButton = this.onDidTriggerSeparatorButtonEmitter.event;
  }
  get quickNavigate() {
    return this._quickNavigate;
  }
  set quickNavigate(e) {
    this._quickNavigate = e, this.update();
  }
  get value() {
    return this._value;
  }
  set value(e) {
    this.doSetValue(e);
  }
  doSetValue(e, t) {
    this._value !== e && (this._value = e, t || this.update(), this.visible && this.ui.list.filter(this.filterValue(this._value)) && this.trySelectFirst(), this.onDidChangeValueEmitter.fire(this._value));
  }
  set ariaLabel(e) {
    this._ariaLabel = e, this.update();
  }
  get ariaLabel() {
    return this._ariaLabel;
  }
  get placeholder() {
    return this._placeholder;
  }
  set placeholder(e) {
    this._placeholder = e, this.update();
  }
  get items() {
    return this._items;
  }
  get scrollTop() {
    return this.ui.list.scrollTop;
  }
  set scrollTop(e) {
    this.ui.list.scrollTop = e;
  }
  set items(e) {
    this._items = e, this.itemsUpdated = !0, this.update();
  }
  get canSelectMany() {
    return this._canSelectMany;
  }
  set canSelectMany(e) {
    this._canSelectMany = e, this.update();
  }
  get canAcceptInBackground() {
    return this._canAcceptInBackground;
  }
  set canAcceptInBackground(e) {
    this._canAcceptInBackground = e;
  }
  get matchOnDescription() {
    return this._matchOnDescription;
  }
  set matchOnDescription(e) {
    this._matchOnDescription = e, this.update();
  }
  get matchOnDetail() {
    return this._matchOnDetail;
  }
  set matchOnDetail(e) {
    this._matchOnDetail = e, this.update();
  }
  get matchOnLabel() {
    return this._matchOnLabel;
  }
  set matchOnLabel(e) {
    this._matchOnLabel = e, this.update();
  }
  get matchOnLabelMode() {
    return this._matchOnLabelMode;
  }
  set matchOnLabelMode(e) {
    this._matchOnLabelMode = e, this.update();
  }
  get sortByLabel() {
    return this._sortByLabel;
  }
  set sortByLabel(e) {
    this._sortByLabel = e, this.update();
  }
  get keepScrollPosition() {
    return this._keepScrollPosition;
  }
  set keepScrollPosition(e) {
    this._keepScrollPosition = e;
  }
  get itemActivation() {
    return this._itemActivation;
  }
  set itemActivation(e) {
    this._itemActivation = e;
  }
  get activeItems() {
    return this._activeItems;
  }
  set activeItems(e) {
    this._activeItems = e, this.activeItemsUpdated = !0, this.update();
  }
  get selectedItems() {
    return this._selectedItems;
  }
  set selectedItems(e) {
    this._selectedItems = e, this.selectedItemsUpdated = !0, this.update();
  }
  get keyMods() {
    return this._quickNavigate ? z$ : this.ui.keyMods;
  }
  get valueSelection() {
    const e = this.ui.inputBox.getSelection();
    if (e)
      return [e.start, e.end];
  }
  set valueSelection(e) {
    this._valueSelection = e, this.valueSelectionUpdated = !0, this.update();
  }
  get customButton() {
    return this._customButton;
  }
  set customButton(e) {
    this._customButton = e, this.update();
  }
  get customLabel() {
    return this._customButtonLabel;
  }
  set customLabel(e) {
    this._customButtonLabel = e, this.update();
  }
  get customHover() {
    return this._customButtonHover;
  }
  set customHover(e) {
    this._customButtonHover = e, this.update();
  }
  get ok() {
    return this._ok;
  }
  set ok(e) {
    this._ok = e, this.update();
  }
  get hideInput() {
    return !!this._hideInput;
  }
  set hideInput(e) {
    this._hideInput = e, this.update();
  }
  trySelectFirst() {
    this.canSelectMany || this.ui.list.focus(_t.First);
  }
  show() {
    this.visible || (this.visibleDisposables.add(this.ui.inputBox.onDidChange((e) => {
      this.doSetValue(
        e,
        !0
        /* skip update since this originates from the UI */
      );
    })), this.visibleDisposables.add(this.ui.onDidAccept(() => {
      this.canSelectMany ? this.ui.list.getCheckedElements().length || (this._selectedItems = [], this.onDidChangeSelectionEmitter.fire(this.selectedItems)) : this.activeItems[0] && (this._selectedItems = [this.activeItems[0]], this.onDidChangeSelectionEmitter.fire(this.selectedItems)), this.handleAccept(!1);
    })), this.visibleDisposables.add(this.ui.onDidCustom(() => {
      this.onDidCustomEmitter.fire();
    })), this.visibleDisposables.add(this._focusEventBufferer.wrapEvent(
      this.ui.list.onDidChangeFocus,
      // Only fire the last event
      (e, t) => t
    )((e) => {
      this.activeItemsUpdated || this.activeItemsToConfirm !== this._activeItems && oi(e, this._activeItems, (t, i) => t === i) || (this._activeItems = e, this.onDidChangeActiveEmitter.fire(e));
    })), this.visibleDisposables.add(this.ui.list.onDidChangeSelection(({ items: e, event: t }) => {
      if (this.canSelectMany) {
        e.length && this.ui.list.setSelectedElements([]);
        return;
      }
      this.selectedItemsToConfirm !== this._selectedItems && oi(e, this._selectedItems, (i, n) => i === n) || (this._selectedItems = e, this.onDidChangeSelectionEmitter.fire(e), e.length && this.handleAccept(
        UL(t) && t.button === 1
        /* mouse middle click */
      ));
    })), this.visibleDisposables.add(this.ui.list.onChangedCheckedElements((e) => {
      !this.canSelectMany || !this.visible || this.selectedItemsToConfirm !== this._selectedItems && oi(e, this._selectedItems, (t, i) => t === i) || (this._selectedItems = e, this.onDidChangeSelectionEmitter.fire(e));
    })), this.visibleDisposables.add(this.ui.list.onButtonTriggered((e) => this.onDidTriggerItemButtonEmitter.fire(e))), this.visibleDisposables.add(this.ui.list.onSeparatorButtonTriggered((e) => this.onDidTriggerSeparatorButtonEmitter.fire(e))), this.visibleDisposables.add(this.registerQuickNavigation()), this.valueSelectionUpdated = !0), super.show();
  }
  handleAccept(e) {
    let t = !1;
    this.onWillAcceptEmitter.fire({ veto: () => t = !0 }), t || this.onDidAcceptEmitter.fire({ inBackground: e });
  }
  registerQuickNavigation() {
    return $(this.ui.container, ee.KEY_UP, (e) => {
      if (this.canSelectMany || !this._quickNavigate)
        return;
      const t = new Lt(e), i = t.keyCode;
      this._quickNavigate.keybindings.some((r) => {
        const a = r.getChords();
        return a.length > 1 ? !1 : a[0].shiftKey && i === 4 ? !(t.ctrlKey || t.altKey || t.metaKey) : !!(a[0].altKey && i === 6 || a[0].ctrlKey && i === 5 || a[0].metaKey && i === 57);
      }) && (this.activeItems[0] && (this._selectedItems = [this.activeItems[0]], this.onDidChangeSelectionEmitter.fire(this.selectedItems), this.handleAccept(!1)), this._quickNavigate = void 0);
    });
  }
  update() {
    if (!this.visible)
      return;
    const e = this.keepScrollPosition ? this.scrollTop : 0, t = !!this.description, i = {
      title: !!this.title || !!this.step || !!this.titleButtons.length,
      description: t,
      checkAll: this.canSelectMany && !this._hideCheckAll,
      checkBox: this.canSelectMany,
      inputBox: !this._hideInput,
      progressBar: !this._hideInput || t,
      visibleCount: !0,
      count: this.canSelectMany && !this._hideCountBadge,
      ok: this.ok === "default" ? this.canSelectMany : this.ok,
      list: !0,
      message: !!this.validationMessage,
      customButton: this.customButton
    };
    this.ui.setVisibilities(i), super.update(), this.ui.inputBox.value !== this.value && (this.ui.inputBox.value = this.value), this.valueSelectionUpdated && (this.valueSelectionUpdated = !1, this.ui.inputBox.select(this._valueSelection && { start: this._valueSelection[0], end: this._valueSelection[1] })), this.ui.inputBox.placeholder !== (this.placeholder || "") && (this.ui.inputBox.placeholder = this.placeholder || "");
    let n = this.ariaLabel;
    !n && i.inputBox && (n = this.placeholder || x1.DEFAULT_ARIA_LABEL, this.title && (n += ` - ${this.title}`)), this.ui.list.ariaLabel !== n && (this.ui.list.ariaLabel = n ?? null), this.ui.list.matchOnDescription = this.matchOnDescription, this.ui.list.matchOnDetail = this.matchOnDetail, this.ui.list.matchOnLabel = this.matchOnLabel, this.ui.list.matchOnLabelMode = this.matchOnLabelMode, this.ui.list.sortByLabel = this.sortByLabel, this.itemsUpdated && (this.itemsUpdated = !1, this._focusEventBufferer.bufferEvents(() => {
      switch (this.ui.list.setElements(this.items), this.ui.list.shouldLoop = !this.canSelectMany, this.ui.list.filter(this.filterValue(this.ui.inputBox.value)), this._itemActivation) {
        case To.NONE:
          this._itemActivation = To.FIRST;
          break;
        case To.SECOND:
          this.ui.list.focus(_t.Second), this._itemActivation = To.FIRST;
          break;
        case To.LAST:
          this.ui.list.focus(_t.Last), this._itemActivation = To.FIRST;
          break;
        default:
          this.trySelectFirst();
          break;
      }
    })), this.ui.container.classList.contains("show-checkboxes") !== !!this.canSelectMany && (this.canSelectMany ? this.ui.list.clearFocus() : this.trySelectFirst()), this.activeItemsUpdated && (this.activeItemsUpdated = !1, this.activeItemsToConfirm = this._activeItems, this.ui.list.setFocusedElements(this.activeItems), this.activeItemsToConfirm === this._activeItems && (this.activeItemsToConfirm = null)), this.selectedItemsUpdated && (this.selectedItemsUpdated = !1, this.selectedItemsToConfirm = this._selectedItems, this.canSelectMany ? this.ui.list.setCheckedElements(this.selectedItems) : this.ui.list.setSelectedElements(this.selectedItems), this.selectedItemsToConfirm === this._selectedItems && (this.selectedItemsToConfirm = null)), this.ui.customButton.label = this.customLabel || "", this.ui.customButton.element.title = this.customHover || "", i.inputBox || (this.ui.list.domFocus(), this.canSelectMany && this.ui.list.focus(_t.First)), this.keepScrollPosition && (this.scrollTop = e);
  }
  focus(e) {
    this.ui.list.focus(e), this.canSelectMany && this.ui.list.domFocus();
  }
  accept(e) {
    e && !this._canAcceptInBackground || this.activeItems[0] && (this._selectedItems = [this.activeItems[0]], this.onDidChangeSelectionEmitter.fire(this.selectedItems), this.handleAccept(e ?? !1));
  }
};
x1.DEFAULT_ARIA_LABEL = p("quickInputBox.ariaLabel", "Type to narrow down results.");
let m_ = x1, iK = class extends g_ {
  constructor() {
    super(...arguments), this._value = "", this.valueSelectionUpdated = !0, this._password = !1, this.onDidValueChangeEmitter = this._register(new O()), this.onDidAcceptEmitter = this._register(new O()), this.type = "inputBox", this.onDidChangeValue = this.onDidValueChangeEmitter.event, this.onDidAccept = this.onDidAcceptEmitter.event;
  }
  get value() {
    return this._value;
  }
  set value(e) {
    this._value = e || "", this.update();
  }
  get placeholder() {
    return this._placeholder;
  }
  set placeholder(e) {
    this._placeholder = e, this.update();
  }
  get password() {
    return this._password;
  }
  set password(e) {
    this._password = e, this.update();
  }
  show() {
    this.visible || (this.visibleDisposables.add(this.ui.inputBox.onDidChange((e) => {
      e !== this.value && (this._value = e, this.onDidValueChangeEmitter.fire(e));
    })), this.visibleDisposables.add(this.ui.onDidAccept(() => this.onDidAcceptEmitter.fire())), this.valueSelectionUpdated = !0), super.show();
  }
  update() {
    if (!this.visible)
      return;
    this.ui.container.classList.remove("hidden-input");
    const e = {
      title: !!this.title || !!this.step || !!this.titleButtons.length,
      description: !!this.description || !!this.step,
      inputBox: !0,
      message: !0,
      progressBar: !0
    };
    this.ui.setVisibilities(e), super.update(), this.ui.inputBox.value !== this.value && (this.ui.inputBox.value = this.value), this.valueSelectionUpdated && (this.valueSelectionUpdated = !1, this.ui.inputBox.select(this._valueSelection && { start: this._valueSelection[0], end: this._valueSelection[1] })), this.ui.inputBox.placeholder !== (this.placeholder || "") && (this.ui.inputBox.placeholder = this.placeholder || ""), this.ui.inputBox.password !== this.password && (this.ui.inputBox.password = this.password);
  }
}, Oy = class extends Kf {
  constructor(e, t) {
    super("element", !1, (i) => this.getOverrideOptions(i), e, t);
  }
  getOverrideOptions(e) {
    const t = (yi(e.content) ? e.content.textContent ?? "" : typeof e.content == "string" ? e.content : e.content.value).includes(`
`);
    return {
      persistence: {
        hideOnKeyDown: !1
      },
      appearance: {
        showHoverHint: t,
        skipFadeInAnimation: !0
      }
    };
  }
};
Oy = Y$([
  CN(0, Vt),
  CN(1, Ag)
], Oy);
Z.white.toString(), Z.white.toString();
class Fy extends q {
  get onDidClick() {
    return this._onDidClick.event;
  }
  constructor(e, t) {
    super(), this._label = "", this._onDidClick = this._register(new O()), this._onDidEscape = this._register(new O()), this.options = t, this._element = document.createElement("a"), this._element.classList.add("monaco-button"), this._element.tabIndex = 0, this._element.setAttribute("role", "button"), this._element.classList.toggle("secondary", !!t.secondary);
    const i = t.secondary ? t.buttonSecondaryBackground : t.buttonBackground, n = t.secondary ? t.buttonSecondaryForeground : t.buttonForeground;
    this._element.style.color = n || "", this._element.style.backgroundColor = i || "", t.supportShortLabel && (this._labelShortElement = document.createElement("div"), this._labelShortElement.classList.add("monaco-button-label-short"), this._element.appendChild(this._labelShortElement), this._labelElement = document.createElement("div"), this._labelElement.classList.add("monaco-button-label"), this._element.appendChild(this._labelElement), this._element.classList.add("monaco-text-button-with-short-label")), typeof t.title == "string" && this.setTitle(t.title), typeof t.ariaLabel == "string" && this._element.setAttribute("aria-label", t.ariaLabel), e.appendChild(this._element), this._register(an.addTarget(this._element)), [ee.CLICK, bt.Tap].forEach((o) => {
      this._register($(this._element, o, (r) => {
        if (!this.enabled) {
          Be.stop(r);
          return;
        }
        this._onDidClick.fire(r);
      }));
    }), this._register($(this._element, ee.KEY_DOWN, (o) => {
      const r = new Lt(o);
      let a = !1;
      this.enabled && (r.equals(
        3
        /* KeyCode.Enter */
      ) || r.equals(
        10
        /* KeyCode.Space */
      )) ? (this._onDidClick.fire(o), a = !0) : r.equals(
        9
        /* KeyCode.Escape */
      ) && (this._onDidEscape.fire(o), this._element.blur(), a = !0), a && Be.stop(r, !0);
    })), this._register($(this._element, ee.MOUSE_OVER, (o) => {
      this._element.classList.contains("disabled") || this.updateBackground(!0);
    })), this._register($(this._element, ee.MOUSE_OUT, (o) => {
      this.updateBackground(!1);
    })), this.focusTracker = this._register(Ff(this._element)), this._register(this.focusTracker.onDidFocus(() => {
      this.enabled && this.updateBackground(!0);
    })), this._register(this.focusTracker.onDidBlur(() => {
      this.enabled && this.updateBackground(!1);
    }));
  }
  dispose() {
    super.dispose(), this._element.remove();
  }
  getContentElements(e) {
    const t = [];
    for (let i of Yl(e))
      if (typeof i == "string") {
        if (i = i.trim(), i === "")
          continue;
        const n = document.createElement("span");
        n.textContent = i, t.push(n);
      } else
        t.push(i);
    return t;
  }
  updateBackground(e) {
    let t;
    this.options.secondary ? t = e ? this.options.buttonSecondaryHoverBackground : this.options.buttonSecondaryBackground : t = e ? this.options.buttonHoverBackground : this.options.buttonBackground, t && (this._element.style.backgroundColor = t);
  }
  get element() {
    return this._element;
  }
  set label(e) {
    var n;
    if (this._label === e || Yh(this._label) && Yh(e) && DW(this._label, e))
      return;
    this._element.classList.add("monaco-text-button");
    const t = this.options.supportShortLabel ? this._labelElement : this._element;
    if (Yh(e)) {
      const o = vk(e, { inline: !0 });
      o.dispose();
      const r = (n = o.element.querySelector("p")) == null ? void 0 : n.innerHTML;
      if (r) {
        const a = gM(r, { ADD_TAGS: ["b", "i", "u", "code", "span"], ALLOWED_ATTR: ["class"], RETURN_TRUSTED_TYPE: !0 });
        t.innerHTML = a;
      } else
        on(t);
    } else
      this.options.supportIcons ? on(t, ...this.getContentElements(e)) : t.textContent = e;
    let i = "";
    typeof this.options.title == "string" ? i = this.options.title : this.options.title && (i = BW(e)), this.setTitle(i), typeof this.options.ariaLabel == "string" ? this._element.setAttribute("aria-label", this.options.ariaLabel) : this.options.ariaLabel && this._element.setAttribute("aria-label", i), this._label = e;
  }
  get label() {
    return this._label;
  }
  set icon(e) {
    this._element.classList.add(...Ke.asClassNameArray(e));
  }
  set enabled(e) {
    e ? (this._element.classList.remove("disabled"), this._element.setAttribute("aria-disabled", String(!1)), this._element.tabIndex = 0) : (this._element.classList.add("disabled"), this._element.setAttribute("aria-disabled", String(!0)));
  }
  get enabled() {
    return !this._element.classList.contains("disabled");
  }
  setTitle(e) {
    !this._hover && e !== "" ? this._hover = this._register(Yo().setupManagedHover(this.options.hoverDelegate ?? Cs("mouse"), this._element, e)) : this._hover && this._hover.update(e);
  }
}
class wN {
  constructor(e, t, i) {
    this.options = t, this.styles = i, this.count = 0, this.element = ae(e, pe(".monaco-count-badge")), this.countFormat = this.options.countFormat || "{0}", this.titleFormat = this.options.titleFormat || "", this.setCount(this.options.count || 0);
  }
  setCount(e) {
    this.count = e, this.render();
  }
  setTitleFormat(e) {
    this.titleFormat = e, this.render();
  }
  render() {
    this.element.textContent = Pw(this.countFormat, this.count), this.element.title = Pw(this.titleFormat, this.count), this.element.style.backgroundColor = this.styles.badgeBackground ?? "", this.element.style.color = this.styles.badgeForeground ?? "", this.styles.badgeBorder && (this.element.style.border = `1px solid ${this.styles.badgeBorder}`);
  }
}
const vN = "done", yN = "active", nC = "infinite", sC = "infinite-long-running", SN = "discrete", D1 = class D1 extends q {
  constructor(e, t) {
    super(), this.progressSignal = this._register(new Zr()), this.workedVal = 0, this.showDelayedScheduler = this._register(new sn(() => xM(this.element), 0)), this.longRunningScheduler = this._register(new sn(() => this.infiniteLongRunning(), D1.LONG_RUNNING_INFINITE_THRESHOLD)), this.create(e, t);
  }
  create(e, t) {
    this.element = document.createElement("div"), this.element.classList.add("monaco-progress-container"), this.element.setAttribute("role", "progressbar"), this.element.setAttribute("aria-valuemin", "0"), e.appendChild(this.element), this.bit = document.createElement("div"), this.bit.classList.add("progress-bit"), this.bit.style.backgroundColor = (t == null ? void 0 : t.progressBarBackground) || "#0E70C0", this.element.appendChild(this.bit);
  }
  off() {
    this.bit.style.width = "inherit", this.bit.style.opacity = "1", this.element.classList.remove(yN, nC, sC, SN), this.workedVal = 0, this.totalWork = void 0, this.longRunningScheduler.cancel(), this.progressSignal.clear();
  }
  /**
   * Stops the progressbar from showing any progress instantly without fading out.
   */
  stop() {
    return this.doDone(!1);
  }
  doDone(e) {
    return this.element.classList.add(vN), this.element.classList.contains(nC) ? (this.bit.style.opacity = "0", e ? setTimeout(() => this.off(), 200) : this.off()) : (this.bit.style.width = "inherit", e ? setTimeout(() => this.off(), 200) : this.off()), this;
  }
  /**
   * Use this mode to indicate progress that has no total number of work units.
   */
  infinite() {
    return this.bit.style.width = "2%", this.bit.style.opacity = "1", this.element.classList.remove(SN, vN, sC), this.element.classList.add(yN, nC), this.longRunningScheduler.schedule(), this;
  }
  infiniteLongRunning() {
    this.element.classList.add(sC);
  }
  getContainer() {
    return this.element;
  }
};
D1.LONG_RUNNING_INFINITE_THRESHOLD = 1e4;
let By = D1;
const nK = p("caseDescription", "Match Case"), sK = p("wordsDescription", "Match Whole Word"), oK = p("regexDescription", "Use Regular Expression");
class rK extends Hb {
  constructor(e) {
    super({
      icon: re.caseSensitive,
      title: nK + e.appendTitle,
      isChecked: e.isChecked,
      hoverDelegate: e.hoverDelegate ?? Cs("element"),
      inputActiveOptionBorder: e.inputActiveOptionBorder,
      inputActiveOptionForeground: e.inputActiveOptionForeground,
      inputActiveOptionBackground: e.inputActiveOptionBackground
    });
  }
}
class aK extends Hb {
  constructor(e) {
    super({
      icon: re.wholeWord,
      title: sK + e.appendTitle,
      isChecked: e.isChecked,
      hoverDelegate: e.hoverDelegate ?? Cs("element"),
      inputActiveOptionBorder: e.inputActiveOptionBorder,
      inputActiveOptionForeground: e.inputActiveOptionForeground,
      inputActiveOptionBackground: e.inputActiveOptionBackground
    });
  }
}
class lK extends Hb {
  constructor(e) {
    super({
      icon: re.regex,
      title: oK + e.appendTitle,
      isChecked: e.isChecked,
      hoverDelegate: e.hoverDelegate ?? Cs("element"),
      inputActiveOptionBorder: e.inputActiveOptionBorder,
      inputActiveOptionForeground: e.inputActiveOptionForeground,
      inputActiveOptionBackground: e.inputActiveOptionBackground
    });
  }
}
class cK {
  constructor(e, t = 0, i = e.length, n = t - 1) {
    this.items = e, this.start = t, this.end = i, this.index = n;
  }
  current() {
    return this.index === this.start - 1 || this.index === this.end ? null : this.items[this.index];
  }
  next() {
    return this.index = Math.min(this.index + 1, this.end), this.current();
  }
  previous() {
    return this.index = Math.max(this.index - 1, this.start - 1), this.current();
  }
  first() {
    return this.index = this.start, this.current();
  }
  last() {
    return this.index = this.end - 1, this.current();
  }
}
class hK {
  constructor(e = [], t = 10) {
    this._initialize(e), this._limit = t, this._onChange();
  }
  getHistory() {
    return this._elements;
  }
  add(e) {
    this._history.delete(e), this._history.add(e), this._onChange();
  }
  next() {
    return this._navigator.next();
  }
  previous() {
    return this._currentPosition() !== 0 ? this._navigator.previous() : null;
  }
  current() {
    return this._navigator.current();
  }
  first() {
    return this._navigator.first();
  }
  last() {
    return this._navigator.last();
  }
  isLast() {
    return this._currentPosition() >= this._elements.length - 1;
  }
  isNowhere() {
    return this._navigator.current() === null;
  }
  has(e) {
    return this._history.has(e);
  }
  _onChange() {
    this._reduceToLimit();
    const e = this._elements;
    this._navigator = new cK(e, 0, e.length, e.length);
  }
  _reduceToLimit() {
    const e = this._elements;
    e.length > this._limit && this._initialize(e.slice(e.length - this._limit));
  }
  _currentPosition() {
    const e = this._navigator.current();
    return e ? this._elements.indexOf(e) : -1;
  }
  _initialize(e) {
    this._history = /* @__PURE__ */ new Set();
    for (const t of e)
      this._history.add(t);
  }
  get _elements() {
    const e = [];
    return this._history.forEach((t) => e.push(t)), e;
  }
}
const _u = pe;
class dK extends ta {
  constructor(e, t, i) {
    super(), this.state = "idle", this.maxHeight = Number.POSITIVE_INFINITY, this._onDidChange = this._register(new O()), this.onDidChange = this._onDidChange.event, this._onDidHeightChange = this._register(new O()), this.onDidHeightChange = this._onDidHeightChange.event, this.contextViewProvider = t, this.options = i, this.message = null, this.placeholder = this.options.placeholder || "", this.tooltip = this.options.tooltip ?? (this.placeholder || ""), this.ariaLabel = this.options.ariaLabel || "", this.options.validationOptions && (this.validation = this.options.validationOptions.validation), this.element = ae(e, _u(".monaco-inputbox.idle"));
    const n = this.options.flexibleHeight ? "textarea" : "input", o = ae(this.element, _u(".ibwrapper"));
    if (this.input = ae(o, _u(n + ".input.empty")), this.input.setAttribute("autocorrect", "off"), this.input.setAttribute("autocapitalize", "off"), this.input.setAttribute("spellcheck", "false"), this.onfocus(this.input, () => this.element.classList.add("synthetic-focus")), this.onblur(this.input, () => this.element.classList.remove("synthetic-focus")), this.options.flexibleHeight) {
      this.maxHeight = typeof this.options.flexibleMaxHeight == "number" ? this.options.flexibleMaxHeight : Number.POSITIVE_INFINITY, this.mirror = ae(o, _u("div.mirror")), this.mirror.innerText = " ", this.scrollableElement = new zB(this.element, {
        vertical: 1
        /* ScrollbarVisibility.Auto */
      }), this.options.flexibleWidth && (this.input.setAttribute("wrap", "off"), this.mirror.style.whiteSpace = "pre", this.mirror.style.wordWrap = "initial"), ae(e, this.scrollableElement.getDomNode()), this._register(this.scrollableElement), this._register(this.scrollableElement.onScroll((l) => this.input.scrollTop = l.scrollTop));
      const r = this._register(new Re(e.ownerDocument, "selectionchange")), a = J.filter(r.event, () => {
        const l = e.ownerDocument.getSelection();
        return (l == null ? void 0 : l.anchorNode) === o;
      });
      this._register(a(this.updateScrollDimensions, this)), this._register(this.onDidHeightChange(this.updateScrollDimensions, this));
    } else
      this.input.type = this.options.type || "text", this.input.setAttribute("wrap", "off");
    this.ariaLabel && this.input.setAttribute("aria-label", this.ariaLabel), this.placeholder && !this.options.showPlaceholderOnFocus && this.setPlaceHolder(this.placeholder), this.tooltip && this.setTooltip(this.tooltip), this.oninput(this.input, () => this.onValueChange()), this.onblur(this.input, () => this.onBlur()), this.onfocus(this.input, () => this.onFocus()), this._register(this.ignoreGesture(this.input)), setTimeout(() => this.updateMirror(), 0), this.options.actions && (this.actionbar = this._register(new Kr(this.element)), this.actionbar.push(this.options.actions, { icon: !0, label: !1 })), this.applyStyles();
  }
  onBlur() {
    this._hideMessage(), this.options.showPlaceholderOnFocus && this.input.setAttribute("placeholder", "");
  }
  onFocus() {
    this._showMessage(), this.options.showPlaceholderOnFocus && this.input.setAttribute("placeholder", this.placeholder || "");
  }
  setPlaceHolder(e) {
    this.placeholder = e, this.input.setAttribute("placeholder", e);
  }
  setTooltip(e) {
    this.tooltip = e, this.hover ? this.hover.update(e) : this.hover = this._register(Yo().setupManagedHover(Cs("mouse"), this.input, e));
  }
  get inputElement() {
    return this.input;
  }
  get value() {
    return this.input.value;
  }
  set value(e) {
    this.input.value !== e && (this.input.value = e, this.onValueChange());
  }
  get height() {
    return typeof this.cachedHeight == "number" ? this.cachedHeight : Yw(this.element);
  }
  focus() {
    this.input.focus();
  }
  blur() {
    this.input.blur();
  }
  hasFocus() {
    return HL(this.input);
  }
  select(e = null) {
    this.input.select(), e && (this.input.setSelectionRange(e.start, e.end), e.end === this.input.value.length && (this.input.scrollLeft = this.input.scrollWidth));
  }
  isSelectionAtEnd() {
    return this.input.selectionEnd === this.input.value.length && this.input.selectionStart === this.input.selectionEnd;
  }
  getSelection() {
    const e = this.input.selectionStart;
    if (e === null)
      return null;
    const t = this.input.selectionEnd ?? e;
    return {
      start: e,
      end: t
    };
  }
  enable() {
    this.input.removeAttribute("disabled");
  }
  disable() {
    this.blur(), this.input.disabled = !0, this._hideMessage();
  }
  set paddingRight(e) {
    this.input.style.width = `calc(100% - ${e}px)`, this.mirror && (this.mirror.style.paddingRight = e + "px");
  }
  updateScrollDimensions() {
    if (typeof this.cachedContentHeight != "number" || typeof this.cachedHeight != "number" || !this.scrollableElement)
      return;
    const e = this.cachedContentHeight, t = this.cachedHeight, i = this.input.scrollTop;
    this.scrollableElement.setScrollDimensions({ scrollHeight: e, height: t }), this.scrollableElement.setScrollPosition({ scrollTop: i });
  }
  showMessage(e, t) {
    if (this.state === "open" && Pn(this.message, e))
      return;
    this.message = e, this.element.classList.remove("idle"), this.element.classList.remove("info"), this.element.classList.remove("warning"), this.element.classList.remove("error"), this.element.classList.add(this.classForType(e.type));
    const i = this.stylesForType(this.message.type);
    this.element.style.border = `1px solid ${Hr(i.border, "transparent")}`, this.message.content && (this.hasFocus() || t) && this._showMessage();
  }
  hideMessage() {
    this.message = null, this.element.classList.remove("info"), this.element.classList.remove("warning"), this.element.classList.remove("error"), this.element.classList.add("idle"), this._hideMessage(), this.applyStyles();
  }
  validate() {
    let e = null;
    return this.validation && (e = this.validation(this.value), e ? (this.inputElement.setAttribute("aria-invalid", "true"), this.showMessage(e)) : this.inputElement.hasAttribute("aria-invalid") && (this.inputElement.removeAttribute("aria-invalid"), this.hideMessage())), e == null ? void 0 : e.type;
  }
  stylesForType(e) {
    const t = this.options.inputBoxStyles;
    switch (e) {
      case 1:
        return { border: t.inputValidationInfoBorder, background: t.inputValidationInfoBackground, foreground: t.inputValidationInfoForeground };
      case 2:
        return { border: t.inputValidationWarningBorder, background: t.inputValidationWarningBackground, foreground: t.inputValidationWarningForeground };
      default:
        return { border: t.inputValidationErrorBorder, background: t.inputValidationErrorBackground, foreground: t.inputValidationErrorForeground };
    }
  }
  classForType(e) {
    switch (e) {
      case 1:
        return "info";
      case 2:
        return "warning";
      default:
        return "error";
    }
  }
  _showMessage() {
    if (!this.contextViewProvider || !this.message)
      return;
    let e;
    const t = () => e.style.width = VL(this.element) + "px";
    this.contextViewProvider.showContextView({
      getAnchor: () => this.element,
      anchorAlignment: 1,
      render: (n) => {
        if (!this.message)
          return null;
        e = ae(n, _u(".monaco-inputbox-container")), t();
        const o = {
          inline: !0,
          className: "monaco-inputbox-message"
        }, r = this.message.formatContent ? YB(this.message.content, o) : ZB(this.message.content, o);
        r.classList.add(this.classForType(this.message.type));
        const a = this.stylesForType(this.message.type);
        return r.style.backgroundColor = a.background ?? "", r.style.color = a.foreground ?? "", r.style.border = a.border ? `1px solid ${a.border}` : "", ae(e, r), null;
      },
      onHide: () => {
        this.state = "closed";
      },
      layout: t
    });
    let i;
    this.message.type === 3 ? i = p("alertErrorMessage", "Error: {0}", this.message.content) : this.message.type === 2 ? i = p("alertWarningMessage", "Warning: {0}", this.message.content) : i = p("alertInfoMessage", "Info: {0}", this.message.content), Gf(i), this.state = "open";
  }
  _hideMessage() {
    this.contextViewProvider && (this.state === "open" && this.contextViewProvider.hideContextView(), this.state = "idle");
  }
  onValueChange() {
    this._onDidChange.fire(this.value), this.validate(), this.updateMirror(), this.input.classList.toggle("empty", !this.value), this.state === "open" && this.contextViewProvider && this.contextViewProvider.layout();
  }
  updateMirror() {
    if (!this.mirror)
      return;
    const e = this.value, i = e.charCodeAt(e.length - 1) === 10 ? " " : "";
    (e + i).replace(/\u000c/g, "") ? this.mirror.textContent = e + i : this.mirror.innerText = " ", this.layout();
  }
  applyStyles() {
    const e = this.options.inputBoxStyles, t = e.inputBackground ?? "", i = e.inputForeground ?? "", n = e.inputBorder ?? "";
    this.element.style.backgroundColor = t, this.element.style.color = i, this.input.style.backgroundColor = "inherit", this.input.style.color = i, this.element.style.border = `1px solid ${Hr(n, "transparent")}`;
  }
  layout() {
    if (!this.mirror)
      return;
    const e = this.cachedContentHeight;
    this.cachedContentHeight = Yw(this.mirror), e !== this.cachedContentHeight && (this.cachedHeight = Math.min(this.cachedContentHeight, this.maxHeight), this.input.style.height = this.cachedHeight + "px", this._onDidHeightChange.fire(this.cachedContentHeight));
  }
  insertAtCursor(e) {
    const t = this.inputElement, i = t.selectionStart, n = t.selectionEnd, o = t.value;
    i !== null && n !== null && (this.value = o.substr(0, i) + e + o.substr(n), t.setSelectionRange(i + 1, i + 1), this.layout());
  }
  dispose() {
    var e;
    this._hideMessage(), this.message = null, (e = this.actionbar) == null || e.dispose(), super.dispose();
  }
}
class uK extends dK {
  constructor(e, t, i) {
    const n = p({
      key: "history.inputbox.hint.suffix.noparens",
      comment: ['Text is the suffix of an input field placeholder coming after the action the input field performs, this will be used when the input field ends in a closing parenthesis ")", for example "Filter (e.g. text, !exclude)". The character inserted into the final string is ⇅ to represent the up and down arrow keys.']
    }, " or {0} for history", "⇅"), o = p({
      key: "history.inputbox.hint.suffix.inparens",
      comment: ['Text is the suffix of an input field placeholder coming after the action the input field performs, this will be used when the input field does NOT end in a closing parenthesis (eg. "Find"). The character inserted into the final string is ⇅ to represent the up and down arrow keys.']
    }, " ({0} for history)", "⇅");
    super(e, t, i), this._onDidFocus = this._register(new O()), this.onDidFocus = this._onDidFocus.event, this._onDidBlur = this._register(new O()), this.onDidBlur = this._onDidBlur.event, this.history = new hK(i.history, 100);
    const r = () => {
      if (i.showHistoryHint && i.showHistoryHint() && !this.placeholder.endsWith(n) && !this.placeholder.endsWith(o) && this.history.getHistory().length) {
        const a = this.placeholder.endsWith(")") ? n : o, l = this.placeholder + a;
        i.showPlaceholderOnFocus && !HL(this.input) ? this.placeholder = l : this.setPlaceHolder(l);
      }
    };
    this.observer = new MutationObserver((a, l) => {
      a.forEach((c) => {
        c.target.textContent || r();
      });
    }), this.observer.observe(this.input, { attributeFilter: ["class"] }), this.onfocus(this.input, () => r()), this.onblur(this.input, () => {
      const a = (l) => {
        if (this.placeholder.endsWith(l)) {
          const c = this.placeholder.slice(0, this.placeholder.length - l.length);
          return i.showPlaceholderOnFocus ? this.placeholder = c : this.setPlaceHolder(c), !0;
        } else
          return !1;
      };
      a(o) || a(n);
    });
  }
  dispose() {
    super.dispose(), this.observer && (this.observer.disconnect(), this.observer = void 0);
  }
  addToHistory(e) {
    this.value && (e || this.value !== this.getCurrentValue()) && this.history.add(this.value);
  }
  isAtLastInHistory() {
    return this.history.isLast();
  }
  isNowhereInHistory() {
    return this.history.isNowhere();
  }
  showNextValue() {
    this.history.has(this.value) || this.addToHistory();
    let e = this.getNextValue();
    e && (e = e === this.value ? this.getNextValue() : e), this.value = e ?? "", Xp(this.value ? this.value : p("clearedInput", "Cleared Input"));
  }
  showPreviousValue() {
    this.history.has(this.value) || this.addToHistory();
    let e = this.getPreviousValue();
    e && (e = e === this.value ? this.getPreviousValue() : e), e && (this.value = e, Xp(this.value));
  }
  setPlaceHolder(e) {
    super.setPlaceHolder(e), this.setTooltip(e);
  }
  onBlur() {
    super.onBlur(), this._onDidBlur.fire();
  }
  onFocus() {
    super.onFocus(), this._onDidFocus.fire();
  }
  getCurrentValue() {
    let e = this.history.current();
    return e || (e = this.history.last(), this.history.next()), e;
  }
  getPreviousValue() {
    return this.history.previous() || this.history.first();
  }
  getNextValue() {
    return this.history.next();
  }
}
const fK = p("defaultLabel", "input");
class gK extends ta {
  constructor(e, t, i) {
    super(), this.fixFocusOnOptionClickEnabled = !0, this.imeSessionInProgress = !1, this.additionalTogglesDisposables = this._register(new Zr()), this.additionalToggles = [], this._onDidOptionChange = this._register(new O()), this.onDidOptionChange = this._onDidOptionChange.event, this._onKeyDown = this._register(new O()), this.onKeyDown = this._onKeyDown.event, this._onMouseDown = this._register(new O()), this.onMouseDown = this._onMouseDown.event, this._onInput = this._register(new O()), this._onKeyUp = this._register(new O()), this._onCaseSensitiveKeyDown = this._register(new O()), this.onCaseSensitiveKeyDown = this._onCaseSensitiveKeyDown.event, this._onRegexKeyDown = this._register(new O()), this.onRegexKeyDown = this._onRegexKeyDown.event, this._lastHighlightFindOptions = 0, this.placeholder = i.placeholder || "", this.validation = i.validation, this.label = i.label || fK, this.showCommonFindToggles = !!i.showCommonFindToggles;
    const n = i.appendCaseSensitiveLabel || "", o = i.appendWholeWordsLabel || "", r = i.appendRegexLabel || "", a = i.history || [], l = !!i.flexibleHeight, c = !!i.flexibleWidth, h = i.flexibleMaxHeight;
    this.domNode = document.createElement("div"), this.domNode.classList.add("monaco-findInput"), this.inputBox = this._register(new uK(this.domNode, t, {
      placeholder: this.placeholder || "",
      ariaLabel: this.label || "",
      validationOptions: {
        validation: this.validation
      },
      history: a,
      showHistoryHint: i.showHistoryHint,
      flexibleHeight: l,
      flexibleWidth: c,
      flexibleMaxHeight: h,
      inputBoxStyles: i.inputBoxStyles
    }));
    const d = this._register(Rk());
    if (this.showCommonFindToggles) {
      this.regex = this._register(new lK({
        appendTitle: r,
        isChecked: !1,
        hoverDelegate: d,
        ...i.toggleStyles
      })), this._register(this.regex.onChange((f) => {
        this._onDidOptionChange.fire(f), !f && this.fixFocusOnOptionClickEnabled && this.inputBox.focus(), this.validate();
      })), this._register(this.regex.onKeyDown((f) => {
        this._onRegexKeyDown.fire(f);
      })), this.wholeWords = this._register(new aK({
        appendTitle: o,
        isChecked: !1,
        hoverDelegate: d,
        ...i.toggleStyles
      })), this._register(this.wholeWords.onChange((f) => {
        this._onDidOptionChange.fire(f), !f && this.fixFocusOnOptionClickEnabled && this.inputBox.focus(), this.validate();
      })), this.caseSensitive = this._register(new rK({
        appendTitle: n,
        isChecked: !1,
        hoverDelegate: d,
        ...i.toggleStyles
      })), this._register(this.caseSensitive.onChange((f) => {
        this._onDidOptionChange.fire(f), !f && this.fixFocusOnOptionClickEnabled && this.inputBox.focus(), this.validate();
      })), this._register(this.caseSensitive.onKeyDown((f) => {
        this._onCaseSensitiveKeyDown.fire(f);
      }));
      const u = [this.caseSensitive.domNode, this.wholeWords.domNode, this.regex.domNode];
      this.onkeydown(this.domNode, (f) => {
        if (f.equals(
          15
          /* KeyCode.LeftArrow */
        ) || f.equals(
          17
          /* KeyCode.RightArrow */
        ) || f.equals(
          9
          /* KeyCode.Escape */
        )) {
          const g = u.indexOf(this.domNode.ownerDocument.activeElement);
          if (g >= 0) {
            let m = -1;
            f.equals(
              17
              /* KeyCode.RightArrow */
            ) ? m = (g + 1) % u.length : f.equals(
              15
              /* KeyCode.LeftArrow */
            ) && (g === 0 ? m = u.length - 1 : m = g - 1), f.equals(
              9
              /* KeyCode.Escape */
            ) ? (u[g].blur(), this.inputBox.focus()) : m >= 0 && u[m].focus(), Be.stop(f, !0);
          }
        }
      });
    }
    this.controls = document.createElement("div"), this.controls.className = "controls", this.controls.style.display = this.showCommonFindToggles ? "" : "none", this.caseSensitive && this.controls.append(this.caseSensitive.domNode), this.wholeWords && this.controls.appendChild(this.wholeWords.domNode), this.regex && this.controls.appendChild(this.regex.domNode), this.setAdditionalToggles(i == null ? void 0 : i.additionalToggles), this.controls && this.domNode.appendChild(this.controls), e == null || e.appendChild(this.domNode), this._register($(this.inputBox.inputElement, "compositionstart", (u) => {
      this.imeSessionInProgress = !0;
    })), this._register($(this.inputBox.inputElement, "compositionend", (u) => {
      this.imeSessionInProgress = !1, this._onInput.fire();
    })), this.onkeydown(this.inputBox.inputElement, (u) => this._onKeyDown.fire(u)), this.onkeyup(this.inputBox.inputElement, (u) => this._onKeyUp.fire(u)), this.oninput(this.inputBox.inputElement, (u) => this._onInput.fire()), this.onmousedown(this.inputBox.inputElement, (u) => this._onMouseDown.fire(u));
  }
  get onDidChange() {
    return this.inputBox.onDidChange;
  }
  layout(e) {
    this.inputBox.layout(), this.updateInputBoxPadding(e.collapsedFindWidget);
  }
  enable() {
    var e, t, i;
    this.domNode.classList.remove("disabled"), this.inputBox.enable(), (e = this.regex) == null || e.enable(), (t = this.wholeWords) == null || t.enable(), (i = this.caseSensitive) == null || i.enable();
    for (const n of this.additionalToggles)
      n.enable();
  }
  disable() {
    var e, t, i;
    this.domNode.classList.add("disabled"), this.inputBox.disable(), (e = this.regex) == null || e.disable(), (t = this.wholeWords) == null || t.disable(), (i = this.caseSensitive) == null || i.disable();
    for (const n of this.additionalToggles)
      n.disable();
  }
  setFocusInputOnOptionClick(e) {
    this.fixFocusOnOptionClickEnabled = e;
  }
  setEnabled(e) {
    e ? this.enable() : this.disable();
  }
  setAdditionalToggles(e) {
    for (const t of this.additionalToggles)
      t.domNode.remove();
    this.additionalToggles = [], this.additionalTogglesDisposables.value = new he();
    for (const t of e ?? [])
      this.additionalTogglesDisposables.value.add(t), this.controls.appendChild(t.domNode), this.additionalTogglesDisposables.value.add(t.onChange((i) => {
        this._onDidOptionChange.fire(i), !i && this.fixFocusOnOptionClickEnabled && this.inputBox.focus();
      })), this.additionalToggles.push(t);
    this.additionalToggles.length > 0 && (this.controls.style.display = ""), this.updateInputBoxPadding();
  }
  updateInputBoxPadding(e = !1) {
    var t, i, n;
    e ? this.inputBox.paddingRight = 0 : this.inputBox.paddingRight = (((t = this.caseSensitive) == null ? void 0 : t.width()) ?? 0) + (((i = this.wholeWords) == null ? void 0 : i.width()) ?? 0) + (((n = this.regex) == null ? void 0 : n.width()) ?? 0) + this.additionalToggles.reduce((o, r) => o + r.width(), 0);
  }
  getValue() {
    return this.inputBox.value;
  }
  setValue(e) {
    this.inputBox.value !== e && (this.inputBox.value = e);
  }
  select() {
    this.inputBox.select();
  }
  focus() {
    this.inputBox.focus();
  }
  getCaseSensitive() {
    var e;
    return ((e = this.caseSensitive) == null ? void 0 : e.checked) ?? !1;
  }
  setCaseSensitive(e) {
    this.caseSensitive && (this.caseSensitive.checked = e);
  }
  getWholeWords() {
    var e;
    return ((e = this.wholeWords) == null ? void 0 : e.checked) ?? !1;
  }
  setWholeWords(e) {
    this.wholeWords && (this.wholeWords.checked = e);
  }
  getRegex() {
    var e;
    return ((e = this.regex) == null ? void 0 : e.checked) ?? !1;
  }
  setRegex(e) {
    this.regex && (this.regex.checked = e, this.validate());
  }
  focusOnCaseSensitive() {
    var e;
    (e = this.caseSensitive) == null || e.focus();
  }
  highlightFindOptions() {
    this.domNode.classList.remove("highlight-" + this._lastHighlightFindOptions), this._lastHighlightFindOptions = 1 - this._lastHighlightFindOptions, this.domNode.classList.add("highlight-" + this._lastHighlightFindOptions);
  }
  validate() {
    this.inputBox.validate();
  }
  showMessage(e) {
    this.inputBox.showMessage(e);
  }
  clearMessage() {
    this.inputBox.hideMessage();
  }
}
const mK = pe;
class pK extends q {
  constructor(e, t, i) {
    super(), this.parent = e, this.onKeyDown = (o) => fi(this.findInput.inputBox.inputElement, ee.KEY_DOWN, o), this.onDidChange = (o) => this.findInput.onDidChange(o), this.container = ae(this.parent, mK(".quick-input-box")), this.findInput = this._register(new gK(this.container, void 0, { label: "", inputBoxStyles: t, toggleStyles: i }));
    const n = this.findInput.inputBox.inputElement;
    n.role = "combobox", n.ariaHasPopup = "menu", n.ariaAutoComplete = "list", n.ariaExpanded = "true";
  }
  get value() {
    return this.findInput.getValue();
  }
  set value(e) {
    this.findInput.setValue(e);
  }
  select(e = null) {
    this.findInput.inputBox.select(e);
  }
  getSelection() {
    return this.findInput.inputBox.getSelection();
  }
  isSelectionAtEnd() {
    return this.findInput.inputBox.isSelectionAtEnd();
  }
  get placeholder() {
    return this.findInput.inputBox.inputElement.getAttribute("placeholder") || "";
  }
  set placeholder(e) {
    this.findInput.inputBox.setPlaceHolder(e);
  }
  get password() {
    return this.findInput.inputBox.inputElement.type === "password";
  }
  set password(e) {
    this.findInput.inputBox.inputElement.type = e ? "password" : "text";
  }
  set enabled(e) {
    this.findInput.inputBox.inputElement.toggleAttribute("readonly", !e);
  }
  set toggles(e) {
    this.findInput.setAdditionalToggles(e);
  }
  setAttribute(e, t) {
    this.findInput.inputBox.inputElement.setAttribute(e, t);
  }
  showDecoration(e) {
    e === Jt.Ignore ? this.findInput.clearMessage() : this.findInput.showMessage({ type: e === Jt.Info ? 1 : e === Jt.Warning ? 2 : 3, content: "" });
  }
  stylesForType(e) {
    return this.findInput.inputBox.stylesForType(
      e === Jt.Info ? 1 : e === Jt.Warning ? 2 : 3
      /* MessageType.ERROR */
    );
  }
  setFocus() {
    this.findInput.focus();
  }
  layout() {
    this.findInput.inputBox.layout();
  }
}
class _K {
  get templateId() {
    return this.renderer.templateId;
  }
  constructor(e, t) {
    this.renderer = e, this.modelProvider = t;
  }
  renderTemplate(e) {
    return { data: this.renderer.renderTemplate(e), disposable: q.None };
  }
  renderElement(e, t, i, n) {
    var l;
    if ((l = i.disposable) == null || l.dispose(), !i.data)
      return;
    const o = this.modelProvider();
    if (o.isResolved(e))
      return this.renderer.renderElement(o.get(e), e, i.data, n);
    const r = new Wd(), a = o.resolve(e, r.token);
    i.disposable = { dispose: () => r.cancel() }, this.renderer.renderPlaceholder(e, i.data), a.then((c) => this.renderer.renderElement(c, e, i.data, n));
  }
  disposeTemplate(e) {
    e.disposable && (e.disposable.dispose(), e.disposable = void 0), e.data && (this.renderer.disposeTemplate(e.data), e.data = void 0);
  }
}
class bK {
  constructor(e, t) {
    this.modelProvider = e, this.accessibilityProvider = t;
  }
  getWidgetAriaLabel() {
    return this.accessibilityProvider.getWidgetAriaLabel();
  }
  getAriaLabel(e) {
    const t = this.modelProvider();
    return t.isResolved(e) ? this.accessibilityProvider.getAriaLabel(t.get(e)) : null;
  }
}
function CK(s, e) {
  return {
    ...e,
    accessibilityProvider: e.accessibilityProvider && new bK(s, e.accessibilityProvider)
  };
}
class wK {
  constructor(e, t, i, n, o = {}) {
    const r = () => this.model, a = n.map((l) => new _K(l, r));
    this.list = new mo(e, t, i, a, CK(r, o));
  }
  updateOptions(e) {
    this.list.updateOptions(e);
  }
  getHTMLElement() {
    return this.list.getHTMLElement();
  }
  get onDidFocus() {
    return this.list.onDidFocus;
  }
  get widget() {
    return this.list;
  }
  get onDidDispose() {
    return this.list.onDidDispose;
  }
  get onMouseDblClick() {
    return J.map(this.list.onMouseDblClick, ({ element: e, index: t, browserEvent: i }) => ({ element: e === void 0 ? void 0 : this._model.get(e), index: t, browserEvent: i }));
  }
  get onPointer() {
    return J.map(this.list.onPointer, ({ element: e, index: t, browserEvent: i }) => ({ element: e === void 0 ? void 0 : this._model.get(e), index: t, browserEvent: i }));
  }
  get onDidChangeSelection() {
    return J.map(this.list.onDidChangeSelection, ({ elements: e, indexes: t, browserEvent: i }) => ({ elements: e.map((n) => this._model.get(n)), indexes: t, browserEvent: i }));
  }
  get model() {
    return this._model;
  }
  set model(e) {
    this._model = e, this.list.splice(0, this.list.length, fn(e.length));
  }
  getFocus() {
    return this.list.getFocus();
  }
  getSelection() {
    return this.list.getSelection();
  }
  getSelectedElements() {
    return this.getSelection().map((e) => this.model.get(e));
  }
  style(e) {
    this.list.style(e);
  }
  dispose() {
    this.list.dispose();
  }
}
var qd = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
};
const vK = !1;
var LN;
(function(s) {
  s.North = "north", s.South = "south", s.East = "east", s.West = "west";
})(LN || (LN = {}));
let yK = 4;
const SK = new O();
let LK = 300;
const kK = new O();
class jk {
  constructor(e) {
    this.el = e, this.disposables = new he();
  }
  get onPointerMove() {
    return this.disposables.add(new Re(ue(this.el), "mousemove")).event;
  }
  get onPointerUp() {
    return this.disposables.add(new Re(ue(this.el), "mouseup")).event;
  }
  dispose() {
    this.disposables.dispose();
  }
}
qd([
  Ht
], jk.prototype, "onPointerMove", null);
qd([
  Ht
], jk.prototype, "onPointerUp", null);
class Gk {
  get onPointerMove() {
    return this.disposables.add(new Re(this.el, bt.Change)).event;
  }
  get onPointerUp() {
    return this.disposables.add(new Re(this.el, bt.End)).event;
  }
  constructor(e) {
    this.el = e, this.disposables = new he();
  }
  dispose() {
    this.disposables.dispose();
  }
}
qd([
  Ht
], Gk.prototype, "onPointerMove", null);
qd([
  Ht
], Gk.prototype, "onPointerUp", null);
class p_ {
  get onPointerMove() {
    return this.factory.onPointerMove;
  }
  get onPointerUp() {
    return this.factory.onPointerUp;
  }
  constructor(e) {
    this.factory = e;
  }
  dispose() {
  }
}
qd([
  Ht
], p_.prototype, "onPointerMove", null);
qd([
  Ht
], p_.prototype, "onPointerUp", null);
const kN = "pointer-events-disabled";
class cs extends q {
  get state() {
    return this._state;
  }
  get orthogonalStartSash() {
    return this._orthogonalStartSash;
  }
  get orthogonalEndSash() {
    return this._orthogonalEndSash;
  }
  /**
   * The state of a sash defines whether it can be interacted with by the user
   * as well as what mouse cursor to use, when hovered.
   */
  set state(e) {
    this._state !== e && (this.el.classList.toggle(
      "disabled",
      e === 0
      /* SashState.Disabled */
    ), this.el.classList.toggle(
      "minimum",
      e === 1
      /* SashState.AtMinimum */
    ), this.el.classList.toggle(
      "maximum",
      e === 2
      /* SashState.AtMaximum */
    ), this._state = e, this.onDidEnablementChange.fire(e));
  }
  /**
   * A reference to another sash, perpendicular to this one, which
   * aligns at the start of this one. A corner sash will be created
   * automatically at that location.
   *
   * The start of a horizontal sash is its left-most position.
   * The start of a vertical sash is its top-most position.
   */
  set orthogonalStartSash(e) {
    if (this._orthogonalStartSash !== e) {
      if (this.orthogonalStartDragHandleDisposables.clear(), this.orthogonalStartSashDisposables.clear(), e) {
        const t = (i) => {
          this.orthogonalStartDragHandleDisposables.clear(), i !== 0 && (this._orthogonalStartDragHandle = ae(this.el, pe(".orthogonal-drag-handle.start")), this.orthogonalStartDragHandleDisposables.add(ke(() => this._orthogonalStartDragHandle.remove())), this.orthogonalStartDragHandleDisposables.add(new Re(this._orthogonalStartDragHandle, "mouseenter")).event(() => cs.onMouseEnter(e), void 0, this.orthogonalStartDragHandleDisposables), this.orthogonalStartDragHandleDisposables.add(new Re(this._orthogonalStartDragHandle, "mouseleave")).event(() => cs.onMouseLeave(e), void 0, this.orthogonalStartDragHandleDisposables));
        };
        this.orthogonalStartSashDisposables.add(e.onDidEnablementChange.event(t, this)), t(e.state);
      }
      this._orthogonalStartSash = e;
    }
  }
  /**
   * A reference to another sash, perpendicular to this one, which
   * aligns at the end of this one. A corner sash will be created
   * automatically at that location.
   *
   * The end of a horizontal sash is its right-most position.
   * The end of a vertical sash is its bottom-most position.
   */
  set orthogonalEndSash(e) {
    if (this._orthogonalEndSash !== e) {
      if (this.orthogonalEndDragHandleDisposables.clear(), this.orthogonalEndSashDisposables.clear(), e) {
        const t = (i) => {
          this.orthogonalEndDragHandleDisposables.clear(), i !== 0 && (this._orthogonalEndDragHandle = ae(this.el, pe(".orthogonal-drag-handle.end")), this.orthogonalEndDragHandleDisposables.add(ke(() => this._orthogonalEndDragHandle.remove())), this.orthogonalEndDragHandleDisposables.add(new Re(this._orthogonalEndDragHandle, "mouseenter")).event(() => cs.onMouseEnter(e), void 0, this.orthogonalEndDragHandleDisposables), this.orthogonalEndDragHandleDisposables.add(new Re(this._orthogonalEndDragHandle, "mouseleave")).event(() => cs.onMouseLeave(e), void 0, this.orthogonalEndDragHandleDisposables));
        };
        this.orthogonalEndSashDisposables.add(e.onDidEnablementChange.event(t, this)), t(e.state);
      }
      this._orthogonalEndSash = e;
    }
  }
  constructor(e, t, i) {
    super(), this.hoverDelay = LK, this.hoverDelayer = this._register(new kg(this.hoverDelay)), this._state = 3, this.onDidEnablementChange = this._register(new O()), this._onDidStart = this._register(new O()), this._onDidChange = this._register(new O()), this._onDidReset = this._register(new O()), this._onDidEnd = this._register(new O()), this.orthogonalStartSashDisposables = this._register(new he()), this.orthogonalStartDragHandleDisposables = this._register(new he()), this.orthogonalEndSashDisposables = this._register(new he()), this.orthogonalEndDragHandleDisposables = this._register(new he()), this.onDidStart = this._onDidStart.event, this.onDidChange = this._onDidChange.event, this.onDidReset = this._onDidReset.event, this.onDidEnd = this._onDidEnd.event, this.linkedSash = void 0, this.el = ae(e, pe(".monaco-sash")), i.orthogonalEdge && this.el.classList.add(`orthogonal-edge-${i.orthogonalEdge}`), He && this.el.classList.add("mac");
    const n = this._register(new Re(this.el, "mousedown")).event;
    this._register(n((d) => this.onPointerStart(d, new jk(e)), this));
    const o = this._register(new Re(this.el, "dblclick")).event;
    this._register(o(this.onPointerDoublePress, this));
    const r = this._register(new Re(this.el, "mouseenter")).event;
    this._register(r(() => cs.onMouseEnter(this)));
    const a = this._register(new Re(this.el, "mouseleave")).event;
    this._register(a(() => cs.onMouseLeave(this))), this._register(an.addTarget(this.el));
    const l = this._register(new Re(this.el, bt.Start)).event;
    this._register(l((d) => this.onPointerStart(d, new Gk(this.el)), this));
    const c = this._register(new Re(this.el, bt.Tap)).event;
    let h;
    this._register(c((d) => {
      if (h) {
        clearTimeout(h), h = void 0, this.onPointerDoublePress(d);
        return;
      }
      clearTimeout(h), h = setTimeout(() => h = void 0, 250);
    }, this)), typeof i.size == "number" ? (this.size = i.size, i.orientation === 0 ? this.el.style.width = `${this.size}px` : this.el.style.height = `${this.size}px`) : (this.size = yK, this._register(SK.event((d) => {
      this.size = d, this.layout();
    }))), this._register(kK.event((d) => this.hoverDelay = d)), this.layoutProvider = t, this.orthogonalStartSash = i.orthogonalStartSash, this.orthogonalEndSash = i.orthogonalEndSash, this.orientation = i.orientation || 0, this.orientation === 1 ? (this.el.classList.add("horizontal"), this.el.classList.remove("vertical")) : (this.el.classList.remove("horizontal"), this.el.classList.add("vertical")), this.el.classList.toggle("debug", vK), this.layout();
  }
  onPointerStart(e, t) {
    Be.stop(e);
    let i = !1;
    if (!e.__orthogonalSashEvent) {
      const g = this.getOrthogonalSash(e);
      g && (i = !0, e.__orthogonalSashEvent = !0, g.onPointerStart(e, new p_(t)));
    }
    if (this.linkedSash && !e.__linkedSashEvent && (e.__linkedSashEvent = !0, this.linkedSash.onPointerStart(e, new p_(t))), !this.state)
      return;
    const n = this.el.ownerDocument.getElementsByTagName("iframe");
    for (const g of n)
      g.classList.add(kN);
    const o = e.pageX, r = e.pageY, a = e.altKey, l = { startX: o, currentX: o, startY: r, currentY: r, altKey: a };
    this.el.classList.add("active"), this._onDidStart.fire(l);
    const c = Os(this.el), h = () => {
      let g = "";
      i ? g = "all-scroll" : this.orientation === 1 ? this.state === 1 ? g = "s-resize" : this.state === 2 ? g = "n-resize" : g = He ? "row-resize" : "ns-resize" : this.state === 1 ? g = "e-resize" : this.state === 2 ? g = "w-resize" : g = He ? "col-resize" : "ew-resize", c.textContent = `* { cursor: ${g} !important; }`;
    }, d = new he();
    h(), i || this.onDidEnablementChange.event(h, null, d);
    const u = (g) => {
      Be.stop(g, !1);
      const m = { startX: o, currentX: g.pageX, startY: r, currentY: g.pageY, altKey: a };
      this._onDidChange.fire(m);
    }, f = (g) => {
      Be.stop(g, !1), c.remove(), this.el.classList.remove("active"), this._onDidEnd.fire(), d.dispose();
      for (const m of n)
        m.classList.remove(kN);
    };
    t.onPointerMove(u, null, d), t.onPointerUp(f, null, d), d.add(t);
  }
  onPointerDoublePress(e) {
    const t = this.getOrthogonalSash(e);
    t && t._onDidReset.fire(), this.linkedSash && this.linkedSash._onDidReset.fire(), this._onDidReset.fire();
  }
  static onMouseEnter(e, t = !1) {
    e.el.classList.contains("active") ? (e.hoverDelayer.cancel(), e.el.classList.add("hover")) : e.hoverDelayer.trigger(() => e.el.classList.add("hover"), e.hoverDelay).then(void 0, () => {
    }), !t && e.linkedSash && cs.onMouseEnter(e.linkedSash, !0);
  }
  static onMouseLeave(e, t = !1) {
    e.hoverDelayer.cancel(), e.el.classList.remove("hover"), !t && e.linkedSash && cs.onMouseLeave(e.linkedSash, !0);
  }
  /**
   * Forcefully stop any user interactions with this sash.
   * Useful when hiding a parent component, while the user is still
   * interacting with the sash.
   */
  clearSashHoverState() {
    cs.onMouseLeave(this);
  }
  /**
   * Layout the sash. The sash will size and position itself
   * based on its provided {@link ISashLayoutProvider layout provider}.
   */
  layout() {
    if (this.orientation === 0) {
      const e = this.layoutProvider;
      this.el.style.left = e.getVerticalSashLeft(this) - this.size / 2 + "px", e.getVerticalSashTop && (this.el.style.top = e.getVerticalSashTop(this) + "px"), e.getVerticalSashHeight && (this.el.style.height = e.getVerticalSashHeight(this) + "px");
    } else {
      const e = this.layoutProvider;
      this.el.style.top = e.getHorizontalSashTop(this) - this.size / 2 + "px", e.getHorizontalSashLeft && (this.el.style.left = e.getHorizontalSashLeft(this) + "px"), e.getHorizontalSashWidth && (this.el.style.width = e.getHorizontalSashWidth(this) + "px");
    }
  }
  getOrthogonalSash(e) {
    const t = e.initialTarget ?? e.target;
    if (!(!t || !yi(t)) && t.classList.contains("orthogonal-drag-handle"))
      return t.classList.contains("start") ? this.orthogonalStartSash : this.orthogonalEndSash;
  }
  dispose() {
    super.dispose(), this.el.remove();
  }
}
const xK = {
  separatorBorder: Z.transparent
};
class f4 {
  set size(e) {
    this._size = e;
  }
  get size() {
    return this._size;
  }
  get visible() {
    return typeof this._cachedVisibleSize > "u";
  }
  setVisible(e, t) {
    var i, n;
    if (e !== this.visible) {
      e ? (this.size = gn(this._cachedVisibleSize, this.viewMinimumSize, this.viewMaximumSize), this._cachedVisibleSize = void 0) : (this._cachedVisibleSize = typeof t == "number" ? t : this.size, this.size = 0), this.container.classList.toggle("visible", e);
      try {
        (n = (i = this.view).setVisible) == null || n.call(i, e);
      } catch (o) {
        console.error("Splitview: Failed to set visible view"), console.error(o);
      }
    }
  }
  get minimumSize() {
    return this.visible ? this.view.minimumSize : 0;
  }
  get viewMinimumSize() {
    return this.view.minimumSize;
  }
  get maximumSize() {
    return this.visible ? this.view.maximumSize : 0;
  }
  get viewMaximumSize() {
    return this.view.maximumSize;
  }
  get priority() {
    return this.view.priority;
  }
  get proportionalLayout() {
    return this.view.proportionalLayout ?? !0;
  }
  get snap() {
    return !!this.view.snap;
  }
  set enabled(e) {
    this.container.style.pointerEvents = e ? "" : "none";
  }
  constructor(e, t, i, n) {
    this.container = e, this.view = t, this.disposable = n, this._cachedVisibleSize = void 0, typeof i == "number" ? (this._size = i, this._cachedVisibleSize = void 0, e.classList.add("visible")) : (this._size = 0, this._cachedVisibleSize = i.cachedVisibleSize);
  }
  layout(e, t) {
    this.layoutContainer(e);
    try {
      this.view.layout(this.size, e, t);
    } catch (i) {
      console.error("Splitview: Failed to layout view"), console.error(i);
    }
  }
  dispose() {
    this.disposable.dispose();
  }
}
class DK extends f4 {
  layoutContainer(e) {
    this.container.style.top = `${e}px`, this.container.style.height = `${this.size}px`;
  }
}
class EK extends f4 {
  layoutContainer(e) {
    this.container.style.left = `${e}px`, this.container.style.width = `${this.size}px`;
  }
}
var fr;
(function(s) {
  s[s.Idle = 0] = "Idle", s[s.Busy = 1] = "Busy";
})(fr || (fr = {}));
var xN;
(function(s) {
  s.Distribute = { type: "distribute" };
  function e(n) {
    return { type: "split", index: n };
  }
  s.Split = e;
  function t(n) {
    return { type: "auto", index: n };
  }
  s.Auto = t;
  function i(n) {
    return { type: "invisible", cachedVisibleSize: n };
  }
  s.Invisible = i;
})(xN || (xN = {}));
class IK extends q {
  get orthogonalStartSash() {
    return this._orthogonalStartSash;
  }
  get orthogonalEndSash() {
    return this._orthogonalEndSash;
  }
  get startSnappingEnabled() {
    return this._startSnappingEnabled;
  }
  get endSnappingEnabled() {
    return this._endSnappingEnabled;
  }
  /**
   * A reference to a sash, perpendicular to all sashes in this {@link SplitView},
   * located at the left- or top-most side of the SplitView.
   * Corner sashes will be created automatically at the intersections.
   */
  set orthogonalStartSash(e) {
    for (const t of this.sashItems)
      t.sash.orthogonalStartSash = e;
    this._orthogonalStartSash = e;
  }
  /**
   * A reference to a sash, perpendicular to all sashes in this {@link SplitView},
   * located at the right- or bottom-most side of the SplitView.
   * Corner sashes will be created automatically at the intersections.
   */
  set orthogonalEndSash(e) {
    for (const t of this.sashItems)
      t.sash.orthogonalEndSash = e;
    this._orthogonalEndSash = e;
  }
  /**
   * Enable/disable snapping at the beginning of this {@link SplitView}.
   */
  set startSnappingEnabled(e) {
    this._startSnappingEnabled !== e && (this._startSnappingEnabled = e, this.updateSashEnablement());
  }
  /**
   * Enable/disable snapping at the end of this {@link SplitView}.
   */
  set endSnappingEnabled(e) {
    this._endSnappingEnabled !== e && (this._endSnappingEnabled = e, this.updateSashEnablement());
  }
  /**
   * Create a new {@link SplitView} instance.
   */
  constructor(e, t = {}) {
    super(), this.size = 0, this._contentSize = 0, this.proportions = void 0, this.viewItems = [], this.sashItems = [], this.state = fr.Idle, this._onDidSashChange = this._register(new O()), this._onDidSashReset = this._register(new O()), this._startSnappingEnabled = !0, this._endSnappingEnabled = !0, this.onDidSashChange = this._onDidSashChange.event, this.onDidSashReset = this._onDidSashReset.event, this.orientation = t.orientation ?? 0, this.inverseAltBehavior = t.inverseAltBehavior ?? !1, this.proportionalLayout = t.proportionalLayout ?? !0, this.getSashOrthogonalSize = t.getSashOrthogonalSize, this.el = document.createElement("div"), this.el.classList.add("monaco-split-view2"), this.el.classList.add(this.orientation === 0 ? "vertical" : "horizontal"), e.appendChild(this.el), this.sashContainer = ae(this.el, pe(".sash-container")), this.viewContainer = pe(".split-view-container"), this.scrollable = this._register(new zd({
      forceIntegerValues: !0,
      smoothScrollDuration: 125,
      scheduleAtNextAnimationFrame: (n) => Wn(ue(this.el), n)
    })), this.scrollableElement = this._register(new xb(this.viewContainer, {
      vertical: this.orientation === 0 ? t.scrollbarVisibility ?? 1 : 2,
      horizontal: this.orientation === 1 ? t.scrollbarVisibility ?? 1 : 2
      /* ScrollbarVisibility.Hidden */
    }, this.scrollable));
    const i = this._register(new Re(this.viewContainer, "scroll")).event;
    this._register(i((n) => {
      const o = this.scrollableElement.getScrollPosition(), r = Math.abs(this.viewContainer.scrollLeft - o.scrollLeft) <= 1 ? void 0 : this.viewContainer.scrollLeft, a = Math.abs(this.viewContainer.scrollTop - o.scrollTop) <= 1 ? void 0 : this.viewContainer.scrollTop;
      (r !== void 0 || a !== void 0) && this.scrollableElement.setScrollPosition({ scrollLeft: r, scrollTop: a });
    })), this.onDidScroll = this.scrollableElement.onScroll, this._register(this.onDidScroll((n) => {
      n.scrollTopChanged && (this.viewContainer.scrollTop = n.scrollTop), n.scrollLeftChanged && (this.viewContainer.scrollLeft = n.scrollLeft);
    })), ae(this.el, this.scrollableElement.getDomNode()), this.style(t.styles || xK), t.descriptor && (this.size = t.descriptor.size, t.descriptor.views.forEach((n, o) => {
      const r = fs(n.visible) || n.visible ? n.size : { type: "invisible", cachedVisibleSize: n.size }, a = n.view;
      this.doAddView(a, r, o, !0);
    }), this._contentSize = this.viewItems.reduce((n, o) => n + o.size, 0), this.saveProportions());
  }
  style(e) {
    e.separatorBorder.isTransparent() ? (this.el.classList.remove("separator-border"), this.el.style.removeProperty("--separator-border")) : (this.el.classList.add("separator-border"), this.el.style.setProperty("--separator-border", e.separatorBorder.toString()));
  }
  /**
   * Add a {@link IView view} to this {@link SplitView}.
   *
   * @param view The view to add.
   * @param size Either a fixed size, or a dynamic {@link Sizing} strategy.
   * @param index The index to insert the view on.
   * @param skipLayout Whether layout should be skipped.
   */
  addView(e, t, i = this.viewItems.length, n) {
    this.doAddView(e, t, i, n);
  }
  /**
   * Layout the {@link SplitView}.
   *
   * @param size The entire size of the {@link SplitView}.
   * @param layoutContext An optional layout context to pass along to {@link IView views}.
   */
  layout(e, t) {
    const i = Math.max(this.size, this._contentSize);
    if (this.size = e, this.layoutContext = t, this.proportions) {
      let n = 0;
      for (let o = 0; o < this.viewItems.length; o++) {
        const r = this.viewItems[o], a = this.proportions[o];
        typeof a == "number" ? n += a : e -= r.size;
      }
      for (let o = 0; o < this.viewItems.length; o++) {
        const r = this.viewItems[o], a = this.proportions[o];
        typeof a == "number" && n > 0 && (r.size = gn(Math.round(a * e / n), r.minimumSize, r.maximumSize));
      }
    } else {
      const n = fn(this.viewItems.length), o = n.filter(
        (a) => this.viewItems[a].priority === 1
        /* LayoutPriority.Low */
      ), r = n.filter(
        (a) => this.viewItems[a].priority === 2
        /* LayoutPriority.High */
      );
      this.resize(this.viewItems.length - 1, e - i, void 0, o, r);
    }
    this.distributeEmptySpace(), this.layoutViews();
  }
  saveProportions() {
    this.proportionalLayout && this._contentSize > 0 && (this.proportions = this.viewItems.map((e) => e.proportionalLayout && e.visible ? e.size / this._contentSize : void 0));
  }
  onSashStart({ sash: e, start: t, alt: i }) {
    for (const a of this.viewItems)
      a.enabled = !1;
    const n = this.sashItems.findIndex((a) => a.sash === e), o = Wo($(this.el.ownerDocument.body, "keydown", (a) => r(this.sashDragState.current, a.altKey)), $(this.el.ownerDocument.body, "keyup", () => r(this.sashDragState.current, !1))), r = (a, l) => {
      const c = this.viewItems.map((g) => g.size);
      let h = Number.NEGATIVE_INFINITY, d = Number.POSITIVE_INFINITY;
      if (this.inverseAltBehavior && (l = !l), l)
        if (n === this.sashItems.length - 1) {
          const m = this.viewItems[n];
          h = (m.minimumSize - m.size) / 2, d = (m.maximumSize - m.size) / 2;
        } else {
          const m = this.viewItems[n + 1];
          h = (m.size - m.maximumSize) / 2, d = (m.size - m.minimumSize) / 2;
        }
      let u, f;
      if (!l) {
        const g = fn(n, -1), m = fn(n + 1, this.viewItems.length), _ = g.reduce((D, E) => D + (this.viewItems[E].minimumSize - c[E]), 0), b = g.reduce((D, E) => D + (this.viewItems[E].viewMaximumSize - c[E]), 0), C = m.length === 0 ? Number.POSITIVE_INFINITY : m.reduce((D, E) => D + (c[E] - this.viewItems[E].minimumSize), 0), v = m.length === 0 ? Number.NEGATIVE_INFINITY : m.reduce((D, E) => D + (c[E] - this.viewItems[E].viewMaximumSize), 0), w = Math.max(_, v), S = Math.min(C, b), L = this.findFirstSnapIndex(g), k = this.findFirstSnapIndex(m);
        if (typeof L == "number") {
          const D = this.viewItems[L], E = Math.floor(D.viewMinimumSize / 2);
          u = {
            index: L,
            limitDelta: D.visible ? w - E : w + E,
            size: D.size
          };
        }
        if (typeof k == "number") {
          const D = this.viewItems[k], E = Math.floor(D.viewMinimumSize / 2);
          f = {
            index: k,
            limitDelta: D.visible ? S + E : S - E,
            size: D.size
          };
        }
      }
      this.sashDragState = { start: a, current: a, index: n, sizes: c, minDelta: h, maxDelta: d, alt: l, snapBefore: u, snapAfter: f, disposable: o };
    };
    r(t, i);
  }
  onSashChange({ current: e }) {
    const { index: t, start: i, sizes: n, alt: o, minDelta: r, maxDelta: a, snapBefore: l, snapAfter: c } = this.sashDragState;
    this.sashDragState.current = e;
    const h = e - i, d = this.resize(t, h, n, void 0, void 0, r, a, l, c);
    if (o) {
      const u = t === this.sashItems.length - 1, f = this.viewItems.map((v) => v.size), g = u ? t : t + 1, m = this.viewItems[g], _ = m.size - m.maximumSize, b = m.size - m.minimumSize, C = u ? t - 1 : t + 1;
      this.resize(C, -d, f, void 0, void 0, _, b);
    }
    this.distributeEmptySpace(), this.layoutViews();
  }
  onSashEnd(e) {
    this._onDidSashChange.fire(e), this.sashDragState.disposable.dispose(), this.saveProportions();
    for (const t of this.viewItems)
      t.enabled = !0;
  }
  onViewChange(e, t) {
    const i = this.viewItems.indexOf(e);
    i < 0 || i >= this.viewItems.length || (t = typeof t == "number" ? t : e.size, t = gn(t, e.minimumSize, e.maximumSize), this.inverseAltBehavior && i > 0 ? (this.resize(i - 1, Math.floor((e.size - t) / 2)), this.distributeEmptySpace(), this.layoutViews()) : (e.size = t, this.relayout([i], void 0)));
  }
  /**
   * Resize a {@link IView view} within the {@link SplitView}.
   *
   * @param index The {@link IView view} index.
   * @param size The {@link IView view} size.
   */
  resizeView(e, t) {
    if (!(e < 0 || e >= this.viewItems.length)) {
      if (this.state !== fr.Idle)
        throw new Error("Cant modify splitview");
      this.state = fr.Busy;
      try {
        const i = fn(this.viewItems.length).filter((a) => a !== e), n = [...i.filter(
          (a) => this.viewItems[a].priority === 1
          /* LayoutPriority.Low */
        ), e], o = i.filter(
          (a) => this.viewItems[a].priority === 2
          /* LayoutPriority.High */
        ), r = this.viewItems[e];
        t = Math.round(t), t = gn(t, r.minimumSize, Math.min(r.maximumSize, this.size)), r.size = t, this.relayout(n, o);
      } finally {
        this.state = fr.Idle;
      }
    }
  }
  /**
   * Distribute the entire {@link SplitView} size among all {@link IView views}.
   */
  distributeViewSizes() {
    const e = [];
    let t = 0;
    for (const a of this.viewItems)
      a.maximumSize - a.minimumSize > 0 && (e.push(a), t += a.size);
    const i = Math.floor(t / e.length);
    for (const a of e)
      a.size = gn(i, a.minimumSize, a.maximumSize);
    const n = fn(this.viewItems.length), o = n.filter(
      (a) => this.viewItems[a].priority === 1
      /* LayoutPriority.Low */
    ), r = n.filter(
      (a) => this.viewItems[a].priority === 2
      /* LayoutPriority.High */
    );
    this.relayout(o, r);
  }
  /**
   * Returns the size of a {@link IView view}.
   */
  getViewSize(e) {
    return e < 0 || e >= this.viewItems.length ? -1 : this.viewItems[e].size;
  }
  doAddView(e, t, i = this.viewItems.length, n) {
    if (this.state !== fr.Idle)
      throw new Error("Cant modify splitview");
    this.state = fr.Busy;
    try {
      const o = pe(".split-view-view");
      i === this.viewItems.length ? this.viewContainer.appendChild(o) : this.viewContainer.insertBefore(o, this.viewContainer.children.item(i));
      const r = e.onDidChange((u) => this.onViewChange(h, u)), a = ke(() => o.remove()), l = Wo(r, a);
      let c;
      typeof t == "number" ? c = t : (t.type === "auto" && (this.areViewsDistributed() ? t = { type: "distribute" } : t = { type: "split", index: t.index }), t.type === "split" ? c = this.getViewSize(t.index) / 2 : t.type === "invisible" ? c = { cachedVisibleSize: t.cachedVisibleSize } : c = e.minimumSize);
      const h = this.orientation === 0 ? new DK(o, e, c, l) : new EK(o, e, c, l);
      if (this.viewItems.splice(i, 0, h), this.viewItems.length > 1) {
        const u = { orthogonalStartSash: this.orthogonalStartSash, orthogonalEndSash: this.orthogonalEndSash }, f = this.orientation === 0 ? new cs(this.sashContainer, { getHorizontalSashTop: (D) => this.getSashPosition(D), getHorizontalSashWidth: this.getSashOrthogonalSize }, {
          ...u,
          orientation: 1
          /* Orientation.HORIZONTAL */
        }) : new cs(this.sashContainer, { getVerticalSashLeft: (D) => this.getSashPosition(D), getVerticalSashHeight: this.getSashOrthogonalSize }, {
          ...u,
          orientation: 0
          /* Orientation.VERTICAL */
        }), g = this.orientation === 0 ? (D) => ({ sash: f, start: D.startY, current: D.currentY, alt: D.altKey }) : (D) => ({ sash: f, start: D.startX, current: D.currentX, alt: D.altKey }), _ = J.map(f.onDidStart, g)(this.onSashStart, this), C = J.map(f.onDidChange, g)(this.onSashChange, this), w = J.map(f.onDidEnd, () => this.sashItems.findIndex((D) => D.sash === f))(this.onSashEnd, this), S = f.onDidReset(() => {
          const D = this.sashItems.findIndex((W) => W.sash === f), E = fn(D, -1), U = fn(D + 1, this.viewItems.length), P = this.findFirstSnapIndex(E), B = this.findFirstSnapIndex(U);
          typeof P == "number" && !this.viewItems[P].visible || typeof B == "number" && !this.viewItems[B].visible || this._onDidSashReset.fire(D);
        }), L = Wo(_, C, w, S, f), k = { sash: f, disposable: L };
        this.sashItems.splice(i - 1, 0, k);
      }
      o.appendChild(e.element);
      let d;
      typeof t != "number" && t.type === "split" && (d = [t.index]), n || this.relayout([i], d), !n && typeof t != "number" && t.type === "distribute" && this.distributeViewSizes();
    } finally {
      this.state = fr.Idle;
    }
  }
  relayout(e, t) {
    const i = this.viewItems.reduce((n, o) => n + o.size, 0);
    this.resize(this.viewItems.length - 1, this.size - i, void 0, e, t), this.distributeEmptySpace(), this.layoutViews(), this.saveProportions();
  }
  resize(e, t, i = this.viewItems.map((h) => h.size), n, o, r = Number.NEGATIVE_INFINITY, a = Number.POSITIVE_INFINITY, l, c) {
    if (e < 0 || e >= this.viewItems.length)
      return 0;
    const h = fn(e, -1), d = fn(e + 1, this.viewItems.length);
    if (o)
      for (const k of o)
        s0(h, k), s0(d, k);
    if (n)
      for (const k of n)
        Yg(h, k), Yg(d, k);
    const u = h.map((k) => this.viewItems[k]), f = h.map((k) => i[k]), g = d.map((k) => this.viewItems[k]), m = d.map((k) => i[k]), _ = h.reduce((k, D) => k + (this.viewItems[D].minimumSize - i[D]), 0), b = h.reduce((k, D) => k + (this.viewItems[D].maximumSize - i[D]), 0), C = d.length === 0 ? Number.POSITIVE_INFINITY : d.reduce((k, D) => k + (i[D] - this.viewItems[D].minimumSize), 0), v = d.length === 0 ? Number.NEGATIVE_INFINITY : d.reduce((k, D) => k + (i[D] - this.viewItems[D].maximumSize), 0), w = Math.max(_, v, r), S = Math.min(C, b, a);
    let L = !1;
    if (l) {
      const k = this.viewItems[l.index], D = t >= l.limitDelta;
      L = D !== k.visible, k.setVisible(D, l.size);
    }
    if (!L && c) {
      const k = this.viewItems[c.index], D = t < c.limitDelta;
      L = D !== k.visible, k.setVisible(D, c.size);
    }
    if (L)
      return this.resize(e, t, i, n, o, r, a);
    t = gn(t, w, S);
    for (let k = 0, D = t; k < u.length; k++) {
      const E = u[k], U = gn(f[k] + D, E.minimumSize, E.maximumSize), P = U - f[k];
      D -= P, E.size = U;
    }
    for (let k = 0, D = t; k < g.length; k++) {
      const E = g[k], U = gn(m[k] - D, E.minimumSize, E.maximumSize), P = U - m[k];
      D += P, E.size = U;
    }
    return t;
  }
  distributeEmptySpace(e) {
    const t = this.viewItems.reduce((a, l) => a + l.size, 0);
    let i = this.size - t;
    const n = fn(this.viewItems.length - 1, -1), o = n.filter(
      (a) => this.viewItems[a].priority === 1
      /* LayoutPriority.Low */
    ), r = n.filter(
      (a) => this.viewItems[a].priority === 2
      /* LayoutPriority.High */
    );
    for (const a of r)
      s0(n, a);
    for (const a of o)
      Yg(n, a);
    typeof e == "number" && Yg(n, e);
    for (let a = 0; i !== 0 && a < n.length; a++) {
      const l = this.viewItems[n[a]], c = gn(l.size + i, l.minimumSize, l.maximumSize), h = c - l.size;
      i -= h, l.size = c;
    }
  }
  layoutViews() {
    this._contentSize = this.viewItems.reduce((t, i) => t + i.size, 0);
    let e = 0;
    for (const t of this.viewItems)
      t.layout(e, this.layoutContext), e += t.size;
    this.sashItems.forEach((t) => t.sash.layout()), this.updateSashEnablement(), this.updateScrollableElement();
  }
  updateScrollableElement() {
    this.orientation === 0 ? this.scrollableElement.setScrollDimensions({
      height: this.size,
      scrollHeight: this._contentSize
    }) : this.scrollableElement.setScrollDimensions({
      width: this.size,
      scrollWidth: this._contentSize
    });
  }
  updateSashEnablement() {
    let e = !1;
    const t = this.viewItems.map((l) => e = l.size - l.minimumSize > 0 || e);
    e = !1;
    const i = this.viewItems.map((l) => e = l.maximumSize - l.size > 0 || e), n = [...this.viewItems].reverse();
    e = !1;
    const o = n.map((l) => e = l.size - l.minimumSize > 0 || e).reverse();
    e = !1;
    const r = n.map((l) => e = l.maximumSize - l.size > 0 || e).reverse();
    let a = 0;
    for (let l = 0; l < this.sashItems.length; l++) {
      const { sash: c } = this.sashItems[l], h = this.viewItems[l];
      a += h.size;
      const d = !(t[l] && r[l + 1]), u = !(i[l] && o[l + 1]);
      if (d && u) {
        const f = fn(l, -1), g = fn(l + 1, this.viewItems.length), m = this.findFirstSnapIndex(f), _ = this.findFirstSnapIndex(g), b = typeof m == "number" && !this.viewItems[m].visible, C = typeof _ == "number" && !this.viewItems[_].visible;
        b && o[l] && (a > 0 || this.startSnappingEnabled) ? c.state = 1 : C && t[l] && (a < this._contentSize || this.endSnappingEnabled) ? c.state = 2 : c.state = 0;
      } else d && !u ? c.state = 1 : !d && u ? c.state = 2 : c.state = 3;
    }
  }
  getSashPosition(e) {
    let t = 0;
    for (let i = 0; i < this.sashItems.length; i++)
      if (t += this.viewItems[i].size, this.sashItems[i].sash === e)
        return t;
    return 0;
  }
  findFirstSnapIndex(e) {
    for (const t of e) {
      const i = this.viewItems[t];
      if (i.visible && i.snap)
        return t;
    }
    for (const t of e) {
      const i = this.viewItems[t];
      if (i.visible && i.maximumSize - i.minimumSize > 0)
        return;
      if (!i.visible && i.snap)
        return t;
    }
  }
  areViewsDistributed() {
    let e, t;
    for (const i of this.viewItems)
      if (e = e === void 0 ? i.size : Math.min(e, i.size), t = t === void 0 ? i.size : Math.max(t, i.size), t - e > 2)
        return !1;
    return !0;
  }
  dispose() {
    var e;
    (e = this.sashDragState) == null || e.disposable.dispose(), Ri(this.viewItems), this.viewItems = [], this.sashItems.forEach((t) => t.disposable.dispose()), this.sashItems = [], super.dispose();
  }
}
const E1 = class E1 {
  constructor(e, t, i) {
    this.columns = e, this.getColumnSize = i, this.templateId = E1.TemplateId, this.renderedTemplates = /* @__PURE__ */ new Set();
    const n = new Map(t.map((o) => [o.templateId, o]));
    this.renderers = [];
    for (const o of e) {
      const r = n.get(o.templateId);
      if (!r)
        throw new Error(`Table cell renderer for template id ${o.templateId} not found.`);
      this.renderers.push(r);
    }
  }
  renderTemplate(e) {
    const t = ae(e, pe(".monaco-table-tr")), i = [], n = [];
    for (let r = 0; r < this.columns.length; r++) {
      const a = this.renderers[r], l = ae(t, pe(".monaco-table-td", { "data-col-index": r }));
      l.style.width = `${this.getColumnSize(r)}px`, i.push(l), n.push(a.renderTemplate(l));
    }
    const o = { container: e, cellContainers: i, cellTemplateData: n };
    return this.renderedTemplates.add(o), o;
  }
  renderElement(e, t, i, n) {
    for (let o = 0; o < this.columns.length; o++) {
      const a = this.columns[o].project(e);
      this.renderers[o].renderElement(a, t, i.cellTemplateData[o], n);
    }
  }
  disposeElement(e, t, i, n) {
    for (let o = 0; o < this.columns.length; o++) {
      const r = this.renderers[o];
      if (r.disposeElement) {
        const l = this.columns[o].project(e);
        r.disposeElement(l, t, i.cellTemplateData[o], n);
      }
    }
  }
  disposeTemplate(e) {
    for (let t = 0; t < this.columns.length; t++)
      this.renderers[t].disposeTemplate(e.cellTemplateData[t]);
    oo(e.container), this.renderedTemplates.delete(e);
  }
  layoutColumn(e, t) {
    for (const { cellContainers: i } of this.renderedTemplates)
      i[e].style.width = `${t}px`;
  }
};
E1.TemplateId = "row";
let __ = E1;
function NK(s) {
  return {
    getHeight(e) {
      return s.getHeight(e);
    },
    getTemplateId() {
      return __.TemplateId;
    }
  };
}
class TK extends q {
  get minimumSize() {
    return this.column.minimumWidth ?? 120;
  }
  get maximumSize() {
    return this.column.maximumWidth ?? Number.POSITIVE_INFINITY;
  }
  get onDidChange() {
    return this.column.onDidChangeWidthConstraints ?? J.None;
  }
  constructor(e, t) {
    super(), this.column = e, this.index = t, this._onDidLayout = new O(), this.onDidLayout = this._onDidLayout.event, this.element = pe(".monaco-table-th", { "data-col-index": t }, e.label), e.tooltip && this._register(Yo().setupManagedHover(Cs("mouse"), this.element, e.tooltip));
  }
  layout(e) {
    this._onDidLayout.fire([this.index, e]);
  }
}
const I1 = class I1 {
  get onDidChangeFocus() {
    return this.list.onDidChangeFocus;
  }
  get onDidChangeSelection() {
    return this.list.onDidChangeSelection;
  }
  get onDidScroll() {
    return this.list.onDidScroll;
  }
  get onMouseDblClick() {
    return this.list.onMouseDblClick;
  }
  get onPointer() {
    return this.list.onPointer;
  }
  get onDidFocus() {
    return this.list.onDidFocus;
  }
  get scrollTop() {
    return this.list.scrollTop;
  }
  set scrollTop(e) {
    this.list.scrollTop = e;
  }
  get scrollHeight() {
    return this.list.scrollHeight;
  }
  get renderHeight() {
    return this.list.renderHeight;
  }
  get onDidDispose() {
    return this.list.onDidDispose;
  }
  constructor(e, t, i, n, o, r) {
    this.virtualDelegate = i, this.columns = n, this.domId = `table_id_${++I1.InstanceCount}`, this.disposables = new he(), this.cachedWidth = 0, this.cachedHeight = 0, this.domNode = ae(t, pe(`.monaco-table.${this.domId}`));
    const a = n.map((h, d) => this.disposables.add(new TK(h, d))), l = {
      size: a.reduce((h, d) => h + d.column.weight, 0),
      views: a.map((h) => ({ size: h.column.weight, view: h }))
    };
    this.splitview = this.disposables.add(new IK(this.domNode, {
      orientation: 1,
      scrollbarVisibility: 2,
      getSashOrthogonalSize: () => this.cachedHeight,
      descriptor: l
    })), this.splitview.el.style.height = `${i.headerRowHeight}px`, this.splitview.el.style.lineHeight = `${i.headerRowHeight}px`;
    const c = new __(n, o, (h) => this.splitview.getViewSize(h));
    this.list = this.disposables.add(new mo(e, this.domNode, NK(i), [c], r)), J.any(...a.map((h) => h.onDidLayout))(([h, d]) => c.layoutColumn(h, d), null, this.disposables), this.splitview.onDidSashReset((h) => {
      const d = n.reduce((f, g) => f + g.weight, 0), u = n[h].weight / d * this.cachedWidth;
      this.splitview.resizeView(h, u);
    }, null, this.disposables), this.styleElement = Os(this.domNode), this.style(KH);
  }
  updateOptions(e) {
    this.list.updateOptions(e);
  }
  splice(e, t, i = []) {
    this.list.splice(e, t, i);
  }
  getHTMLElement() {
    return this.domNode;
  }
  style(e) {
    const t = [];
    t.push(`.monaco-table.${this.domId} > .monaco-split-view2 .monaco-sash.vertical::before {
			top: ${this.virtualDelegate.headerRowHeight + 1}px;
			height: calc(100% - ${this.virtualDelegate.headerRowHeight}px);
		}`), this.styleElement.textContent = t.join(`
`), this.list.style(e);
  }
  getSelectedElements() {
    return this.list.getSelectedElements();
  }
  getSelection() {
    return this.list.getSelection();
  }
  getFocus() {
    return this.list.getFocus();
  }
  dispose() {
    this.disposables.dispose();
  }
};
I1.InstanceCount = 0;
let Wy = I1;
var qn;
(function(s) {
  s[s.Expanded = 0] = "Expanded", s[s.Collapsed = 1] = "Collapsed", s[s.PreserveOrExpanded = 2] = "PreserveOrExpanded", s[s.PreserveOrCollapsed = 3] = "PreserveOrCollapsed";
})(qn || (qn = {}));
var ql;
(function(s) {
  s[s.Unknown = 0] = "Unknown", s[s.Twistie = 1] = "Twistie", s[s.Element = 2] = "Element", s[s.Filter = 3] = "Filter";
})(ql || (ql = {}));
class Yn extends Error {
  constructor(e, t) {
    super(`TreeError [${e}] ${t}`);
  }
}
class Zk {
  constructor(e) {
    this.fn = e, this._map = /* @__PURE__ */ new WeakMap();
  }
  map(e) {
    let t = this._map.get(e);
    return t || (t = this.fn(e), this._map.set(e, t)), t;
  }
}
function Yk(s) {
  return typeof s == "object" && "visibility" in s && "data" in s;
}
function ng(s) {
  switch (s) {
    case !0:
      return 1;
    case !1:
      return 0;
    default:
      return s;
  }
}
function oC(s) {
  return typeof s.collapsible == "boolean";
}
class MK {
  constructor(e, t, i, n = {}) {
    this.user = e, this.list = t, this.rootRef = [], this.eventBufferer = new yg(), this._onDidChangeCollapseState = new O(), this.onDidChangeCollapseState = this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event), this._onDidChangeRenderNodeCount = new O(), this.onDidChangeRenderNodeCount = this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event), this._onDidSplice = new O(), this.onDidSplice = this._onDidSplice.event, this.refilterDelayer = new kg(sM), this.collapseByDefault = typeof n.collapseByDefault > "u" ? !1 : n.collapseByDefault, this.allowNonCollapsibleParents = n.allowNonCollapsibleParents ?? !1, this.filter = n.filter, this.autoExpandSingleChildren = typeof n.autoExpandSingleChildren > "u" ? !1 : n.autoExpandSingleChildren, this.root = {
      parent: void 0,
      element: i,
      children: [],
      depth: 0,
      visibleChildrenCount: 0,
      visibleChildIndex: -1,
      collapsible: !1,
      collapsed: !1,
      renderNodeCount: 0,
      visibility: 1,
      visible: !0,
      filterData: void 0
    };
  }
  splice(e, t, i = Ye.empty(), n = {}) {
    if (e.length === 0)
      throw new Yn(this.user, "Invalid tree location");
    n.diffIdentityProvider ? this.spliceSmart(n.diffIdentityProvider, e, t, i, n) : this.spliceSimple(e, t, i, n);
  }
  spliceSmart(e, t, i, n = Ye.empty(), o, r = o.diffDepth ?? 0) {
    const { parentNode: a } = this.getParentNodeWithListIndex(t);
    if (!a.lastDiffIds)
      return this.spliceSimple(t, i, n, o);
    const l = [...n], c = t[t.length - 1], h = new Er({ getElements: () => a.lastDiffIds }, {
      getElements: () => [
        ...a.children.slice(0, c),
        ...l,
        ...a.children.slice(c + i)
      ].map((m) => e.getId(m.element).toString())
    }).ComputeDiff(!1);
    if (h.quitEarly)
      return a.lastDiffIds = void 0, this.spliceSimple(t, i, l, o);
    const d = t.slice(0, -1), u = (m, _, b) => {
      if (r > 0)
        for (let C = 0; C < b; C++)
          m--, _--, this.spliceSmart(e, [...d, m, 0], Number.MAX_SAFE_INTEGER, l[_].children, o, r - 1);
    };
    let f = Math.min(a.children.length, c + i), g = l.length;
    for (const m of h.changes.sort((_, b) => b.originalStart - _.originalStart))
      u(f, g, f - (m.originalStart + m.originalLength)), f = m.originalStart, g = m.modifiedStart - c, this.spliceSimple([...d, f], m.originalLength, Ye.slice(l, g, g + m.modifiedLength), o);
    u(f, g, f);
  }
  spliceSimple(e, t, i = Ye.empty(), { onDidCreateNode: n, onDidDeleteNode: o, diffIdentityProvider: r }) {
    const { parentNode: a, listIndex: l, revealed: c, visible: h } = this.getParentNodeWithListIndex(e), d = [], u = Ye.map(i, (S) => this.createTreeNode(S, a, a.visible ? 1 : 0, c, d, n)), f = e[e.length - 1];
    let g = 0;
    for (let S = f; S >= 0 && S < a.children.length; S--) {
      const L = a.children[S];
      if (L.visible) {
        g = L.visibleChildIndex;
        break;
      }
    }
    const m = [];
    let _ = 0, b = 0;
    for (const S of u)
      m.push(S), b += S.renderNodeCount, S.visible && (S.visibleChildIndex = g + _++);
    const C = Qx(a.children, f, t, m);
    r ? a.lastDiffIds ? Qx(a.lastDiffIds, f, t, m.map((S) => r.getId(S.element).toString())) : a.lastDiffIds = a.children.map((S) => r.getId(S.element).toString()) : a.lastDiffIds = void 0;
    let v = 0;
    for (const S of C)
      S.visible && v++;
    if (v !== 0)
      for (let S = f + m.length; S < a.children.length; S++) {
        const L = a.children[S];
        L.visible && (L.visibleChildIndex -= v);
      }
    if (a.visibleChildrenCount += _ - v, c && h) {
      const S = C.reduce((L, k) => L + (k.visible ? k.renderNodeCount : 0), 0);
      this._updateAncestorsRenderNodeCount(a, b - S), this.list.splice(l, S, d);
    }
    if (C.length > 0 && o) {
      const S = (L) => {
        o(L), L.children.forEach(S);
      };
      C.forEach(S);
    }
    this._onDidSplice.fire({ insertedNodes: m, deletedNodes: C });
    let w = a;
    for (; w; ) {
      if (w.visibility === 2) {
        this.refilterDelayer.trigger(() => this.refilter());
        break;
      }
      w = w.parent;
    }
  }
  rerender(e) {
    if (e.length === 0)
      throw new Yn(this.user, "Invalid tree location");
    const { node: t, listIndex: i, revealed: n } = this.getTreeNodeWithListIndex(e);
    t.visible && n && this.list.splice(i, 1, [t]);
  }
  has(e) {
    return this.hasTreeNode(e);
  }
  getListIndex(e) {
    const { listIndex: t, visible: i, revealed: n } = this.getTreeNodeWithListIndex(e);
    return i && n ? t : -1;
  }
  getListRenderCount(e) {
    return this.getTreeNode(e).renderNodeCount;
  }
  isCollapsible(e) {
    return this.getTreeNode(e).collapsible;
  }
  setCollapsible(e, t) {
    const i = this.getTreeNode(e);
    typeof t > "u" && (t = !i.collapsible);
    const n = { collapsible: t };
    return this.eventBufferer.bufferEvents(() => this._setCollapseState(e, n));
  }
  isCollapsed(e) {
    return this.getTreeNode(e).collapsed;
  }
  setCollapsed(e, t, i) {
    const n = this.getTreeNode(e);
    typeof t > "u" && (t = !n.collapsed);
    const o = { collapsed: t, recursive: i || !1 };
    return this.eventBufferer.bufferEvents(() => this._setCollapseState(e, o));
  }
  _setCollapseState(e, t) {
    const { node: i, listIndex: n, revealed: o } = this.getTreeNodeWithListIndex(e), r = this._setListNodeCollapseState(i, n, o, t);
    if (i !== this.root && this.autoExpandSingleChildren && r && !oC(t) && i.collapsible && !i.collapsed && !t.recursive) {
      let a = -1;
      for (let l = 0; l < i.children.length; l++)
        if (i.children[l].visible)
          if (a > -1) {
            a = -1;
            break;
          } else
            a = l;
      a > -1 && this._setCollapseState([...e, a], t);
    }
    return r;
  }
  _setListNodeCollapseState(e, t, i, n) {
    const o = this._setNodeCollapseState(e, n, !1);
    if (!i || !e.visible || !o)
      return o;
    const r = e.renderNodeCount, a = this.updateNodeAfterCollapseChange(e), l = r - (t === -1 ? 0 : 1);
    return this.list.splice(t + 1, l, a.slice(1)), o;
  }
  _setNodeCollapseState(e, t, i) {
    let n;
    if (e === this.root ? n = !1 : (oC(t) ? (n = e.collapsible !== t.collapsible, e.collapsible = t.collapsible) : e.collapsible ? (n = e.collapsed !== t.collapsed, e.collapsed = t.collapsed) : n = !1, n && this._onDidChangeCollapseState.fire({ node: e, deep: i })), !oC(t) && t.recursive)
      for (const o of e.children)
        n = this._setNodeCollapseState(o, t, !0) || n;
    return n;
  }
  expandTo(e) {
    this.eventBufferer.bufferEvents(() => {
      let t = this.getTreeNode(e);
      for (; t.parent; )
        t = t.parent, e = e.slice(0, e.length - 1), t.collapsed && this._setCollapseState(e, { collapsed: !1, recursive: !1 });
    });
  }
  refilter() {
    const e = this.root.renderNodeCount, t = this.updateNodeAfterFilterChange(this.root);
    this.list.splice(0, e, t), this.refilterDelayer.cancel();
  }
  createTreeNode(e, t, i, n, o, r) {
    const a = {
      parent: t,
      element: e.element,
      children: [],
      depth: t.depth + 1,
      visibleChildrenCount: 0,
      visibleChildIndex: -1,
      collapsible: typeof e.collapsible == "boolean" ? e.collapsible : typeof e.collapsed < "u",
      collapsed: typeof e.collapsed > "u" ? this.collapseByDefault : e.collapsed,
      renderNodeCount: 1,
      visibility: 1,
      visible: !0,
      filterData: void 0
    }, l = this._filterNode(a, i);
    a.visibility = l, n && o.push(a);
    const c = e.children || Ye.empty(), h = n && l !== 0 && !a.collapsed;
    let d = 0, u = 1;
    for (const f of c) {
      const g = this.createTreeNode(f, a, l, h, o, r);
      a.children.push(g), u += g.renderNodeCount, g.visible && (g.visibleChildIndex = d++);
    }
    return this.allowNonCollapsibleParents || (a.collapsible = a.collapsible || a.children.length > 0), a.visibleChildrenCount = d, a.visible = l === 2 ? d > 0 : l === 1, a.visible ? a.collapsed || (a.renderNodeCount = u) : (a.renderNodeCount = 0, n && o.pop()), r == null || r(a), a;
  }
  updateNodeAfterCollapseChange(e) {
    const t = e.renderNodeCount, i = [];
    return this._updateNodeAfterCollapseChange(e, i), this._updateAncestorsRenderNodeCount(e.parent, i.length - t), i;
  }
  _updateNodeAfterCollapseChange(e, t) {
    if (e.visible === !1)
      return 0;
    if (t.push(e), e.renderNodeCount = 1, !e.collapsed)
      for (const i of e.children)
        e.renderNodeCount += this._updateNodeAfterCollapseChange(i, t);
    return this._onDidChangeRenderNodeCount.fire(e), e.renderNodeCount;
  }
  updateNodeAfterFilterChange(e) {
    const t = e.renderNodeCount, i = [];
    return this._updateNodeAfterFilterChange(e, e.visible ? 1 : 0, i), this._updateAncestorsRenderNodeCount(e.parent, i.length - t), i;
  }
  _updateNodeAfterFilterChange(e, t, i, n = !0) {
    let o;
    if (e !== this.root) {
      if (o = this._filterNode(e, t), o === 0)
        return e.visible = !1, e.renderNodeCount = 0, !1;
      n && i.push(e);
    }
    const r = i.length;
    e.renderNodeCount = e === this.root ? 0 : 1;
    let a = !1;
    if (!e.collapsed || o !== 0) {
      let l = 0;
      for (const c of e.children)
        a = this._updateNodeAfterFilterChange(c, o, i, n && !e.collapsed) || a, c.visible && (c.visibleChildIndex = l++);
      e.visibleChildrenCount = l;
    } else
      e.visibleChildrenCount = 0;
    return e !== this.root && (e.visible = o === 2 ? a : o === 1, e.visibility = o), e.visible ? e.collapsed || (e.renderNodeCount += i.length - r) : (e.renderNodeCount = 0, n && i.pop()), this._onDidChangeRenderNodeCount.fire(e), e.visible;
  }
  _updateAncestorsRenderNodeCount(e, t) {
    if (t !== 0)
      for (; e; )
        e.renderNodeCount += t, this._onDidChangeRenderNodeCount.fire(e), e = e.parent;
  }
  _filterNode(e, t) {
    const i = this.filter ? this.filter.filter(e.element, t) : 1;
    return typeof i == "boolean" ? (e.filterData = void 0, i ? 1 : 0) : Yk(i) ? (e.filterData = i.data, ng(i.visibility)) : (e.filterData = void 0, ng(i));
  }
  // cheap
  hasTreeNode(e, t = this.root) {
    if (!e || e.length === 0)
      return !0;
    const [i, ...n] = e;
    return i < 0 || i > t.children.length ? !1 : this.hasTreeNode(n, t.children[i]);
  }
  // cheap
  getTreeNode(e, t = this.root) {
    if (!e || e.length === 0)
      return t;
    const [i, ...n] = e;
    if (i < 0 || i > t.children.length)
      throw new Yn(this.user, "Invalid tree location");
    return this.getTreeNode(n, t.children[i]);
  }
  // expensive
  getTreeNodeWithListIndex(e) {
    if (e.length === 0)
      return { node: this.root, listIndex: -1, revealed: !0, visible: !1 };
    const { parentNode: t, listIndex: i, revealed: n, visible: o } = this.getParentNodeWithListIndex(e), r = e[e.length - 1];
    if (r < 0 || r > t.children.length)
      throw new Yn(this.user, "Invalid tree location");
    const a = t.children[r];
    return { node: a, listIndex: i, revealed: n, visible: o && a.visible };
  }
  getParentNodeWithListIndex(e, t = this.root, i = 0, n = !0, o = !0) {
    const [r, ...a] = e;
    if (r < 0 || r > t.children.length)
      throw new Yn(this.user, "Invalid tree location");
    for (let l = 0; l < r; l++)
      i += t.children[l].renderNodeCount;
    return n = n && !t.collapsed, o = o && t.visible, a.length === 0 ? { parentNode: t, listIndex: i, revealed: n, visible: o } : this.getParentNodeWithListIndex(a, t.children[r], i + 1, n, o);
  }
  getNode(e = []) {
    return this.getTreeNode(e);
  }
  // TODO@joao perf!
  getNodeLocation(e) {
    const t = [];
    let i = e;
    for (; i.parent; )
      t.push(i.parent.children.indexOf(i)), i = i.parent;
    return t.reverse();
  }
  getParentNodeLocation(e) {
    if (e.length !== 0)
      return e.length === 1 ? [] : R5(e)[0];
  }
  getFirstElementChild(e) {
    const t = this.getTreeNode(e);
    if (t.children.length !== 0)
      return t.children[0].element;
  }
}
class RK extends Bg {
  constructor(e) {
    super(e.elements.map((t) => t.element)), this.data = e;
  }
}
function rC(s) {
  return s instanceof Bg ? new RK(s) : s;
}
class AK {
  constructor(e, t) {
    this.modelProvider = e, this.dnd = t, this.autoExpandDisposable = q.None, this.disposables = new he();
  }
  getDragURI(e) {
    return this.dnd.getDragURI(e.element);
  }
  getDragLabel(e, t) {
    if (this.dnd.getDragLabel)
      return this.dnd.getDragLabel(e.map((i) => i.element), t);
  }
  onDragStart(e, t) {
    var i, n;
    (n = (i = this.dnd).onDragStart) == null || n.call(i, rC(e), t);
  }
  onDragOver(e, t, i, n, o, r = !0) {
    const a = this.dnd.onDragOver(rC(e), t && t.element, i, n, o), l = this.autoExpandNode !== t;
    if (l && (this.autoExpandDisposable.dispose(), this.autoExpandNode = t), typeof t > "u")
      return a;
    if (l && typeof a != "boolean" && a.autoExpand && (this.autoExpandDisposable = zw(() => {
      const f = this.modelProvider(), g = f.getNodeLocation(t);
      f.isCollapsed(g) && f.setCollapsed(g, !1), this.autoExpandNode = void 0;
    }, 500, this.disposables)), typeof a == "boolean" || !a.accept || typeof a.bubble > "u" || a.feedback) {
      if (!r) {
        const f = typeof a == "boolean" ? a : a.accept, g = typeof a == "boolean" ? void 0 : a.effect;
        return { accept: f, effect: g, feedback: [i] };
      }
      return a;
    }
    if (a.bubble === 1) {
      const f = this.modelProvider(), g = f.getNodeLocation(t), m = f.getParentNodeLocation(g), _ = f.getNode(m), b = m && f.getListIndex(m);
      return this.onDragOver(e, _, b, n, o, !1);
    }
    const c = this.modelProvider(), h = c.getNodeLocation(t), d = c.getListIndex(h), u = c.getListRenderCount(h);
    return { ...a, feedback: fn(d, d + u) };
  }
  drop(e, t, i, n, o) {
    this.autoExpandDisposable.dispose(), this.autoExpandNode = void 0, this.dnd.drop(rC(e), t && t.element, i, n, o);
  }
  onDragEnd(e) {
    var t, i;
    (i = (t = this.dnd).onDragEnd) == null || i.call(t, e);
  }
  dispose() {
    this.disposables.dispose(), this.dnd.dispose();
  }
}
function PK(s, e) {
  return e && {
    ...e,
    identityProvider: e.identityProvider && {
      getId(t) {
        return e.identityProvider.getId(t.element);
      }
    },
    dnd: e.dnd && new AK(s, e.dnd),
    multipleSelectionController: e.multipleSelectionController && {
      isSelectionSingleChangeEvent(t) {
        return e.multipleSelectionController.isSelectionSingleChangeEvent({ ...t, element: t.element });
      },
      isSelectionRangeChangeEvent(t) {
        return e.multipleSelectionController.isSelectionRangeChangeEvent({ ...t, element: t.element });
      }
    },
    accessibilityProvider: e.accessibilityProvider && {
      ...e.accessibilityProvider,
      getSetSize(t) {
        const i = s(), n = i.getNodeLocation(t), o = i.getParentNodeLocation(n);
        return i.getNode(o).visibleChildrenCount;
      },
      getPosInSet(t) {
        return t.visibleChildIndex + 1;
      },
      isChecked: e.accessibilityProvider && e.accessibilityProvider.isChecked ? (t) => e.accessibilityProvider.isChecked(t.element) : void 0,
      getRole: e.accessibilityProvider && e.accessibilityProvider.getRole ? (t) => e.accessibilityProvider.getRole(t.element) : () => "treeitem",
      getAriaLabel(t) {
        return e.accessibilityProvider.getAriaLabel(t.element);
      },
      getWidgetAriaLabel() {
        return e.accessibilityProvider.getWidgetAriaLabel();
      },
      getWidgetRole: e.accessibilityProvider && e.accessibilityProvider.getWidgetRole ? () => e.accessibilityProvider.getWidgetRole() : () => "tree",
      getAriaLevel: e.accessibilityProvider && e.accessibilityProvider.getAriaLevel ? (t) => e.accessibilityProvider.getAriaLevel(t.element) : (t) => t.depth,
      getActiveDescendantId: e.accessibilityProvider.getActiveDescendantId && ((t) => e.accessibilityProvider.getActiveDescendantId(t.element))
    },
    keyboardNavigationLabelProvider: e.keyboardNavigationLabelProvider && {
      ...e.keyboardNavigationLabelProvider,
      getKeyboardNavigationLabel(t) {
        return e.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(t.element);
      }
    }
  };
}
class Qk {
  constructor(e) {
    this.delegate = e;
  }
  getHeight(e) {
    return this.delegate.getHeight(e.element);
  }
  getTemplateId(e) {
    return this.delegate.getTemplateId(e.element);
  }
  hasDynamicHeight(e) {
    return !!this.delegate.hasDynamicHeight && this.delegate.hasDynamicHeight(e.element);
  }
  setDynamicHeight(e, t) {
    var i, n;
    (n = (i = this.delegate).setDynamicHeight) == null || n.call(i, e.element, t);
  }
}
var Md;
(function(s) {
  s.None = "none", s.OnHover = "onHover", s.Always = "always";
})(Md || (Md = {}));
class OK {
  get elements() {
    return this._elements;
  }
  constructor(e, t = []) {
    this._elements = t, this.disposables = new he(), this.onDidChange = J.forEach(e, (i) => this._elements = i, this.disposables);
  }
  dispose() {
    this.disposables.dispose();
  }
}
const yf = class yf {
  constructor(e, t, i, n, o, r = {}) {
    var a;
    this.renderer = e, this.modelProvider = t, this.activeNodes = n, this.renderedIndentGuides = o, this.renderedElements = /* @__PURE__ */ new Map(), this.renderedNodes = /* @__PURE__ */ new Map(), this.indent = yf.DefaultIndent, this.hideTwistiesOfChildlessElements = !1, this.shouldRenderIndentGuides = !1, this.activeIndentNodes = /* @__PURE__ */ new Set(), this.indentGuidesDisposable = q.None, this.disposables = new he(), this.templateId = e.templateId, this.updateOptions(r), J.map(i, (l) => l.node)(this.onDidChangeNodeTwistieState, this, this.disposables), (a = e.onDidChangeTwistieState) == null || a.call(e, this.onDidChangeTwistieState, this, this.disposables);
  }
  updateOptions(e = {}) {
    if (typeof e.indent < "u") {
      const t = gn(e.indent, 0, 40);
      if (t !== this.indent) {
        this.indent = t;
        for (const [i, n] of this.renderedNodes)
          this.renderTreeElement(i, n);
      }
    }
    if (typeof e.renderIndentGuides < "u") {
      const t = e.renderIndentGuides !== Md.None;
      if (t !== this.shouldRenderIndentGuides) {
        this.shouldRenderIndentGuides = t;
        for (const [i, n] of this.renderedNodes)
          this._renderIndentGuides(i, n);
        if (this.indentGuidesDisposable.dispose(), t) {
          const i = new he();
          this.activeNodes.onDidChange(this._onDidChangeActiveNodes, this, i), this.indentGuidesDisposable = i, this._onDidChangeActiveNodes(this.activeNodes.elements);
        }
      }
    }
    typeof e.hideTwistiesOfChildlessElements < "u" && (this.hideTwistiesOfChildlessElements = e.hideTwistiesOfChildlessElements);
  }
  renderTemplate(e) {
    const t = ae(e, pe(".monaco-tl-row")), i = ae(t, pe(".monaco-tl-indent")), n = ae(t, pe(".monaco-tl-twistie")), o = ae(t, pe(".monaco-tl-contents")), r = this.renderer.renderTemplate(o);
    return { container: e, indent: i, twistie: n, indentGuidesDisposable: q.None, templateData: r };
  }
  renderElement(e, t, i, n) {
    this.renderedNodes.set(e, i), this.renderedElements.set(e.element, e), this.renderTreeElement(e, i), this.renderer.renderElement(e, t, i.templateData, n);
  }
  disposeElement(e, t, i, n) {
    var o, r;
    i.indentGuidesDisposable.dispose(), (r = (o = this.renderer).disposeElement) == null || r.call(o, e, t, i.templateData, n), typeof n == "number" && (this.renderedNodes.delete(e), this.renderedElements.delete(e.element));
  }
  disposeTemplate(e) {
    this.renderer.disposeTemplate(e.templateData);
  }
  onDidChangeTwistieState(e) {
    const t = this.renderedElements.get(e);
    t && this.onDidChangeNodeTwistieState(t);
  }
  onDidChangeNodeTwistieState(e) {
    const t = this.renderedNodes.get(e);
    t && (this._onDidChangeActiveNodes(this.activeNodes.elements), this.renderTreeElement(e, t));
  }
  renderTreeElement(e, t) {
    const i = yf.DefaultIndent + (e.depth - 1) * this.indent;
    t.twistie.style.paddingLeft = `${i}px`, t.indent.style.width = `${i + this.indent - 16}px`, e.collapsible ? t.container.setAttribute("aria-expanded", String(!e.collapsed)) : t.container.removeAttribute("aria-expanded"), t.twistie.classList.remove(...Ke.asClassNameArray(re.treeItemExpanded));
    let n = !1;
    this.renderer.renderTwistie && (n = this.renderer.renderTwistie(e.element, t.twistie)), e.collapsible && (!this.hideTwistiesOfChildlessElements || e.visibleChildrenCount > 0) ? (n || t.twistie.classList.add(...Ke.asClassNameArray(re.treeItemExpanded)), t.twistie.classList.add("collapsible"), t.twistie.classList.toggle("collapsed", e.collapsed)) : t.twistie.classList.remove("collapsible", "collapsed"), this._renderIndentGuides(e, t);
  }
  _renderIndentGuides(e, t) {
    if (oo(t.indent), t.indentGuidesDisposable.dispose(), !this.shouldRenderIndentGuides)
      return;
    const i = new he(), n = this.modelProvider();
    for (; ; ) {
      const o = n.getNodeLocation(e), r = n.getParentNodeLocation(o);
      if (!r)
        break;
      const a = n.getNode(r), l = pe(".indent-guide", { style: `width: ${this.indent}px` });
      this.activeIndentNodes.has(a) && l.classList.add("active"), t.indent.childElementCount === 0 ? t.indent.appendChild(l) : t.indent.insertBefore(l, t.indent.firstElementChild), this.renderedIndentGuides.add(a, l), i.add(ke(() => this.renderedIndentGuides.delete(a, l))), e = a;
    }
    t.indentGuidesDisposable = i;
  }
  _onDidChangeActiveNodes(e) {
    if (!this.shouldRenderIndentGuides)
      return;
    const t = /* @__PURE__ */ new Set(), i = this.modelProvider();
    e.forEach((n) => {
      const o = i.getNodeLocation(n);
      try {
        const r = i.getParentNodeLocation(o);
        n.collapsible && n.children.length > 0 && !n.collapsed ? t.add(n) : r && t.add(i.getNode(r));
      } catch {
      }
    }), this.activeIndentNodes.forEach((n) => {
      t.has(n) || this.renderedIndentGuides.forEach(n, (o) => o.classList.remove("active"));
    }), t.forEach((n) => {
      this.activeIndentNodes.has(n) || this.renderedIndentGuides.forEach(n, (o) => o.classList.add("active"));
    }), this.activeIndentNodes = t;
  }
  dispose() {
    this.renderedNodes.clear(), this.renderedElements.clear(), this.indentGuidesDisposable.dispose(), Ri(this.disposables);
  }
};
yf.DefaultIndent = 8;
let Vy = yf;
class FK {
  get totalCount() {
    return this._totalCount;
  }
  get matchCount() {
    return this._matchCount;
  }
  constructor(e, t, i) {
    this.tree = e, this.keyboardNavigationLabelProvider = t, this._filter = i, this._totalCount = 0, this._matchCount = 0, this._pattern = "", this._lowercasePattern = "", this.disposables = new he(), e.onWillRefilter(this.reset, this, this.disposables);
  }
  filter(e, t) {
    let i = 1;
    if (this._filter) {
      const r = this._filter.filter(e, t);
      if (typeof r == "boolean" ? i = r ? 1 : 0 : Yk(r) ? i = ng(r.visibility) : i = r, i === 0)
        return !1;
    }
    if (this._totalCount++, !this._pattern)
      return this._matchCount++, { data: Zh.Default, visibility: i };
    const n = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e), o = Array.isArray(n) ? n : [n];
    for (const r of o) {
      const a = r && r.toString();
      if (typeof a > "u")
        return { data: Zh.Default, visibility: i };
      let l;
      if (this.tree.findMatchType === yc.Contiguous) {
        const c = a.toLowerCase().indexOf(this._lowercasePattern);
        if (c > -1) {
          l = [Number.MAX_SAFE_INTEGER, 0];
          for (let h = this._lowercasePattern.length; h > 0; h--)
            l.push(c + h - 1);
        }
      } else
        l = iA(this._pattern, this._lowercasePattern, 0, a, a.toLowerCase(), 0, { firstMatchCanBeWeak: !0, boostFullMatch: !0 });
      if (l)
        return this._matchCount++, o.length === 1 ? { data: l, visibility: i } : { data: { label: a, score: l }, visibility: i };
    }
    return this.tree.findMode === Pr.Filter ? typeof this.tree.options.defaultFindVisibility == "number" ? this.tree.options.defaultFindVisibility : this.tree.options.defaultFindVisibility ? this.tree.options.defaultFindVisibility(e) : 2 : { data: Zh.Default, visibility: i };
  }
  reset() {
    this._totalCount = 0, this._matchCount = 0;
  }
  dispose() {
    Ri(this.disposables);
  }
}
var Pr;
(function(s) {
  s[s.Highlight = 0] = "Highlight", s[s.Filter = 1] = "Filter";
})(Pr || (Pr = {}));
var yc;
(function(s) {
  s[s.Fuzzy = 0] = "Fuzzy", s[s.Contiguous = 1] = "Contiguous";
})(yc || (yc = {}));
class BK {
  get pattern() {
    return this._pattern;
  }
  get mode() {
    return this._mode;
  }
  set mode(e) {
    e !== this._mode && (this._mode = e, this.widget && (this.widget.mode = this._mode), this.tree.refilter(), this.render(), this._onDidChangeMode.fire(e));
  }
  get matchType() {
    return this._matchType;
  }
  set matchType(e) {
    e !== this._matchType && (this._matchType = e, this.widget && (this.widget.matchType = this._matchType), this.tree.refilter(), this.render(), this._onDidChangeMatchType.fire(e));
  }
  constructor(e, t, i, n, o, r = {}) {
    this.tree = e, this.view = i, this.filter = n, this.contextViewProvider = o, this.options = r, this._pattern = "", this.width = 0, this._onDidChangeMode = new O(), this.onDidChangeMode = this._onDidChangeMode.event, this._onDidChangeMatchType = new O(), this.onDidChangeMatchType = this._onDidChangeMatchType.event, this._onDidChangePattern = new O(), this._onDidChangeOpenState = new O(), this.onDidChangeOpenState = this._onDidChangeOpenState.event, this.enabledDisposables = new he(), this.disposables = new he(), this._mode = e.options.defaultFindMode ?? Pr.Highlight, this._matchType = e.options.defaultFindMatchType ?? yc.Fuzzy, t.onDidSplice(this.onDidSpliceModel, this, this.disposables);
  }
  updateOptions(e = {}) {
    e.defaultFindMode !== void 0 && (this.mode = e.defaultFindMode), e.defaultFindMatchType !== void 0 && (this.matchType = e.defaultFindMatchType);
  }
  onDidSpliceModel() {
    !this.widget || this.pattern.length === 0 || (this.tree.refilter(), this.render());
  }
  render() {
    var t, i, n;
    const e = this.filter.totalCount > 0 && this.filter.matchCount === 0;
    this.pattern && e ? (Gf(p("replFindNoResults", "No results")), this.tree.options.showNotFoundMessage ?? !0 ? (t = this.widget) == null || t.showMessage({ type: 2, content: p("not found", "No elements found.") }) : (i = this.widget) == null || i.showMessage({
      type: 2
      /* MessageType.WARNING */
    })) : ((n = this.widget) == null || n.clearMessage(), this.pattern && Gf(p("replFindResults", "{0} results", this.filter.matchCount)));
  }
  shouldAllowFocus(e) {
    return !this.widget || !this.pattern || this.filter.totalCount > 0 && this.filter.matchCount <= 1 ? !0 : !Zh.isDefault(e.filterData);
  }
  layout(e) {
    var t;
    this.width = e, (t = this.widget) == null || t.layout(e);
  }
  dispose() {
    this._history = void 0, this._onDidChangePattern.dispose(), this.enabledDisposables.dispose(), this.disposables.dispose();
  }
}
function WK(s, e) {
  return s.position === e.position && g4(s, e);
}
function g4(s, e) {
  return s.node.element === e.node.element && s.startIndex === e.startIndex && s.height === e.height && s.endIndex === e.endIndex;
}
class VK {
  constructor(e = []) {
    this.stickyNodes = e;
  }
  get count() {
    return this.stickyNodes.length;
  }
  equal(e) {
    return oi(this.stickyNodes, e.stickyNodes, WK);
  }
  lastNodePartiallyVisible() {
    if (this.count === 0)
      return !1;
    const e = this.stickyNodes[this.count - 1];
    if (this.count === 1)
      return e.position !== 0;
    const t = this.stickyNodes[this.count - 2];
    return t.position + t.height !== e.position;
  }
  animationStateChanged(e) {
    if (!oi(this.stickyNodes, e.stickyNodes, g4) || this.count === 0)
      return !1;
    const t = this.stickyNodes[this.count - 1], i = e.stickyNodes[e.count - 1];
    return t.position !== i.position;
  }
}
class HK {
  constrainStickyScrollNodes(e, t, i) {
    for (let n = 0; n < e.length; n++) {
      const o = e[n];
      if (o.position + o.height > i || n >= t)
        return e.slice(0, n);
    }
    return e;
  }
}
class DN extends q {
  constructor(e, t, i, n, o, r = {}) {
    super(), this.tree = e, this.model = t, this.view = i, this.treeDelegate = o, this.maxWidgetViewRatio = 0.4;
    const a = this.validateStickySettings(r);
    this.stickyScrollMaxItemCount = a.stickyScrollMaxItemCount, this.stickyScrollDelegate = r.stickyScrollDelegate ?? new HK(), this._widget = this._register(new zK(i.getScrollableElement(), i, e, n, o, r.accessibilityProvider)), this.onDidChangeHasFocus = this._widget.onDidChangeHasFocus, this.onContextMenu = this._widget.onContextMenu, this._register(i.onDidScroll(() => this.update())), this._register(i.onDidChangeContentHeight(() => this.update())), this._register(e.onDidChangeCollapseState(() => this.update())), this.update();
  }
  get height() {
    return this._widget.height;
  }
  getNodeAtHeight(e) {
    let t;
    if (e === 0 ? t = this.view.firstVisibleIndex : t = this.view.indexAt(e + this.view.scrollTop), !(t < 0 || t >= this.view.length))
      return this.view.element(t);
  }
  update() {
    const e = this.getNodeAtHeight(0);
    if (!e || this.tree.scrollTop === 0) {
      this._widget.setState(void 0);
      return;
    }
    const t = this.findStickyState(e);
    this._widget.setState(t);
  }
  findStickyState(e) {
    const t = [];
    let i = e, n = 0, o = this.getNextStickyNode(i, void 0, n);
    for (; o && (t.push(o), n += o.height, !(t.length <= this.stickyScrollMaxItemCount && (i = this.getNextVisibleNode(o), !i))); )
      o = this.getNextStickyNode(i, o.node, n);
    const r = this.constrainStickyNodes(t);
    return r.length ? new VK(r) : void 0;
  }
  getNextVisibleNode(e) {
    return this.getNodeAtHeight(e.position + e.height);
  }
  getNextStickyNode(e, t, i) {
    const n = this.getAncestorUnderPrevious(e, t);
    if (n && !(n === e && (!this.nodeIsUncollapsedParent(e) || this.nodeTopAlignsWithStickyNodesBottom(e, i))))
      return this.createStickyScrollNode(n, i);
  }
  nodeTopAlignsWithStickyNodesBottom(e, t) {
    const i = this.getNodeIndex(e), n = this.view.getElementTop(i), o = t;
    return this.view.scrollTop === n - o;
  }
  createStickyScrollNode(e, t) {
    const i = this.treeDelegate.getHeight(e), { startIndex: n, endIndex: o } = this.getNodeRange(e), r = this.calculateStickyNodePosition(o, t, i);
    return { node: e, position: r, height: i, startIndex: n, endIndex: o };
  }
  getAncestorUnderPrevious(e, t = void 0) {
    let i = e, n = this.getParentNode(i);
    for (; n; ) {
      if (n === t)
        return i;
      i = n, n = this.getParentNode(i);
    }
    if (t === void 0)
      return i;
  }
  calculateStickyNodePosition(e, t, i) {
    let n = this.view.getRelativeTop(e);
    if (n === null && this.view.firstVisibleIndex === e && e + 1 < this.view.length) {
      const c = this.treeDelegate.getHeight(this.view.element(e)), h = this.view.getRelativeTop(e + 1);
      n = h ? h - c / this.view.renderHeight : null;
    }
    if (n === null)
      return t;
    const o = this.view.element(e), r = this.treeDelegate.getHeight(o), l = n * this.view.renderHeight + r;
    return t + i > l && t <= l ? l - i : t;
  }
  constrainStickyNodes(e) {
    if (e.length === 0)
      return [];
    const t = this.view.renderHeight * this.maxWidgetViewRatio, i = e[e.length - 1];
    if (e.length <= this.stickyScrollMaxItemCount && i.position + i.height <= t)
      return e;
    const n = this.stickyScrollDelegate.constrainStickyScrollNodes(e, this.stickyScrollMaxItemCount, t);
    if (!n.length)
      return [];
    const o = n[n.length - 1];
    if (n.length > this.stickyScrollMaxItemCount || o.position + o.height > t)
      throw new Error("stickyScrollDelegate violates constraints");
    return n;
  }
  getParentNode(e) {
    const t = this.model.getNodeLocation(e), i = this.model.getParentNodeLocation(t);
    return i ? this.model.getNode(i) : void 0;
  }
  nodeIsUncollapsedParent(e) {
    const t = this.model.getNodeLocation(e);
    return this.model.getListRenderCount(t) > 1;
  }
  getNodeIndex(e) {
    const t = this.model.getNodeLocation(e);
    return this.model.getListIndex(t);
  }
  getNodeRange(e) {
    const t = this.model.getNodeLocation(e), i = this.model.getListIndex(t);
    if (i < 0)
      throw new Error("Node not found in tree");
    const n = this.model.getListRenderCount(t), o = i + n - 1;
    return { startIndex: i, endIndex: o };
  }
  nodePositionTopBelowWidget(e) {
    const t = [];
    let i = this.getParentNode(e);
    for (; i; )
      t.push(i), i = this.getParentNode(i);
    let n = 0;
    for (let o = 0; o < t.length && o < this.stickyScrollMaxItemCount; o++)
      n += this.treeDelegate.getHeight(t[o]);
    return n;
  }
  domFocus() {
    this._widget.domFocus();
  }
  // Whether sticky scroll was the last focused part in the tree or not
  focusedLast() {
    return this._widget.focusedLast();
  }
  updateOptions(e = {}) {
    if (!e.stickyScrollMaxItemCount)
      return;
    const t = this.validateStickySettings(e);
    this.stickyScrollMaxItemCount !== t.stickyScrollMaxItemCount && (this.stickyScrollMaxItemCount = t.stickyScrollMaxItemCount, this.update());
  }
  validateStickySettings(e) {
    let t = 7;
    return typeof e.stickyScrollMaxItemCount == "number" && (t = Math.max(e.stickyScrollMaxItemCount, 1)), { stickyScrollMaxItemCount: t };
  }
}
class zK {
  constructor(e, t, i, n, o, r) {
    this.view = t, this.tree = i, this.treeRenderers = n, this.treeDelegate = o, this.accessibilityProvider = r, this._previousElements = [], this._previousStateDisposables = new he(), this._rootDomNode = pe(".monaco-tree-sticky-container.empty"), e.appendChild(this._rootDomNode);
    const a = pe(".monaco-tree-sticky-container-shadow");
    this._rootDomNode.appendChild(a), this.stickyScrollFocus = new UK(this._rootDomNode, t), this.onDidChangeHasFocus = this.stickyScrollFocus.onDidChangeHasFocus, this.onContextMenu = this.stickyScrollFocus.onContextMenu;
  }
  get height() {
    if (!this._previousState)
      return 0;
    const e = this._previousState.stickyNodes[this._previousState.count - 1];
    return e.position + e.height;
  }
  setState(e) {
    const t = !!this._previousState && this._previousState.count > 0, i = !!e && e.count > 0;
    if (!t && !i || t && i && this._previousState.equal(e))
      return;
    if (t !== i && this.setVisible(i), !i) {
      this._previousState = void 0, this._previousElements = [], this._previousStateDisposables.clear();
      return;
    }
    const n = e.stickyNodes[e.count - 1];
    if (this._previousState && e.animationStateChanged(this._previousState))
      this._previousElements[this._previousState.count - 1].style.top = `${n.position}px`;
    else {
      this._previousStateDisposables.clear();
      const o = Array(e.count);
      for (let r = e.count - 1; r >= 0; r--) {
        const a = e.stickyNodes[r], { element: l, disposable: c } = this.createElement(a, r, e.count);
        o[r] = l, this._rootDomNode.appendChild(l), this._previousStateDisposables.add(c);
      }
      this.stickyScrollFocus.updateElements(o, e), this._previousElements = o;
    }
    this._previousState = e, this._rootDomNode.style.height = `${n.position + n.height}px`;
  }
  createElement(e, t, i) {
    const n = e.startIndex, o = document.createElement("div");
    o.style.top = `${e.position}px`, this.tree.options.setRowHeight !== !1 && (o.style.height = `${e.height}px`), this.tree.options.setRowLineHeight !== !1 && (o.style.lineHeight = `${e.height}px`), o.classList.add("monaco-tree-sticky-row"), o.classList.add("monaco-list-row"), o.setAttribute("data-index", `${n}`), o.setAttribute("data-parity", n % 2 === 0 ? "even" : "odd"), o.setAttribute("id", this.view.getElementID(n));
    const r = this.setAccessibilityAttributes(o, e.node.element, t, i), a = this.treeDelegate.getTemplateId(e.node), l = this.treeRenderers.find((u) => u.templateId === a);
    if (!l)
      throw new Error(`No renderer found for template id ${a}`);
    let c = e.node;
    c === this.tree.getNode(this.tree.getNodeLocation(e.node)) && (c = new Proxy(e.node, {}));
    const h = l.renderTemplate(o);
    l.renderElement(c, e.startIndex, h, e.height);
    const d = ke(() => {
      r.dispose(), l.disposeElement(c, e.startIndex, h, e.height), l.disposeTemplate(h), o.remove();
    });
    return { element: o, disposable: d };
  }
  setAccessibilityAttributes(e, t, i, n) {
    if (!this.accessibilityProvider)
      return q.None;
    this.accessibilityProvider.getSetSize && e.setAttribute("aria-setsize", String(this.accessibilityProvider.getSetSize(t, i, n))), this.accessibilityProvider.getPosInSet && e.setAttribute("aria-posinset", String(this.accessibilityProvider.getPosInSet(t, i))), this.accessibilityProvider.getRole && e.setAttribute("role", this.accessibilityProvider.getRole(t) ?? "treeitem");
    const o = this.accessibilityProvider.getAriaLabel(t), r = o && typeof o != "string" ? o : n_(o), a = Qe((c) => {
      const h = c.readObservable(r);
      h ? e.setAttribute("aria-label", h) : e.removeAttribute("aria-label");
    });
    typeof o == "string" || o && e.setAttribute("aria-label", o.get());
    const l = this.accessibilityProvider.getAriaLevel && this.accessibilityProvider.getAriaLevel(t);
    return typeof l == "number" && e.setAttribute("aria-level", `${l}`), e.setAttribute("aria-selected", String(!1)), a;
  }
  setVisible(e) {
    this._rootDomNode.classList.toggle("empty", !e), e || this.stickyScrollFocus.updateElements([], void 0);
  }
  domFocus() {
    this.stickyScrollFocus.domFocus();
  }
  focusedLast() {
    return this.stickyScrollFocus.focusedLast();
  }
  dispose() {
    this.stickyScrollFocus.dispose(), this._previousStateDisposables.dispose(), this._rootDomNode.remove();
  }
}
class UK extends q {
  get domHasFocus() {
    return this._domHasFocus;
  }
  set domHasFocus(e) {
    e !== this._domHasFocus && (this._onDidChangeHasFocus.fire(e), this._domHasFocus = e);
  }
  constructor(e, t) {
    super(), this.container = e, this.view = t, this.focusedIndex = -1, this.elements = [], this._onDidChangeHasFocus = new O(), this.onDidChangeHasFocus = this._onDidChangeHasFocus.event, this._onContextMenu = new O(), this.onContextMenu = this._onContextMenu.event, this._domHasFocus = !1, this._register($(this.container, "focus", () => this.onFocus())), this._register($(this.container, "blur", () => this.onBlur())), this._register(this.view.onDidFocus(() => this.toggleStickyScrollFocused(!1))), this._register(this.view.onKeyDown((i) => this.onKeyDown(i))), this._register(this.view.onMouseDown((i) => this.onMouseDown(i))), this._register(this.view.onContextMenu((i) => this.handleContextMenu(i)));
  }
  handleContextMenu(e) {
    const t = e.browserEvent.target;
    if (!Yf(t) && !ju(t)) {
      this.focusedLast() && this.view.domFocus();
      return;
    }
    if (!wr(e.browserEvent)) {
      if (!this.state)
        throw new Error("Context menu should not be triggered when state is undefined");
      const r = this.state.stickyNodes.findIndex((a) => {
        var l;
        return a.node.element === ((l = e.element) == null ? void 0 : l.element);
      });
      if (r === -1)
        throw new Error("Context menu should not be triggered when element is not in sticky scroll widget");
      this.container.focus(), this.setFocus(r);
      return;
    }
    if (!this.state || this.focusedIndex < 0)
      throw new Error("Context menu key should not be triggered when focus is not in sticky scroll widget");
    const n = this.state.stickyNodes[this.focusedIndex].node.element, o = this.elements[this.focusedIndex];
    this._onContextMenu.fire({ element: n, anchor: o, browserEvent: e.browserEvent, isStickyScroll: !0 });
  }
  onKeyDown(e) {
    if (this.domHasFocus && this.state) {
      if (e.key === "ArrowUp")
        this.setFocusedElement(Math.max(0, this.focusedIndex - 1)), e.preventDefault(), e.stopPropagation();
      else if (e.key === "ArrowDown" || e.key === "ArrowRight") {
        if (this.focusedIndex >= this.state.count - 1) {
          const t = this.state.stickyNodes[this.state.count - 1].startIndex + 1;
          this.view.domFocus(), this.view.setFocus([t]), this.scrollNodeUnderWidget(t, this.state);
        } else
          this.setFocusedElement(this.focusedIndex + 1);
        e.preventDefault(), e.stopPropagation();
      }
    }
  }
  onMouseDown(e) {
    const t = e.browserEvent.target;
    !Yf(t) && !ju(t) || (e.browserEvent.preventDefault(), e.browserEvent.stopPropagation());
  }
  updateElements(e, t) {
    if (t && t.count === 0)
      throw new Error("Sticky scroll state must be undefined when there are no sticky nodes");
    if (t && t.count !== e.length)
      throw new Error("Sticky scroll focus received illigel state");
    const i = this.focusedIndex;
    if (this.removeFocus(), this.elements = e, this.state = t, t) {
      const n = gn(i, 0, t.count - 1);
      this.setFocus(n);
    } else
      this.domHasFocus && this.view.domFocus();
    this.container.tabIndex = t ? 0 : -1;
  }
  setFocusedElement(e) {
    const t = this.state;
    if (!t)
      throw new Error("Cannot set focus when state is undefined");
    if (this.setFocus(e), !(e < t.count - 1) && t.lastNodePartiallyVisible()) {
      const i = t.stickyNodes[e];
      this.scrollNodeUnderWidget(i.endIndex + 1, t);
    }
  }
  scrollNodeUnderWidget(e, t) {
    const i = t.stickyNodes[t.count - 1], n = t.count > 1 ? t.stickyNodes[t.count - 2] : void 0, o = this.view.getElementTop(e), r = n ? n.position + n.height + i.height : i.height;
    this.view.scrollTop = o - r;
  }
  domFocus() {
    if (!this.state)
      throw new Error("Cannot focus when state is undefined");
    this.container.focus();
  }
  focusedLast() {
    return this.state ? this.view.getHTMLElement().classList.contains("sticky-scroll-focused") : !1;
  }
  removeFocus() {
    this.focusedIndex !== -1 && (this.toggleElementFocus(this.elements[this.focusedIndex], !1), this.focusedIndex = -1);
  }
  setFocus(e) {
    if (0 > e)
      throw new Error("addFocus() can not remove focus");
    if (!this.state && e >= 0)
      throw new Error("Cannot set focus index when state is undefined");
    if (this.state && e >= this.state.count)
      throw new Error("Cannot set focus index to an index that does not exist");
    const t = this.focusedIndex;
    t >= 0 && this.toggleElementFocus(this.elements[t], !1), e >= 0 && this.toggleElementFocus(this.elements[e], !0), this.focusedIndex = e;
  }
  toggleElementFocus(e, t) {
    this.toggleElementActiveFocus(e, t && this.domHasFocus), this.toggleElementPassiveFocus(e, t);
  }
  toggleCurrentElementActiveFocus(e) {
    this.focusedIndex !== -1 && this.toggleElementActiveFocus(this.elements[this.focusedIndex], e);
  }
  toggleElementActiveFocus(e, t) {
    e.classList.toggle("focused", t);
  }
  toggleElementPassiveFocus(e, t) {
    e.classList.toggle("passive-focused", t);
  }
  toggleStickyScrollFocused(e) {
    this.view.getHTMLElement().classList.toggle("sticky-scroll-focused", e);
  }
  onFocus() {
    if (!this.state || this.elements.length === 0)
      throw new Error("Cannot focus when state is undefined or elements are empty");
    this.domHasFocus = !0, this.toggleStickyScrollFocused(!0), this.toggleCurrentElementActiveFocus(!0), this.focusedIndex === -1 && this.setFocus(0);
  }
  onBlur() {
    this.domHasFocus = !1, this.toggleCurrentElementActiveFocus(!1);
  }
  dispose() {
    this.toggleStickyScrollFocused(!1), this._onDidChangeHasFocus.fire(!1), super.dispose();
  }
}
function Nm(s) {
  let e = ql.Unknown;
  return C0(s.browserEvent.target, "monaco-tl-twistie", "monaco-tl-row") ? e = ql.Twistie : C0(s.browserEvent.target, "monaco-tl-contents", "monaco-tl-row") ? e = ql.Element : C0(s.browserEvent.target, "monaco-tree-type-filter", "monaco-list") && (e = ql.Filter), {
    browserEvent: s.browserEvent,
    element: s.element ? s.element.element : null,
    target: e
  };
}
function $K(s) {
  const e = Yf(s.browserEvent.target);
  return {
    element: s.element ? s.element.element : null,
    browserEvent: s.browserEvent,
    anchor: s.anchor,
    isStickyScroll: e
  };
}
function rp(s, e) {
  e(s), s.children.forEach((t) => rp(t, e));
}
class aC {
  get nodeSet() {
    return this._nodeSet || (this._nodeSet = this.createNodeSet()), this._nodeSet;
  }
  constructor(e, t) {
    this.getFirstViewElementWithTrait = e, this.identityProvider = t, this.nodes = [], this._onDidChange = new O(), this.onDidChange = this._onDidChange.event;
  }
  set(e, t) {
    !(t != null && t.__forceEvent) && oi(this.nodes, e) || this._set(e, !1, t);
  }
  _set(e, t, i) {
    if (this.nodes = [...e], this.elements = void 0, this._nodeSet = void 0, !t) {
      const n = this;
      this._onDidChange.fire({ get elements() {
        return n.get();
      }, browserEvent: i });
    }
  }
  get() {
    return this.elements || (this.elements = this.nodes.map((e) => e.element)), [...this.elements];
  }
  getNodes() {
    return this.nodes;
  }
  has(e) {
    return this.nodeSet.has(e);
  }
  onDidModelSplice({ insertedNodes: e, deletedNodes: t }) {
    if (!this.identityProvider) {
      const l = this.createNodeSet(), c = (h) => l.delete(h);
      t.forEach((h) => rp(h, c)), this.set([...l.values()]);
      return;
    }
    const i = /* @__PURE__ */ new Set(), n = (l) => i.add(this.identityProvider.getId(l.element).toString());
    t.forEach((l) => rp(l, n));
    const o = /* @__PURE__ */ new Map(), r = (l) => o.set(this.identityProvider.getId(l.element).toString(), l);
    e.forEach((l) => rp(l, r));
    const a = [];
    for (const l of this.nodes) {
      const c = this.identityProvider.getId(l.element).toString();
      if (!i.has(c))
        a.push(l);
      else {
        const d = o.get(c);
        d && d.visible && a.push(d);
      }
    }
    if (this.nodes.length > 0 && a.length === 0) {
      const l = this.getFirstViewElementWithTrait();
      l && a.push(l);
    }
    this._set(a, !0);
  }
  createNodeSet() {
    const e = /* @__PURE__ */ new Set();
    for (const t of this.nodes)
      e.add(t);
    return e;
  }
}
class KK extends kA {
  constructor(e, t, i) {
    super(e), this.tree = t, this.stickyScrollProvider = i;
  }
  onViewPointer(e) {
    if (vA(e.browserEvent.target) || Wa(e.browserEvent.target) || Nu(e.browserEvent.target) || e.browserEvent.isHandledByList)
      return;
    const t = e.element;
    if (!t)
      return super.onViewPointer(e);
    if (this.isSelectionRangeChangeEvent(e) || this.isSelectionSingleChangeEvent(e))
      return super.onViewPointer(e);
    const i = e.browserEvent.target, n = i.classList.contains("monaco-tl-twistie") || i.classList.contains("monaco-icon-label") && i.classList.contains("folder-icon") && e.browserEvent.offsetX < 16, o = ju(e.browserEvent.target);
    let r = !1;
    if (o ? r = !0 : typeof this.tree.expandOnlyOnTwistieClick == "function" ? r = this.tree.expandOnlyOnTwistieClick(t.element) : r = !!this.tree.expandOnlyOnTwistieClick, o)
      this.handleStickyScrollMouseEvent(e, t);
    else {
      if (r && !n && e.browserEvent.detail !== 2)
        return super.onViewPointer(e);
      if (!this.tree.expandOnDoubleClick && e.browserEvent.detail === 2)
        return super.onViewPointer(e);
    }
    if (t.collapsible && (!o || n)) {
      const a = this.tree.getNodeLocation(t), l = e.browserEvent.altKey;
      if (this.tree.setFocus([a]), this.tree.toggleCollapsed(a, l), n) {
        e.browserEvent.isHandledByList = !0;
        return;
      }
    }
    o || super.onViewPointer(e);
  }
  handleStickyScrollMouseEvent(e, t) {
    if (WH(e.browserEvent.target) || VH(e.browserEvent.target))
      return;
    const i = this.stickyScrollProvider();
    if (!i)
      throw new Error("Sticky scroll controller not found");
    const n = this.list.indexOf(t), o = this.list.getElementTop(n), r = i.nodePositionTopBelowWidget(t);
    this.tree.scrollTop = o - r, this.list.domFocus(), this.list.setFocus([n]), this.list.setSelection([n]);
  }
  onDoubleClick(e) {
    e.browserEvent.target.classList.contains("monaco-tl-twistie") || !this.tree.expandOnDoubleClick || e.browserEvent.isHandledByList || super.onDoubleClick(e);
  }
  // to make sure dom focus is not stolen (for example with context menu)
  onMouseDown(e) {
    const t = e.browserEvent.target;
    if (!Yf(t) && !ju(t)) {
      super.onMouseDown(e);
      return;
    }
  }
  onContextMenu(e) {
    const t = e.browserEvent.target;
    if (!Yf(t) && !ju(t)) {
      super.onContextMenu(e);
      return;
    }
  }
}
class qK extends mo {
  constructor(e, t, i, n, o, r, a, l) {
    super(e, t, i, n, l), this.focusTrait = o, this.selectionTrait = r, this.anchorTrait = a;
  }
  createMouseController(e) {
    return new KK(this, e.tree, e.stickyScrollProvider);
  }
  splice(e, t, i = []) {
    if (super.splice(e, t, i), i.length === 0)
      return;
    const n = [], o = [];
    let r;
    i.forEach((a, l) => {
      this.focusTrait.has(a) && n.push(e + l), this.selectionTrait.has(a) && o.push(e + l), this.anchorTrait.has(a) && (r = e + l);
    }), n.length > 0 && super.setFocus(uc([...super.getFocus(), ...n])), o.length > 0 && super.setSelection(uc([...super.getSelection(), ...o])), typeof r == "number" && super.setAnchor(r);
  }
  setFocus(e, t, i = !1) {
    super.setFocus(e, t), i || this.focusTrait.set(e.map((n) => this.element(n)), t);
  }
  setSelection(e, t, i = !1) {
    super.setSelection(e, t), i || this.selectionTrait.set(e.map((n) => this.element(n)), t);
  }
  setAnchor(e, t = !1) {
    super.setAnchor(e), t || (typeof e > "u" ? this.anchorTrait.set([]) : this.anchorTrait.set([this.element(e)]));
  }
}
class m4 {
  get onDidScroll() {
    return this.view.onDidScroll;
  }
  get onDidChangeFocus() {
    return this.eventBufferer.wrapEvent(this.focus.onDidChange);
  }
  get onDidChangeSelection() {
    return this.eventBufferer.wrapEvent(this.selection.onDidChange);
  }
  get onMouseDblClick() {
    return J.filter(J.map(this.view.onMouseDblClick, Nm), (e) => e.target !== ql.Filter);
  }
  get onMouseOver() {
    return J.map(this.view.onMouseOver, Nm);
  }
  get onMouseOut() {
    return J.map(this.view.onMouseOut, Nm);
  }
  get onContextMenu() {
    var e;
    return J.any(J.filter(J.map(this.view.onContextMenu, $K), (t) => !t.isStickyScroll), ((e = this.stickyScrollController) == null ? void 0 : e.onContextMenu) ?? J.None);
  }
  get onPointer() {
    return J.map(this.view.onPointer, Nm);
  }
  get onKeyDown() {
    return this.view.onKeyDown;
  }
  get onDidFocus() {
    return this.view.onDidFocus;
  }
  get onDidChangeModel() {
    return J.signal(this.model.onDidSplice);
  }
  get onDidChangeCollapseState() {
    return this.model.onDidChangeCollapseState;
  }
  get findMode() {
    var e;
    return ((e = this.findController) == null ? void 0 : e.mode) ?? Pr.Highlight;
  }
  set findMode(e) {
    this.findController && (this.findController.mode = e);
  }
  get findMatchType() {
    var e;
    return ((e = this.findController) == null ? void 0 : e.matchType) ?? yc.Fuzzy;
  }
  set findMatchType(e) {
    this.findController && (this.findController.matchType = e);
  }
  get expandOnDoubleClick() {
    return typeof this._options.expandOnDoubleClick > "u" ? !0 : this._options.expandOnDoubleClick;
  }
  get expandOnlyOnTwistieClick() {
    return typeof this._options.expandOnlyOnTwistieClick > "u" ? !0 : this._options.expandOnlyOnTwistieClick;
  }
  get onDidDispose() {
    return this.view.onDidDispose;
  }
  constructor(e, t, i, n, o = {}) {
    this._user = e, this._options = o, this.eventBufferer = new yg(), this.onDidChangeFindOpenState = J.None, this.onDidChangeStickyScrollFocused = J.None, this.disposables = new he(), this._onWillRefilter = new O(), this.onWillRefilter = this._onWillRefilter.event, this._onDidUpdateOptions = new O(), this.treeDelegate = new Qk(i);
    const r = new oD(), a = new oD(), l = this.disposables.add(new OK(a.event)), c = new YM();
    this.renderers = n.map((g) => new Vy(g, () => this.model, r.event, l, c, o));
    for (const g of this.renderers)
      this.disposables.add(g);
    let h;
    o.keyboardNavigationLabelProvider && (h = new FK(this, o.keyboardNavigationLabelProvider, o.filter), o = { ...o, filter: h }, this.disposables.add(h)), this.focus = new aC(() => this.view.getFocusedElements()[0], o.identityProvider), this.selection = new aC(() => this.view.getSelectedElements()[0], o.identityProvider), this.anchor = new aC(() => this.view.getAnchorElement(), o.identityProvider), this.view = new qK(e, t, this.treeDelegate, this.renderers, this.focus, this.selection, this.anchor, { ...PK(() => this.model, o), tree: this, stickyScrollProvider: () => this.stickyScrollController }), this.model = this.createModel(e, this.view, o), r.input = this.model.onDidChangeCollapseState;
    const d = J.forEach(this.model.onDidSplice, (g) => {
      this.eventBufferer.bufferEvents(() => {
        this.focus.onDidModelSplice(g), this.selection.onDidModelSplice(g);
      });
    }, this.disposables);
    d(() => null, null, this.disposables);
    const u = this.disposables.add(new O()), f = this.disposables.add(new kg(0));
    if (this.disposables.add(J.any(d, this.focus.onDidChange, this.selection.onDidChange)(() => {
      f.trigger(() => {
        const g = /* @__PURE__ */ new Set();
        for (const m of this.focus.getNodes())
          g.add(m);
        for (const m of this.selection.getNodes())
          g.add(m);
        u.fire([...g.values()]);
      });
    })), a.input = u.event, o.keyboardSupport !== !1) {
      const g = J.chain(this.view.onKeyDown, (m) => m.filter((_) => !Wa(_.target)).map((_) => new Lt(_)));
      J.chain(g, (m) => m.filter(
        (_) => _.keyCode === 15
        /* KeyCode.LeftArrow */
      ))(this.onLeftArrow, this, this.disposables), J.chain(g, (m) => m.filter(
        (_) => _.keyCode === 17
        /* KeyCode.RightArrow */
      ))(this.onRightArrow, this, this.disposables), J.chain(g, (m) => m.filter(
        (_) => _.keyCode === 10
        /* KeyCode.Space */
      ))(this.onSpace, this, this.disposables);
    }
    if ((o.findWidgetEnabled ?? !0) && o.keyboardNavigationLabelProvider && o.contextViewProvider) {
      const g = this.options.findWidgetStyles ? { styles: this.options.findWidgetStyles } : void 0;
      this.findController = new BK(this, this.model, this.view, h, o.contextViewProvider, g), this.focusNavigationFilter = (m) => this.findController.shouldAllowFocus(m), this.onDidChangeFindOpenState = this.findController.onDidChangeOpenState, this.disposables.add(this.findController), this.onDidChangeFindMode = this.findController.onDidChangeMode, this.onDidChangeFindMatchType = this.findController.onDidChangeMatchType;
    } else
      this.onDidChangeFindMode = J.None, this.onDidChangeFindMatchType = J.None;
    o.enableStickyScroll && (this.stickyScrollController = new DN(this, this.model, this.view, this.renderers, this.treeDelegate, o), this.onDidChangeStickyScrollFocused = this.stickyScrollController.onDidChangeHasFocus), this.styleElement = Os(this.view.getHTMLElement()), this.getHTMLElement().classList.toggle("always", this._options.renderIndentGuides === Md.Always);
  }
  updateOptions(e = {}) {
    var t;
    this._options = { ...this._options, ...e };
    for (const i of this.renderers)
      i.updateOptions(e);
    this.view.updateOptions(this._options), (t = this.findController) == null || t.updateOptions(e), this.updateStickyScroll(e), this._onDidUpdateOptions.fire(this._options), this.getHTMLElement().classList.toggle("always", this._options.renderIndentGuides === Md.Always);
  }
  get options() {
    return this._options;
  }
  updateStickyScroll(e) {
    var t;
    !this.stickyScrollController && this._options.enableStickyScroll ? (this.stickyScrollController = new DN(this, this.model, this.view, this.renderers, this.treeDelegate, this._options), this.onDidChangeStickyScrollFocused = this.stickyScrollController.onDidChangeHasFocus) : this.stickyScrollController && !this._options.enableStickyScroll && (this.onDidChangeStickyScrollFocused = J.None, this.stickyScrollController.dispose(), this.stickyScrollController = void 0), (t = this.stickyScrollController) == null || t.updateOptions(e);
  }
  // Widget
  getHTMLElement() {
    return this.view.getHTMLElement();
  }
  get scrollTop() {
    return this.view.scrollTop;
  }
  set scrollTop(e) {
    this.view.scrollTop = e;
  }
  get scrollHeight() {
    return this.view.scrollHeight;
  }
  get renderHeight() {
    return this.view.renderHeight;
  }
  get ariaLabel() {
    return this.view.ariaLabel;
  }
  set ariaLabel(e) {
    this.view.ariaLabel = e;
  }
  domFocus() {
    var e;
    (e = this.stickyScrollController) != null && e.focusedLast() ? this.stickyScrollController.domFocus() : this.view.domFocus();
  }
  layout(e, t) {
    var i;
    this.view.layout(e, t), Od(t) && ((i = this.findController) == null || i.layout(t));
  }
  style(e) {
    const t = `.${this.view.domId}`, i = [];
    e.treeIndentGuidesStroke && (i.push(`.monaco-list${t}:hover .monaco-tl-indent > .indent-guide, .monaco-list${t}.always .monaco-tl-indent > .indent-guide  { border-color: ${e.treeInactiveIndentGuidesStroke}; }`), i.push(`.monaco-list${t} .monaco-tl-indent > .indent-guide.active { border-color: ${e.treeIndentGuidesStroke}; }`));
    const n = e.treeStickyScrollBackground ?? e.listBackground;
    n && (i.push(`.monaco-list${t} .monaco-scrollable-element .monaco-tree-sticky-container { background-color: ${n}; }`), i.push(`.monaco-list${t} .monaco-scrollable-element .monaco-tree-sticky-container .monaco-tree-sticky-row { background-color: ${n}; }`)), e.treeStickyScrollBorder && i.push(`.monaco-list${t} .monaco-scrollable-element .monaco-tree-sticky-container { border-bottom: 1px solid ${e.treeStickyScrollBorder}; }`), e.treeStickyScrollShadow && i.push(`.monaco-list${t} .monaco-scrollable-element .monaco-tree-sticky-container .monaco-tree-sticky-container-shadow { box-shadow: ${e.treeStickyScrollShadow} 0 6px 6px -6px inset; height: 3px; }`), e.listFocusForeground && (i.push(`.monaco-list${t}.sticky-scroll-focused .monaco-scrollable-element .monaco-tree-sticky-container:focus .monaco-list-row.focused { color: ${e.listFocusForeground}; }`), i.push(`.monaco-list${t}:not(.sticky-scroll-focused) .monaco-scrollable-element .monaco-tree-sticky-container .monaco-list-row.focused { color: inherit; }`));
    const o = Hr(e.listFocusAndSelectionOutline, Hr(e.listSelectionOutline, e.listFocusOutline ?? ""));
    o && (i.push(`.monaco-list${t}.sticky-scroll-focused .monaco-scrollable-element .monaco-tree-sticky-container:focus .monaco-list-row.focused.selected { outline: 1px solid ${o}; outline-offset: -1px;}`), i.push(`.monaco-list${t}:not(.sticky-scroll-focused) .monaco-scrollable-element .monaco-tree-sticky-container .monaco-list-row.focused.selected { outline: inherit;}`)), e.listFocusOutline && (i.push(`.monaco-list${t}.sticky-scroll-focused .monaco-scrollable-element .monaco-tree-sticky-container:focus .monaco-list-row.focused { outline: 1px solid ${e.listFocusOutline}; outline-offset: -1px; }`), i.push(`.monaco-list${t}:not(.sticky-scroll-focused) .monaco-scrollable-element .monaco-tree-sticky-container .monaco-list-row.focused { outline: inherit; }`), i.push(`.monaco-workbench.context-menu-visible .monaco-list${t}.last-focused.sticky-scroll-focused .monaco-scrollable-element .monaco-tree-sticky-container .monaco-list-row.passive-focused { outline: 1px solid ${e.listFocusOutline}; outline-offset: -1px; }`), i.push(`.monaco-workbench.context-menu-visible .monaco-list${t}.last-focused.sticky-scroll-focused .monaco-list-rows .monaco-list-row.focused { outline: inherit; }`), i.push(`.monaco-workbench.context-menu-visible .monaco-list${t}.last-focused:not(.sticky-scroll-focused) .monaco-tree-sticky-container .monaco-list-rows .monaco-list-row.focused { outline: inherit; }`)), this.styleElement.textContent = i.join(`
`), this.view.style(e);
  }
  // Tree navigation
  getParentElement(e) {
    const t = this.model.getParentNodeLocation(e);
    return this.model.getNode(t).element;
  }
  getFirstElementChild(e) {
    return this.model.getFirstElementChild(e);
  }
  // Tree
  getNode(e) {
    return this.model.getNode(e);
  }
  getNodeLocation(e) {
    return this.model.getNodeLocation(e);
  }
  collapse(e, t = !1) {
    return this.model.setCollapsed(e, !0, t);
  }
  expand(e, t = !1) {
    return this.model.setCollapsed(e, !1, t);
  }
  toggleCollapsed(e, t = !1) {
    return this.model.setCollapsed(e, void 0, t);
  }
  isCollapsible(e) {
    return this.model.isCollapsible(e);
  }
  setCollapsible(e, t) {
    return this.model.setCollapsible(e, t);
  }
  isCollapsed(e) {
    return this.model.isCollapsed(e);
  }
  refilter() {
    this._onWillRefilter.fire(void 0), this.model.refilter();
  }
  setSelection(e, t) {
    this.eventBufferer.bufferEvents(() => {
      const i = e.map((o) => this.model.getNode(o));
      this.selection.set(i, t);
      const n = e.map((o) => this.model.getListIndex(o)).filter((o) => o > -1);
      this.view.setSelection(n, t, !0);
    });
  }
  getSelection() {
    return this.selection.get();
  }
  setFocus(e, t) {
    this.eventBufferer.bufferEvents(() => {
      const i = e.map((o) => this.model.getNode(o));
      this.focus.set(i, t);
      const n = e.map((o) => this.model.getListIndex(o)).filter((o) => o > -1);
      this.view.setFocus(n, t, !0);
    });
  }
  focusNext(e = 1, t = !1, i, n = wr(i) && i.altKey ? void 0 : this.focusNavigationFilter) {
    this.view.focusNext(e, t, i, n);
  }
  focusPrevious(e = 1, t = !1, i, n = wr(i) && i.altKey ? void 0 : this.focusNavigationFilter) {
    this.view.focusPrevious(e, t, i, n);
  }
  focusNextPage(e, t = wr(e) && e.altKey ? void 0 : this.focusNavigationFilter) {
    return this.view.focusNextPage(e, t);
  }
  focusPreviousPage(e, t = wr(e) && e.altKey ? void 0 : this.focusNavigationFilter) {
    return this.view.focusPreviousPage(e, t, () => {
      var i;
      return ((i = this.stickyScrollController) == null ? void 0 : i.height) ?? 0;
    });
  }
  focusLast(e, t = wr(e) && e.altKey ? void 0 : this.focusNavigationFilter) {
    this.view.focusLast(e, t);
  }
  focusFirst(e, t = wr(e) && e.altKey ? void 0 : this.focusNavigationFilter) {
    this.view.focusFirst(e, t);
  }
  getFocus() {
    return this.focus.get();
  }
  reveal(e, t) {
    this.model.expandTo(e);
    const i = this.model.getListIndex(e);
    if (i !== -1)
      if (!this.stickyScrollController)
        this.view.reveal(i, t);
      else {
        const n = this.stickyScrollController.nodePositionTopBelowWidget(this.getNode(e));
        this.view.reveal(i, t, n);
      }
  }
  // List
  onLeftArrow(e) {
    e.preventDefault(), e.stopPropagation();
    const t = this.view.getFocusedElements();
    if (t.length === 0)
      return;
    const i = t[0], n = this.model.getNodeLocation(i);
    if (!this.model.setCollapsed(n, !0)) {
      const r = this.model.getParentNodeLocation(n);
      if (!r)
        return;
      const a = this.model.getListIndex(r);
      this.view.reveal(a), this.view.setFocus([a]);
    }
  }
  onRightArrow(e) {
    e.preventDefault(), e.stopPropagation();
    const t = this.view.getFocusedElements();
    if (t.length === 0)
      return;
    const i = t[0], n = this.model.getNodeLocation(i);
    if (!this.model.setCollapsed(n, !1)) {
      if (!i.children.some((l) => l.visible))
        return;
      const [r] = this.view.getFocus(), a = r + 1;
      this.view.reveal(a), this.view.setFocus([a]);
    }
  }
  onSpace(e) {
    e.preventDefault(), e.stopPropagation();
    const t = this.view.getFocusedElements();
    if (t.length === 0)
      return;
    const i = t[0], n = this.model.getNodeLocation(i), o = e.browserEvent.altKey;
    this.model.setCollapsed(n, void 0, o);
  }
  dispose() {
    var e;
    Ri(this.disposables), (e = this.stickyScrollController) == null || e.dispose(), this.view.dispose();
  }
}
class Xk {
  constructor(e, t, i = {}) {
    this.user = e, this.rootRef = null, this.nodes = /* @__PURE__ */ new Map(), this.nodesByIdentity = /* @__PURE__ */ new Map(), this.model = new MK(e, t, null, i), this.onDidSplice = this.model.onDidSplice, this.onDidChangeCollapseState = this.model.onDidChangeCollapseState, this.onDidChangeRenderNodeCount = this.model.onDidChangeRenderNodeCount, i.sorter && (this.sorter = {
      compare(n, o) {
        return i.sorter.compare(n.element, o.element);
      }
    }), this.identityProvider = i.identityProvider;
  }
  setChildren(e, t = Ye.empty(), i = {}) {
    const n = this.getElementLocation(e);
    this._setChildren(n, this.preserveCollapseState(t), i);
  }
  _setChildren(e, t = Ye.empty(), i) {
    const n = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Set(), r = (l) => {
      var h;
      if (l.element === null)
        return;
      const c = l;
      if (n.add(c.element), this.nodes.set(c.element, c), this.identityProvider) {
        const d = this.identityProvider.getId(c.element).toString();
        o.add(d), this.nodesByIdentity.set(d, c);
      }
      (h = i.onDidCreateNode) == null || h.call(i, c);
    }, a = (l) => {
      var h;
      if (l.element === null)
        return;
      const c = l;
      if (n.has(c.element) || this.nodes.delete(c.element), this.identityProvider) {
        const d = this.identityProvider.getId(c.element).toString();
        o.has(d) || this.nodesByIdentity.delete(d);
      }
      (h = i.onDidDeleteNode) == null || h.call(i, c);
    };
    this.model.splice([...e, 0], Number.MAX_VALUE, t, { ...i, onDidCreateNode: r, onDidDeleteNode: a });
  }
  preserveCollapseState(e = Ye.empty()) {
    return this.sorter && (e = [...e].sort(this.sorter.compare.bind(this.sorter))), Ye.map(e, (t) => {
      let i = this.nodes.get(t.element);
      if (!i && this.identityProvider) {
        const r = this.identityProvider.getId(t.element).toString();
        i = this.nodesByIdentity.get(r);
      }
      if (!i) {
        let r;
        return typeof t.collapsed > "u" ? r = void 0 : t.collapsed === qn.Collapsed || t.collapsed === qn.PreserveOrCollapsed ? r = !0 : t.collapsed === qn.Expanded || t.collapsed === qn.PreserveOrExpanded ? r = !1 : r = !!t.collapsed, {
          ...t,
          children: this.preserveCollapseState(t.children),
          collapsed: r
        };
      }
      const n = typeof t.collapsible == "boolean" ? t.collapsible : i.collapsible;
      let o;
      return typeof t.collapsed > "u" || t.collapsed === qn.PreserveOrCollapsed || t.collapsed === qn.PreserveOrExpanded ? o = i.collapsed : t.collapsed === qn.Collapsed ? o = !0 : t.collapsed === qn.Expanded ? o = !1 : o = !!t.collapsed, {
        ...t,
        collapsible: n,
        collapsed: o,
        children: this.preserveCollapseState(t.children)
      };
    });
  }
  rerender(e) {
    const t = this.getElementLocation(e);
    this.model.rerender(t);
  }
  getFirstElementChild(e = null) {
    const t = this.getElementLocation(e);
    return this.model.getFirstElementChild(t);
  }
  has(e) {
    return this.nodes.has(e);
  }
  getListIndex(e) {
    const t = this.getElementLocation(e);
    return this.model.getListIndex(t);
  }
  getListRenderCount(e) {
    const t = this.getElementLocation(e);
    return this.model.getListRenderCount(t);
  }
  isCollapsible(e) {
    const t = this.getElementLocation(e);
    return this.model.isCollapsible(t);
  }
  setCollapsible(e, t) {
    const i = this.getElementLocation(e);
    return this.model.setCollapsible(i, t);
  }
  isCollapsed(e) {
    const t = this.getElementLocation(e);
    return this.model.isCollapsed(t);
  }
  setCollapsed(e, t, i) {
    const n = this.getElementLocation(e);
    return this.model.setCollapsed(n, t, i);
  }
  expandTo(e) {
    const t = this.getElementLocation(e);
    this.model.expandTo(t);
  }
  refilter() {
    this.model.refilter();
  }
  getNode(e = null) {
    if (e === null)
      return this.model.getNode(this.model.rootRef);
    const t = this.nodes.get(e);
    if (!t)
      throw new Yn(this.user, `Tree element not found: ${e}`);
    return t;
  }
  getNodeLocation(e) {
    return e.element;
  }
  getParentNodeLocation(e) {
    if (e === null)
      throw new Yn(this.user, "Invalid getParentNodeLocation call");
    const t = this.nodes.get(e);
    if (!t)
      throw new Yn(this.user, `Tree element not found: ${e}`);
    const i = this.model.getNodeLocation(t), n = this.model.getParentNodeLocation(i);
    return this.model.getNode(n).element;
  }
  getElementLocation(e) {
    if (e === null)
      return [];
    const t = this.nodes.get(e);
    if (!t)
      throw new Yn(this.user, `Tree element not found: ${e}`);
    return this.model.getNodeLocation(t);
  }
}
function ap(s) {
  const e = [s.element], t = s.incompressible || !1;
  return {
    element: { elements: e, incompressible: t },
    children: Ye.map(Ye.from(s.children), ap),
    collapsible: s.collapsible,
    collapsed: s.collapsed
  };
}
function lp(s) {
  const e = [s.element], t = s.incompressible || !1;
  let i, n;
  for (; [n, i] = Ye.consume(Ye.from(s.children), 2), !(n.length !== 1 || n[0].incompressible); )
    s = n[0], e.push(s.element);
  return {
    element: { elements: e, incompressible: t },
    children: Ye.map(Ye.concat(n, i), lp),
    collapsible: s.collapsible,
    collapsed: s.collapsed
  };
}
function Hy(s, e = 0) {
  let t;
  return e < s.element.elements.length - 1 ? t = [Hy(s, e + 1)] : t = Ye.map(Ye.from(s.children), (i) => Hy(i, 0)), e === 0 && s.element.incompressible ? {
    element: s.element.elements[e],
    children: t,
    incompressible: !0,
    collapsible: s.collapsible,
    collapsed: s.collapsed
  } : {
    element: s.element.elements[e],
    children: t,
    collapsible: s.collapsible,
    collapsed: s.collapsed
  };
}
function EN(s) {
  return Hy(s, 0);
}
function p4(s, e, t) {
  return s.element === e ? { ...s, children: t } : { ...s, children: Ye.map(Ye.from(s.children), (i) => p4(i, e, t)) };
}
const jK = (s) => ({
  getId(e) {
    return e.elements.map((t) => s.getId(t).toString()).join("\0");
  }
});
class GK {
  get onDidSplice() {
    return this.model.onDidSplice;
  }
  get onDidChangeCollapseState() {
    return this.model.onDidChangeCollapseState;
  }
  get onDidChangeRenderNodeCount() {
    return this.model.onDidChangeRenderNodeCount;
  }
  constructor(e, t, i = {}) {
    this.user = e, this.rootRef = null, this.nodes = /* @__PURE__ */ new Map(), this.model = new Xk(e, t, i), this.enabled = typeof i.compressionEnabled > "u" ? !0 : i.compressionEnabled, this.identityProvider = i.identityProvider;
  }
  setChildren(e, t = Ye.empty(), i) {
    const n = i.diffIdentityProvider && jK(i.diffIdentityProvider);
    if (e === null) {
      const g = Ye.map(t, this.enabled ? lp : ap);
      this._setChildren(null, g, { diffIdentityProvider: n, diffDepth: 1 / 0 });
      return;
    }
    const o = this.nodes.get(e);
    if (!o)
      throw new Yn(this.user, "Unknown compressed tree node");
    const r = this.model.getNode(o), a = this.model.getParentNodeLocation(o), l = this.model.getNode(a), c = EN(r), h = p4(c, e, t), d = (this.enabled ? lp : ap)(h), u = i.diffIdentityProvider ? ((g, m) => i.diffIdentityProvider.getId(g) === i.diffIdentityProvider.getId(m)) : void 0;
    if (oi(d.element.elements, r.element.elements, u)) {
      this._setChildren(o, d.children || Ye.empty(), { diffIdentityProvider: n, diffDepth: 1 });
      return;
    }
    const f = l.children.map((g) => g === r ? d : g);
    this._setChildren(l.element, f, {
      diffIdentityProvider: n,
      diffDepth: r.depth - l.depth
    });
  }
  isCompressionEnabled() {
    return this.enabled;
  }
  setCompressionEnabled(e) {
    if (e === this.enabled)
      return;
    this.enabled = e;
    const i = this.model.getNode().children, n = Ye.map(i, EN), o = Ye.map(n, e ? lp : ap);
    this._setChildren(null, o, {
      diffIdentityProvider: this.identityProvider,
      diffDepth: 1 / 0
    });
  }
  _setChildren(e, t, i) {
    const n = /* @__PURE__ */ new Set(), o = (a) => {
      for (const l of a.element.elements)
        n.add(l), this.nodes.set(l, a.element);
    }, r = (a) => {
      for (const l of a.element.elements)
        n.has(l) || this.nodes.delete(l);
    };
    this.model.setChildren(e, t, { ...i, onDidCreateNode: o, onDidDeleteNode: r });
  }
  has(e) {
    return this.nodes.has(e);
  }
  getListIndex(e) {
    const t = this.getCompressedNode(e);
    return this.model.getListIndex(t);
  }
  getListRenderCount(e) {
    const t = this.getCompressedNode(e);
    return this.model.getListRenderCount(t);
  }
  getNode(e) {
    if (typeof e > "u")
      return this.model.getNode();
    const t = this.getCompressedNode(e);
    return this.model.getNode(t);
  }
  // TODO: review this
  getNodeLocation(e) {
    const t = this.model.getNodeLocation(e);
    return t === null ? null : t.elements[t.elements.length - 1];
  }
  // TODO: review this
  getParentNodeLocation(e) {
    const t = this.getCompressedNode(e), i = this.model.getParentNodeLocation(t);
    return i === null ? null : i.elements[i.elements.length - 1];
  }
  getFirstElementChild(e) {
    const t = this.getCompressedNode(e);
    return this.model.getFirstElementChild(t);
  }
  isCollapsible(e) {
    const t = this.getCompressedNode(e);
    return this.model.isCollapsible(t);
  }
  setCollapsible(e, t) {
    const i = this.getCompressedNode(e);
    return this.model.setCollapsible(i, t);
  }
  isCollapsed(e) {
    const t = this.getCompressedNode(e);
    return this.model.isCollapsed(t);
  }
  setCollapsed(e, t, i) {
    const n = this.getCompressedNode(e);
    return this.model.setCollapsed(n, t, i);
  }
  expandTo(e) {
    const t = this.getCompressedNode(e);
    this.model.expandTo(t);
  }
  rerender(e) {
    const t = this.getCompressedNode(e);
    this.model.rerender(t);
  }
  refilter() {
    this.model.refilter();
  }
  getCompressedNode(e) {
    if (e === null)
      return null;
    const t = this.nodes.get(e);
    if (!t)
      throw new Yn(this.user, `Tree element not found: ${e}`);
    return t;
  }
}
const ZK = (s) => s[s.length - 1];
class Jk {
  get element() {
    return this.node.element === null ? null : this.unwrapper(this.node.element);
  }
  get children() {
    return this.node.children.map((e) => new Jk(this.unwrapper, e));
  }
  get depth() {
    return this.node.depth;
  }
  get visibleChildrenCount() {
    return this.node.visibleChildrenCount;
  }
  get visibleChildIndex() {
    return this.node.visibleChildIndex;
  }
  get collapsible() {
    return this.node.collapsible;
  }
  get collapsed() {
    return this.node.collapsed;
  }
  get visible() {
    return this.node.visible;
  }
  get filterData() {
    return this.node.filterData;
  }
  constructor(e, t) {
    this.unwrapper = e, this.node = t;
  }
}
function YK(s, e) {
  return {
    splice(t, i, n) {
      e.splice(t, i, n.map((o) => s.map(o)));
    },
    updateElementHeight(t, i) {
      e.updateElementHeight(t, i);
    }
  };
}
function QK(s, e) {
  return {
    ...e,
    identityProvider: e.identityProvider && {
      getId(t) {
        return e.identityProvider.getId(s(t));
      }
    },
    sorter: e.sorter && {
      compare(t, i) {
        return e.sorter.compare(t.elements[0], i.elements[0]);
      }
    },
    filter: e.filter && {
      filter(t, i) {
        return e.filter.filter(s(t), i);
      }
    }
  };
}
class XK {
  get onDidSplice() {
    return J.map(this.model.onDidSplice, ({ insertedNodes: e, deletedNodes: t }) => ({
      insertedNodes: e.map((i) => this.nodeMapper.map(i)),
      deletedNodes: t.map((i) => this.nodeMapper.map(i))
    }));
  }
  get onDidChangeCollapseState() {
    return J.map(this.model.onDidChangeCollapseState, ({ node: e, deep: t }) => ({
      node: this.nodeMapper.map(e),
      deep: t
    }));
  }
  get onDidChangeRenderNodeCount() {
    return J.map(this.model.onDidChangeRenderNodeCount, (e) => this.nodeMapper.map(e));
  }
  constructor(e, t, i = {}) {
    this.rootRef = null, this.elementMapper = i.elementMapper || ZK;
    const n = (o) => this.elementMapper(o.elements);
    this.nodeMapper = new Zk((o) => new Jk(n, o)), this.model = new GK(e, YK(this.nodeMapper, t), QK(n, i));
  }
  setChildren(e, t = Ye.empty(), i = {}) {
    this.model.setChildren(e, t, i);
  }
  isCompressionEnabled() {
    return this.model.isCompressionEnabled();
  }
  setCompressionEnabled(e) {
    this.model.setCompressionEnabled(e);
  }
  has(e) {
    return this.model.has(e);
  }
  getListIndex(e) {
    return this.model.getListIndex(e);
  }
  getListRenderCount(e) {
    return this.model.getListRenderCount(e);
  }
  getNode(e) {
    return this.nodeMapper.map(this.model.getNode(e));
  }
  getNodeLocation(e) {
    return e.element;
  }
  getParentNodeLocation(e) {
    return this.model.getParentNodeLocation(e);
  }
  getFirstElementChild(e) {
    const t = this.model.getFirstElementChild(e);
    return t === null || typeof t > "u" ? t : this.elementMapper(t.elements);
  }
  isCollapsible(e) {
    return this.model.isCollapsible(e);
  }
  setCollapsible(e, t) {
    return this.model.setCollapsible(e, t);
  }
  isCollapsed(e) {
    return this.model.isCollapsed(e);
  }
  setCollapsed(e, t, i) {
    return this.model.setCollapsed(e, t, i);
  }
  expandTo(e) {
    return this.model.expandTo(e);
  }
  rerender(e) {
    return this.model.rerender(e);
  }
  refilter() {
    return this.model.refilter();
  }
  getCompressedTreeNode(e = null) {
    return this.model.getNode(e);
  }
}
var JK = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
};
class ex extends m4 {
  get onDidChangeCollapseState() {
    return this.model.onDidChangeCollapseState;
  }
  constructor(e, t, i, n, o = {}) {
    super(e, t, i, n, o), this.user = e;
  }
  setChildren(e, t = Ye.empty(), i) {
    this.model.setChildren(e, t, i);
  }
  rerender(e) {
    if (e === void 0) {
      this.view.rerender();
      return;
    }
    this.model.rerender(e);
  }
  hasElement(e) {
    return this.model.has(e);
  }
  createModel(e, t, i) {
    return new Xk(e, t, i);
  }
}
class _4 {
  get compressedTreeNodeProvider() {
    return this._compressedTreeNodeProvider();
  }
  constructor(e, t, i) {
    this._compressedTreeNodeProvider = e, this.stickyScrollDelegate = t, this.renderer = i, this.templateId = i.templateId, i.onDidChangeTwistieState && (this.onDidChangeTwistieState = i.onDidChangeTwistieState);
  }
  renderTemplate(e) {
    return { compressedTreeNode: void 0, data: this.renderer.renderTemplate(e) };
  }
  renderElement(e, t, i, n) {
    let o = this.stickyScrollDelegate.getCompressedNode(e);
    o || (o = this.compressedTreeNodeProvider.getCompressedTreeNode(e.element)), o.element.elements.length === 1 ? (i.compressedTreeNode = void 0, this.renderer.renderElement(e, t, i.data, n)) : (i.compressedTreeNode = o, this.renderer.renderCompressedElements(o, t, i.data, n));
  }
  disposeElement(e, t, i, n) {
    var o, r, a, l;
    i.compressedTreeNode ? (r = (o = this.renderer).disposeCompressedElements) == null || r.call(o, i.compressedTreeNode, t, i.data, n) : (l = (a = this.renderer).disposeElement) == null || l.call(a, e, t, i.data, n);
  }
  disposeTemplate(e) {
    this.renderer.disposeTemplate(e.data);
  }
  renderTwistie(e, t) {
    return this.renderer.renderTwistie ? this.renderer.renderTwistie(e, t) : !1;
  }
}
JK([
  Ht
], _4.prototype, "compressedTreeNodeProvider", null);
class eq {
  constructor(e) {
    this.modelProvider = e, this.compressedStickyNodes = /* @__PURE__ */ new Map();
  }
  getCompressedNode(e) {
    return this.compressedStickyNodes.get(e);
  }
  constrainStickyScrollNodes(e, t, i) {
    if (this.compressedStickyNodes.clear(), e.length === 0)
      return [];
    for (let n = 0; n < e.length; n++) {
      const o = e[n], r = o.position + o.height;
      if (n + 1 < e.length && r + e[n + 1].height > i || n >= t - 1 && t < e.length) {
        const l = e.slice(0, n), c = e.slice(n), h = this.compressStickyNodes(c);
        return [...l, h];
      }
    }
    return e;
  }
  compressStickyNodes(e) {
    if (e.length === 0)
      throw new Error("Can't compress empty sticky nodes");
    const t = this.modelProvider();
    if (!t.isCompressionEnabled())
      return e[0];
    const i = [];
    for (let c = 0; c < e.length; c++) {
      const h = e[c], d = t.getCompressedTreeNode(h.node.element);
      if (d.element) {
        if (c !== 0 && d.element.incompressible)
          break;
        i.push(...d.element.elements);
      }
    }
    if (i.length < 2)
      return e[0];
    const n = e[e.length - 1], o = { elements: i, incompressible: !1 }, r = { ...n.node, children: [], element: o }, a = new Proxy(e[0].node, {}), l = {
      node: a,
      startIndex: e[0].startIndex,
      endIndex: n.endIndex,
      position: e[0].position,
      height: e[0].height
    };
    return this.compressedStickyNodes.set(a, r), l;
  }
}
function tq(s, e) {
  return e && {
    ...e,
    keyboardNavigationLabelProvider: e.keyboardNavigationLabelProvider && {
      getKeyboardNavigationLabel(t) {
        let i;
        try {
          i = s().getCompressedTreeNode(t);
        } catch {
          return e.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(t);
        }
        return i.element.elements.length === 1 ? e.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(t) : e.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(i.element.elements);
      }
    }
  };
}
class b4 extends ex {
  constructor(e, t, i, n, o = {}) {
    const r = () => this, a = new eq(() => this.model), l = n.map((c) => new _4(r, a, c));
    super(e, t, i, l, { ...tq(r, o), stickyScrollDelegate: a });
  }
  setChildren(e, t = Ye.empty(), i) {
    this.model.setChildren(e, t, i);
  }
  createModel(e, t, i) {
    return new XK(e, t, i);
  }
  updateOptions(e = {}) {
    super.updateOptions(e), typeof e.compressionEnabled < "u" && this.model.setCompressionEnabled(e.compressionEnabled);
  }
  getCompressedTreeNode(e = null) {
    return this.model.getCompressedTreeNode(e);
  }
}
function lC(s) {
  return {
    ...s,
    children: [],
    refreshPromise: void 0,
    stale: !0,
    slow: !1,
    forceExpanded: !1
  };
}
function zy(s, e) {
  return e.parent ? e.parent === s ? !0 : zy(s, e.parent) : !1;
}
function iq(s, e) {
  return s === e || zy(s, e) || zy(e, s);
}
class tx {
  get element() {
    return this.node.element.element;
  }
  get children() {
    return this.node.children.map((e) => new tx(e));
  }
  get depth() {
    return this.node.depth;
  }
  get visibleChildrenCount() {
    return this.node.visibleChildrenCount;
  }
  get visibleChildIndex() {
    return this.node.visibleChildIndex;
  }
  get collapsible() {
    return this.node.collapsible;
  }
  get collapsed() {
    return this.node.collapsed;
  }
  get visible() {
    return this.node.visible;
  }
  get filterData() {
    return this.node.filterData;
  }
  constructor(e) {
    this.node = e;
  }
}
class nq {
  constructor(e, t, i) {
    this.renderer = e, this.nodeMapper = t, this.onDidChangeTwistieState = i, this.renderedNodes = /* @__PURE__ */ new Map(), this.templateId = e.templateId;
  }
  renderTemplate(e) {
    return { templateData: this.renderer.renderTemplate(e) };
  }
  renderElement(e, t, i, n) {
    this.renderer.renderElement(this.nodeMapper.map(e), t, i.templateData, n);
  }
  renderTwistie(e, t) {
    return e.slow ? (t.classList.add(...Ke.asClassNameArray(re.treeItemLoading)), !0) : (t.classList.remove(...Ke.asClassNameArray(re.treeItemLoading)), !1);
  }
  disposeElement(e, t, i, n) {
    var o, r;
    (r = (o = this.renderer).disposeElement) == null || r.call(o, this.nodeMapper.map(e), t, i.templateData, n);
  }
  disposeTemplate(e) {
    this.renderer.disposeTemplate(e.templateData);
  }
  dispose() {
    this.renderedNodes.clear();
  }
}
function IN(s) {
  return {
    browserEvent: s.browserEvent,
    elements: s.elements.map((e) => e.element)
  };
}
function NN(s) {
  return {
    browserEvent: s.browserEvent,
    element: s.element && s.element.element,
    target: s.target
  };
}
class sq extends Bg {
  constructor(e) {
    super(e.elements.map((t) => t.element)), this.data = e;
  }
}
function cC(s) {
  return s instanceof Bg ? new sq(s) : s;
}
class oq {
  constructor(e) {
    this.dnd = e;
  }
  getDragURI(e) {
    return this.dnd.getDragURI(e.element);
  }
  getDragLabel(e, t) {
    if (this.dnd.getDragLabel)
      return this.dnd.getDragLabel(e.map((i) => i.element), t);
  }
  onDragStart(e, t) {
    var i, n;
    (n = (i = this.dnd).onDragStart) == null || n.call(i, cC(e), t);
  }
  onDragOver(e, t, i, n, o, r = !0) {
    return this.dnd.onDragOver(cC(e), t && t.element, i, n, o);
  }
  drop(e, t, i, n, o) {
    this.dnd.drop(cC(e), t && t.element, i, n, o);
  }
  onDragEnd(e) {
    var t, i;
    (i = (t = this.dnd).onDragEnd) == null || i.call(t, e);
  }
  dispose() {
    this.dnd.dispose();
  }
}
function C4(s) {
  return s && {
    ...s,
    collapseByDefault: !0,
    identityProvider: s.identityProvider && {
      getId(e) {
        return s.identityProvider.getId(e.element);
      }
    },
    dnd: s.dnd && new oq(s.dnd),
    multipleSelectionController: s.multipleSelectionController && {
      isSelectionSingleChangeEvent(e) {
        return s.multipleSelectionController.isSelectionSingleChangeEvent({ ...e, element: e.element });
      },
      isSelectionRangeChangeEvent(e) {
        return s.multipleSelectionController.isSelectionRangeChangeEvent({ ...e, element: e.element });
      }
    },
    accessibilityProvider: s.accessibilityProvider && {
      ...s.accessibilityProvider,
      getPosInSet: void 0,
      getSetSize: void 0,
      getRole: s.accessibilityProvider.getRole ? (e) => s.accessibilityProvider.getRole(e.element) : () => "treeitem",
      isChecked: s.accessibilityProvider.isChecked ? (e) => {
        var t;
        return !!((t = s.accessibilityProvider) != null && t.isChecked(e.element));
      } : void 0,
      getAriaLabel(e) {
        return s.accessibilityProvider.getAriaLabel(e.element);
      },
      getWidgetAriaLabel() {
        return s.accessibilityProvider.getWidgetAriaLabel();
      },
      getWidgetRole: s.accessibilityProvider.getWidgetRole ? () => s.accessibilityProvider.getWidgetRole() : () => "tree",
      getAriaLevel: s.accessibilityProvider.getAriaLevel && ((e) => s.accessibilityProvider.getAriaLevel(e.element)),
      getActiveDescendantId: s.accessibilityProvider.getActiveDescendantId && ((e) => s.accessibilityProvider.getActiveDescendantId(e.element))
    },
    filter: s.filter && {
      filter(e, t) {
        return s.filter.filter(e.element, t);
      }
    },
    keyboardNavigationLabelProvider: s.keyboardNavigationLabelProvider && {
      ...s.keyboardNavigationLabelProvider,
      getKeyboardNavigationLabel(e) {
        return s.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e.element);
      }
    },
    sorter: void 0,
    expandOnlyOnTwistieClick: typeof s.expandOnlyOnTwistieClick > "u" ? void 0 : typeof s.expandOnlyOnTwistieClick != "function" ? s.expandOnlyOnTwistieClick : ((e) => s.expandOnlyOnTwistieClick(e.element)),
    defaultFindVisibility: (e) => e.hasChildren && e.stale ? 1 : typeof s.defaultFindVisibility == "number" ? s.defaultFindVisibility : typeof s.defaultFindVisibility > "u" ? 2 : s.defaultFindVisibility(e.element)
  };
}
function Uy(s, e) {
  e(s), s.children.forEach((t) => Uy(t, e));
}
class w4 {
  get onDidScroll() {
    return this.tree.onDidScroll;
  }
  get onDidChangeFocus() {
    return J.map(this.tree.onDidChangeFocus, IN);
  }
  get onDidChangeSelection() {
    return J.map(this.tree.onDidChangeSelection, IN);
  }
  get onMouseDblClick() {
    return J.map(this.tree.onMouseDblClick, NN);
  }
  get onPointer() {
    return J.map(this.tree.onPointer, NN);
  }
  get onDidFocus() {
    return this.tree.onDidFocus;
  }
  /**
   * To be used internally only!
   * @deprecated
   */
  get onDidChangeModel() {
    return this.tree.onDidChangeModel;
  }
  get onDidChangeCollapseState() {
    return this.tree.onDidChangeCollapseState;
  }
  get onDidChangeFindOpenState() {
    return this.tree.onDidChangeFindOpenState;
  }
  get onDidChangeStickyScrollFocused() {
    return this.tree.onDidChangeStickyScrollFocused;
  }
  get onDidDispose() {
    return this.tree.onDidDispose;
  }
  constructor(e, t, i, n, o, r = {}) {
    this.user = e, this.dataSource = o, this.nodes = /* @__PURE__ */ new Map(), this.subTreeRefreshPromises = /* @__PURE__ */ new Map(), this.refreshPromises = /* @__PURE__ */ new Map(), this._onDidRender = new O(), this._onDidChangeNodeSlowState = new O(), this.nodeMapper = new Zk((a) => new tx(a)), this.disposables = new he(), this.identityProvider = r.identityProvider, this.autoExpandSingleChildren = typeof r.autoExpandSingleChildren > "u" ? !1 : r.autoExpandSingleChildren, this.sorter = r.sorter, this.getDefaultCollapseState = (a) => r.collapseByDefault ? r.collapseByDefault(a) ? qn.PreserveOrCollapsed : qn.PreserveOrExpanded : void 0, this.tree = this.createTree(e, t, i, n, r), this.onDidChangeFindMode = this.tree.onDidChangeFindMode, this.onDidChangeFindMatchType = this.tree.onDidChangeFindMatchType, this.root = lC({
      element: void 0,
      parent: null,
      hasChildren: !0,
      defaultCollapseState: void 0
    }), this.identityProvider && (this.root = {
      ...this.root,
      id: null
    }), this.nodes.set(null, this.root), this.tree.onDidChangeCollapseState(this._onDidChangeCollapseState, this, this.disposables);
  }
  createTree(e, t, i, n, o) {
    const r = new Qk(i), a = n.map((c) => new nq(c, this.nodeMapper, this._onDidChangeNodeSlowState.event)), l = C4(o) || {};
    return new ex(e, t, r, a, l);
  }
  updateOptions(e = {}) {
    this.tree.updateOptions(e);
  }
  // Widget
  getHTMLElement() {
    return this.tree.getHTMLElement();
  }
  get scrollTop() {
    return this.tree.scrollTop;
  }
  set scrollTop(e) {
    this.tree.scrollTop = e;
  }
  get scrollHeight() {
    return this.tree.scrollHeight;
  }
  get renderHeight() {
    return this.tree.renderHeight;
  }
  domFocus() {
    this.tree.domFocus();
  }
  layout(e, t) {
    this.tree.layout(e, t);
  }
  style(e) {
    this.tree.style(e);
  }
  // Model
  getInput() {
    return this.root.element;
  }
  async setInput(e, t) {
    this.refreshPromises.forEach((n) => n.cancel()), this.refreshPromises.clear(), this.root.element = e;
    const i = t && { viewState: t, focus: [], selection: [] };
    await this._updateChildren(e, !0, !1, i), i && (this.tree.setFocus(i.focus), this.tree.setSelection(i.selection)), t && typeof t.scrollTop == "number" && (this.scrollTop = t.scrollTop);
  }
  async _updateChildren(e = this.root.element, t = !0, i = !1, n, o) {
    if (typeof this.root.element > "u")
      throw new Yn(this.user, "Tree input not set");
    this.root.refreshPromise && (await this.root.refreshPromise, await J.toPromise(this._onDidRender.event));
    const r = this.getDataNode(e);
    if (await this.refreshAndRenderNode(r, t, n, o), i)
      try {
        this.tree.rerender(r);
      } catch {
      }
  }
  // View
  rerender(e) {
    if (e === void 0 || e === this.root.element) {
      this.tree.rerender();
      return;
    }
    const t = this.getDataNode(e);
    this.tree.rerender(t);
  }
  // Tree
  getNode(e = this.root.element) {
    const t = this.getDataNode(e), i = this.tree.getNode(t === this.root ? null : t);
    return this.nodeMapper.map(i);
  }
  collapse(e, t = !1) {
    const i = this.getDataNode(e);
    return this.tree.collapse(i === this.root ? null : i, t);
  }
  async expand(e, t = !1) {
    if (typeof this.root.element > "u")
      throw new Yn(this.user, "Tree input not set");
    this.root.refreshPromise && (await this.root.refreshPromise, await J.toPromise(this._onDidRender.event));
    const i = this.getDataNode(e);
    if (this.tree.hasElement(i) && !this.tree.isCollapsible(i) || (i.refreshPromise && (await this.root.refreshPromise, await J.toPromise(this._onDidRender.event)), i !== this.root && !i.refreshPromise && !this.tree.isCollapsed(i)))
      return !1;
    const n = this.tree.expand(i === this.root ? null : i, t);
    return i.refreshPromise && (await this.root.refreshPromise, await J.toPromise(this._onDidRender.event)), n;
  }
  setSelection(e, t) {
    const i = e.map((n) => this.getDataNode(n));
    this.tree.setSelection(i, t);
  }
  getSelection() {
    return this.tree.getSelection().map((t) => t.element);
  }
  setFocus(e, t) {
    const i = e.map((n) => this.getDataNode(n));
    this.tree.setFocus(i, t);
  }
  getFocus() {
    return this.tree.getFocus().map((t) => t.element);
  }
  reveal(e, t) {
    this.tree.reveal(this.getDataNode(e), t);
  }
  // Tree navigation
  getParentElement(e) {
    const t = this.tree.getParentElement(this.getDataNode(e));
    return t && t.element;
  }
  getFirstElementChild(e = this.root.element) {
    const t = this.getDataNode(e), i = this.tree.getFirstElementChild(t === this.root ? null : t);
    return i && i.element;
  }
  // Implementation
  getDataNode(e) {
    const t = this.nodes.get(e === this.root.element ? null : e);
    if (!t)
      throw new Yn(this.user, `Data tree node not found: ${e}`);
    return t;
  }
  async refreshAndRenderNode(e, t, i, n) {
    await this.refreshNode(e, t, i), !this.disposables.isDisposed && this.render(e, i, n);
  }
  async refreshNode(e, t, i) {
    let n;
    if (this.subTreeRefreshPromises.forEach((o, r) => {
      !n && iq(r, e) && (n = o.then(() => this.refreshNode(e, t, i)));
    }), n)
      return n;
    if (e !== this.root && this.tree.getNode(e).collapsed) {
      e.hasChildren = !!this.dataSource.hasChildren(e.element), e.stale = !0, this.setChildren(e, [], t, i);
      return;
    }
    return this.doRefreshSubTree(e, t, i);
  }
  async doRefreshSubTree(e, t, i) {
    let n;
    e.refreshPromise = new Promise((o) => n = o), this.subTreeRefreshPromises.set(e, e.refreshPromise), e.refreshPromise.finally(() => {
      e.refreshPromise = void 0, this.subTreeRefreshPromises.delete(e);
    });
    try {
      const o = await this.doRefreshNode(e, t, i);
      e.stale = !1, await Uw.settled(o.map((r) => this.doRefreshSubTree(r, t, i)));
    } finally {
      n();
    }
  }
  async doRefreshNode(e, t, i) {
    e.hasChildren = !!this.dataSource.hasChildren(e.element);
    let n;
    if (!e.hasChildren)
      n = Promise.resolve(Ye.empty());
    else {
      const o = this.doGetChildren(e);
      if (Xx(o))
        n = Promise.resolve(o);
      else {
        const r = Of(800);
        r.then(() => {
          e.slow = !0, this._onDidChangeNodeSlowState.fire(e);
        }, (a) => null), n = o.finally(() => r.cancel());
      }
    }
    try {
      const o = await n;
      return this.setChildren(e, o, t, i);
    } catch (o) {
      if (e !== this.root && this.tree.hasElement(e) && this.tree.collapse(e), wg(o))
        return [];
      throw o;
    } finally {
      e.slow && (e.slow = !1, this._onDidChangeNodeSlowState.fire(e));
    }
  }
  doGetChildren(e) {
    let t = this.refreshPromises.get(e);
    if (t)
      return t;
    const i = this.dataSource.getChildren(e.element);
    return Xx(i) ? this.processChildren(i) : (t = oM(async () => this.processChildren(await i)), this.refreshPromises.set(e, t), t.finally(() => {
      this.refreshPromises.delete(e);
    }));
  }
  _onDidChangeCollapseState({ node: e, deep: t }) {
    e.element !== null && !e.collapsed && e.element.stale && (t ? this.collapse(e.element.element) : this.refreshAndRenderNode(e.element, !1).catch(ht));
  }
  setChildren(e, t, i, n) {
    const o = [...t];
    if (e.children.length === 0 && o.length === 0)
      return [];
    const r = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map();
    for (const h of e.children)
      r.set(h.element, h), this.identityProvider && a.set(h.id, { node: h, collapsed: this.tree.hasElement(h) && this.tree.isCollapsed(h) });
    const l = [], c = o.map((h) => {
      const d = !!this.dataSource.hasChildren(h);
      if (!this.identityProvider) {
        const m = lC({ element: h, parent: e, hasChildren: d, defaultCollapseState: this.getDefaultCollapseState(h) });
        return d && m.defaultCollapseState === qn.PreserveOrExpanded && l.push(m), m;
      }
      const u = this.identityProvider.getId(h).toString(), f = a.get(u);
      if (f) {
        const m = f.node;
        return r.delete(m.element), this.nodes.delete(m.element), this.nodes.set(h, m), m.element = h, m.hasChildren = d, i ? f.collapsed ? (m.children.forEach((_) => Uy(_, (b) => this.nodes.delete(b.element))), m.children.splice(0, m.children.length), m.stale = !0) : l.push(m) : d && !f.collapsed && l.push(m), m;
      }
      const g = lC({ element: h, parent: e, id: u, hasChildren: d, defaultCollapseState: this.getDefaultCollapseState(h) });
      return n && n.viewState.focus && n.viewState.focus.indexOf(u) > -1 && n.focus.push(g), n && n.viewState.selection && n.viewState.selection.indexOf(u) > -1 && n.selection.push(g), (n && n.viewState.expanded && n.viewState.expanded.indexOf(u) > -1 || d && g.defaultCollapseState === qn.PreserveOrExpanded) && l.push(g), g;
    });
    for (const h of r.values())
      Uy(h, (d) => this.nodes.delete(d.element));
    for (const h of c)
      this.nodes.set(h.element, h);
    return e.children.splice(0, e.children.length, ...c), e !== this.root && this.autoExpandSingleChildren && c.length === 1 && l.length === 0 && (c[0].forceExpanded = !0, l.push(c[0])), l;
  }
  render(e, t, i) {
    const n = e.children.map((r) => this.asTreeElement(r, t)), o = i && {
      ...i,
      diffIdentityProvider: i.diffIdentityProvider && {
        getId(r) {
          return i.diffIdentityProvider.getId(r.element);
        }
      }
    };
    this.tree.setChildren(e === this.root ? null : e, n, o), e !== this.root && this.tree.setCollapsible(e, e.hasChildren), this._onDidRender.fire();
  }
  asTreeElement(e, t) {
    if (e.stale)
      return {
        element: e,
        collapsible: e.hasChildren,
        collapsed: !0
      };
    let i;
    return t && t.viewState.expanded && e.id && t.viewState.expanded.indexOf(e.id) > -1 ? i = !1 : e.forceExpanded ? (i = !1, e.forceExpanded = !1) : i = e.defaultCollapseState, {
      element: e,
      children: e.hasChildren ? Ye.map(e.children, (n) => this.asTreeElement(n, t)) : [],
      collapsible: e.hasChildren,
      collapsed: i
    };
  }
  processChildren(e) {
    return this.sorter && (e = [...e].sort(this.sorter.compare.bind(this.sorter))), e;
  }
  dispose() {
    this.disposables.dispose(), this.tree.dispose();
  }
}
class ix {
  get element() {
    return {
      elements: this.node.element.elements.map((e) => e.element),
      incompressible: this.node.element.incompressible
    };
  }
  get children() {
    return this.node.children.map((e) => new ix(e));
  }
  get depth() {
    return this.node.depth;
  }
  get visibleChildrenCount() {
    return this.node.visibleChildrenCount;
  }
  get visibleChildIndex() {
    return this.node.visibleChildIndex;
  }
  get collapsible() {
    return this.node.collapsible;
  }
  get collapsed() {
    return this.node.collapsed;
  }
  get visible() {
    return this.node.visible;
  }
  get filterData() {
    return this.node.filterData;
  }
  constructor(e) {
    this.node = e;
  }
}
class rq {
  constructor(e, t, i, n) {
    this.renderer = e, this.nodeMapper = t, this.compressibleNodeMapperProvider = i, this.onDidChangeTwistieState = n, this.renderedNodes = /* @__PURE__ */ new Map(), this.disposables = [], this.templateId = e.templateId;
  }
  renderTemplate(e) {
    return { templateData: this.renderer.renderTemplate(e) };
  }
  renderElement(e, t, i, n) {
    this.renderer.renderElement(this.nodeMapper.map(e), t, i.templateData, n);
  }
  renderCompressedElements(e, t, i, n) {
    this.renderer.renderCompressedElements(this.compressibleNodeMapperProvider().map(e), t, i.templateData, n);
  }
  renderTwistie(e, t) {
    return e.slow ? (t.classList.add(...Ke.asClassNameArray(re.treeItemLoading)), !0) : (t.classList.remove(...Ke.asClassNameArray(re.treeItemLoading)), !1);
  }
  disposeElement(e, t, i, n) {
    var o, r;
    (r = (o = this.renderer).disposeElement) == null || r.call(o, this.nodeMapper.map(e), t, i.templateData, n);
  }
  disposeCompressedElements(e, t, i, n) {
    var o, r;
    (r = (o = this.renderer).disposeCompressedElements) == null || r.call(o, this.compressibleNodeMapperProvider().map(e), t, i.templateData, n);
  }
  disposeTemplate(e) {
    this.renderer.disposeTemplate(e.templateData);
  }
  dispose() {
    this.renderedNodes.clear(), this.disposables = Ri(this.disposables);
  }
}
function aq(s) {
  const e = s && C4(s);
  return e && {
    ...e,
    keyboardNavigationLabelProvider: e.keyboardNavigationLabelProvider && {
      ...e.keyboardNavigationLabelProvider,
      getCompressedNodeKeyboardNavigationLabel(t) {
        return s.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(t.map((i) => i.element));
      }
    }
  };
}
class lq extends w4 {
  constructor(e, t, i, n, o, r, a = {}) {
    super(e, t, i, o, r, a), this.compressionDelegate = n, this.compressibleNodeMapper = new Zk((l) => new ix(l)), this.filter = a.filter;
  }
  createTree(e, t, i, n, o) {
    const r = new Qk(i), a = n.map((c) => new rq(c, this.nodeMapper, () => this.compressibleNodeMapper, this._onDidChangeNodeSlowState.event)), l = aq(o) || {};
    return new b4(e, t, r, a, l);
  }
  asTreeElement(e, t) {
    return {
      incompressible: this.compressionDelegate.isIncompressible(e.element),
      ...super.asTreeElement(e, t)
    };
  }
  updateOptions(e = {}) {
    this.tree.updateOptions(e);
  }
  render(e, t, i) {
    if (!this.identityProvider)
      return super.render(e, t);
    const n = (f) => this.identityProvider.getId(f).toString(), o = (f) => {
      const g = /* @__PURE__ */ new Set();
      for (const m of f) {
        const _ = this.tree.getCompressedTreeNode(m === this.root ? null : m);
        if (_.element)
          for (const b of _.element.elements)
            g.add(n(b.element));
      }
      return g;
    }, r = o(this.tree.getSelection()), a = o(this.tree.getFocus());
    super.render(e, t, i);
    const l = this.getSelection();
    let c = !1;
    const h = this.getFocus();
    let d = !1;
    const u = (f) => {
      const g = f.element;
      if (g)
        for (let m = 0; m < g.elements.length; m++) {
          const _ = n(g.elements[m].element), b = g.elements[g.elements.length - 1].element;
          r.has(_) && l.indexOf(b) === -1 && (l.push(b), c = !0), a.has(_) && h.indexOf(b) === -1 && (h.push(b), d = !0);
        }
      f.children.forEach(u);
    };
    u(this.tree.getCompressedTreeNode(e === this.root ? null : e)), c && this.setSelection(l), d && this.setFocus(h);
  }
  // For compressed async data trees, `TreeVisibility.Recurse` doesn't currently work
  // and we have to filter everything beforehand
  // Related to #85193 and #85835
  processChildren(e) {
    return this.filter && (e = Ye.filter(e, (t) => {
      const i = this.filter.filter(
        t,
        1
        /* TreeVisibility.Visible */
      ), n = cq(i);
      if (n === 2)
        throw new Error("Recursive tree visibility not supported in async data compressed trees");
      return n === 1;
    })), super.processChildren(e);
  }
}
function cq(s) {
  return typeof s == "boolean" ? s ? 1 : 0 : Yk(s) ? ng(s.visibility) : ng(s);
}
class hq extends m4 {
  constructor(e, t, i, n, o, r = {}) {
    super(e, t, i, n, r), this.user = e, this.dataSource = o, this.identityProvider = r.identityProvider;
  }
  createModel(e, t, i) {
    return new Xk(e, t, i);
  }
}
new de("isMac", He, p("isMac", "Whether the operating system is macOS"));
new de("isLinux", wn, p("isLinux", "Whether the operating system is Linux"));
new de("isWindows", Fn, p("isWindows", "Whether the operating system is Windows"));
new de("isWeb", Fd, p("isWeb", "Whether the platform is a web browser"));
new de("isMacNative", He && !Fd, p("isMacNative", "Whether the operating system is macOS on a non-browser platform"));
new de("isIOS", fc, p("isIOS", "Whether the operating system is iOS"));
new de("isMobile", x2, p("isMobile", "Whether the platform is a mobile web browser"));
new de("isDevelopment", !1, !0);
new de("productQualityType", "", p("productQualityType", "Quality type of VS Code"));
const v4 = "inputFocus", dq = new de(v4, !1, p("inputFocus", "Whether keyboard focus is inside an input box"));
var na = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, wt = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const Qo = Ve("listService");
class uq {
  get lastFocusedList() {
    return this._lastFocusedWidget;
  }
  constructor() {
    this.disposables = new he(), this.lists = [], this._lastFocusedWidget = void 0, this._hasCreatedStyleController = !1;
  }
  setLastFocusedList(e) {
    var t, i;
    e !== this._lastFocusedWidget && ((t = this._lastFocusedWidget) == null || t.getHTMLElement().classList.remove("last-focused"), this._lastFocusedWidget = e, (i = this._lastFocusedWidget) == null || i.getHTMLElement().classList.add("last-focused"));
  }
  register(e, t) {
    if (this._hasCreatedStyleController || (this._hasCreatedStyleController = !0, new xA(Os(), "").style(Kd)), this.lists.some((n) => n.widget === e))
      throw new Error("Cannot register the same widget multiple times");
    const i = { widget: e, extraContextKeys: t };
    return this.lists.push(i), HL(e.getHTMLElement()) && this.setLastFocusedList(e), Wo(e.onDidFocus(() => this.setLastFocusedList(e)), ke(() => this.lists.splice(this.lists.indexOf(i), 1)), e.onDidDispose(() => {
      this.lists = this.lists.filter((n) => n !== i), this._lastFocusedWidget === e && this.setLastFocusedList(void 0);
    }));
  }
  dispose() {
    this.disposables.dispose();
  }
}
const sg = new de("listScrollAtBoundary", "none");
et.or(sg.isEqualTo("top"), sg.isEqualTo("both"));
et.or(sg.isEqualTo("bottom"), sg.isEqualTo("both"));
const y4 = new de("listFocus", !0), S4 = new de("treestickyScrollFocused", !1), zb = new de("listSupportsMultiselect", !0);
et.and(y4, et.not(v4), S4.negate());
const nx = new de("listHasSelectionOrFocus", !1), sx = new de("listDoubleSelection", !1), ox = new de("listMultiSelection", !1), Ub = new de("listSelectionNavigation", !1), fq = new de("listSupportsFind", !0), gq = new de("treeElementCanCollapse", !1), mq = new de("treeElementHasParent", !1), pq = new de("treeElementCanExpand", !1), _q = new de("treeElementHasChild", !1), bq = new de("treeFindOpen", !1), L4 = "listTypeNavigationMode", k4 = "listAutomaticKeyboardNavigation";
function $b(s, e) {
  const t = s.createScoped(e.getHTMLElement());
  return y4.bindTo(t), t;
}
function Kb(s, e) {
  const t = sg.bindTo(s), i = () => {
    const n = e.scrollTop === 0, o = e.scrollHeight - e.renderHeight - e.scrollTop < 1;
    n && o ? t.set("both") : n ? t.set("top") : o ? t.set("bottom") : t.set("none");
  };
  return i(), e.onDidScroll(i);
}
const Wc = "workbench.list.multiSelectModifier", cp = "workbench.list.openMode", _s = "workbench.list.horizontalScrolling", rx = "workbench.list.defaultFindMode", ax = "workbench.list.typeNavigationMode", b_ = "workbench.list.keyboardNavigation", lo = "workbench.list.scrollByPage", lx = "workbench.list.defaultFindMatchType", og = "workbench.tree.indent", C_ = "workbench.tree.renderIndentGuides", co = "workbench.list.smoothScrolling", Ko = "workbench.list.mouseWheelScrollSensitivity", qo = "workbench.list.fastScrollSensitivity", w_ = "workbench.tree.expandMode", v_ = "workbench.tree.enableStickyScroll", y_ = "workbench.tree.stickyScrollMaxItemCount";
function jo(s) {
  return s.getValue(Wc) === "alt";
}
class Cq extends q {
  constructor(e) {
    super(), this.configurationService = e, this.useAltAsMultipleSelectionModifier = jo(e), this.registerListeners();
  }
  registerListeners() {
    this._register(this.configurationService.onDidChangeConfiguration((e) => {
      e.affectsConfiguration(Wc) && (this.useAltAsMultipleSelectionModifier = jo(this.configurationService));
    }));
  }
  isSelectionSingleChangeEvent(e) {
    return this.useAltAsMultipleSelectionModifier ? e.browserEvent.altKey : SA(e);
  }
  isSelectionRangeChangeEvent(e) {
    return LA(e);
  }
}
function qb(s, e) {
  const t = s.get(Vt), i = s.get(Ai), n = new he();
  return [{
    ...e,
    keyboardNavigationDelegate: { mightProducePrintableCharacter(r) {
      return i.mightProducePrintableCharacter(r);
    } },
    smoothScrolling: !!t.getValue(co),
    mouseWheelScrollSensitivity: t.getValue(Ko),
    fastScrollSensitivity: t.getValue(qo),
    multipleSelectionController: e.multipleSelectionController ?? n.add(new Cq(t)),
    keyboardNavigationEventFilter: yq(i),
    scrollByPage: !!t.getValue(lo)
  }, n];
}
let TN = class extends mo {
  constructor(e, t, i, n, o, r, a, l, c) {
    const h = typeof o.horizontalScrolling < "u" ? o.horizontalScrolling : !!l.getValue(_s), [d, u] = c.invokeFunction(qb, o);
    super(e, t, i, n, {
      keyboardSupport: !1,
      ...d,
      horizontalScrolling: h
    }), this.disposables.add(u), this.contextKeyService = $b(r, this), this.disposables.add(Kb(this.contextKeyService, this)), this.listSupportsMultiSelect = zb.bindTo(this.contextKeyService), this.listSupportsMultiSelect.set(o.multipleSelectionSupport !== !1), Ub.bindTo(this.contextKeyService).set(!!o.selectionNavigation), this.listHasSelectionOrFocus = nx.bindTo(this.contextKeyService), this.listDoubleSelection = sx.bindTo(this.contextKeyService), this.listMultiSelection = ox.bindTo(this.contextKeyService), this.horizontalScrolling = o.horizontalScrolling, this._useAltAsMultipleSelectionModifier = jo(l), this.disposables.add(this.contextKeyService), this.disposables.add(a.register(this)), this.updateStyles(o.overrideStyles), this.disposables.add(this.onDidChangeSelection(() => {
      const g = this.getSelection(), m = this.getFocus();
      this.contextKeyService.bufferChangeEvents(() => {
        this.listHasSelectionOrFocus.set(g.length > 0 || m.length > 0), this.listMultiSelection.set(g.length > 1), this.listDoubleSelection.set(g.length === 2);
      });
    })), this.disposables.add(this.onDidChangeFocus(() => {
      const g = this.getSelection(), m = this.getFocus();
      this.listHasSelectionOrFocus.set(g.length > 0 || m.length > 0);
    })), this.disposables.add(l.onDidChangeConfiguration((g) => {
      g.affectsConfiguration(Wc) && (this._useAltAsMultipleSelectionModifier = jo(l));
      let m = {};
      if (g.affectsConfiguration(_s) && this.horizontalScrolling === void 0) {
        const _ = !!l.getValue(_s);
        m = { ...m, horizontalScrolling: _ };
      }
      if (g.affectsConfiguration(lo)) {
        const _ = !!l.getValue(lo);
        m = { ...m, scrollByPage: _ };
      }
      if (g.affectsConfiguration(co)) {
        const _ = !!l.getValue(co);
        m = { ...m, smoothScrolling: _ };
      }
      if (g.affectsConfiguration(Ko)) {
        const _ = l.getValue(Ko);
        m = { ...m, mouseWheelScrollSensitivity: _ };
      }
      if (g.affectsConfiguration(qo)) {
        const _ = l.getValue(qo);
        m = { ...m, fastScrollSensitivity: _ };
      }
      Object.keys(m).length > 0 && this.updateOptions(m);
    })), this.navigator = new x4(this, { configurationService: l, ...o }), this.disposables.add(this.navigator);
  }
  updateOptions(e) {
    super.updateOptions(e), e.overrideStyles !== void 0 && this.updateStyles(e.overrideStyles), e.multipleSelectionSupport !== void 0 && this.listSupportsMultiSelect.set(!!e.multipleSelectionSupport);
  }
  updateStyles(e) {
    this.style(e ? Vg(e) : Kd);
  }
};
TN = na([
  wt(5, nt),
  wt(6, Qo),
  wt(7, Vt),
  wt(8, ot)
], TN);
let MN = class extends wK {
  constructor(e, t, i, n, o, r, a, l, c) {
    const h = typeof o.horizontalScrolling < "u" ? o.horizontalScrolling : !!l.getValue(_s), [d, u] = c.invokeFunction(qb, o);
    super(e, t, i, n, {
      keyboardSupport: !1,
      ...d,
      horizontalScrolling: h
    }), this.disposables = new he(), this.disposables.add(u), this.contextKeyService = $b(r, this), this.disposables.add(Kb(this.contextKeyService, this.widget)), this.horizontalScrolling = o.horizontalScrolling, this.listSupportsMultiSelect = zb.bindTo(this.contextKeyService), this.listSupportsMultiSelect.set(o.multipleSelectionSupport !== !1), Ub.bindTo(this.contextKeyService).set(!!o.selectionNavigation), this._useAltAsMultipleSelectionModifier = jo(l), this.disposables.add(this.contextKeyService), this.disposables.add(a.register(this)), this.updateStyles(o.overrideStyles), this.disposables.add(l.onDidChangeConfiguration((g) => {
      g.affectsConfiguration(Wc) && (this._useAltAsMultipleSelectionModifier = jo(l));
      let m = {};
      if (g.affectsConfiguration(_s) && this.horizontalScrolling === void 0) {
        const _ = !!l.getValue(_s);
        m = { ...m, horizontalScrolling: _ };
      }
      if (g.affectsConfiguration(lo)) {
        const _ = !!l.getValue(lo);
        m = { ...m, scrollByPage: _ };
      }
      if (g.affectsConfiguration(co)) {
        const _ = !!l.getValue(co);
        m = { ...m, smoothScrolling: _ };
      }
      if (g.affectsConfiguration(Ko)) {
        const _ = l.getValue(Ko);
        m = { ...m, mouseWheelScrollSensitivity: _ };
      }
      if (g.affectsConfiguration(qo)) {
        const _ = l.getValue(qo);
        m = { ...m, fastScrollSensitivity: _ };
      }
      Object.keys(m).length > 0 && this.updateOptions(m);
    })), this.navigator = new x4(this, { configurationService: l, ...o }), this.disposables.add(this.navigator);
  }
  updateOptions(e) {
    super.updateOptions(e), e.overrideStyles !== void 0 && this.updateStyles(e.overrideStyles), e.multipleSelectionSupport !== void 0 && this.listSupportsMultiSelect.set(!!e.multipleSelectionSupport);
  }
  updateStyles(e) {
    this.style(e ? Vg(e) : Kd);
  }
  dispose() {
    this.disposables.dispose(), super.dispose();
  }
};
MN = na([
  wt(5, nt),
  wt(6, Qo),
  wt(7, Vt),
  wt(8, ot)
], MN);
let RN = class extends Wy {
  constructor(e, t, i, n, o, r, a, l, c, h) {
    const d = typeof r.horizontalScrolling < "u" ? r.horizontalScrolling : !!c.getValue(_s), [u, f] = h.invokeFunction(qb, r);
    super(e, t, i, n, o, {
      keyboardSupport: !1,
      ...u,
      horizontalScrolling: d
    }), this.disposables.add(f), this.contextKeyService = $b(a, this), this.disposables.add(Kb(this.contextKeyService, this)), this.listSupportsMultiSelect = zb.bindTo(this.contextKeyService), this.listSupportsMultiSelect.set(r.multipleSelectionSupport !== !1), Ub.bindTo(this.contextKeyService).set(!!r.selectionNavigation), this.listHasSelectionOrFocus = nx.bindTo(this.contextKeyService), this.listDoubleSelection = sx.bindTo(this.contextKeyService), this.listMultiSelection = ox.bindTo(this.contextKeyService), this.horizontalScrolling = r.horizontalScrolling, this._useAltAsMultipleSelectionModifier = jo(c), this.disposables.add(this.contextKeyService), this.disposables.add(l.register(this)), this.updateStyles(r.overrideStyles), this.disposables.add(this.onDidChangeSelection(() => {
      const m = this.getSelection(), _ = this.getFocus();
      this.contextKeyService.bufferChangeEvents(() => {
        this.listHasSelectionOrFocus.set(m.length > 0 || _.length > 0), this.listMultiSelection.set(m.length > 1), this.listDoubleSelection.set(m.length === 2);
      });
    })), this.disposables.add(this.onDidChangeFocus(() => {
      const m = this.getSelection(), _ = this.getFocus();
      this.listHasSelectionOrFocus.set(m.length > 0 || _.length > 0);
    })), this.disposables.add(c.onDidChangeConfiguration((m) => {
      m.affectsConfiguration(Wc) && (this._useAltAsMultipleSelectionModifier = jo(c));
      let _ = {};
      if (m.affectsConfiguration(_s) && this.horizontalScrolling === void 0) {
        const b = !!c.getValue(_s);
        _ = { ..._, horizontalScrolling: b };
      }
      if (m.affectsConfiguration(lo)) {
        const b = !!c.getValue(lo);
        _ = { ..._, scrollByPage: b };
      }
      if (m.affectsConfiguration(co)) {
        const b = !!c.getValue(co);
        _ = { ..._, smoothScrolling: b };
      }
      if (m.affectsConfiguration(Ko)) {
        const b = c.getValue(Ko);
        _ = { ..._, mouseWheelScrollSensitivity: b };
      }
      if (m.affectsConfiguration(qo)) {
        const b = c.getValue(qo);
        _ = { ..._, fastScrollSensitivity: b };
      }
      Object.keys(_).length > 0 && this.updateOptions(_);
    })), this.navigator = new wq(this, { configurationService: c, ...r }), this.disposables.add(this.navigator);
  }
  updateOptions(e) {
    super.updateOptions(e), e.overrideStyles !== void 0 && this.updateStyles(e.overrideStyles), e.multipleSelectionSupport !== void 0 && this.listSupportsMultiSelect.set(!!e.multipleSelectionSupport);
  }
  updateStyles(e) {
    this.style(e ? Vg(e) : Kd);
  }
  dispose() {
    this.disposables.dispose(), super.dispose();
  }
};
RN = na([
  wt(6, nt),
  wt(7, Qo),
  wt(8, Vt),
  wt(9, ot)
], RN);
class cx extends q {
  constructor(e, t) {
    super(), this.widget = e, this._onDidOpen = this._register(new O()), this.onDidOpen = this._onDidOpen.event, this._register(J.filter(this.widget.onDidChangeSelection, (i) => wr(i.browserEvent))((i) => this.onSelectionFromKeyboard(i))), this._register(this.widget.onPointer((i) => this.onPointer(i.element, i.browserEvent))), this._register(this.widget.onMouseDblClick((i) => this.onMouseDblClick(i.element, i.browserEvent))), typeof (t == null ? void 0 : t.openOnSingleClick) != "boolean" && (t != null && t.configurationService) ? (this.openOnSingleClick = (t == null ? void 0 : t.configurationService.getValue(cp)) !== "doubleClick", this._register(t == null ? void 0 : t.configurationService.onDidChangeConfiguration((i) => {
      i.affectsConfiguration(cp) && (this.openOnSingleClick = (t == null ? void 0 : t.configurationService.getValue(cp)) !== "doubleClick");
    }))) : this.openOnSingleClick = (t == null ? void 0 : t.openOnSingleClick) ?? !0;
  }
  onSelectionFromKeyboard(e) {
    if (e.elements.length !== 1)
      return;
    const t = e.browserEvent, i = typeof t.preserveFocus == "boolean" ? t.preserveFocus : !0, n = typeof t.pinned == "boolean" ? t.pinned : !i;
    this._open(this.getSelectedElement(), i, n, !1, e.browserEvent);
  }
  onPointer(e, t) {
    if (!this.openOnSingleClick || t.detail === 2)
      return;
    const n = t.button === 1, o = !0, r = n, a = t.ctrlKey || t.metaKey || t.altKey;
    this._open(e, o, r, a, t);
  }
  onMouseDblClick(e, t) {
    if (!t)
      return;
    const i = t.target;
    if (i.classList.contains("monaco-tl-twistie") || i.classList.contains("monaco-icon-label") && i.classList.contains("folder-icon") && t.offsetX < 16)
      return;
    const o = !1, r = !0, a = t.ctrlKey || t.metaKey || t.altKey;
    this._open(e, o, r, a, t);
  }
  _open(e, t, i, n, o) {
    e && this._onDidOpen.fire({
      editorOptions: {
        preserveFocus: t,
        pinned: i,
        revealIfVisible: !0
      },
      sideBySide: n,
      element: e,
      browserEvent: o
    });
  }
}
class x4 extends cx {
  constructor(e, t) {
    super(e, t), this.widget = e;
  }
  getSelectedElement() {
    return this.widget.getSelectedElements()[0];
  }
}
class wq extends cx {
  constructor(e, t) {
    super(e, t);
  }
  getSelectedElement() {
    return this.widget.getSelectedElements()[0];
  }
}
class vq extends cx {
  constructor(e, t) {
    super(e, t);
  }
  getSelectedElement() {
    return this.widget.getSelection()[0] ?? void 0;
  }
}
function yq(s) {
  let e = !1;
  return (t) => {
    if (t.toKeyCodeChord().isModifierKey())
      return !1;
    if (e)
      return e = !1, !1;
    const i = s.softDispatch(t, t.target);
    return i.kind === 1 ? (e = !0, !1) : (e = !1, i.kind === 0);
  };
}
let $y = class extends ex {
  constructor(e, t, i, n, o, r, a, l, c) {
    const { options: h, getTypeNavigationMode: d, disposable: u } = r.invokeFunction($g, o);
    super(e, t, i, n, h), this.disposables.add(u), this.internals = new Sc(this, o, d, o.overrideStyles, a, l, c), this.disposables.add(this.internals);
  }
  updateOptions(e) {
    super.updateOptions(e), this.internals.updateOptions(e);
  }
};
$y = na([
  wt(5, ot),
  wt(6, nt),
  wt(7, Qo),
  wt(8, Vt)
], $y);
let AN = class extends b4 {
  constructor(e, t, i, n, o, r, a, l, c) {
    const { options: h, getTypeNavigationMode: d, disposable: u } = r.invokeFunction($g, o);
    super(e, t, i, n, h), this.disposables.add(u), this.internals = new Sc(this, o, d, o.overrideStyles, a, l, c), this.disposables.add(this.internals);
  }
  updateOptions(e = {}) {
    super.updateOptions(e), e.overrideStyles && this.internals.updateStyleOverrides(e.overrideStyles), this.internals.updateOptions(e);
  }
};
AN = na([
  wt(5, ot),
  wt(6, nt),
  wt(7, Qo),
  wt(8, Vt)
], AN);
let PN = class extends hq {
  constructor(e, t, i, n, o, r, a, l, c, h) {
    const { options: d, getTypeNavigationMode: u, disposable: f } = a.invokeFunction($g, r);
    super(e, t, i, n, o, d), this.disposables.add(f), this.internals = new Sc(this, r, u, r.overrideStyles, l, c, h), this.disposables.add(this.internals);
  }
  updateOptions(e = {}) {
    super.updateOptions(e), e.overrideStyles !== void 0 && this.internals.updateStyleOverrides(e.overrideStyles), this.internals.updateOptions(e);
  }
};
PN = na([
  wt(6, ot),
  wt(7, nt),
  wt(8, Qo),
  wt(9, Vt)
], PN);
let ON = class extends w4 {
  get onDidOpen() {
    return this.internals.onDidOpen;
  }
  constructor(e, t, i, n, o, r, a, l, c, h) {
    const { options: d, getTypeNavigationMode: u, disposable: f } = a.invokeFunction($g, r);
    super(e, t, i, n, o, d), this.disposables.add(f), this.internals = new Sc(this, r, u, r.overrideStyles, l, c, h), this.disposables.add(this.internals);
  }
  updateOptions(e = {}) {
    super.updateOptions(e), e.overrideStyles && this.internals.updateStyleOverrides(e.overrideStyles), this.internals.updateOptions(e);
  }
};
ON = na([
  wt(6, ot),
  wt(7, nt),
  wt(8, Qo),
  wt(9, Vt)
], ON);
let FN = class extends lq {
  constructor(e, t, i, n, o, r, a, l, c, h, d) {
    const { options: u, getTypeNavigationMode: f, disposable: g } = l.invokeFunction($g, a);
    super(e, t, i, n, o, r, u), this.disposables.add(g), this.internals = new Sc(this, a, f, a.overrideStyles, c, h, d), this.disposables.add(this.internals);
  }
  updateOptions(e) {
    super.updateOptions(e), this.internals.updateOptions(e);
  }
};
FN = na([
  wt(7, ot),
  wt(8, nt),
  wt(9, Qo),
  wt(10, Vt)
], FN);
function D4(s) {
  const e = s.getValue(rx);
  if (e === "highlight")
    return Pr.Highlight;
  if (e === "filter")
    return Pr.Filter;
  const t = s.getValue(b_);
  if (t === "simple" || t === "highlight")
    return Pr.Highlight;
  if (t === "filter")
    return Pr.Filter;
}
function E4(s) {
  const e = s.getValue(lx);
  if (e === "fuzzy")
    return yc.Fuzzy;
  if (e === "contiguous")
    return yc.Contiguous;
}
function $g(s, e) {
  const t = s.get(Vt), i = s.get(Pg), n = s.get(nt), o = s.get(ot), r = () => {
    const u = n.getContextKeyValue(L4);
    if (u === "automatic")
      return Fo.Automatic;
    if (u === "trigger" || n.getContextKeyValue(k4) === !1)
      return Fo.Trigger;
    const g = t.getValue(ax);
    if (g === "automatic")
      return Fo.Automatic;
    if (g === "trigger")
      return Fo.Trigger;
  }, a = e.horizontalScrolling !== void 0 ? e.horizontalScrolling : !!t.getValue(_s), [l, c] = o.invokeFunction(qb, e), h = e.paddingBottom, d = e.renderIndentGuides !== void 0 ? e.renderIndentGuides : t.getValue(C_);
  return {
    getTypeNavigationMode: r,
    disposable: c,
    options: {
      // ...options, // TODO@Joao why is this not splatted here?
      keyboardSupport: !1,
      ...l,
      indent: typeof t.getValue(og) == "number" ? t.getValue(og) : void 0,
      renderIndentGuides: d,
      smoothScrolling: !!t.getValue(co),
      defaultFindMode: D4(t),
      defaultFindMatchType: E4(t),
      horizontalScrolling: a,
      scrollByPage: !!t.getValue(lo),
      paddingBottom: h,
      hideTwistiesOfChildlessElements: e.hideTwistiesOfChildlessElements,
      expandOnlyOnTwistieClick: e.expandOnlyOnTwistieClick ?? t.getValue(w_) === "doubleClick",
      contextViewProvider: i,
      findWidgetStyles: dz,
      enableStickyScroll: !!t.getValue(v_),
      stickyScrollMaxItemCount: Number(t.getValue(y_))
    }
  };
}
let Sc = class {
  get onDidOpen() {
    return this.navigator.onDidOpen;
  }
  constructor(e, t, i, n, o, r, a) {
    this.tree = e, this.disposables = [], this.contextKeyService = $b(o, e), this.disposables.push(Kb(this.contextKeyService, e)), this.listSupportsMultiSelect = zb.bindTo(this.contextKeyService), this.listSupportsMultiSelect.set(t.multipleSelectionSupport !== !1), Ub.bindTo(this.contextKeyService).set(!!t.selectionNavigation), this.listSupportFindWidget = fq.bindTo(this.contextKeyService), this.listSupportFindWidget.set(t.findWidgetEnabled ?? !0), this.hasSelectionOrFocus = nx.bindTo(this.contextKeyService), this.hasDoubleSelection = sx.bindTo(this.contextKeyService), this.hasMultiSelection = ox.bindTo(this.contextKeyService), this.treeElementCanCollapse = gq.bindTo(this.contextKeyService), this.treeElementHasParent = mq.bindTo(this.contextKeyService), this.treeElementCanExpand = pq.bindTo(this.contextKeyService), this.treeElementHasChild = _q.bindTo(this.contextKeyService), this.treeFindOpen = bq.bindTo(this.contextKeyService), this.treeStickyScrollFocused = S4.bindTo(this.contextKeyService), this._useAltAsMultipleSelectionModifier = jo(a), this.updateStyleOverrides(n);
    const c = () => {
      const d = e.getFocus()[0];
      if (!d)
        return;
      const u = e.getNode(d);
      this.treeElementCanCollapse.set(u.collapsible && !u.collapsed), this.treeElementHasParent.set(!!e.getParentElement(d)), this.treeElementCanExpand.set(u.collapsible && u.collapsed), this.treeElementHasChild.set(!!e.getFirstElementChild(d));
    }, h = /* @__PURE__ */ new Set();
    h.add(L4), h.add(k4), this.disposables.push(this.contextKeyService, r.register(e), e.onDidChangeSelection(() => {
      const d = e.getSelection(), u = e.getFocus();
      this.contextKeyService.bufferChangeEvents(() => {
        this.hasSelectionOrFocus.set(d.length > 0 || u.length > 0), this.hasMultiSelection.set(d.length > 1), this.hasDoubleSelection.set(d.length === 2);
      });
    }), e.onDidChangeFocus(() => {
      const d = e.getSelection(), u = e.getFocus();
      this.hasSelectionOrFocus.set(d.length > 0 || u.length > 0), c();
    }), e.onDidChangeCollapseState(c), e.onDidChangeModel(c), e.onDidChangeFindOpenState((d) => this.treeFindOpen.set(d)), e.onDidChangeStickyScrollFocused((d) => this.treeStickyScrollFocused.set(d)), a.onDidChangeConfiguration((d) => {
      let u = {};
      if (d.affectsConfiguration(Wc) && (this._useAltAsMultipleSelectionModifier = jo(a)), d.affectsConfiguration(og)) {
        const f = a.getValue(og);
        u = { ...u, indent: f };
      }
      if (d.affectsConfiguration(C_) && t.renderIndentGuides === void 0) {
        const f = a.getValue(C_);
        u = { ...u, renderIndentGuides: f };
      }
      if (d.affectsConfiguration(co)) {
        const f = !!a.getValue(co);
        u = { ...u, smoothScrolling: f };
      }
      if (d.affectsConfiguration(rx) || d.affectsConfiguration(b_)) {
        const f = D4(a);
        u = { ...u, defaultFindMode: f };
      }
      if (d.affectsConfiguration(ax) || d.affectsConfiguration(b_)) {
        const f = i();
        u = { ...u, typeNavigationMode: f };
      }
      if (d.affectsConfiguration(lx)) {
        const f = E4(a);
        u = { ...u, defaultFindMatchType: f };
      }
      if (d.affectsConfiguration(_s) && t.horizontalScrolling === void 0) {
        const f = !!a.getValue(_s);
        u = { ...u, horizontalScrolling: f };
      }
      if (d.affectsConfiguration(lo)) {
        const f = !!a.getValue(lo);
        u = { ...u, scrollByPage: f };
      }
      if (d.affectsConfiguration(w_) && t.expandOnlyOnTwistieClick === void 0 && (u = { ...u, expandOnlyOnTwistieClick: a.getValue(w_) === "doubleClick" }), d.affectsConfiguration(v_)) {
        const f = a.getValue(v_);
        u = { ...u, enableStickyScroll: f };
      }
      if (d.affectsConfiguration(y_)) {
        const f = Math.max(1, a.getValue(y_));
        u = { ...u, stickyScrollMaxItemCount: f };
      }
      if (d.affectsConfiguration(Ko)) {
        const f = a.getValue(Ko);
        u = { ...u, mouseWheelScrollSensitivity: f };
      }
      if (d.affectsConfiguration(qo)) {
        const f = a.getValue(qo);
        u = { ...u, fastScrollSensitivity: f };
      }
      Object.keys(u).length > 0 && e.updateOptions(u);
    }), this.contextKeyService.onDidChangeContext((d) => {
      d.affectsSome(h) && e.updateOptions({ typeNavigationMode: i() });
    })), this.navigator = new vq(e, { configurationService: a, ...t }), this.disposables.push(this.navigator);
  }
  updateOptions(e) {
    e.multipleSelectionSupport !== void 0 && this.listSupportsMultiSelect.set(!!e.multipleSelectionSupport);
  }
  updateStyleOverrides(e) {
    this.tree.style(e ? Vg(e) : Kd);
  }
  dispose() {
    this.disposables = Ri(this.disposables);
  }
};
Sc = na([
  wt(4, nt),
  wt(5, Qo),
  wt(6, Vt)
], Sc);
const Sq = Li.as(Oc.Configuration);
Sq.registerConfiguration({
  id: "workbench",
  order: 7,
  title: p("workbenchConfigurationTitle", "Workbench"),
  type: "object",
  properties: {
    [Wc]: {
      type: "string",
      enum: ["ctrlCmd", "alt"],
      markdownEnumDescriptions: [
        p("multiSelectModifier.ctrlCmd", "Maps to `Control` on Windows and Linux and to `Command` on macOS."),
        p("multiSelectModifier.alt", "Maps to `Alt` on Windows and Linux and to `Option` on macOS.")
      ],
      default: "ctrlCmd",
      description: p({
        key: "multiSelectModifier",
        comment: [
          "- `ctrlCmd` refers to a value the setting can take and should not be localized.",
          "- `Control` and `Command` refer to the modifier keys Ctrl or Cmd on the keyboard and can be localized."
        ]
      }, "The modifier to be used to add an item in trees and lists to a multi-selection with the mouse (for example in the explorer, open editors and scm view). The 'Open to Side' mouse gestures - if supported - will adapt such that they do not conflict with the multiselect modifier.")
    },
    [cp]: {
      type: "string",
      enum: ["singleClick", "doubleClick"],
      default: "singleClick",
      description: p({
        key: "openModeModifier",
        comment: ["`singleClick` and `doubleClick` refers to a value the setting can take and should not be localized."]
      }, "Controls how to open items in trees and lists using the mouse (if supported). Note that some trees and lists might choose to ignore this setting if it is not applicable.")
    },
    [_s]: {
      type: "boolean",
      default: !1,
      description: p("horizontalScrolling setting", "Controls whether lists and trees support horizontal scrolling in the workbench. Warning: turning on this setting has a performance implication.")
    },
    [lo]: {
      type: "boolean",
      default: !1,
      description: p("list.scrollByPage", "Controls whether clicks in the scrollbar scroll page by page.")
    },
    [og]: {
      type: "number",
      default: 8,
      minimum: 4,
      maximum: 40,
      description: p("tree indent setting", "Controls tree indentation in pixels.")
    },
    [C_]: {
      type: "string",
      enum: ["none", "onHover", "always"],
      default: "onHover",
      description: p("render tree indent guides", "Controls whether the tree should render indent guides.")
    },
    [co]: {
      type: "boolean",
      default: !1,
      description: p("list smoothScrolling setting", "Controls whether lists and trees have smooth scrolling.")
    },
    [Ko]: {
      type: "number",
      default: 1,
      markdownDescription: p("Mouse Wheel Scroll Sensitivity", "A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.")
    },
    [qo]: {
      type: "number",
      default: 5,
      markdownDescription: p("Fast Scroll Sensitivity", "Scrolling speed multiplier when pressing `Alt`.")
    },
    [rx]: {
      type: "string",
      enum: ["highlight", "filter"],
      enumDescriptions: [
        p("defaultFindModeSettingKey.highlight", "Highlight elements when searching. Further up and down navigation will traverse only the highlighted elements."),
        p("defaultFindModeSettingKey.filter", "Filter elements when searching.")
      ],
      default: "highlight",
      description: p("defaultFindModeSettingKey", "Controls the default find mode for lists and trees in the workbench.")
    },
    [b_]: {
      type: "string",
      enum: ["simple", "highlight", "filter"],
      enumDescriptions: [
        p("keyboardNavigationSettingKey.simple", "Simple keyboard navigation focuses elements which match the keyboard input. Matching is done only on prefixes."),
        p("keyboardNavigationSettingKey.highlight", "Highlight keyboard navigation highlights elements which match the keyboard input. Further up and down navigation will traverse only the highlighted elements."),
        p("keyboardNavigationSettingKey.filter", "Filter keyboard navigation will filter out and hide all the elements which do not match the keyboard input.")
      ],
      default: "highlight",
      description: p("keyboardNavigationSettingKey", "Controls the keyboard navigation style for lists and trees in the workbench. Can be simple, highlight and filter."),
      deprecated: !0,
      deprecationMessage: p("keyboardNavigationSettingKeyDeprecated", "Please use 'workbench.list.defaultFindMode' and	'workbench.list.typeNavigationMode' instead.")
    },
    [lx]: {
      type: "string",
      enum: ["fuzzy", "contiguous"],
      enumDescriptions: [
        p("defaultFindMatchTypeSettingKey.fuzzy", "Use fuzzy matching when searching."),
        p("defaultFindMatchTypeSettingKey.contiguous", "Use contiguous matching when searching.")
      ],
      default: "fuzzy",
      description: p("defaultFindMatchTypeSettingKey", "Controls the type of matching used when searching lists and trees in the workbench.")
    },
    [w_]: {
      type: "string",
      enum: ["singleClick", "doubleClick"],
      default: "singleClick",
      description: p("expand mode", "Controls how tree folders are expanded when clicking the folder names. Note that some trees and lists might choose to ignore this setting if it is not applicable.")
    },
    [v_]: {
      type: "boolean",
      default: !0,
      description: p("sticky scroll", "Controls whether sticky scrolling is enabled in trees.")
    },
    [y_]: {
      type: "number",
      minimum: 1,
      default: 7,
      markdownDescription: p("sticky scroll maximum items", "Controls the number of sticky elements displayed in the tree when {0} is enabled.", "`#workbench.tree.enableStickyScroll#`")
    },
    [ax]: {
      type: "string",
      enum: ["automatic", "trigger"],
      default: "automatic",
      markdownDescription: p("typeNavigationMode2", "Controls how type navigation works in lists and trees in the workbench. When set to `trigger`, type navigation begins once the `list.triggerTypeNavigation` command is run.")
    }
  }
});
class tc extends q {
  /**
   * Create a new {@link HighlightedLabel}.
   *
   * @param container The parent container to append to.
   */
  constructor(e, t) {
    super(), this.options = t, this.text = "", this.title = "", this.highlights = [], this.didEverRender = !1, this.supportIcons = (t == null ? void 0 : t.supportIcons) ?? !1, this.domNode = ae(e, pe("span.monaco-highlighted-label"));
  }
  /**
   * The label's DOM node.
   */
  get element() {
    return this.domNode;
  }
  /**
   * Set the label and highlights.
   *
   * @param text The label to display.
   * @param highlights The ranges to highlight.
   * @param title An optional title for the hover tooltip.
   * @param escapeNewLines Whether to escape new lines.
   * @returns
   */
  set(e, t = [], i = "", n) {
    e || (e = ""), n && (e = tc.escapeNewLines(e, t)), !(this.didEverRender && this.text === e && this.title === i && Pn(this.highlights, t)) && (this.text = e, this.title = i, this.highlights = t, this.render());
  }
  render() {
    var i, n, o;
    const e = [];
    let t = 0;
    for (const r of this.highlights) {
      if (r.end === r.start)
        continue;
      if (t < r.start) {
        const c = this.text.substring(t, r.start);
        this.supportIcons ? e.push(...Yl(c)) : e.push(c), t = r.start;
      }
      const a = this.text.substring(t, r.end), l = pe("span.highlight", void 0, ...this.supportIcons ? Yl(a) : [a]);
      r.extraClasses && l.classList.add(...r.extraClasses), e.push(l), t = r.end;
    }
    if (t < this.text.length) {
      const r = this.text.substring(t);
      this.supportIcons ? e.push(...Yl(r)) : e.push(r);
    }
    if (on(this.domNode, ...e), (n = (i = this.options) == null ? void 0 : i.hoverDelegate) != null && n.showNativeHover)
      this.domNode.title = this.title;
    else if (!this.customHover && this.title !== "") {
      const r = ((o = this.options) == null ? void 0 : o.hoverDelegate) ?? Cs("mouse");
      this.customHover = this._register(Yo().setupManagedHover(r, this.domNode, this.title));
    } else this.customHover && this.customHover.update(this.title);
    this.didEverRender = !0;
  }
  static escapeNewLines(e, t) {
    let i = 0, n = 0;
    return e.replace(/\r\n|\r|\n/g, (o, r) => {
      n = o === `\r
` ? -1 : 0, r += i;
      for (const a of t)
        a.end <= r || (a.start >= r && (a.start += n), a.end >= r && (a.end += n));
      return i += n, "⏎";
    });
  }
}
class bu {
  constructor(e) {
    this._element = e;
  }
  get element() {
    return this._element;
  }
  set textContent(e) {
    this.disposed || e === this._textContent || (this._textContent = e, this._element.textContent = e);
  }
  set classNames(e) {
    this.disposed || Pn(e, this._classNames) || (this._classNames = e, this._element.classList.value = "", this._element.classList.add(...e));
  }
  set empty(e) {
    this.disposed || e === this._empty || (this._empty = e, this._element.style.marginLeft = e ? "0" : "");
  }
  dispose() {
    this.disposed = !0;
  }
}
class BN extends q {
  constructor(e, t) {
    super(), this.customHovers = /* @__PURE__ */ new Map(), this.creationOptions = t, this.domNode = this._register(new bu(ae(e, pe(".monaco-icon-label")))), this.labelContainer = ae(this.domNode.element, pe(".monaco-icon-label-container")), this.nameContainer = ae(this.labelContainer, pe("span.monaco-icon-name-container")), t != null && t.supportHighlights || t != null && t.supportIcons ? this.nameNode = this._register(new xq(this.nameContainer, !!t.supportIcons)) : this.nameNode = new Lq(this.nameContainer), this.hoverDelegate = (t == null ? void 0 : t.hoverDelegate) ?? Cs("mouse");
  }
  get element() {
    return this.domNode.element;
  }
  setLabel(e, t, i) {
    const n = ["monaco-icon-label"], o = ["monaco-icon-label-container"];
    let r = "";
    i && (i.extraClasses && n.push(...i.extraClasses), i.italic && n.push("italic"), i.strikethrough && n.push("strikethrough"), i.disabledCommand && o.push("disabled"), i.title && (typeof i.title == "string" ? r += i.title : r += e));
    const a = this.domNode.element.querySelector(".monaco-icon-label-iconpath");
    if (i != null && i.iconPath) {
      let l;
      !a || !yi(a) ? (l = pe(".monaco-icon-label-iconpath"), this.domNode.element.prepend(l)) : l = a, l.style.backgroundImage = Qr(i == null ? void 0 : i.iconPath);
    } else a && a.remove();
    if (this.domNode.classNames = n, this.domNode.element.setAttribute("aria-label", r), this.labelContainer.classList.value = "", this.labelContainer.classList.add(...o), this.setupHover(i != null && i.descriptionTitle ? this.labelContainer : this.element, i == null ? void 0 : i.title), this.nameNode.setLabel(e, i), t || this.descriptionNode) {
      const l = this.getOrCreateDescriptionNode();
      l instanceof tc ? (l.set(t || "", i ? i.descriptionMatches : void 0, void 0, i == null ? void 0 : i.labelEscapeNewLines), this.setupHover(l.element, i == null ? void 0 : i.descriptionTitle)) : (l.textContent = t && (i != null && i.labelEscapeNewLines) ? tc.escapeNewLines(t, []) : t || "", this.setupHover(l.element, (i == null ? void 0 : i.descriptionTitle) || ""), l.empty = !t);
    }
    if (i != null && i.suffix || this.suffixNode) {
      const l = this.getOrCreateSuffixNode();
      l.textContent = (i == null ? void 0 : i.suffix) ?? "";
    }
  }
  setupHover(e, t) {
    const i = this.customHovers.get(e);
    if (i && (i.dispose(), this.customHovers.delete(e)), !t) {
      e.removeAttribute("title");
      return;
    }
    if (this.hoverDelegate.showNativeHover)
      (function(o, r) {
        Jn(r) ? o.title = nA(r) : r != null && r.markdownNotSupportedFallback ? o.title = r.markdownNotSupportedFallback : o.removeAttribute("title");
      })(e, t);
    else {
      const n = Yo().setupManagedHover(this.hoverDelegate, e, t);
      n && this.customHovers.set(e, n);
    }
  }
  dispose() {
    super.dispose();
    for (const e of this.customHovers.values())
      e.dispose();
    this.customHovers.clear();
  }
  getOrCreateSuffixNode() {
    if (!this.suffixNode) {
      const e = this._register(new bu(d7(this.nameContainer, pe("span.monaco-icon-suffix-container"))));
      this.suffixNode = this._register(new bu(ae(e.element, pe("span.label-suffix"))));
    }
    return this.suffixNode;
  }
  getOrCreateDescriptionNode() {
    var e;
    if (!this.descriptionNode) {
      const t = this._register(new bu(ae(this.labelContainer, pe("span.monaco-icon-description-container"))));
      (e = this.creationOptions) != null && e.supportDescriptionHighlights ? this.descriptionNode = this._register(new tc(ae(t.element, pe("span.label-description")), { supportIcons: !!this.creationOptions.supportIcons })) : this.descriptionNode = this._register(new bu(ae(t.element, pe("span.label-description"))));
    }
    return this.descriptionNode;
  }
}
class Lq {
  constructor(e) {
    this.container = e, this.label = void 0, this.singleLabel = void 0;
  }
  setLabel(e, t) {
    if (!(this.label === e && Pn(this.options, t)))
      if (this.label = e, this.options = t, typeof e == "string")
        this.singleLabel || (this.container.innerText = "", this.container.classList.remove("multiple"), this.singleLabel = ae(this.container, pe("a.label-name", { id: t == null ? void 0 : t.domId }))), this.singleLabel.textContent = e;
      else {
        this.container.innerText = "", this.container.classList.add("multiple"), this.singleLabel = void 0;
        for (let i = 0; i < e.length; i++) {
          const n = e[i], o = (t == null ? void 0 : t.domId) && `${t == null ? void 0 : t.domId}_${i}`;
          ae(this.container, pe("a.label-name", { id: o, "data-icon-label-count": e.length, "data-icon-label-index": i, role: "treeitem" }, n)), i < e.length - 1 && ae(this.container, pe("span.label-separator", void 0, (t == null ? void 0 : t.separator) || "/"));
        }
      }
  }
}
function kq(s, e, t) {
  if (!t)
    return;
  let i = 0;
  return s.map((n) => {
    const o = { start: i, end: i + n.length }, r = t.map((a) => Pi.intersect(o, a)).filter((a) => !Pi.isEmpty(a)).map(({ start: a, end: l }) => ({ start: a - i, end: l - i }));
    return i = o.end + e.length, r;
  });
}
class xq extends q {
  constructor(e, t) {
    super(), this.container = e, this.supportIcons = t, this.label = void 0, this.singleLabel = void 0;
  }
  setLabel(e, t) {
    if (!(this.label === e && Pn(this.options, t)))
      if (this.label = e, this.options = t, typeof e == "string")
        this.singleLabel || (this.container.innerText = "", this.container.classList.remove("multiple"), this.singleLabel = this._register(new tc(ae(this.container, pe("a.label-name", { id: t == null ? void 0 : t.domId })), { supportIcons: this.supportIcons }))), this.singleLabel.set(e, t == null ? void 0 : t.matches, void 0, t == null ? void 0 : t.labelEscapeNewLines);
      else {
        this.container.innerText = "", this.container.classList.add("multiple"), this.singleLabel = void 0;
        const i = (t == null ? void 0 : t.separator) || "/", n = kq(e, i, t == null ? void 0 : t.matches);
        for (let o = 0; o < e.length; o++) {
          const r = e[o], a = n ? n[o] : void 0, l = (t == null ? void 0 : t.domId) && `${t == null ? void 0 : t.domId}_${o}`, c = pe("a.label-name", { id: l, "data-icon-label-count": e.length, "data-icon-label-index": o, role: "treeitem" });
          this._register(new tc(ae(this.container, c), { supportIcons: this.supportIcons })).set(r, a, void 0, t == null ? void 0 : t.labelEscapeNewLines), o < e.length - 1 && ae(c, pe("span.label-separator", void 0, i));
        }
      }
  }
}
const Tm = pe;
class hx extends q {
  constructor(e, t, i) {
    super(), this.os = t, this.keyElements = /* @__PURE__ */ new Set(), this.options = i || /* @__PURE__ */ Object.create(null);
    const n = this.options.keybindingLabelForeground;
    this.domNode = ae(e, Tm(".monaco-keybinding")), n && (this.domNode.style.color = n), this.hover = this._register(Yo().setupManagedHover(Cs("mouse"), this.domNode, "")), this.didEverRender = !1, e.appendChild(this.domNode);
  }
  get element() {
    return this.domNode;
  }
  set(e, t) {
    this.didEverRender && this.keybinding === e && hx.areSame(this.matches, t) || (this.keybinding = e, this.matches = t, this.render());
  }
  render() {
    if (this.clear(), this.keybinding) {
      const e = this.keybinding.getChords();
      e[0] && this.renderChord(this.domNode, e[0], this.matches ? this.matches.firstPart : null);
      for (let i = 1; i < e.length; i++)
        ae(this.domNode, Tm("span.monaco-keybinding-key-chord-separator", void 0, " ")), this.renderChord(this.domNode, e[i], this.matches ? this.matches.chordPart : null);
      const t = this.options.disableTitle ?? !1 ? void 0 : this.keybinding.getAriaLabel() || void 0;
      this.hover.update(t), this.domNode.setAttribute("aria-label", t || "");
    } else this.options && this.options.renderUnboundKeybindings && this.renderUnbound(this.domNode);
    this.didEverRender = !0;
  }
  clear() {
    oo(this.domNode), this.keyElements.clear();
  }
  renderChord(e, t, i) {
    const n = kk.modifierLabels[this.os];
    t.ctrlKey && this.renderKey(e, n.ctrlKey, !!(i != null && i.ctrlKey), n.separator), t.shiftKey && this.renderKey(e, n.shiftKey, !!(i != null && i.shiftKey), n.separator), t.altKey && this.renderKey(e, n.altKey, !!(i != null && i.altKey), n.separator), t.metaKey && this.renderKey(e, n.metaKey, !!(i != null && i.metaKey), n.separator);
    const o = t.keyLabel;
    o && this.renderKey(e, o, !!(i != null && i.keyCode), "");
  }
  renderKey(e, t, i, n) {
    ae(e, this.createKeyElement(t, i ? ".highlight" : "")), n && ae(e, Tm("span.monaco-keybinding-key-separator", void 0, n));
  }
  renderUnbound(e) {
    ae(e, this.createKeyElement(p("unbound", "Unbound")));
  }
  createKeyElement(e, t = "") {
    const i = Tm("span.monaco-keybinding-key" + t, void 0, e);
    return this.keyElements.add(i), this.options.keybindingLabelBackground && (i.style.backgroundColor = this.options.keybindingLabelBackground), this.options.keybindingLabelBorder && (i.style.borderColor = this.options.keybindingLabelBorder), this.options.keybindingLabelBottomBorder && (i.style.borderBottomColor = this.options.keybindingLabelBottomBorder), this.options.keybindingLabelShadow && (i.style.boxShadow = `inset 0 -1px 0 ${this.options.keybindingLabelShadow}`), i;
  }
  static areSame(e, t) {
    return e === t || !e && !t ? !0 : !!e && !!t && Pn(e.firstPart, t.firstPart) && Pn(e.chordPart, t.chordPart);
  }
}
const WN = new Ha(() => {
  const s = new Intl.Collator(void 0, { numeric: !0, sensitivity: "base" });
  return {
    collator: s,
    collatorIsNumeric: s.resolvedOptions().numeric
  };
});
function Dq(s, e, t = !1) {
  const i = s || "", n = e || "", o = WN.value.collator.compare(i, n);
  return WN.value.collatorIsNumeric && o === 0 && i !== n ? i < n ? -1 : 1 : o;
}
function Eq(s, e, t) {
  const i = s.toLowerCase(), n = e.toLowerCase(), o = Iq(s, e, t);
  if (o)
    return o;
  const r = i.endsWith(t), a = n.endsWith(t);
  if (r !== a)
    return r ? -1 : 1;
  const l = Dq(i, n);
  return l !== 0 ? l : i.localeCompare(n);
}
function Iq(s, e, t) {
  const i = s.toLowerCase(), n = e.toLowerCase(), o = i.startsWith(t), r = n.startsWith(t);
  if (o !== r)
    return o ? -1 : 1;
  if (o && r) {
    if (i.length < n.length)
      return -1;
    if (i.length > n.length)
      return 1;
  }
  return 0;
}
var jb = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Ky = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, qy;
const qs = pe;
class I4 {
  constructor(e, t, i) {
    this.index = e, this.hasCheckbox = t, this._hidden = !1, this._init = new Ha(() => {
      const n = i.label ?? "", o = Eu(n).text.trim(), r = i.ariaLabel || [n, this.saneDescription, this.saneDetail].map((a) => yW(a)).filter((a) => !!a).join(", ");
      return {
        saneLabel: n,
        saneSortLabel: o,
        saneAriaLabel: r
      };
    }), this._saneDescription = i.description, this._saneTooltip = i.tooltip;
  }
  // #region Lazy Getters
  get saneLabel() {
    return this._init.value.saneLabel;
  }
  get saneSortLabel() {
    return this._init.value.saneSortLabel;
  }
  get saneAriaLabel() {
    return this._init.value.saneAriaLabel;
  }
  get element() {
    return this._element;
  }
  set element(e) {
    this._element = e;
  }
  get hidden() {
    return this._hidden;
  }
  set hidden(e) {
    this._hidden = e;
  }
  get saneDescription() {
    return this._saneDescription;
  }
  set saneDescription(e) {
    this._saneDescription = e;
  }
  get saneDetail() {
    return this._saneDetail;
  }
  set saneDetail(e) {
    this._saneDetail = e;
  }
  get saneTooltip() {
    return this._saneTooltip;
  }
  set saneTooltip(e) {
    this._saneTooltip = e;
  }
  get labelHighlights() {
    return this._labelHighlights;
  }
  set labelHighlights(e) {
    this._labelHighlights = e;
  }
  get descriptionHighlights() {
    return this._descriptionHighlights;
  }
  set descriptionHighlights(e) {
    this._descriptionHighlights = e;
  }
  get detailHighlights() {
    return this._detailHighlights;
  }
  set detailHighlights(e) {
    this._detailHighlights = e;
  }
}
class Di extends I4 {
  constructor(e, t, i, n, o, r) {
    var a, l, c;
    super(e, t, o), this.fireButtonTriggered = i, this._onChecked = n, this.item = o, this._separator = r, this._checked = !1, this.onChecked = t ? J.map(J.filter(this._onChecked.event, (h) => h.element === this), (h) => h.checked) : J.None, this._saneDetail = o.detail, this._labelHighlights = (a = o.highlights) == null ? void 0 : a.label, this._descriptionHighlights = (l = o.highlights) == null ? void 0 : l.description, this._detailHighlights = (c = o.highlights) == null ? void 0 : c.detail;
  }
  get separator() {
    return this._separator;
  }
  set separator(e) {
    this._separator = e;
  }
  get checked() {
    return this._checked;
  }
  set checked(e) {
    e !== this._checked && (this._checked = e, this._onChecked.fire({ element: this, checked: e }));
  }
  get checkboxDisabled() {
    return !!this.item.disabled;
  }
}
var Mo;
(function(s) {
  s[s.NONE = 0] = "NONE", s[s.MOUSE_HOVER = 1] = "MOUSE_HOVER", s[s.ACTIVE_ITEM = 2] = "ACTIVE_ITEM";
})(Mo || (Mo = {}));
class bl extends I4 {
  constructor(e, t, i) {
    super(e, !1, i), this.fireSeparatorButtonTriggered = t, this.separator = i, this.children = new Array(), this.focusInsideSeparator = Mo.NONE;
  }
}
class Nq {
  getHeight(e) {
    return e instanceof bl ? 30 : e.saneDetail ? 44 : 22;
  }
  getTemplateId(e) {
    return e instanceof Di ? S_.ID : L_.ID;
  }
}
class Tq {
  getWidgetAriaLabel() {
    return p("quickInput", "Quick Input");
  }
  getAriaLabel(e) {
    var t;
    return (t = e.separator) != null && t.label ? `${e.saneAriaLabel}, ${e.separator.label}` : e.saneAriaLabel;
  }
  getWidgetRole() {
    return "listbox";
  }
  getRole(e) {
    return e.hasCheckbox ? "checkbox" : "option";
  }
  isChecked(e) {
    if (!(!e.hasCheckbox || !(e instanceof Di)))
      return {
        get value() {
          return e.checked;
        },
        onDidChange: (t) => e.onChecked(() => t())
      };
  }
}
class N4 {
  constructor(e) {
    this.hoverDelegate = e;
  }
  // TODO: only do the common stuff here and have a subclass handle their specific stuff
  renderTemplate(e) {
    const t = /* @__PURE__ */ Object.create(null);
    t.toDisposeElement = new he(), t.toDisposeTemplate = new he(), t.entry = ae(e, qs(".quick-input-list-entry"));
    const i = ae(t.entry, qs("label.quick-input-list-label"));
    t.toDisposeTemplate.add(fi(i, ee.CLICK, (c) => {
      t.checkbox.offsetParent || c.preventDefault();
    })), t.checkbox = ae(i, qs("input.quick-input-list-checkbox")), t.checkbox.type = "checkbox";
    const n = ae(i, qs(".quick-input-list-rows")), o = ae(n, qs(".quick-input-list-row")), r = ae(n, qs(".quick-input-list-row"));
    t.label = new BN(o, { supportHighlights: !0, supportDescriptionHighlights: !0, supportIcons: !0, hoverDelegate: this.hoverDelegate }), t.toDisposeTemplate.add(t.label), t.icon = $L(t.label.element, qs(".quick-input-list-icon"));
    const a = ae(o, qs(".quick-input-list-entry-keybinding"));
    t.keybinding = new hx(a, Es), t.toDisposeTemplate.add(t.keybinding);
    const l = ae(r, qs(".quick-input-list-label-meta"));
    return t.detail = new BN(l, { supportHighlights: !0, supportIcons: !0, hoverDelegate: this.hoverDelegate }), t.toDisposeTemplate.add(t.detail), t.separator = ae(t.entry, qs(".quick-input-list-separator")), t.actionBar = new Kr(t.entry, this.hoverDelegate ? { hoverDelegate: this.hoverDelegate } : void 0), t.actionBar.domNode.classList.add("quick-input-list-entry-action-bar"), t.toDisposeTemplate.add(t.actionBar), t;
  }
  disposeTemplate(e) {
    e.toDisposeElement.dispose(), e.toDisposeTemplate.dispose();
  }
  disposeElement(e, t, i) {
    i.toDisposeElement.clear(), i.actionBar.clear();
  }
}
var oc;
let S_ = (oc = class extends N4 {
  constructor(e, t) {
    super(e), this.themeService = t, this._itemsWithSeparatorsFrequency = /* @__PURE__ */ new Map();
  }
  get templateId() {
    return qy.ID;
  }
  renderTemplate(e) {
    const t = super.renderTemplate(e);
    return t.toDisposeTemplate.add(fi(t.checkbox, ee.CHANGE, (i) => {
      t.element.checked = t.checkbox.checked;
    })), t;
  }
  renderElement(e, t, i) {
    var u;
    const n = e.element;
    i.element = n, n.element = i.entry ?? void 0;
    const o = n.item;
    i.checkbox.checked = n.checked, i.toDisposeElement.add(n.onChecked((f) => i.checkbox.checked = f)), i.checkbox.disabled = n.checkboxDisabled;
    const { labelHighlights: r, descriptionHighlights: a, detailHighlights: l } = n;
    if (o.iconPath) {
      const f = vb(this.themeService.getColorTheme().type) ? o.iconPath.dark : o.iconPath.light ?? o.iconPath.dark, g = Te.revive(f);
      i.icon.className = "quick-input-list-icon", i.icon.style.backgroundImage = Qr(g);
    } else
      i.icon.style.backgroundImage = "", i.icon.className = o.iconClass ? `quick-input-list-icon ${o.iconClass}` : "";
    let c;
    !n.saneTooltip && n.saneDescription && (c = {
      markdown: {
        value: n.saneDescription,
        supportThemeIcons: !0
      },
      markdownNotSupportedFallback: n.saneDescription
    });
    const h = {
      matches: r || [],
      // If we have a tooltip, we want that to be shown and not any other hover
      descriptionTitle: c,
      descriptionMatches: a || [],
      labelEscapeNewLines: !0
    };
    if (h.extraClasses = o.iconClasses, h.italic = o.italic, h.strikethrough = o.strikethrough, i.entry.classList.remove("quick-input-list-separator-as-item"), i.label.setLabel(n.saneLabel, n.saneDescription, h), i.keybinding.set(o.keybinding), n.saneDetail) {
      let f;
      n.saneTooltip || (f = {
        markdown: {
          value: n.saneDetail,
          supportThemeIcons: !0
        },
        markdownNotSupportedFallback: n.saneDetail
      }), i.detail.element.style.display = "", i.detail.setLabel(n.saneDetail, void 0, {
        matches: l,
        title: f,
        labelEscapeNewLines: !0
      });
    } else
      i.detail.element.style.display = "none";
    (u = n.separator) != null && u.label ? (i.separator.textContent = n.separator.label, i.separator.style.display = "", this.addItemWithSeparator(n)) : i.separator.style.display = "none", i.entry.classList.toggle("quick-input-list-separator-border", !!n.separator);
    const d = o.buttons;
    d && d.length ? (i.actionBar.push(d.map((f, g) => ef(f, `id-${g}`, () => n.fireButtonTriggered({ button: f, item: n.item }))), { icon: !0, label: !1 }), i.entry.classList.add("has-actions")) : i.entry.classList.remove("has-actions");
  }
  disposeElement(e, t, i) {
    this.removeItemWithSeparator(e.element), super.disposeElement(e, t, i);
  }
  isItemWithSeparatorVisible(e) {
    return this._itemsWithSeparatorsFrequency.has(e);
  }
  addItemWithSeparator(e) {
    this._itemsWithSeparatorsFrequency.set(e, (this._itemsWithSeparatorsFrequency.get(e) || 0) + 1);
  }
  removeItemWithSeparator(e) {
    const t = this._itemsWithSeparatorsFrequency.get(e) || 0;
    t > 1 ? this._itemsWithSeparatorsFrequency.set(e, t - 1) : this._itemsWithSeparatorsFrequency.delete(e);
  }
}, qy = oc, oc.ID = "quickpickitem", oc);
S_ = qy = jb([
  Ky(1, Ws)
], S_);
const N1 = class N1 extends N4 {
  constructor() {
    super(...arguments), this._visibleSeparatorsFrequency = /* @__PURE__ */ new Map();
  }
  get templateId() {
    return N1.ID;
  }
  get visibleSeparators() {
    return [...this._visibleSeparatorsFrequency.keys()];
  }
  isSeparatorVisible(e) {
    return this._visibleSeparatorsFrequency.has(e);
  }
  renderTemplate(e) {
    const t = super.renderTemplate(e);
    return t.checkbox.style.display = "none", t;
  }
  renderElement(e, t, i) {
    const n = e.element;
    i.element = n, n.element = i.entry ?? void 0, n.element.classList.toggle("focus-inside", !!n.focusInsideSeparator);
    const o = n.separator, { labelHighlights: r, descriptionHighlights: a, detailHighlights: l } = n;
    i.icon.style.backgroundImage = "", i.icon.className = "";
    let c;
    !n.saneTooltip && n.saneDescription && (c = {
      markdown: {
        value: n.saneDescription,
        supportThemeIcons: !0
      },
      markdownNotSupportedFallback: n.saneDescription
    });
    const h = {
      matches: r || [],
      // If we have a tooltip, we want that to be shown and not any other hover
      descriptionTitle: c,
      descriptionMatches: a || [],
      labelEscapeNewLines: !0
    };
    if (i.entry.classList.add("quick-input-list-separator-as-item"), i.label.setLabel(n.saneLabel, n.saneDescription, h), n.saneDetail) {
      let u;
      n.saneTooltip || (u = {
        markdown: {
          value: n.saneDetail,
          supportThemeIcons: !0
        },
        markdownNotSupportedFallback: n.saneDetail
      }), i.detail.element.style.display = "", i.detail.setLabel(n.saneDetail, void 0, {
        matches: l,
        title: u,
        labelEscapeNewLines: !0
      });
    } else
      i.detail.element.style.display = "none";
    i.separator.style.display = "none", i.entry.classList.add("quick-input-list-separator-border");
    const d = o.buttons;
    d && d.length ? (i.actionBar.push(d.map((u, f) => ef(u, `id-${f}`, () => n.fireSeparatorButtonTriggered({ button: u, separator: n.separator }))), { icon: !0, label: !1 }), i.entry.classList.add("has-actions")) : i.entry.classList.remove("has-actions"), this.addSeparator(n);
  }
  disposeElement(e, t, i) {
    var n;
    this.removeSeparator(e.element), this.isSeparatorVisible(e.element) || (n = e.element.element) == null || n.classList.remove("focus-inside"), super.disposeElement(e, t, i);
  }
  addSeparator(e) {
    this._visibleSeparatorsFrequency.set(e, (this._visibleSeparatorsFrequency.get(e) || 0) + 1);
  }
  removeSeparator(e) {
    const t = this._visibleSeparatorsFrequency.get(e) || 0;
    t > 1 ? this._visibleSeparatorsFrequency.set(e, t - 1) : this._visibleSeparatorsFrequency.delete(e);
  }
};
N1.ID = "quickpickseparator";
let L_ = N1, rg = class extends q {
  constructor(e, t, i, n, o, r) {
    super(), this.parent = e, this.hoverDelegate = t, this.linkOpenerDelegate = i, this.accessibilityService = r, this._onKeyDown = new O(), this._onLeave = new O(), this.onLeave = this._onLeave.event, this._visibleCountObservable = $e("VisibleCount", 0), this.onChangedVisibleCount = J.fromObservable(this._visibleCountObservable, this._store), this._allVisibleCheckedObservable = $e("AllVisibleChecked", !1), this.onChangedAllVisibleChecked = J.fromObservable(this._allVisibleCheckedObservable, this._store), this._checkedCountObservable = $e("CheckedCount", 0), this.onChangedCheckedCount = J.fromObservable(this._checkedCountObservable, this._store), this._checkedElementsObservable = ry({ equalsFn: oi }, new Array()), this.onChangedCheckedElements = J.fromObservable(this._checkedElementsObservable, this._store), this._onButtonTriggered = new O(), this.onButtonTriggered = this._onButtonTriggered.event, this._onSeparatorButtonTriggered = new O(), this.onSeparatorButtonTriggered = this._onSeparatorButtonTriggered.event, this._elementChecked = new O(), this._elementCheckedEventBufferer = new yg(), this._hasCheckboxes = !1, this._inputElements = new Array(), this._elementTree = new Array(), this._itemElements = new Array(), this._elementDisposable = this._register(new he()), this._matchOnDescription = !1, this._matchOnDetail = !1, this._matchOnLabel = !0, this._matchOnLabelMode = "fuzzy", this._sortByLabel = !0, this._shouldLoop = !0, this._container = ae(this.parent, qs(".quick-input-list")), this._separatorRenderer = new L_(t), this._itemRenderer = o.createInstance(S_, t), this._tree = this._register(o.createInstance($y, "QuickInput", this._container, new Nq(), [this._itemRenderer, this._separatorRenderer], {
      filter: {
        filter(a) {
          return a.hidden ? 0 : a instanceof bl ? 2 : 1;
        }
      },
      sorter: {
        compare: (a, l) => {
          if (!this.sortByLabel || !this._lastQueryString)
            return 0;
          const c = this._lastQueryString.toLowerCase();
          return Rq(a, l, c);
        }
      },
      accessibilityProvider: new Tq(),
      setRowLineHeight: !1,
      multipleSelectionSupport: !1,
      hideTwistiesOfChildlessElements: !0,
      renderIndentGuides: Md.None,
      findWidgetEnabled: !1,
      indent: 0,
      horizontalScrolling: !1,
      allowNonCollapsibleParents: !0,
      alwaysConsumeMouseWheel: !0
    })), this._tree.getHTMLElement().id = n, this._registerListeners();
  }
  //#region public getters/setters
  get onDidChangeFocus() {
    return J.map(this._tree.onDidChangeFocus, (e) => e.elements.filter((t) => t instanceof Di).map((t) => t.item), this._store);
  }
  get onDidChangeSelection() {
    return J.map(this._tree.onDidChangeSelection, (e) => ({
      items: e.elements.filter((t) => t instanceof Di).map((t) => t.item),
      event: e.browserEvent
    }), this._store);
  }
  get displayed() {
    return this._container.style.display !== "none";
  }
  set displayed(e) {
    this._container.style.display = e ? "" : "none";
  }
  get scrollTop() {
    return this._tree.scrollTop;
  }
  set scrollTop(e) {
    this._tree.scrollTop = e;
  }
  get ariaLabel() {
    return this._tree.ariaLabel;
  }
  set ariaLabel(e) {
    this._tree.ariaLabel = e ?? "";
  }
  set enabled(e) {
    this._tree.getHTMLElement().style.pointerEvents = e ? "" : "none";
  }
  get matchOnDescription() {
    return this._matchOnDescription;
  }
  set matchOnDescription(e) {
    this._matchOnDescription = e;
  }
  get matchOnDetail() {
    return this._matchOnDetail;
  }
  set matchOnDetail(e) {
    this._matchOnDetail = e;
  }
  get matchOnLabel() {
    return this._matchOnLabel;
  }
  set matchOnLabel(e) {
    this._matchOnLabel = e;
  }
  get matchOnLabelMode() {
    return this._matchOnLabelMode;
  }
  set matchOnLabelMode(e) {
    this._matchOnLabelMode = e;
  }
  get sortByLabel() {
    return this._sortByLabel;
  }
  set sortByLabel(e) {
    this._sortByLabel = e;
  }
  get shouldLoop() {
    return this._shouldLoop;
  }
  set shouldLoop(e) {
    this._shouldLoop = e;
  }
  //#endregion
  //#region register listeners
  _registerListeners() {
    this._registerOnKeyDown(), this._registerOnContainerClick(), this._registerOnMouseMiddleClick(), this._registerOnTreeModelChanged(), this._registerOnElementChecked(), this._registerOnContextMenu(), this._registerHoverListeners(), this._registerSelectionChangeListener(), this._registerSeparatorActionShowingListeners();
  }
  _registerOnKeyDown() {
    this._register(this._tree.onKeyDown((e) => {
      const t = new Lt(e);
      switch (t.keyCode) {
        case 10:
          this.toggleCheckbox();
          break;
      }
      this._onKeyDown.fire(t);
    }));
  }
  _registerOnContainerClick() {
    this._register($(this._container, ee.CLICK, (e) => {
      (e.x || e.y) && this._onLeave.fire();
    }));
  }
  _registerOnMouseMiddleClick() {
    this._register($(this._container, ee.AUXCLICK, (e) => {
      e.button === 1 && this._onLeave.fire();
    }));
  }
  _registerOnTreeModelChanged() {
    this._register(this._tree.onDidChangeModel(() => {
      const e = this._itemElements.filter((t) => !t.hidden).length;
      this._visibleCountObservable.set(e, void 0), this._hasCheckboxes && this._updateCheckedObservables();
    }));
  }
  _registerOnElementChecked() {
    this._register(this._elementCheckedEventBufferer.wrapEvent(this._elementChecked.event, (e, t) => t)((e) => this._updateCheckedObservables()));
  }
  _registerOnContextMenu() {
    this._register(this._tree.onContextMenu((e) => {
      e.element && (e.browserEvent.preventDefault(), this._tree.setSelection([e.element]));
    }));
  }
  _registerHoverListeners() {
    const e = this._register(new rM(this.hoverDelegate.delay));
    this._register(this._tree.onMouseOver(async (t) => {
      var i;
      if (OD(t.browserEvent.target)) {
        e.cancel();
        return;
      }
      if (
        // anchors are an exception as called out above so we skip them here
        !(!OD(t.browserEvent.relatedTarget) && // check if the mouse is still over the same element
        ui(t.browserEvent.relatedTarget, (i = t.element) == null ? void 0 : i.element))
      )
        try {
          await e.trigger(async () => {
            t.element instanceof Di && this.showHover(t.element);
          });
        } catch (n) {
          if (!wg(n))
            throw n;
        }
    })), this._register(this._tree.onMouseOut((t) => {
      var i;
      ui(t.browserEvent.relatedTarget, (i = t.element) == null ? void 0 : i.element) || e.cancel();
    }));
  }
  /**
   * Register's focus change and mouse events so that we can track when items inside of a
   * separator's section are focused or hovered so that we can display the separator's actions
   */
  _registerSeparatorActionShowingListeners() {
    this._register(this._tree.onDidChangeFocus((e) => {
      const t = e.elements[0] ? this._tree.getParentElement(e.elements[0]) : null;
      for (const i of this._separatorRenderer.visibleSeparators) {
        const n = i === t;
        !!(i.focusInsideSeparator & Mo.ACTIVE_ITEM) !== n && (n ? i.focusInsideSeparator |= Mo.ACTIVE_ITEM : i.focusInsideSeparator &= ~Mo.ACTIVE_ITEM, this._tree.rerender(i));
      }
    })), this._register(this._tree.onMouseOver((e) => {
      const t = e.element ? this._tree.getParentElement(e.element) : null;
      for (const i of this._separatorRenderer.visibleSeparators) {
        if (i !== t)
          continue;
        !!(i.focusInsideSeparator & Mo.MOUSE_HOVER) || (i.focusInsideSeparator |= Mo.MOUSE_HOVER, this._tree.rerender(i));
      }
    })), this._register(this._tree.onMouseOut((e) => {
      const t = e.element ? this._tree.getParentElement(e.element) : null;
      for (const i of this._separatorRenderer.visibleSeparators) {
        if (i !== t)
          continue;
        !!(i.focusInsideSeparator & Mo.MOUSE_HOVER) && (i.focusInsideSeparator &= ~Mo.MOUSE_HOVER, this._tree.rerender(i));
      }
    }));
  }
  _registerSelectionChangeListener() {
    this._register(this._tree.onDidChangeSelection((e) => {
      const t = e.elements.filter((i) => i instanceof Di);
      t.length !== e.elements.length && (e.elements.length === 1 && e.elements[0] instanceof bl && (this._tree.setFocus([e.elements[0].children[0]]), this._tree.reveal(e.elements[0], 0)), this._tree.setSelection(t));
    }));
  }
  //#endregion
  //#region public methods
  setAllVisibleChecked(e) {
    this._elementCheckedEventBufferer.bufferEvents(() => {
      this._itemElements.forEach((t) => {
        !t.hidden && !t.checkboxDisabled && (t.checked = e);
      });
    });
  }
  setElements(e) {
    this._elementDisposable.clear(), this._lastQueryString = void 0, this._inputElements = e, this._hasCheckboxes = this.parent.classList.contains("show-checkboxes");
    let t;
    this._itemElements = new Array(), this._elementTree = e.reduce((i, n, o) => {
      let r;
      if (n.type === "separator") {
        if (!n.buttons)
          return i;
        t = new bl(o, (a) => this._onSeparatorButtonTriggered.fire(a), n), r = t;
      } else {
        const a = o > 0 ? e[o - 1] : void 0;
        let l;
        a && a.type === "separator" && !a.buttons && (t = void 0, l = a);
        const c = new Di(o, this._hasCheckboxes, (h) => this._onButtonTriggered.fire(h), this._elementChecked, n, l);
        if (this._itemElements.push(c), t)
          return t.children.push(c), i;
        r = c;
      }
      return i.push(r), i;
    }, new Array()), this._setElementsToTree(this._elementTree), this.accessibilityService.isScreenReaderOptimized() && setTimeout(() => {
      const i = this._tree.getHTMLElement().querySelector(".monaco-list-row.focused"), n = i == null ? void 0 : i.parentNode;
      if (i && n) {
        const o = i.nextSibling;
        i.remove(), n.insertBefore(i, o);
      }
    }, 0);
  }
  setFocusedElements(e) {
    const t = e.map((i) => this._itemElements.find((n) => n.item === i)).filter((i) => !!i).filter((i) => !i.hidden);
    if (this._tree.setFocus(t), e.length > 0) {
      const i = this._tree.getFocus()[0];
      i && this._tree.reveal(i);
    }
  }
  getActiveDescendant() {
    return this._tree.getHTMLElement().getAttribute("aria-activedescendant");
  }
  setSelectedElements(e) {
    const t = e.map((i) => this._itemElements.find((n) => n.item === i)).filter((i) => !!i);
    this._tree.setSelection(t);
  }
  getCheckedElements() {
    return this._itemElements.filter((e) => e.checked).map((e) => e.item);
  }
  setCheckedElements(e) {
    this._elementCheckedEventBufferer.bufferEvents(() => {
      const t = /* @__PURE__ */ new Set();
      for (const i of e)
        t.add(i);
      for (const i of this._itemElements)
        i.checked = t.has(i.item);
    });
  }
  focus(e) {
    var t;
    if (this._itemElements.length)
      switch (e === _t.Second && this._itemElements.length < 2 && (e = _t.First), e) {
        case _t.First:
          this._tree.scrollTop = 0, this._tree.focusFirst(void 0, (i) => i.element instanceof Di);
          break;
        case _t.Second: {
          this._tree.scrollTop = 0;
          let i = !1;
          this._tree.focusFirst(void 0, (n) => n.element instanceof Di ? i ? !0 : (i = !i, !1) : !1);
          break;
        }
        case _t.Last:
          this._tree.scrollTop = this._tree.scrollHeight, this._tree.focusLast(void 0, (i) => i.element instanceof Di);
          break;
        case _t.Next: {
          const i = this._tree.getFocus();
          this._tree.focusNext(void 0, this._shouldLoop, void 0, (o) => o.element instanceof Di ? (this._tree.reveal(o.element), !0) : !1);
          const n = this._tree.getFocus();
          i.length && i[0] === n[0] && i[0] === this._itemElements[this._itemElements.length - 1] && this._onLeave.fire();
          break;
        }
        case _t.Previous: {
          const i = this._tree.getFocus();
          this._tree.focusPrevious(void 0, this._shouldLoop, void 0, (o) => {
            if (!(o.element instanceof Di))
              return !1;
            const r = this._tree.getParentElement(o.element);
            return r === null || r.children[0] !== o.element ? this._tree.reveal(o.element) : this._tree.reveal(r), !0;
          });
          const n = this._tree.getFocus();
          i.length && i[0] === n[0] && i[0] === this._itemElements[0] && this._onLeave.fire();
          break;
        }
        case _t.NextPage:
          this._tree.focusNextPage(void 0, (i) => i.element instanceof Di ? (this._tree.reveal(i.element), !0) : !1);
          break;
        case _t.PreviousPage:
          this._tree.focusPreviousPage(void 0, (i) => {
            if (!(i.element instanceof Di))
              return !1;
            const n = this._tree.getParentElement(i.element);
            return n === null || n.children[0] !== i.element ? this._tree.reveal(i.element) : this._tree.reveal(n), !0;
          });
          break;
        case _t.NextSeparator: {
          let i = !1;
          const n = this._tree.getFocus()[0];
          this._tree.focusNext(void 0, !0, void 0, (r) => {
            if (i)
              return !0;
            if (r.element instanceof bl)
              i = !0, this._separatorRenderer.isSeparatorVisible(r.element) ? this._tree.reveal(r.element.children[0]) : this._tree.reveal(r.element, 0);
            else if (r.element instanceof Di) {
              if (r.element.separator)
                return this._itemRenderer.isItemWithSeparatorVisible(r.element) ? this._tree.reveal(r.element) : this._tree.reveal(r.element, 0), !0;
              if (r.element === this._elementTree[0])
                return this._tree.reveal(r.element, 0), !0;
            }
            return !1;
          });
          const o = this._tree.getFocus()[0];
          n === o && (this._tree.scrollTop = this._tree.scrollHeight, this._tree.focusLast(void 0, (r) => r.element instanceof Di));
          break;
        }
        case _t.PreviousSeparator: {
          let i, n = !!((t = this._tree.getFocus()[0]) != null && t.separator);
          this._tree.focusPrevious(void 0, !0, void 0, (o) => {
            if (o.element instanceof bl)
              n ? i || (this._separatorRenderer.isSeparatorVisible(o.element) ? this._tree.reveal(o.element) : this._tree.reveal(o.element, 0), i = o.element.children[0]) : n = !0;
            else if (o.element instanceof Di && !i) {
              if (o.element.separator)
                this._itemRenderer.isItemWithSeparatorVisible(o.element) ? this._tree.reveal(o.element) : this._tree.reveal(o.element, 0), i = o.element;
              else if (o.element === this._elementTree[0])
                return this._tree.reveal(o.element, 0), !0;
            }
            return !1;
          }), i && this._tree.setFocus([i]);
          break;
        }
      }
  }
  clearFocus() {
    this._tree.setFocus([]);
  }
  domFocus() {
    this._tree.domFocus();
  }
  layout(e) {
    this._tree.getHTMLElement().style.maxHeight = e ? `${// Make sure height aligns with list item heights
    Math.floor(e / 44) * 44 + 6}px` : "", this._tree.layout();
  }
  filter(e) {
    if (this._lastQueryString = e, !(this._sortByLabel || this._matchOnLabel || this._matchOnDescription || this._matchOnDetail))
      return this._tree.layout(), !1;
    const t = e;
    if (e = e.trim(), !e || !(this.matchOnLabel || this.matchOnDescription || this.matchOnDetail))
      this._itemElements.forEach((i) => {
        i.labelHighlights = void 0, i.descriptionHighlights = void 0, i.detailHighlights = void 0, i.hidden = !1;
        const n = i.index && this._inputElements[i.index - 1];
        i.item && (i.separator = n && n.type === "separator" && !n.buttons ? n : void 0);
      });
    else {
      let i;
      this._itemElements.forEach((n) => {
        let o;
        this.matchOnLabelMode === "fuzzy" ? o = this.matchOnLabel ? H0(e, Eu(n.saneLabel)) ?? void 0 : void 0 : o = this.matchOnLabel ? Mq(t, Eu(n.saneLabel)) ?? void 0 : void 0;
        const r = this.matchOnDescription ? H0(e, Eu(n.saneDescription || "")) ?? void 0 : void 0, a = this.matchOnDetail ? H0(e, Eu(n.saneDetail || "")) ?? void 0 : void 0;
        if (o || r || a ? (n.labelHighlights = o, n.descriptionHighlights = r, n.detailHighlights = a, n.hidden = !1) : (n.labelHighlights = void 0, n.descriptionHighlights = void 0, n.detailHighlights = void 0, n.hidden = n.item ? !n.item.alwaysShow : !0), n.item ? n.separator = void 0 : n.separator && (n.hidden = !0), !this.sortByLabel) {
          const l = n.index && this._inputElements[n.index - 1] || void 0;
          (l == null ? void 0 : l.type) === "separator" && !l.buttons && (i = l), i && !n.hidden && (n.separator = i, i = void 0);
        }
      });
    }
    return this._setElementsToTree(this._sortByLabel && e ? this._itemElements : this._elementTree), this._tree.layout(), !0;
  }
  toggleCheckbox() {
    this._elementCheckedEventBufferer.bufferEvents(() => {
      const e = this._tree.getFocus().filter((i) => i instanceof Di), t = this._allVisibleChecked(e);
      for (const i of e)
        i.checkboxDisabled || (i.checked = !t);
    });
  }
  style(e) {
    this._tree.style(e);
  }
  toggleHover() {
    const e = this._tree.getFocus()[0];
    if (!(e != null && e.saneTooltip) || !(e instanceof Di))
      return;
    if (this._lastHover && !this._lastHover.isDisposed) {
      this._lastHover.dispose();
      return;
    }
    this.showHover(e);
    const t = new he();
    t.add(this._tree.onDidChangeFocus((i) => {
      i.elements[0] instanceof Di && this.showHover(i.elements[0]);
    })), this._lastHover && t.add(this._lastHover), this._elementDisposable.add(t);
  }
  //#endregion
  //#region private methods
  _setElementsToTree(e) {
    const t = new Array();
    for (const i of e)
      i instanceof bl ? t.push({
        element: i,
        collapsible: !1,
        collapsed: !1,
        children: i.children.map((n) => ({
          element: n,
          collapsible: !1,
          collapsed: !1
        }))
      }) : t.push({
        element: i,
        collapsible: !1,
        collapsed: !1
      });
    this._tree.setChildren(null, t);
  }
  _allVisibleChecked(e, t = !0) {
    for (let i = 0, n = e.length; i < n; i++) {
      const o = e[i];
      if (!o.hidden)
        if (o.checked)
          t = !0;
        else
          return !1;
    }
    return t;
  }
  _updateCheckedObservables() {
    ni((e) => {
      this._allVisibleCheckedObservable.set(this._allVisibleChecked(this._itemElements, !1), e);
      const t = this._itemElements.filter((i) => i.checked).length;
      this._checkedCountObservable.set(t, e), this._checkedElementsObservable.set(this.getCheckedElements(), e);
    });
  }
  /**
   * Disposes of the hover and shows a new one for the given index if it has a tooltip.
   * @param element The element to show the hover for
   */
  showHover(e) {
    var t, i, n;
    this._lastHover && !this._lastHover.isDisposed && ((i = (t = this.hoverDelegate).onDidHideHover) == null || i.call(t), (n = this._lastHover) == null || n.dispose()), !(!e.element || !e.saneTooltip) && (this._lastHover = this.hoverDelegate.showHover({
      content: e.saneTooltip,
      target: e.element,
      linkHandler: (o) => {
        this.linkOpenerDelegate(o);
      },
      appearance: {
        showPointer: !0
      },
      container: this._container,
      position: {
        hoverPosition: 1
        /* HoverPosition.RIGHT */
      }
    }, !1));
  }
};
jb([
  Ht
], rg.prototype, "onDidChangeFocus", null);
jb([
  Ht
], rg.prototype, "onDidChangeSelection", null);
rg = jb([
  Ky(4, ot),
  Ky(5, go)
], rg);
function Mq(s, e) {
  const { text: t, iconOffsets: i } = e;
  if (!i || i.length === 0)
    return VN(s, t);
  const n = ib(t, " "), o = t.length - n.length, r = VN(s, n);
  if (r)
    for (const a of r) {
      const l = i[a.start + o] + o;
      a.start += l, a.end += l;
    }
  return r;
}
function VN(s, e) {
  const t = e.toLowerCase().indexOf(s.toLowerCase());
  return t !== -1 ? [{ start: t, end: t + s.length }] : null;
}
function Rq(s, e, t) {
  const i = s.labelHighlights || [], n = e.labelHighlights || [];
  return i.length && !n.length ? -1 : !i.length && n.length ? 1 : i.length === 0 && n.length === 0 ? 0 : Eq(s.saneSortLabel, e.saneSortLabel, t);
}
const T4 = {
  weight: 200,
  when: et.and(et.equals(
    d4,
    "quickPick"
    /* QuickInputType.QuickPick */
  ), X$),
  metadata: { description: p("quickPick", "Used while in the context of the quick pick. If you change one keybinding for this command, you should change all of the other keybindings (modifier variants) of this command as well.") }
};
function Tn(s, e = {}) {
  Dg.registerCommandAndKeybindingRule({
    ...T4,
    ...s,
    secondary: Aq(s.primary, s.secondary ?? [], e)
  });
}
const k_ = He ? 256 : 2048;
function Aq(s, e, t = {}) {
  return t.withAltMod && e.push(512 + s), t.withCtrlMod && (e.push(k_ + s), t.withAltMod && e.push(512 + k_ + s)), t.withCmdMod && He && (e.push(2048 + s), t.withCtrlMod && e.push(2304 + s), t.withAltMod && (e.push(2560 + s), t.withCtrlMod && e.push(2816 + s))), e;
}
function jn(s, e) {
  return (t) => {
    const i = t.get(Vb).currentQuickInput;
    if (i)
      return e && i.quickNavigate ? i.focus(e) : i.focus(s);
  };
}
Tn({ id: "quickInput.pageNext", primary: 12, handler: jn(_t.NextPage) }, { withAltMod: !0, withCtrlMod: !0, withCmdMod: !0 });
Tn({ id: "quickInput.pagePrevious", primary: 11, handler: jn(_t.PreviousPage) }, { withAltMod: !0, withCtrlMod: !0, withCmdMod: !0 });
Tn({ id: "quickInput.first", primary: k_ + 14, handler: jn(_t.First) }, { withAltMod: !0, withCmdMod: !0 });
Tn({ id: "quickInput.last", primary: k_ + 13, handler: jn(_t.Last) }, { withAltMod: !0, withCmdMod: !0 });
Tn({ id: "quickInput.next", primary: 18, handler: jn(_t.Next) }, { withCtrlMod: !0 });
Tn({ id: "quickInput.previous", primary: 16, handler: jn(_t.Previous) }, { withCtrlMod: !0 });
const HN = p("quickInput.nextSeparatorWithQuickAccessFallback", "If we're in quick access mode, this will navigate to the next item. If we are not in quick access mode, this will navigate to the next separator."), zN = p("quickInput.previousSeparatorWithQuickAccessFallback", "If we're in quick access mode, this will navigate to the previous item. If we are not in quick access mode, this will navigate to the previous separator.");
He ? (Tn({
  id: "quickInput.nextSeparatorWithQuickAccessFallback",
  primary: 2066,
  handler: jn(_t.NextSeparator, _t.Next),
  metadata: { description: HN }
}), Tn({
  id: "quickInput.nextSeparator",
  primary: 2578,
  // Since macOS has the cmd key as the primary modifier, we need to add this additional
  // keybinding to capture cmd+ctrl+upArrow
  secondary: [
    2322
    /* KeyCode.DownArrow */
  ],
  handler: jn(_t.NextSeparator)
}, { withCtrlMod: !0 }), Tn({
  id: "quickInput.previousSeparatorWithQuickAccessFallback",
  primary: 2064,
  handler: jn(_t.PreviousSeparator, _t.Previous),
  metadata: { description: zN }
}), Tn({
  id: "quickInput.previousSeparator",
  primary: 2576,
  // Since macOS has the cmd key as the primary modifier, we need to add this additional
  // keybinding to capture cmd+ctrl+upArrow
  secondary: [
    2320
    /* KeyCode.UpArrow */
  ],
  handler: jn(_t.PreviousSeparator)
}, { withCtrlMod: !0 })) : (Tn({
  id: "quickInput.nextSeparatorWithQuickAccessFallback",
  primary: 530,
  handler: jn(_t.NextSeparator, _t.Next),
  metadata: { description: HN }
}), Tn({
  id: "quickInput.nextSeparator",
  primary: 2578,
  handler: jn(_t.NextSeparator)
}), Tn({
  id: "quickInput.previousSeparatorWithQuickAccessFallback",
  primary: 528,
  handler: jn(_t.PreviousSeparator, _t.Previous),
  metadata: { description: zN }
}), Tn({
  id: "quickInput.previousSeparator",
  primary: 2576,
  handler: jn(_t.PreviousSeparator)
}));
Tn({
  id: "quickInput.acceptInBackground",
  // If we are in the quick pick but the input box is not focused or our cursor is at the end of the input box
  when: et.and(T4.when, et.or(dq.negate(), tK)),
  primary: 17,
  // Need a little extra weight to ensure this keybinding is preferred over the default cmd+alt+right arrow keybinding
  // https://github.com/microsoft/vscode/blob/1451e4fbbbf074a4355cc537c35b547b80ce1c52/src/vs/workbench/browser/parts/editor/editorActions.ts#L1178-L1195
  weight: 250,
  handler: (s) => {
    const e = s.get(Vb).currentQuickInput;
    e == null || e.accept(!0);
  }
}, { withAltMod: !0, withCtrlMod: !0, withCmdMod: !0 });
var Pq = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, hC = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, jy;
const En = pe;
var rc;
let Gy = (rc = class extends q {
  // Max total width of quick input widget
  get currentQuickInput() {
    return this.controller ?? void 0;
  }
  get container() {
    return this._container;
  }
  constructor(e, t, i, n) {
    super(), this.options = e, this.layoutService = t, this.instantiationService = i, this.contextKeyService = n, this.enabled = !0, this.onDidAcceptEmitter = this._register(new O()), this.onDidCustomEmitter = this._register(new O()), this.onDidTriggerButtonEmitter = this._register(new O()), this.keyMods = { ctrlCmd: !1, alt: !1 }, this.controller = null, this.onShowEmitter = this._register(new O()), this.onShow = this.onShowEmitter.event, this.onHideEmitter = this._register(new O()), this.onHide = this.onHideEmitter.event, this.inQuickInputContext = Q$.bindTo(this.contextKeyService), this.quickInputTypeContext = J$.bindTo(this.contextKeyService), this.endOfQuickInputBoxContext = eK.bindTo(this.contextKeyService), this.idPrefix = e.idPrefix, this._container = e.container, this.styles = e.styles, this._register(J.runAndSubscribe(rb, ({ window: o, disposables: r }) => this.registerKeyModsListeners(o, r), { window: ut, disposables: this._store })), this._register(Z6((o) => {
      this.ui && ue(this.ui.container) === o && (this.reparentUI(this.layoutService.mainContainer), this.layout(this.layoutService.mainContainerDimension, this.layoutService.mainContainerOffset.quickPickTop));
    }));
  }
  registerKeyModsListeners(e, t) {
    const i = (n) => {
      this.keyMods.ctrlCmd = n.ctrlKey || n.metaKey, this.keyMods.alt = n.altKey;
    };
    for (const n of [ee.KEY_DOWN, ee.KEY_UP, ee.MOUSE_DOWN])
      t.add($(e, n, i, !0));
  }
  getUI(e) {
    if (this.ui)
      return e && ue(this._container) !== ue(this.layoutService.activeContainer) && (this.reparentUI(this.layoutService.activeContainer), this.layout(this.layoutService.activeContainerDimension, this.layoutService.activeContainerOffset.quickPickTop)), this.ui;
    const t = ae(this._container, En(".quick-input-widget.show-file-icons"));
    t.tabIndex = -1, t.style.display = "none";
    const i = Os(t), n = ae(t, En(".quick-input-titlebar")), o = this._register(new Kr(n, { hoverDelegate: this.options.hoverDelegate }));
    o.domNode.classList.add("quick-input-left-action-bar");
    const r = ae(n, En(".quick-input-title")), a = this._register(new Kr(n, { hoverDelegate: this.options.hoverDelegate }));
    a.domNode.classList.add("quick-input-right-action-bar");
    const l = ae(t, En(".quick-input-header")), c = ae(l, En("input.quick-input-check-all"));
    c.type = "checkbox", c.setAttribute("aria-label", p("quickInput.checkAll", "Toggle all checkboxes")), this._register(fi(c, ee.CHANGE, (A) => {
      const K = c.checked;
      B.setAllVisibleChecked(K);
    })), this._register($(c, ee.CLICK, (A) => {
      (A.x || A.y) && f.setFocus();
    }));
    const h = ae(l, En(".quick-input-description")), d = ae(l, En(".quick-input-and-message")), u = ae(d, En(".quick-input-filter")), f = this._register(new pK(u, this.styles.inputBox, this.styles.toggle));
    f.setAttribute("aria-describedby", `${this.idPrefix}message`);
    const g = ae(u, En(".quick-input-visible-count"));
    g.setAttribute("aria-live", "polite"), g.setAttribute("aria-atomic", "true");
    const m = new wN(g, { countFormat: p({ key: "quickInput.visibleCount", comment: ["This tells the user how many items are shown in a list of items to select from. The items can be anything. Currently not visible, but read by screen readers."] }, "{0} Results") }, this.styles.countBadge), _ = ae(u, En(".quick-input-count"));
    _.setAttribute("aria-live", "polite");
    const b = new wN(_, { countFormat: p({ key: "quickInput.countSelected", comment: ["This tells the user how many items are selected in a list of items to select from. The items can be anything."] }, "{0} Selected") }, this.styles.countBadge), C = this._register(new Kr(l, { hoverDelegate: this.options.hoverDelegate }));
    C.domNode.classList.add("quick-input-inline-action-bar");
    const v = ae(l, En(".quick-input-action")), w = this._register(new Fy(v, this.styles.button));
    w.label = p("ok", "OK"), this._register(w.onDidClick((A) => {
      this.onDidAcceptEmitter.fire();
    }));
    const S = ae(l, En(".quick-input-action")), L = this._register(new Fy(S, { ...this.styles.button, supportIcons: !0 }));
    L.label = p("custom", "Custom"), this._register(L.onDidClick((A) => {
      this.onDidCustomEmitter.fire();
    }));
    const k = ae(d, En(`#${this.idPrefix}message.quick-input-message`)), D = this._register(new By(t, this.styles.progressBar));
    D.getContainer().classList.add("quick-input-progress");
    const E = ae(t, En(".quick-input-html-widget"));
    E.tabIndex = -1;
    const U = ae(t, En(".quick-input-description")), P = this.idPrefix + "list", B = this._register(this.instantiationService.createInstance(rg, t, this.options.hoverDelegate, this.options.linkOpenerDelegate, P));
    f.setAttribute("aria-controls", P), this._register(B.onDidChangeFocus(() => {
      f.setAttribute("aria-activedescendant", B.getActiveDescendant() ?? "");
    })), this._register(B.onChangedAllVisibleChecked((A) => {
      c.checked = A;
    })), this._register(B.onChangedVisibleCount((A) => {
      m.setCount(A);
    })), this._register(B.onChangedCheckedCount((A) => {
      b.setCount(A);
    })), this._register(B.onLeave(() => {
      setTimeout(() => {
        this.controller && (f.setFocus(), this.controller instanceof m_ && this.controller.canSelectMany && B.clearFocus());
      }, 0);
    }));
    const W = Ff(t);
    return this._register(W), this._register($(t, ee.FOCUS, (A) => {
      const K = this.getUI();
      if (ui(A.relatedTarget, K.inputContainer)) {
        const Y = K.inputBox.isSelectionAtEnd();
        this.endOfQuickInputBoxContext.get() !== Y && this.endOfQuickInputBoxContext.set(Y);
      }
      ui(A.relatedTarget, K.container) || (this.inQuickInputContext.set(!0), this.previousFocusElement = yi(A.relatedTarget) ? A.relatedTarget : void 0);
    }, !0)), this._register(W.onDidBlur(() => {
      !this.getUI().ignoreFocusOut && !this.options.ignoreFocusOut() && this.hide(Td.Blur), this.inQuickInputContext.set(!1), this.endOfQuickInputBoxContext.set(!1), this.previousFocusElement = void 0;
    })), this._register(f.onKeyDown((A) => {
      const K = this.getUI().inputBox.isSelectionAtEnd();
      this.endOfQuickInputBoxContext.get() !== K && this.endOfQuickInputBoxContext.set(K);
    })), this._register($(t, ee.FOCUS, (A) => {
      f.setFocus();
    })), this._register(fi(t, ee.KEY_DOWN, (A) => {
      if (!ui(A.target, E))
        switch (A.keyCode) {
          case 3:
            Be.stop(A, !0), this.enabled && this.onDidAcceptEmitter.fire();
            break;
          case 9:
            Be.stop(A, !0), this.hide(Td.Gesture);
            break;
          case 2:
            if (!A.altKey && !A.ctrlKey && !A.metaKey) {
              const K = [
                ".quick-input-list .monaco-action-bar .always-visible",
                ".quick-input-list-entry:hover .monaco-action-bar",
                ".monaco-list-row.focused .monaco-action-bar"
              ];
              if (t.classList.contains("show-checkboxes") ? K.push("input") : K.push("input[type=text]"), this.getUI().list.displayed && K.push(".monaco-list"), this.getUI().message && K.push(".quick-input-message a"), this.getUI().widget) {
                if (ui(A.target, this.getUI().widget))
                  break;
                K.push(".quick-input-html-widget");
              }
              const Y = t.querySelectorAll(K.join(", "));
              A.shiftKey && A.target === Y[0] ? (Be.stop(A, !0), B.clearFocus()) : !A.shiftKey && ui(A.target, Y[Y.length - 1]) && (Be.stop(A, !0), Y[0].focus());
            }
            break;
          case 10:
            A.ctrlKey && (Be.stop(A, !0), this.getUI().list.toggleHover());
            break;
        }
    })), this.ui = {
      container: t,
      styleSheet: i,
      leftActionBar: o,
      titleBar: n,
      title: r,
      description1: U,
      description2: h,
      widget: E,
      rightActionBar: a,
      inlineActionBar: C,
      checkAll: c,
      inputContainer: d,
      filterContainer: u,
      inputBox: f,
      visibleCountContainer: g,
      visibleCount: m,
      countContainer: _,
      count: b,
      okContainer: v,
      ok: w,
      message: k,
      customButtonContainer: S,
      customButton: L,
      list: B,
      progressBar: D,
      onDidAccept: this.onDidAcceptEmitter.event,
      onDidCustom: this.onDidCustomEmitter.event,
      onDidTriggerButton: this.onDidTriggerButtonEmitter.event,
      ignoreFocusOut: !1,
      keyMods: this.keyMods,
      show: (A) => this.show(A),
      hide: () => this.hide(),
      setVisibilities: (A) => this.setVisibilities(A),
      setEnabled: (A) => this.setEnabled(A),
      setContextKey: (A) => this.options.setContextKey(A),
      linkOpenerDelegate: (A) => this.options.linkOpenerDelegate(A)
    }, this.updateStyles(), this.ui;
  }
  reparentUI(e) {
    this.ui && (this._container = e, ae(this._container, this.ui.container));
  }
  pick(e, t = {}, i = Rs.None) {
    return new Promise((n, o) => {
      let r = (h) => {
        var d;
        r = n, (d = t.onKeyMods) == null || d.call(t, a.keyMods), n(h);
      };
      if (i.isCancellationRequested) {
        r(void 0);
        return;
      }
      const a = this.createQuickPick({ useSeparators: !0 });
      let l;
      const c = [
        a,
        a.onDidAccept(() => {
          if (a.canSelectMany)
            r(a.selectedItems.slice()), a.hide();
          else {
            const h = a.activeItems[0];
            h && (r(h), a.hide());
          }
        }),
        a.onDidChangeActive((h) => {
          const d = h[0];
          d && t.onDidFocus && t.onDidFocus(d);
        }),
        a.onDidChangeSelection((h) => {
          if (!a.canSelectMany) {
            const d = h[0];
            d && (r(d), a.hide());
          }
        }),
        a.onDidTriggerItemButton((h) => t.onDidTriggerItemButton && t.onDidTriggerItemButton({
          ...h,
          removeItem: () => {
            const d = a.items.indexOf(h.item);
            if (d !== -1) {
              const u = a.items.slice(), f = u.splice(d, 1), g = a.activeItems.filter((_) => _ !== f[0]), m = a.keepScrollPosition;
              a.keepScrollPosition = !0, a.items = u, g && (a.activeItems = g), a.keepScrollPosition = m;
            }
          }
        })),
        a.onDidTriggerSeparatorButton((h) => {
          var d;
          return (d = t.onDidTriggerSeparatorButton) == null ? void 0 : d.call(t, h);
        }),
        a.onDidChangeValue((h) => {
          l && !h && (a.activeItems.length !== 1 || a.activeItems[0] !== l) && (a.activeItems = [l]);
        }),
        i.onCancellationRequested(() => {
          a.hide();
        }),
        a.onDidHide(() => {
          Ri(c), r(void 0);
        })
      ];
      a.title = t.title, t.value && (a.value = t.value), a.canSelectMany = !!t.canPickMany, a.placeholder = t.placeHolder, a.ignoreFocusOut = !!t.ignoreFocusLost, a.matchOnDescription = !!t.matchOnDescription, a.matchOnDetail = !!t.matchOnDetail, a.matchOnLabel = t.matchOnLabel === void 0 || t.matchOnLabel, a.quickNavigate = t.quickNavigate, a.hideInput = !!t.hideInput, a.contextKey = t.contextKey, a.busy = !0, Promise.all([e, t.activeItem]).then(([h, d]) => {
        l = d, a.busy = !1, a.items = h, a.canSelectMany && (a.selectedItems = h.filter((u) => u.type !== "separator" && u.picked)), l && (a.activeItems = [l]);
      }), a.show(), Promise.resolve(e).then(void 0, (h) => {
        o(h), a.hide();
      });
    });
  }
  createQuickPick(e = { useSeparators: !1 }) {
    const t = this.getUI(!0);
    return new m_(t);
  }
  createInputBox() {
    const e = this.getUI(!0);
    return new iK(e);
  }
  show(e) {
    const t = this.getUI(!0);
    this.onShowEmitter.fire();
    const i = this.controller;
    this.controller = e, i == null || i.didHide(), this.setEnabled(!0), t.leftActionBar.clear(), t.title.textContent = "", t.description1.textContent = "", t.description2.textContent = "", on(t.widget), t.rightActionBar.clear(), t.inlineActionBar.clear(), t.checkAll.checked = !1, t.inputBox.placeholder = "", t.inputBox.password = !1, t.inputBox.showDecoration(Jt.Ignore), t.visibleCount.setCount(0), t.count.setCount(0), on(t.message), t.progressBar.stop(), t.list.setElements([]), t.list.matchOnDescription = !1, t.list.matchOnDetail = !1, t.list.matchOnLabel = !0, t.list.sortByLabel = !0, t.ignoreFocusOut = !1, t.inputBox.toggles = void 0;
    const n = this.options.backKeybindingLabel();
    Py.tooltip = n ? p("quickInput.backWithKeybinding", "Back ({0})", n) : p("quickInput.back", "Back"), t.container.style.display = "", this.updateLayout(), t.inputBox.setFocus(), this.quickInputTypeContext.set(e.type);
  }
  isVisible() {
    return !!this.ui && this.ui.container.style.display !== "none";
  }
  setVisibilities(e) {
    const t = this.getUI();
    t.title.style.display = e.title ? "" : "none", t.description1.style.display = e.description && (e.inputBox || e.checkAll) ? "" : "none", t.description2.style.display = e.description && !(e.inputBox || e.checkAll) ? "" : "none", t.checkAll.style.display = e.checkAll ? "" : "none", t.inputContainer.style.display = e.inputBox ? "" : "none", t.filterContainer.style.display = e.inputBox ? "" : "none", t.visibleCountContainer.style.display = e.visibleCount ? "" : "none", t.countContainer.style.display = e.count ? "" : "none", t.okContainer.style.display = e.ok ? "" : "none", t.customButtonContainer.style.display = e.customButton ? "" : "none", t.message.style.display = e.message ? "" : "none", t.progressBar.getContainer().style.display = e.progressBar ? "" : "none", t.list.displayed = !!e.list, t.container.classList.toggle("show-checkboxes", !!e.checkBox), t.container.classList.toggle("hidden-input", !e.inputBox && !e.description), this.updateLayout();
  }
  setEnabled(e) {
    if (e !== this.enabled) {
      this.enabled = e;
      for (const t of this.getUI().leftActionBar.viewItems)
        t.action.enabled = e;
      for (const t of this.getUI().rightActionBar.viewItems)
        t.action.enabled = e;
      this.getUI().checkAll.disabled = !e, this.getUI().inputBox.enabled = e, this.getUI().ok.enabled = e, this.getUI().list.enabled = e;
    }
  }
  hide(e) {
    var o;
    const t = this.controller;
    if (!t)
      return;
    t.willHide(e);
    const i = (o = this.ui) == null ? void 0 : o.container, n = i && !SM(i);
    if (this.controller = null, this.onHideEmitter.fire(), i && (i.style.display = "none"), !n) {
      let r = this.previousFocusElement;
      for (; r && !r.offsetParent; )
        r = r.parentElement ?? void 0;
      r != null && r.offsetParent ? (r.focus(), this.previousFocusElement = void 0) : this.options.returnFocus();
    }
    t.didHide(e);
  }
  layout(e, t) {
    this.dimension = e, this.titleBarOffset = t, this.updateLayout();
  }
  updateLayout() {
    if (this.ui && this.isVisible()) {
      this.ui.container.style.top = `${this.titleBarOffset}px`;
      const e = this.ui.container.style, t = Math.min(this.dimension.width * 0.62, jy.MAX_WIDTH);
      e.width = t + "px", e.marginLeft = "-" + t / 2 + "px", this.ui.inputBox.layout(), this.ui.list.layout(this.dimension && this.dimension.height * 0.4);
    }
  }
  applyStyles(e) {
    this.styles = e, this.updateStyles();
  }
  updateStyles() {
    if (this.ui) {
      const { quickInputTitleBackground: e, quickInputBackground: t, quickInputForeground: i, widgetBorder: n, widgetShadow: o } = this.styles.widget;
      this.ui.titleBar.style.backgroundColor = e ?? "", this.ui.container.style.backgroundColor = t ?? "", this.ui.container.style.color = i ?? "", this.ui.container.style.border = n ? `1px solid ${n}` : "", this.ui.container.style.boxShadow = o ? `0 0 8px 2px ${o}` : "", this.ui.list.style(this.styles.list);
      const r = [];
      this.styles.pickerGroup.pickerGroupBorder && r.push(`.quick-input-list .quick-input-list-entry { border-top-color:  ${this.styles.pickerGroup.pickerGroupBorder}; }`), this.styles.pickerGroup.pickerGroupForeground && r.push(`.quick-input-list .quick-input-list-separator { color:  ${this.styles.pickerGroup.pickerGroupForeground}; }`), this.styles.pickerGroup.pickerGroupForeground && r.push(".quick-input-list .quick-input-list-separator-as-item { color: var(--vscode-descriptionForeground); }"), (this.styles.keybindingLabel.keybindingLabelBackground || this.styles.keybindingLabel.keybindingLabelBorder || this.styles.keybindingLabel.keybindingLabelBottomBorder || this.styles.keybindingLabel.keybindingLabelShadow || this.styles.keybindingLabel.keybindingLabelForeground) && (r.push(".quick-input-list .monaco-keybinding > .monaco-keybinding-key {"), this.styles.keybindingLabel.keybindingLabelBackground && r.push(`background-color: ${this.styles.keybindingLabel.keybindingLabelBackground};`), this.styles.keybindingLabel.keybindingLabelBorder && r.push(`border-color: ${this.styles.keybindingLabel.keybindingLabelBorder};`), this.styles.keybindingLabel.keybindingLabelBottomBorder && r.push(`border-bottom-color: ${this.styles.keybindingLabel.keybindingLabelBottomBorder};`), this.styles.keybindingLabel.keybindingLabelShadow && r.push(`box-shadow: inset 0 -1px 0 ${this.styles.keybindingLabel.keybindingLabelShadow};`), this.styles.keybindingLabel.keybindingLabelForeground && r.push(`color: ${this.styles.keybindingLabel.keybindingLabelForeground};`), r.push("}"));
      const a = r.join(`
`);
      a !== this.ui.styleSheet.textContent && (this.ui.styleSheet.textContent = a);
    }
  }
}, jy = rc, rc.MAX_WIDTH = 600, rc);
Gy = jy = Pq([
  hC(1, Xa),
  hC(2, ot),
  hC(3, nt)
], Gy);
var Oq = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Cu = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let Zy = class extends dF {
  get controller() {
    return this._controller || (this._controller = this._register(this.createController())), this._controller;
  }
  get hasController() {
    return !!this._controller;
  }
  get currentQuickInput() {
    return this.controller.currentQuickInput;
  }
  get quickAccess() {
    return this._quickAccess || (this._quickAccess = this._register(this.instantiationService.createInstance(Ay))), this._quickAccess;
  }
  constructor(e, t, i, n, o) {
    super(i), this.instantiationService = e, this.contextKeyService = t, this.layoutService = n, this.configurationService = o, this._onShow = this._register(new O()), this._onHide = this._register(new O()), this.contexts = /* @__PURE__ */ new Map();
  }
  createController(e = this.layoutService, t) {
    const i = {
      idPrefix: "quickInput_",
      container: e.activeContainer,
      ignoreFocusOut: () => !1,
      backKeybindingLabel: () => {
      },
      setContextKey: (o) => this.setContextKey(o),
      linkOpenerDelegate: (o) => {
        this.instantiationService.invokeFunction((r) => {
          r.get(Og).open(o, { allowCommands: !0, fromUserGesture: !0 });
        });
      },
      returnFocus: () => e.focus(),
      styles: this.computeStyles(),
      hoverDelegate: this._register(this.instantiationService.createInstance(Oy))
    }, n = this._register(this.instantiationService.createInstance(Gy, {
      ...i,
      ...t
    }));
    return n.layout(e.activeContainerDimension, e.activeContainerOffset.quickPickTop), this._register(e.onDidLayoutActiveContainer((o) => {
      ue(e.activeContainer) === ue(n.container) && n.layout(o, e.activeContainerOffset.quickPickTop);
    })), this._register(e.onDidChangeActiveContainer(() => {
      n.isVisible() || n.layout(e.activeContainerDimension, e.activeContainerOffset.quickPickTop);
    })), this._register(n.onShow(() => {
      this.resetContextKeys(), this._onShow.fire();
    })), this._register(n.onHide(() => {
      this.resetContextKeys(), this._onHide.fire();
    })), n;
  }
  setContextKey(e) {
    let t;
    e && (t = this.contexts.get(e), t || (t = new de(e, !1).bindTo(this.contextKeyService), this.contexts.set(e, t))), !(t && t.get()) && (this.resetContextKeys(), t == null || t.set(!0));
  }
  resetContextKeys() {
    this.contexts.forEach((e) => {
      e.get() && e.reset();
    });
  }
  pick(e, t, i = Rs.None) {
    return this.controller.pick(e, t, i);
  }
  createQuickPick(e = { useSeparators: !1 }) {
    return this.controller.createQuickPick(e);
  }
  createInputBox() {
    return this.controller.createInputBox();
  }
  updateStyles() {
    this.hasController && this.controller.applyStyles(this.computeStyles());
  }
  computeStyles() {
    return {
      widget: {
        quickInputBackground: te(nI),
        quickInputForeground: te(xB),
        quickInputTitleBackground: te(DB),
        widgetBorder: te(h8),
        widgetShadow: te(Rg)
      },
      inputBox: IA,
      toggle: EA,
      countBadge: uz,
      button: cz,
      progressBar: hz,
      keybindingLabel: lz,
      list: Vg({
        listBackground: nI,
        listFocusBackground: Bv,
        listFocusForeground: Fv,
        // Look like focused when inactive.
        listInactiveFocusForeground: Fv,
        listInactiveSelectionIconForeground: KR,
        listInactiveFocusBackground: Bv,
        listFocusOutline: jt,
        listInactiveFocusOutline: jt
      }),
      pickerGroup: {
        pickerGroupBorder: te(EB),
        pickerGroupForeground: te($R)
      }
    };
  }
};
Zy = Oq([
  Cu(0, ot),
  Cu(1, nt),
  Cu(2, Ws),
  Cu(3, Xa),
  Cu(4, Vt)
], Zy);
var M4 = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Tl = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let Yy = class extends Zy {
  constructor(e, t, i, n, o, r) {
    super(t, i, n, new yv(e.getContainerDomNode(), o), r), this.host = void 0;
    const a = ag.get(e);
    if (a) {
      const l = a.widget;
      this.host = {
        _serviceBrand: void 0,
        get mainContainer() {
          return l.getDomNode();
        },
        getContainer() {
          return l.getDomNode();
        },
        whenContainerStylesLoaded() {
        },
        get containers() {
          return [l.getDomNode()];
        },
        get activeContainer() {
          return l.getDomNode();
        },
        get mainContainerDimension() {
          return e.getLayoutInfo();
        },
        get activeContainerDimension() {
          return e.getLayoutInfo();
        },
        get onDidLayoutMainContainer() {
          return e.onDidLayoutChange;
        },
        get onDidLayoutActiveContainer() {
          return e.onDidLayoutChange;
        },
        get onDidLayoutContainer() {
          return J.map(e.onDidLayoutChange, (c) => ({ container: l.getDomNode(), dimension: c }));
        },
        get onDidChangeActiveContainer() {
          return J.None;
        },
        get onDidAddContainer() {
          return J.None;
        },
        get mainContainerOffset() {
          return { top: 0, quickPickTop: 0 };
        },
        get activeContainerOffset() {
          return { top: 0, quickPickTop: 0 };
        },
        focus: () => e.focus()
      };
    } else
      this.host = void 0;
  }
  createController() {
    return super.createController(this.host);
  }
};
Yy = M4([
  Tl(1, ot),
  Tl(2, nt),
  Tl(3, Ws),
  Tl(4, ri),
  Tl(5, Vt)
], Yy);
let Qy = class {
  get activeService() {
    const e = this.codeEditorService.getFocusedCodeEditor();
    if (!e)
      throw new Error("Quick input service needs a focused editor to work.");
    let t = this.mapEditorToService.get(e);
    if (!t) {
      const i = t = this.instantiationService.createInstance(Yy, e);
      this.mapEditorToService.set(e, t), pd(e.onDidDispose)(() => {
        i.dispose(), this.mapEditorToService.delete(e);
      });
    }
    return t;
  }
  get currentQuickInput() {
    return this.activeService.currentQuickInput;
  }
  get quickAccess() {
    return this.activeService.quickAccess;
  }
  constructor(e, t) {
    this.instantiationService = e, this.codeEditorService = t, this.mapEditorToService = /* @__PURE__ */ new Map();
  }
  pick(e, t, i = Rs.None) {
    return this.activeService.pick(e, t, i);
  }
  createQuickPick(e = { useSeparators: !1 }) {
    return this.activeService.createQuickPick(e);
  }
  createInputBox() {
    return this.activeService.createInputBox();
  }
};
Qy = M4([
  Tl(0, ot),
  Tl(1, ri)
], Qy);
const T1 = class T1 {
  static get(e) {
    return e.getContribution(T1.ID);
  }
  constructor(e) {
    this.editor = e, this.widget = new Xy(this.editor);
  }
  dispose() {
    this.widget.dispose();
  }
};
T1.ID = "editor.controller.quickInput";
let ag = T1;
const M1 = class M1 {
  constructor(e) {
    this.codeEditor = e, this.domNode = document.createElement("div"), this.codeEditor.addOverlayWidget(this);
  }
  getId() {
    return M1.ID;
  }
  getDomNode() {
    return this.domNode;
  }
  getPosition() {
    return {
      preference: 2
      /* OverlayWidgetPositionPreference.TOP_CENTER */
    };
  }
  dispose() {
    this.codeEditor.removeOverlayWidget(this);
  }
};
M1.ID = "editor.contrib.quickInputWidget";
let Xy = M1;
AM(
  ag.ID,
  ag,
  4
  /* EditorContributionInstantiation.Lazy */
);
class Fq {
  constructor(e, t, i, n, o) {
    this._parsedThemeRuleBrand = void 0, this.token = e, this.index = t, this.fontStyle = i, this.foreground = n, this.background = o;
  }
}
function Bq(s) {
  if (!s || !Array.isArray(s))
    return [];
  const e = [];
  let t = 0;
  for (let i = 0, n = s.length; i < n; i++) {
    const o = s[i];
    let r = -1;
    if (typeof o.fontStyle == "string") {
      r = 0;
      const c = o.fontStyle.split(" ");
      for (let h = 0, d = c.length; h < d; h++)
        switch (c[h]) {
          case "italic":
            r = r | 1;
            break;
          case "bold":
            r = r | 2;
            break;
          case "underline":
            r = r | 4;
            break;
          case "strikethrough":
            r = r | 8;
            break;
        }
    }
    let a = null;
    typeof o.foreground == "string" && (a = o.foreground);
    let l = null;
    typeof o.background == "string" && (l = o.background), e[t++] = new Fq(o.token || "", i, r, a, l);
  }
  return e;
}
function Wq(s, e) {
  s.sort((h, d) => {
    const u = $q(h.token, d.token);
    return u !== 0 ? u : h.index - d.index;
  });
  let t = 0, i = "000000", n = "ffffff";
  for (; s.length >= 1 && s[0].token === ""; ) {
    const h = s.shift();
    h.fontStyle !== -1 && (t = h.fontStyle), h.foreground !== null && (i = h.foreground), h.background !== null && (n = h.background);
  }
  const o = new Hq();
  for (const h of e)
    o.getId(h);
  const r = o.getId(i), a = o.getId(n), l = new dx(t, r, a), c = new ux(l);
  for (let h = 0, d = s.length; h < d; h++) {
    const u = s[h];
    c.insert(u.token, u.fontStyle, o.getId(u.foreground), o.getId(u.background));
  }
  return new R4(o, c);
}
const Vq = /^#?([0-9A-Fa-f]{6})([0-9A-Fa-f]{2})?$/;
class Hq {
  constructor() {
    this._lastColorId = 0, this._id2color = [], this._color2id = /* @__PURE__ */ new Map();
  }
  getId(e) {
    if (e === null)
      return 0;
    const t = e.match(Vq);
    if (!t)
      throw new Error("Illegal value for token color: " + e);
    e = t[1].toUpperCase();
    let i = this._color2id.get(e);
    return i || (i = ++this._lastColorId, this._color2id.set(e, i), this._id2color[i] = Z.fromHex("#" + e), i);
  }
  getColorMap() {
    return this._id2color.slice(0);
  }
}
class R4 {
  static createFromRawTokenTheme(e, t) {
    return this.createFromParsedTokenTheme(Bq(e), t);
  }
  static createFromParsedTokenTheme(e, t) {
    return Wq(e, t);
  }
  constructor(e, t) {
    this._colorMap = e, this._root = t, this._cache = /* @__PURE__ */ new Map();
  }
  getColorMap() {
    return this._colorMap.getColorMap();
  }
  _match(e) {
    return this._root.match(e);
  }
  match(e, t) {
    let i = this._cache.get(t);
    if (typeof i > "u") {
      const n = this._match(t), o = Uq(t);
      i = (n.metadata | o << 8) >>> 0, this._cache.set(t, i);
    }
    return (i | e << 0) >>> 0;
  }
}
const zq = /\b(comment|string|regex|regexp)\b/;
function Uq(s) {
  const e = s.match(zq);
  if (!e)
    return 0;
  switch (e[1]) {
    case "comment":
      return 1;
    case "string":
      return 2;
    case "regex":
      return 3;
    case "regexp":
      return 3;
  }
  throw new Error("Unexpected match for standard token type!");
}
function $q(s, e) {
  return s < e ? -1 : s > e ? 1 : 0;
}
class dx {
  constructor(e, t, i) {
    this._themeTrieElementRuleBrand = void 0, this._fontStyle = e, this._foreground = t, this._background = i, this.metadata = (this._fontStyle << 11 | this._foreground << 15 | this._background << 24) >>> 0;
  }
  clone() {
    return new dx(this._fontStyle, this._foreground, this._background);
  }
  acceptOverwrite(e, t, i) {
    e !== -1 && (this._fontStyle = e), t !== 0 && (this._foreground = t), i !== 0 && (this._background = i), this.metadata = (this._fontStyle << 11 | this._foreground << 15 | this._background << 24) >>> 0;
  }
}
class ux {
  constructor(e) {
    this._themeTrieElementBrand = void 0, this._mainRule = e, this._children = /* @__PURE__ */ new Map();
  }
  match(e) {
    if (e === "")
      return this._mainRule;
    const t = e.indexOf(".");
    let i, n;
    t === -1 ? (i = e, n = "") : (i = e.substring(0, t), n = e.substring(t + 1));
    const o = this._children.get(i);
    return typeof o < "u" ? o.match(n) : this._mainRule;
  }
  insert(e, t, i, n) {
    if (e === "") {
      this._mainRule.acceptOverwrite(t, i, n);
      return;
    }
    const o = e.indexOf(".");
    let r, a;
    o === -1 ? (r = e, a = "") : (r = e.substring(0, o), a = e.substring(o + 1));
    let l = this._children.get(r);
    typeof l > "u" && (l = new ux(this._mainRule.clone()), this._children.set(r, l)), l.insert(a, t, i, n);
  }
}
function Kq(s) {
  const e = [];
  for (let t = 1, i = s.length; t < i; t++) {
    const n = s[t];
    e[t] = `.mtk${t} { color: ${n}; }`;
  }
  return e.push(".mtki { font-style: italic; }"), e.push(".mtkb { font-weight: bold; }"), e.push(".mtku { text-decoration: underline; text-underline-position: under; }"), e.push(".mtks { text-decoration: line-through; }"), e.push(".mtks.mtku { text-decoration: underline line-through; text-underline-position: under; }"), e.join(`
`);
}
const qq = {
  base: "vs",
  inherit: !1,
  rules: [
    { token: "", foreground: "000000", background: "fffffe" },
    { token: "invalid", foreground: "cd3131" },
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "variable", foreground: "001188" },
    { token: "variable.predefined", foreground: "4864AA" },
    { token: "constant", foreground: "dd0000" },
    { token: "comment", foreground: "008000" },
    { token: "number", foreground: "098658" },
    { token: "number.hex", foreground: "3030c0" },
    { token: "regexp", foreground: "800000" },
    { token: "annotation", foreground: "808080" },
    { token: "type", foreground: "008080" },
    { token: "delimiter", foreground: "000000" },
    { token: "delimiter.html", foreground: "383838" },
    { token: "delimiter.xml", foreground: "0000FF" },
    { token: "tag", foreground: "800000" },
    { token: "tag.id.pug", foreground: "4F76AC" },
    { token: "tag.class.pug", foreground: "4F76AC" },
    { token: "meta.scss", foreground: "800000" },
    { token: "metatag", foreground: "e00000" },
    { token: "metatag.content.html", foreground: "FF0000" },
    { token: "metatag.html", foreground: "808080" },
    { token: "metatag.xml", foreground: "808080" },
    { token: "metatag.php", fontStyle: "bold" },
    { token: "key", foreground: "863B00" },
    { token: "string.key.json", foreground: "A31515" },
    { token: "string.value.json", foreground: "0451A5" },
    { token: "attribute.name", foreground: "FF0000" },
    { token: "attribute.value", foreground: "0451A5" },
    { token: "attribute.value.number", foreground: "098658" },
    { token: "attribute.value.unit", foreground: "098658" },
    { token: "attribute.value.html", foreground: "0000FF" },
    { token: "attribute.value.xml", foreground: "0000FF" },
    { token: "string", foreground: "A31515" },
    { token: "string.html", foreground: "0000FF" },
    { token: "string.sql", foreground: "FF0000" },
    { token: "string.yaml", foreground: "0451A5" },
    { token: "keyword", foreground: "0000FF" },
    { token: "keyword.json", foreground: "0451A5" },
    { token: "keyword.flow", foreground: "AF00DB" },
    { token: "keyword.flow.scss", foreground: "0000FF" },
    { token: "operator.scss", foreground: "666666" },
    { token: "operator.sql", foreground: "778899" },
    { token: "operator.swift", foreground: "666666" },
    { token: "predefined.sql", foreground: "C700C7" }
  ],
  colors: {
    [ro]: "#FFFFFE",
    [Mg]: "#000000",
    [TR]: "#E5EBF1",
    [zg]: "#D3D3D3",
    [Ug]: "#939393",
    [MR]: "#ADD6FF4D"
  }
}, jq = {
  base: "vs-dark",
  inherit: !1,
  rules: [
    { token: "", foreground: "D4D4D4", background: "1E1E1E" },
    { token: "invalid", foreground: "f44747" },
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "variable", foreground: "74B0DF" },
    { token: "variable.predefined", foreground: "4864AA" },
    { token: "variable.parameter", foreground: "9CDCFE" },
    { token: "constant", foreground: "569CD6" },
    { token: "comment", foreground: "608B4E" },
    { token: "number", foreground: "B5CEA8" },
    { token: "number.hex", foreground: "5BB498" },
    { token: "regexp", foreground: "B46695" },
    { token: "annotation", foreground: "cc6666" },
    { token: "type", foreground: "3DC9B0" },
    { token: "delimiter", foreground: "DCDCDC" },
    { token: "delimiter.html", foreground: "808080" },
    { token: "delimiter.xml", foreground: "808080" },
    { token: "tag", foreground: "569CD6" },
    { token: "tag.id.pug", foreground: "4F76AC" },
    { token: "tag.class.pug", foreground: "4F76AC" },
    { token: "meta.scss", foreground: "A79873" },
    { token: "meta.tag", foreground: "CE9178" },
    { token: "metatag", foreground: "DD6A6F" },
    { token: "metatag.content.html", foreground: "9CDCFE" },
    { token: "metatag.html", foreground: "569CD6" },
    { token: "metatag.xml", foreground: "569CD6" },
    { token: "metatag.php", fontStyle: "bold" },
    { token: "key", foreground: "9CDCFE" },
    { token: "string.key.json", foreground: "9CDCFE" },
    { token: "string.value.json", foreground: "CE9178" },
    { token: "attribute.name", foreground: "9CDCFE" },
    { token: "attribute.value", foreground: "CE9178" },
    { token: "attribute.value.number.css", foreground: "B5CEA8" },
    { token: "attribute.value.unit.css", foreground: "B5CEA8" },
    { token: "attribute.value.hex.css", foreground: "D4D4D4" },
    { token: "string", foreground: "CE9178" },
    { token: "string.sql", foreground: "FF0000" },
    { token: "keyword", foreground: "569CD6" },
    { token: "keyword.flow", foreground: "C586C0" },
    { token: "keyword.json", foreground: "CE9178" },
    { token: "keyword.flow.scss", foreground: "569CD6" },
    { token: "operator.scss", foreground: "909090" },
    { token: "operator.sql", foreground: "778899" },
    { token: "operator.swift", foreground: "909090" },
    { token: "predefined.sql", foreground: "FF00FF" }
  ],
  colors: {
    [ro]: "#1E1E1E",
    [Mg]: "#D4D4D4",
    [TR]: "#3A3D41",
    [zg]: "#404040",
    [Ug]: "#707070",
    [MR]: "#ADD6FF26"
  }
}, Gq = {
  base: "hc-black",
  inherit: !1,
  rules: [
    { token: "", foreground: "FFFFFF", background: "000000" },
    { token: "invalid", foreground: "f44747" },
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "variable", foreground: "1AEBFF" },
    { token: "variable.parameter", foreground: "9CDCFE" },
    { token: "constant", foreground: "569CD6" },
    { token: "comment", foreground: "608B4E" },
    { token: "number", foreground: "FFFFFF" },
    { token: "regexp", foreground: "C0C0C0" },
    { token: "annotation", foreground: "569CD6" },
    { token: "type", foreground: "3DC9B0" },
    { token: "delimiter", foreground: "FFFF00" },
    { token: "delimiter.html", foreground: "FFFF00" },
    { token: "tag", foreground: "569CD6" },
    { token: "tag.id.pug", foreground: "4F76AC" },
    { token: "tag.class.pug", foreground: "4F76AC" },
    { token: "meta", foreground: "D4D4D4" },
    { token: "meta.tag", foreground: "CE9178" },
    { token: "metatag", foreground: "569CD6" },
    { token: "metatag.content.html", foreground: "1AEBFF" },
    { token: "metatag.html", foreground: "569CD6" },
    { token: "metatag.xml", foreground: "569CD6" },
    { token: "metatag.php", fontStyle: "bold" },
    { token: "key", foreground: "9CDCFE" },
    { token: "string.key", foreground: "9CDCFE" },
    { token: "string.value", foreground: "CE9178" },
    { token: "attribute.name", foreground: "569CD6" },
    { token: "attribute.value", foreground: "3FF23F" },
    { token: "string", foreground: "CE9178" },
    { token: "string.sql", foreground: "FF0000" },
    { token: "keyword", foreground: "569CD6" },
    { token: "keyword.flow", foreground: "C586C0" },
    { token: "operator.sql", foreground: "778899" },
    { token: "operator.swift", foreground: "909090" },
    { token: "predefined.sql", foreground: "FF00FF" }
  ],
  colors: {
    [ro]: "#000000",
    [Mg]: "#FFFFFF",
    [zg]: "#FFFFFF",
    [Ug]: "#FFFFFF"
  }
}, Zq = {
  base: "hc-light",
  inherit: !1,
  rules: [
    { token: "", foreground: "292929", background: "FFFFFF" },
    { token: "invalid", foreground: "B5200D" },
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "variable", foreground: "264F70" },
    { token: "variable.predefined", foreground: "4864AA" },
    { token: "constant", foreground: "dd0000" },
    { token: "comment", foreground: "008000" },
    { token: "number", foreground: "098658" },
    { token: "number.hex", foreground: "3030c0" },
    { token: "regexp", foreground: "800000" },
    { token: "annotation", foreground: "808080" },
    { token: "type", foreground: "008080" },
    { token: "delimiter", foreground: "000000" },
    { token: "delimiter.html", foreground: "383838" },
    { token: "tag", foreground: "800000" },
    { token: "tag.id.pug", foreground: "4F76AC" },
    { token: "tag.class.pug", foreground: "4F76AC" },
    { token: "meta.scss", foreground: "800000" },
    { token: "metatag", foreground: "e00000" },
    { token: "metatag.content.html", foreground: "B5200D" },
    { token: "metatag.html", foreground: "808080" },
    { token: "metatag.xml", foreground: "808080" },
    { token: "metatag.php", fontStyle: "bold" },
    { token: "key", foreground: "863B00" },
    { token: "string.key.json", foreground: "A31515" },
    { token: "string.value.json", foreground: "0451A5" },
    { token: "attribute.name", foreground: "264F78" },
    { token: "attribute.value", foreground: "0451A5" },
    { token: "string", foreground: "A31515" },
    { token: "string.sql", foreground: "B5200D" },
    { token: "keyword", foreground: "0000FF" },
    { token: "keyword.flow", foreground: "AF00DB" },
    { token: "operator.sql", foreground: "778899" },
    { token: "operator.swift", foreground: "666666" },
    { token: "predefined.sql", foreground: "C700C7" }
  ],
  colors: {
    [ro]: "#FFFFFF",
    [Mg]: "#292929",
    [zg]: "#292929",
    [Ug]: "#292929"
  }
}, Yq = {
  IconContribution: "base.contributions.icons"
};
var UN;
(function(s) {
  function e(t, i) {
    let n = t.defaults;
    for (; Ke.isThemeIcon(n); ) {
      const o = Vc.getIcon(n.id);
      if (!o)
        return;
      n = o.defaults;
    }
    return n;
  }
  s.getDefinition = e;
})(UN || (UN = {}));
var $N;
(function(s) {
  function e(i) {
    return {
      weight: i.weight,
      style: i.style,
      src: i.src.map((n) => ({ format: n.format, location: n.location.toString() }))
    };
  }
  s.toJSONObject = e;
  function t(i) {
    const n = (o) => Jn(o) ? o : void 0;
    if (i && Array.isArray(i.src) && i.src.every((o) => Jn(o.format) && Jn(o.location)))
      return {
        weight: n(i.weight),
        style: n(i.style),
        src: i.src.map((o) => ({ format: o.format, location: Te.parse(o.location) }))
      };
  }
  s.fromJSONObject = t;
})($N || ($N = {}));
class Qq {
  constructor() {
    this._onDidChange = new O(), this.onDidChange = this._onDidChange.event, this.iconSchema = {
      definitions: {
        icons: {
          type: "object",
          properties: {
            fontId: { type: "string", description: p("iconDefinition.fontId", "The id of the font to use. If not set, the font that is defined first is used.") },
            fontCharacter: { type: "string", description: p("iconDefinition.fontCharacter", "The font character associated with the icon definition.") }
          },
          additionalProperties: !1,
          defaultSnippets: [{ body: { fontCharacter: "\\\\e030" } }]
        }
      },
      type: "object",
      properties: {}
    }, this.iconReferenceSchema = { type: "string", pattern: `^${Ke.iconNameExpression}$`, enum: [], enumDescriptions: [] }, this.iconsById = {}, this.iconFontsById = {};
  }
  registerIcon(e, t, i, n) {
    const o = this.iconsById[e];
    if (o) {
      if (i && !o.description) {
        o.description = i, this.iconSchema.properties[e].markdownDescription = `${i} $(${e})`;
        const l = this.iconReferenceSchema.enum.indexOf(e);
        l !== -1 && (this.iconReferenceSchema.enumDescriptions[l] = i), this._onDidChange.fire();
      }
      return o;
    }
    const r = { id: e, description: i, defaults: t, deprecationMessage: n };
    this.iconsById[e] = r;
    const a = { $ref: "#/definitions/icons" };
    return n && (a.deprecationMessage = n), i && (a.markdownDescription = `${i}: $(${e})`), this.iconSchema.properties[e] = a, this.iconReferenceSchema.enum.push(e), this.iconReferenceSchema.enumDescriptions.push(i || ""), this._onDidChange.fire(), { id: e };
  }
  getIcons() {
    return Object.keys(this.iconsById).map((e) => this.iconsById[e]);
  }
  getIcon(e) {
    return this.iconsById[e];
  }
  getIconSchema() {
    return this.iconSchema;
  }
  toString() {
    const e = (o, r) => o.id.localeCompare(r.id), t = (o) => {
      for (; Ke.isThemeIcon(o.defaults); )
        o = this.iconsById[o.defaults.id];
      return `codicon codicon-${o ? o.id : ""}`;
    }, i = [];
    i.push("| preview     | identifier                        | default codicon ID                | description"), i.push("| ----------- | --------------------------------- | --------------------------------- | --------------------------------- |");
    const n = Object.keys(this.iconsById).map((o) => this.iconsById[o]);
    for (const o of n.filter((r) => !!r.description).sort(e))
      i.push(`|<i class="${t(o)}"></i>|${o.id}|${Ke.isThemeIcon(o.defaults) ? o.defaults.id : o.id}|${o.description || ""}|`);
    i.push("| preview     | identifier                        "), i.push("| ----------- | --------------------------------- |");
    for (const o of n.filter((r) => !Ke.isThemeIcon(r.defaults)).sort(e))
      i.push(`|<i class="${t(o)}"></i>|${o.id}|`);
    return i.join(`
`);
  }
}
const Vc = new Qq();
Li.add(Yq.IconContribution, Vc);
function tl(s, e, t, i) {
  return Vc.registerIcon(s, e, t, i);
}
function A4() {
  return Vc;
}
function Xq() {
  const s = q2();
  for (const e in s) {
    const t = "\\" + s[e].toString(16);
    Vc.registerIcon(e, { fontCharacter: t });
  }
}
Xq();
const P4 = "vscode://schemas/icons", O4 = Li.as(wb.JSONContribution);
O4.registerSchema(P4, Vc.getIconSchema());
const KN = new sn(() => O4.notifySchemaChanged(P4), 200);
Vc.onDidChange(() => {
  KN.isScheduled() || KN.schedule();
});
tl("widget-close", re.close, p("widgetClose", "Icon for the close action in widgets."));
tl("goto-previous-location", re.arrowUp, p("previousChangeIcon", "Icon for goto previous editor location."));
tl("goto-next-location", re.arrowDown, p("nextChangeIcon", "Icon for goto next editor location."));
Ke.modify(re.sync, "spin");
Ke.modify(re.loading, "spin");
function Jq(s) {
  const e = new he(), t = e.add(new O()), i = A4();
  return e.add(i.onDidChange(() => t.fire())), s && e.add(s.onDidProductIconThemeChange(() => t.fire())), {
    dispose: () => e.dispose(),
    onDidChange: t.event,
    getCSS() {
      const n = s ? s.getProductIconTheme() : new F4(), o = {}, r = [], a = [];
      for (const l of i.getIcons()) {
        const c = n.getIcon(l);
        if (!c)
          continue;
        const h = c.font, d = `--vscode-icon-${l.id}-font-family`, u = `--vscode-icon-${l.id}-content`;
        h ? (o[h.id] = h.definition, a.push(`${d}: ${v0(h.id)};`, `${u}: '${c.fontCharacter}';`), r.push(`.codicon-${l.id}:before { content: '${c.fontCharacter}'; font-family: ${v0(h.id)}; }`)) : (a.push(`${u}: '${c.fontCharacter}'; ${d}: 'codicon';`), r.push(`.codicon-${l.id}:before { content: '${c.fontCharacter}'; }`));
      }
      for (const l in o) {
        const c = o[l], h = c.weight ? `font-weight: ${c.weight};` : "", d = c.style ? `font-style: ${c.style};` : "", u = c.src.map((f) => `${Qr(f.location)} format('${f.format}')`).join(", ");
        r.push(`@font-face { src: ${u}; font-family: ${v0(l)};${h}${d} font-display: block; }`);
      }
      return r.push(`:root { ${a.join(" ")} }`), r.join(`
`);
    }
  };
}
class F4 {
  getIcon(e) {
    const t = A4();
    let i = e.defaults;
    for (; Ke.isThemeIcon(i); ) {
      const n = t.getIcon(i.id);
      if (!n)
        return;
      i = n.defaults;
    }
    return i;
  }
}
const va = "vs", tf = "vs-dark", sd = "hc-black", od = "hc-light", B4 = Li.as(LR.ColorContribution), ej = Li.as(aR.ThemingContribution);
class W4 {
  constructor(e, t) {
    this.semanticHighlighting = !1, this.themeData = t;
    const i = t.base;
    e.length > 0 ? (hp(e) ? this.id = e : this.id = i + " " + e, this.themeName = e) : (this.id = i, this.themeName = i), this.colors = null, this.defaultColors = /* @__PURE__ */ Object.create(null), this._tokenTheme = null;
  }
  get base() {
    return this.themeData.base;
  }
  notifyBaseUpdated() {
    this.themeData.inherit && (this.colors = null, this._tokenTheme = null);
  }
  getColors() {
    if (!this.colors) {
      const e = /* @__PURE__ */ new Map();
      for (const t in this.themeData.colors)
        e.set(t, Z.fromHex(this.themeData.colors[t]));
      if (this.themeData.inherit) {
        const t = Jy(this.themeData.base);
        for (const i in t.colors)
          e.has(i) || e.set(i, Z.fromHex(t.colors[i]));
      }
      this.colors = e;
    }
    return this.colors;
  }
  getColor(e, t) {
    const i = this.getColors().get(e);
    if (i)
      return i;
    if (t !== !1)
      return this.getDefault(e);
  }
  getDefault(e) {
    let t = this.defaultColors[e];
    return t || (t = B4.resolveDefaultColor(e, this), this.defaultColors[e] = t, t);
  }
  defines(e) {
    return this.getColors().has(e);
  }
  get type() {
    switch (this.base) {
      case va:
        return ms.LIGHT;
      case sd:
        return ms.HIGH_CONTRAST_DARK;
      case od:
        return ms.HIGH_CONTRAST_LIGHT;
      default:
        return ms.DARK;
    }
  }
  get tokenTheme() {
    if (!this._tokenTheme) {
      let e = [], t = [];
      if (this.themeData.inherit) {
        const o = Jy(this.themeData.base);
        e = o.rules, o.encodedTokensColors && (t = o.encodedTokensColors);
      }
      const i = this.themeData.colors["editor.foreground"], n = this.themeData.colors["editor.background"];
      if (i || n) {
        const o = { token: "" };
        i && (o.foreground = i), n && (o.background = n), e.push(o);
      }
      e = e.concat(this.themeData.rules), this.themeData.encodedTokensColors && (t = this.themeData.encodedTokensColors), this._tokenTheme = R4.createFromRawTokenTheme(e, t);
    }
    return this._tokenTheme;
  }
  getTokenStyleMetadata(e, t, i) {
    const o = this.tokenTheme._match([e].concat(t).join(".")).metadata, r = Xs.getForeground(o), a = Xs.getFontStyle(o);
    return {
      foreground: r,
      italic: !!(a & 1),
      bold: !!(a & 2),
      underline: !!(a & 4),
      strikethrough: !!(a & 8)
    };
  }
}
function hp(s) {
  return s === va || s === tf || s === sd || s === od;
}
function Jy(s) {
  switch (s) {
    case va:
      return qq;
    case tf:
      return jq;
    case sd:
      return Gq;
    case od:
      return Zq;
  }
}
function Mm(s) {
  const e = Jy(s);
  return new W4(s, e);
}
class tj extends q {
  constructor() {
    super(), this._onColorThemeChange = this._register(new O()), this.onDidColorThemeChange = this._onColorThemeChange.event, this._onProductIconThemeChange = this._register(new O()), this.onDidProductIconThemeChange = this._onProductIconThemeChange.event, this._environment = /* @__PURE__ */ Object.create(null), this._builtInProductIconTheme = new F4(), this._autoDetectHighContrast = !0, this._knownThemes = /* @__PURE__ */ new Map(), this._knownThemes.set(va, Mm(va)), this._knownThemes.set(tf, Mm(tf)), this._knownThemes.set(sd, Mm(sd)), this._knownThemes.set(od, Mm(od));
    const e = this._register(Jq(this));
    this._codiconCSS = e.getCSS(), this._themeCSS = "", this._allCSS = `${this._codiconCSS}
${this._themeCSS}`, this._globalStyleElement = null, this._styleElements = [], this._colorMapOverride = null, this.setTheme(va), this._onOSSchemeChanged(), this._register(e.onDidChange(() => {
      this._codiconCSS = e.getCSS(), this._updateCSS();
    })), tM(ut, "(forced-colors: active)", () => {
      this._onOSSchemeChanged();
    });
  }
  registerEditorContainer(e) {
    return Qw(e) ? this._registerShadowDomContainer(e) : this._registerRegularEditorContainer();
  }
  _registerRegularEditorContainer() {
    return this._globalStyleElement || (this._globalStyleElement = Os(void 0, (e) => {
      e.className = "monaco-colors", e.textContent = this._allCSS;
    }), this._styleElements.push(this._globalStyleElement)), q.None;
  }
  _registerShadowDomContainer(e) {
    const t = Os(e, (i) => {
      i.className = "monaco-colors", i.textContent = this._allCSS;
    });
    return this._styleElements.push(t), {
      dispose: () => {
        for (let i = 0; i < this._styleElements.length; i++)
          if (this._styleElements[i] === t) {
            this._styleElements.splice(i, 1);
            return;
          }
      }
    };
  }
  defineTheme(e, t) {
    if (!/^[a-z0-9\-]+$/i.test(e))
      throw new Error("Illegal theme name!");
    if (!hp(t.base) && !hp(e))
      throw new Error("Illegal theme base!");
    this._knownThemes.set(e, new W4(e, t)), hp(e) && this._knownThemes.forEach((i) => {
      i.base === e && i.notifyBaseUpdated();
    }), this._theme.themeName === e && this.setTheme(e);
  }
  getColorTheme() {
    return this._theme;
  }
  setColorMapOverride(e) {
    this._colorMapOverride = e, this._updateThemeOrColorMap();
  }
  setTheme(e) {
    let t;
    this._knownThemes.has(e) ? t = this._knownThemes.get(e) : t = this._knownThemes.get(va), this._updateActualTheme(t);
  }
  _updateActualTheme(e) {
    !e || this._theme === e || (this._theme = e, this._updateThemeOrColorMap());
  }
  _onOSSchemeChanged() {
    if (this._autoDetectHighContrast) {
      const e = ut.matchMedia("(forced-colors: active)").matches;
      if (e !== Gh(this._theme.type)) {
        let t;
        vb(this._theme.type) ? t = e ? sd : tf : t = e ? od : va, this._updateActualTheme(this._knownThemes.get(t));
      }
    }
  }
  setAutoDetectHighContrast(e) {
    this._autoDetectHighContrast = e, this._onOSSchemeChanged();
  }
  _updateThemeOrColorMap() {
    const e = [], t = {}, i = {
      addRule: (r) => {
        t[r] || (e.push(r), t[r] = !0);
      }
    };
    ej.getThemingParticipants().forEach((r) => r(this._theme, i, this._environment));
    const n = [];
    for (const r of B4.getColors()) {
      const a = this._theme.getColor(r.id, !0);
      a && n.push(`${rk(r.id)}: ${a.toString()};`);
    }
    i.addRule(`.monaco-editor, .monaco-diff-editor, .monaco-component { ${n.join(`
`)} }`);
    const o = this._colorMapOverride || this._theme.tokenTheme.getColorMap();
    i.addRule(Kq(o)), this._themeCSS = e.join(`
`), this._updateCSS(), Yt.setColorMap(o), this._onColorThemeChange.fire(this._theme);
  }
  _updateCSS() {
    this._allCSS = `${this._codiconCSS}
${this._themeCSS}`, this._styleElements.forEach((e) => e.textContent = this._allCSS);
  }
  getFileIconTheme() {
    return {
      hasFileIcons: !1,
      hasFolderIcons: !1,
      hidesExplorerArrows: !1
    };
  }
  getProductIconTheme() {
    return this._builtInProductIconTheme;
  }
}
const Vs = Ve("themeService");
var ij = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, dC = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let eS = class extends q {
  constructor(e, t, i) {
    super(), this._contextKeyService = e, this._layoutService = t, this._configurationService = i, this._accessibilitySupport = 0, this._onDidChangeScreenReaderOptimized = new O(), this._onDidChangeReducedMotion = new O(), this._onDidChangeLinkUnderline = new O(), this._accessibilityModeEnabledContext = lV.bindTo(this._contextKeyService);
    const n = () => this._accessibilityModeEnabledContext.set(this.isScreenReaderOptimized());
    this._register(this._configurationService.onDidChangeConfiguration((r) => {
      r.affectsConfiguration("editor.accessibilitySupport") && (n(), this._onDidChangeScreenReaderOptimized.fire()), r.affectsConfiguration("workbench.reduceMotion") && (this._configMotionReduced = this._configurationService.getValue("workbench.reduceMotion"), this._onDidChangeReducedMotion.fire());
    })), n(), this._register(this.onDidChangeScreenReaderOptimized(() => n()));
    const o = ut.matchMedia("(prefers-reduced-motion: reduce)");
    this._systemMotionReduced = o.matches, this._configMotionReduced = this._configurationService.getValue("workbench.reduceMotion"), this._linkUnderlinesEnabled = this._configurationService.getValue("accessibility.underlineLinks"), this.initReducedMotionListeners(o), this.initLinkUnderlineListeners();
  }
  initReducedMotionListeners(e) {
    this._register($(e, "change", () => {
      this._systemMotionReduced = e.matches, this._configMotionReduced === "auto" && this._onDidChangeReducedMotion.fire();
    }));
    const t = () => {
      const i = this.isMotionReduced();
      this._layoutService.mainContainer.classList.toggle("reduce-motion", i), this._layoutService.mainContainer.classList.toggle("enable-motion", !i);
    };
    t(), this._register(this.onDidChangeReducedMotion(() => t()));
  }
  initLinkUnderlineListeners() {
    this._register(this._configurationService.onDidChangeConfiguration((t) => {
      if (t.affectsConfiguration("accessibility.underlineLinks")) {
        const i = this._configurationService.getValue("accessibility.underlineLinks");
        this._linkUnderlinesEnabled = i, this._onDidChangeLinkUnderline.fire();
      }
    }));
    const e = () => {
      const t = this._linkUnderlinesEnabled;
      this._layoutService.mainContainer.classList.toggle("underline-links", t);
    };
    e(), this._register(this.onDidChangeLinkUnderlines(() => e()));
  }
  onDidChangeLinkUnderlines(e) {
    return this._onDidChangeLinkUnderline.event(e);
  }
  get onDidChangeScreenReaderOptimized() {
    return this._onDidChangeScreenReaderOptimized.event;
  }
  isScreenReaderOptimized() {
    const e = this._configurationService.getValue("editor.accessibilitySupport");
    return e === "on" || e === "auto" && this._accessibilitySupport === 2;
  }
  get onDidChangeReducedMotion() {
    return this._onDidChangeReducedMotion.event;
  }
  isMotionReduced() {
    const e = this._configMotionReduced;
    return e === "on" || e === "auto" && this._systemMotionReduced;
  }
  getAccessibilitySupport() {
    return this._accessibilitySupport;
  }
};
eS = ij([
  dC(0, nt),
  dC(1, Xa),
  dC(2, Vt)
], eS);
var Gb = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Ho = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, ah, Ru;
let tS = class {
  constructor(e, t, i) {
    this._commandService = e, this._keybindingService = t, this._hiddenStates = new iS(i);
  }
  createMenu(e, t, i) {
    return new x_(e, this._hiddenStates, { emitEventsForSubmenuChanges: !1, eventDebounceDelay: 50, ...i }, this._commandService, this._keybindingService, t);
  }
  getMenuActions(e, t, i) {
    const n = new x_(e, this._hiddenStates, { emitEventsForSubmenuChanges: !1, eventDebounceDelay: 50, ...i }, this._commandService, this._keybindingService, t), o = n.getActions(i);
    return n.dispose(), o;
  }
  resetHiddenStates(e) {
    this._hiddenStates.reset(e);
  }
};
tS = Gb([
  Ho(0, ss),
  Ho(1, Ai),
  Ho(2, Fb)
], tS);
var ac;
let iS = (ac = class {
  constructor(e) {
    this._storageService = e, this._disposables = new he(), this._onDidChange = new O(), this.onDidChange = this._onDidChange.event, this._ignoreChangeEvent = !1, this._hiddenByDefaultCache = /* @__PURE__ */ new Map();
    try {
      const t = e.get(ah._key, 0, "{}");
      this._data = JSON.parse(t);
    } catch {
      this._data = /* @__PURE__ */ Object.create(null);
    }
    this._disposables.add(e.onDidChangeValue(0, ah._key, this._disposables)(() => {
      if (!this._ignoreChangeEvent)
        try {
          const t = e.get(ah._key, 0, "{}");
          this._data = JSON.parse(t);
        } catch (t) {
          console.log("FAILED to read storage after UPDATE", t);
        }
      this._onDidChange.fire();
    }));
  }
  dispose() {
    this._onDidChange.dispose(), this._disposables.dispose();
  }
  _isHiddenByDefault(e, t) {
    return this._hiddenByDefaultCache.get(`${e.id}/${t}`) ?? !1;
  }
  setDefaultState(e, t, i) {
    this._hiddenByDefaultCache.set(`${e.id}/${t}`, i);
  }
  isHidden(e, t) {
    var o;
    const i = this._isHiddenByDefault(e, t), n = ((o = this._data[e.id]) == null ? void 0 : o.includes(t)) ?? !1;
    return i ? !n : n;
  }
  updateHidden(e, t, i) {
    this._isHiddenByDefault(e, t) && (i = !i);
    const o = this._data[e.id];
    if (i)
      o ? o.indexOf(t) < 0 && o.push(t) : this._data[e.id] = [t];
    else if (o) {
      const r = o.indexOf(t);
      r >= 0 && A5(o, r), o.length === 0 && delete this._data[e.id];
    }
    this._persist();
  }
  reset(e) {
    if (e === void 0)
      this._data = /* @__PURE__ */ Object.create(null), this._persist();
    else {
      for (const { id: t } of e)
        this._data[t] && delete this._data[t];
      this._persist();
    }
  }
  _persist() {
    try {
      this._ignoreChangeEvent = !0;
      const e = JSON.stringify(this._data);
      this._storageService.store(
        ah._key,
        e,
        0,
        0
        /* StorageTarget.USER */
      );
    } finally {
      this._ignoreChangeEvent = !1;
    }
  }
}, ah = ac, ac._key = "menu.hiddenCommands", ac);
iS = ah = Gb([
  Ho(0, Fb)
], iS);
class nf {
  constructor(e, t) {
    this._id = e, this._collectContextKeysForSubmenus = t, this._menuGroups = [], this._allMenuIds = /* @__PURE__ */ new Set(), this._structureContextKeys = /* @__PURE__ */ new Set(), this._preconditionContextKeys = /* @__PURE__ */ new Set(), this._toggledContextKeys = /* @__PURE__ */ new Set(), this.refresh();
  }
  get allMenuIds() {
    return this._allMenuIds;
  }
  get structureContextKeys() {
    return this._structureContextKeys;
  }
  get preconditionContextKeys() {
    return this._preconditionContextKeys;
  }
  get toggledContextKeys() {
    return this._toggledContextKeys;
  }
  refresh() {
    this._menuGroups.length = 0, this._allMenuIds.clear(), this._structureContextKeys.clear(), this._preconditionContextKeys.clear(), this._toggledContextKeys.clear();
    const e = this._sort(Cd.getMenuItems(this._id));
    let t;
    for (const i of e) {
      const n = i.group || "";
      (!t || t[0] !== n) && (t = [n, []], this._menuGroups.push(t)), t[1].push(i), this._collectContextKeysAndSubmenuIds(i);
    }
    this._allMenuIds.add(this._id);
  }
  _sort(e) {
    return e;
  }
  _collectContextKeysAndSubmenuIds(e) {
    if (nf._fillInKbExprKeys(e.when, this._structureContextKeys), Hu(e)) {
      if (e.command.precondition && nf._fillInKbExprKeys(e.command.precondition, this._preconditionContextKeys), e.command.toggled) {
        const t = e.command.toggled.condition || e.command.toggled;
        nf._fillInKbExprKeys(t, this._toggledContextKeys);
      }
    } else this._collectContextKeysForSubmenus && (Cd.getMenuItems(e.submenu).forEach(this._collectContextKeysAndSubmenuIds, this), this._allMenuIds.add(e.submenu));
  }
  static _fillInKbExprKeys(e, t) {
    if (e)
      for (const i of e.keys())
        t.add(i);
  }
}
let nS = Ru = class extends nf {
  constructor(e, t, i, n, o, r) {
    super(e, i), this._hiddenStates = t, this._commandService = n, this._keybindingService = o, this._contextKeyService = r, this.refresh();
  }
  createActionGroups(e) {
    const t = [];
    for (const i of this._menuGroups) {
      const [n, o] = i;
      let r;
      for (const a of o)
        if (this._contextKeyService.contextMatchesRules(a.when)) {
          const l = Hu(a);
          l && this._hiddenStates.setDefaultState(this._id, a.command.id, !!a.isHiddenByDefault);
          const c = nj(this._id, l ? a.command : a, this._hiddenStates);
          if (l) {
            const h = V4(this._commandService, this._keybindingService, a.command.id, a.when);
            (r ?? (r = [])).push(new Ur(a.command, a.alt, e, c, h, this._contextKeyService, this._commandService));
          } else {
            const h = new Ru(a.submenu, this._hiddenStates, this._collectContextKeysForSubmenus, this._commandService, this._keybindingService, this._contextKeyService).createActionGroups(e), d = Zi.join(...h.map((u) => u[1]));
            d.length > 0 && (r ?? (r = [])).push(new zu(a, c, d));
          }
        }
      r && r.length > 0 && t.push([n, r]);
    }
    return t;
  }
  _sort(e) {
    return e.sort(Ru._compareMenuItems);
  }
  static _compareMenuItems(e, t) {
    const i = e.group, n = t.group;
    if (i !== n) {
      if (i) {
        if (!n)
          return -1;
      } else return 1;
      if (i === "navigation")
        return -1;
      if (n === "navigation")
        return 1;
      const a = i.localeCompare(n);
      if (a !== 0)
        return a;
    }
    const o = e.order || 0, r = t.order || 0;
    return o < r ? -1 : o > r ? 1 : Ru._compareTitles(Hu(e) ? e.command.title : e.title, Hu(t) ? t.command.title : t.title);
  }
  static _compareTitles(e, t) {
    const i = typeof e == "string" ? e : e.original, n = typeof t == "string" ? t : t.original;
    return i.localeCompare(n);
  }
};
nS = Ru = Gb([
  Ho(3, ss),
  Ho(4, Ai),
  Ho(5, nt)
], nS);
let x_ = class {
  constructor(e, t, i, n, o, r) {
    this._disposables = new he(), this._menuInfo = new nS(e, t, i.emitEventsForSubmenuChanges, n, o, r);
    const a = new sn(() => {
      this._menuInfo.refresh(), this._onDidChange.fire({ menu: this, isStructuralChange: !0, isEnablementChange: !0, isToggleChange: !0 });
    }, i.eventDebounceDelay);
    this._disposables.add(a), this._disposables.add(Cd.onDidChangeMenu((d) => {
      for (const u of this._menuInfo.allMenuIds)
        if (d.has(u)) {
          a.schedule();
          break;
        }
    }));
    const l = this._disposables.add(new he()), c = (d) => {
      let u = !1, f = !1, g = !1;
      for (const m of d)
        if (u = u || m.isStructuralChange, f = f || m.isEnablementChange, g = g || m.isToggleChange, u && f && g)
          break;
      return { menu: this, isStructuralChange: u, isEnablementChange: f, isToggleChange: g };
    }, h = () => {
      l.add(r.onDidChangeContext((d) => {
        const u = d.affectsSome(this._menuInfo.structureContextKeys), f = d.affectsSome(this._menuInfo.preconditionContextKeys), g = d.affectsSome(this._menuInfo.toggledContextKeys);
        (u || f || g) && this._onDidChange.fire({ menu: this, isStructuralChange: u, isEnablementChange: f, isToggleChange: g });
      })), l.add(t.onDidChange((d) => {
        this._onDidChange.fire({ menu: this, isStructuralChange: !0, isEnablementChange: !1, isToggleChange: !1 });
      }));
    };
    this._onDidChange = new O2({
      // start/stop context key listener
      onWillAddFirstListener: h,
      onDidRemoveLastListener: l.clear.bind(l),
      delay: i.eventDebounceDelay,
      merge: c
    }), this.onDidChange = this._onDidChange.event;
  }
  getActions(e) {
    return this._menuInfo.createActionGroups(e);
  }
  dispose() {
    this._disposables.dispose(), this._onDidChange.dispose();
  }
};
x_ = Gb([
  Ho(3, ss),
  Ho(4, Ai),
  Ho(5, nt)
], x_);
function nj(s, e, t) {
  const i = K7(e) ? e.submenu.id : e.id, n = typeof e.title == "string" ? e.title : e.title.value, o = $h({
    id: `hide/${s.id}/${i}`,
    label: p("hide.label", "Hide '{0}'", n),
    run() {
      t.updateHidden(s, i, !0);
    }
  }), r = $h({
    id: `toggle/${s.id}/${i}`,
    label: n,
    get checked() {
      return !t.isHidden(s, i);
    },
    run() {
      t.updateHidden(s, i, !!this.checked);
    }
  });
  return {
    hide: o,
    toggle: r,
    get isHidden() {
      return !r.checked;
    }
  };
}
function V4(s, e, t, i = void 0, n = !0) {
  return $h({
    id: `configureKeybinding/${t}`,
    label: p("configure keybinding", "Configure Keybinding"),
    enabled: n,
    run() {
      const r = !!!e.lookupKeybinding(t) && i ? i.serialize() : void 0;
      s.executeCommand("workbench.action.openGlobalKeybindings", `@command:${t}` + (r ? ` +when:${r}` : ""));
    }
  });
}
var sj = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, qN = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, sS;
const jN = "application/vnd.code.resources";
var lc;
let oS = (lc = class extends q {
  constructor(e, t) {
    super(), this.layoutService = e, this.logService = t, this.mapTextToType = /* @__PURE__ */ new Map(), this.findText = "", this.resources = [], this.resourcesStateHash = void 0, (Ua || iM) && this.installWebKitWriteTextWorkaround(), this._register(J.runAndSubscribe(rb, ({ window: i, disposables: n }) => {
      n.add($(i.document, "copy", () => this.clearResourcesState()));
    }, { window: ut, disposables: this._store }));
  }
  // In Safari, it has the following note:
  //
  // "The request to write to the clipboard must be triggered during a user gesture.
  // A call to clipboard.write or clipboard.writeText outside the scope of a user
  // gesture(such as "click" or "touch" event handlers) will result in the immediate
  // rejection of the promise returned by the API call."
  // From: https://webkit.org/blog/10855/async-clipboard-api/
  //
  // Since extensions run in a web worker, and handle gestures in an asynchronous way,
  // they are not classified by Safari as "in response to a user gesture" and will reject.
  //
  // This function sets up some handlers to work around that behavior.
  installWebKitWriteTextWorkaround() {
    const e = () => {
      const t = new lM();
      this.webKitPendingClipboardWritePromise && !this.webKitPendingClipboardWritePromise.isSettled && this.webKitPendingClipboardWritePromise.cancel(), this.webKitPendingClipboardWritePromise = t, Lu().navigator.clipboard.write([new ClipboardItem({
        "text/plain": t.p
      })]).catch(async (i) => {
        (!(i instanceof Error) || i.name !== "NotAllowedError" || !t.isRejected) && this.logService.error(i);
      });
    };
    this._register(J.runAndSubscribe(this.layoutService.onDidAddContainer, ({ container: t, disposables: i }) => {
      i.add($(t, "click", e)), i.add($(t, "keydown", e));
    }, { container: this.layoutService.mainContainer, disposables: this._store }));
  }
  async writeText(e, t) {
    if (this.clearResourcesState(), t) {
      this.mapTextToType.set(t, e);
      return;
    }
    if (this.webKitPendingClipboardWritePromise)
      return this.webKitPendingClipboardWritePromise.complete(e);
    try {
      return await Lu().navigator.clipboard.writeText(e);
    } catch (i) {
      console.error(i);
    }
    this.fallbackWriteText(e);
  }
  fallbackWriteText(e) {
    const t = zL(), i = t.activeElement, n = t.body.appendChild(pe("textarea", { "aria-hidden": !0 }));
    n.style.height = "1px", n.style.width = "1px", n.style.position = "absolute", n.value = e, n.focus(), n.select(), t.execCommand("copy"), yi(i) && i.focus(), n.remove();
  }
  async readText(e) {
    if (e)
      return this.mapTextToType.get(e) || "";
    try {
      return await Lu().navigator.clipboard.readText();
    } catch (t) {
      console.error(t);
    }
    return "";
  }
  async readFindText() {
    return this.findText;
  }
  async writeFindText(e) {
    this.findText = e;
  }
  async readResources() {
    try {
      const t = await Lu().navigator.clipboard.read();
      for (const i of t)
        if (i.types.includes(`web ${jN}`)) {
          const n = await i.getType(`web ${jN}`);
          return JSON.parse(await n.text()).map((r) => Te.from(r));
        }
    } catch {
    }
    const e = await this.computeResourcesStateHash();
    return this.resourcesStateHash !== e && this.clearResourcesState(), this.resources;
  }
  async computeResourcesStateHash() {
    if (this.resources.length === 0)
      return;
    const e = await this.readText();
    return bM(e.substring(0, sS.MAX_RESOURCE_STATE_SOURCE_LENGTH));
  }
  clearInternalState() {
    this.clearResourcesState();
  }
  clearResourcesState() {
    this.resources = [], this.resourcesStateHash = void 0;
  }
}, sS = lc, lc.MAX_RESOURCE_STATE_SOURCE_LENGTH = 1e3, lc);
oS = sS = sj([
  qN(0, Xa),
  qN(1, uo)
], oS);
const fx = Ve("clipboardService");
var oj = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, rj = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const sf = "data-keybinding-context";
class gx {
  constructor(e, t) {
    this._id = e, this._parent = t, this._value = /* @__PURE__ */ Object.create(null), this._value._contextId = e;
  }
  get value() {
    return { ...this._value };
  }
  setValue(e, t) {
    return this._value[e] !== t ? (this._value[e] = t, !0) : !1;
  }
  removeValue(e) {
    return e in this._value ? (delete this._value[e], !0) : !1;
  }
  getValue(e) {
    const t = this._value[e];
    return typeof t > "u" && this._parent ? this._parent.getValue(e) : t;
  }
}
const R1 = class R1 extends gx {
  constructor() {
    super(-1, null);
  }
  setValue(e, t) {
    return !1;
  }
  removeValue(e) {
    return !1;
  }
  getValue(e) {
  }
};
R1.INSTANCE = new R1();
let Rd = R1;
const Sf = class Sf extends gx {
  constructor(e, t, i) {
    super(e, null), this._configurationService = t, this._values = qu.forConfigKeys(), this._listener = this._configurationService.onDidChangeConfiguration((n) => {
      if (n.source === 7) {
        const o = Array.from(this._values, ([r]) => r);
        this._values.clear(), i.fire(new ZN(o));
      } else {
        const o = [];
        for (const r of n.affectedKeys) {
          const a = `config.${r}`, l = this._values.findSuperstr(a);
          l !== void 0 && (o.push(...Ye.map(l, ([c]) => c)), this._values.deleteSuperstr(a)), this._values.has(a) && (o.push(a), this._values.delete(a));
        }
        i.fire(new ZN(o));
      }
    });
  }
  dispose() {
    this._listener.dispose();
  }
  getValue(e) {
    if (e.indexOf(Sf._keyPrefix) !== 0)
      return super.getValue(e);
    if (this._values.has(e))
      return this._values.get(e);
    const t = e.substr(Sf._keyPrefix.length), i = this._configurationService.getValue(t);
    let n;
    switch (typeof i) {
      case "number":
      case "boolean":
      case "string":
        n = i;
        break;
      default:
        Array.isArray(i) ? n = JSON.stringify(i) : n = i;
    }
    return this._values.set(e, n), n;
  }
  setValue(e, t) {
    return super.setValue(e, t);
  }
  removeValue(e) {
    return super.removeValue(e);
  }
};
Sf._keyPrefix = "config.";
let rS = Sf;
class aj {
  constructor(e, t, i) {
    this._service = e, this._key = t, this._defaultValue = i, this.reset();
  }
  set(e) {
    this._service.setContext(this._key, e);
  }
  reset() {
    typeof this._defaultValue > "u" ? this._service.removeContext(this._key) : this._service.setContext(this._key, this._defaultValue);
  }
  get() {
    return this._service.getContextKeyValue(this._key);
  }
}
class GN {
  constructor(e) {
    this.key = e;
  }
  affectsSome(e) {
    return e.has(this.key);
  }
  allKeysContainedIn(e) {
    return this.affectsSome(e);
  }
}
class ZN {
  constructor(e) {
    this.keys = e;
  }
  affectsSome(e) {
    for (const t of this.keys)
      if (e.has(t))
        return !0;
    return !1;
  }
  allKeysContainedIn(e) {
    return this.keys.every((t) => e.has(t));
  }
}
class lj {
  constructor(e) {
    this.events = e;
  }
  affectsSome(e) {
    for (const t of this.events)
      if (t.affectsSome(e))
        return !0;
    return !1;
  }
  allKeysContainedIn(e) {
    return this.events.every((t) => t.allKeysContainedIn(e));
  }
}
function cj(s, e) {
  return s.allKeysContainedIn(new Set(Object.keys(e)));
}
class H4 extends q {
  constructor(e) {
    super(), this._onDidChangeContext = this._register(new Mf({ merge: (t) => new lj(t) })), this.onDidChangeContext = this._onDidChangeContext.event, this._isDisposed = !1, this._myContextId = e;
  }
  createKey(e, t) {
    if (this._isDisposed)
      throw new Error("AbstractContextKeyService has been disposed");
    return new aj(this, e, t);
  }
  bufferChangeEvents(e) {
    this._onDidChangeContext.pause();
    try {
      e();
    } finally {
      this._onDidChangeContext.resume();
    }
  }
  createScoped(e) {
    if (this._isDisposed)
      throw new Error("AbstractContextKeyService has been disposed");
    return new hj(this, e);
  }
  contextMatchesRules(e) {
    if (this._isDisposed)
      throw new Error("AbstractContextKeyService has been disposed");
    const t = this.getContextValuesContainer(this._myContextId);
    return e ? e.evaluate(t) : !0;
  }
  getContextKeyValue(e) {
    if (!this._isDisposed)
      return this.getContextValuesContainer(this._myContextId).getValue(e);
  }
  setContext(e, t) {
    if (this._isDisposed)
      return;
    const i = this.getContextValuesContainer(this._myContextId);
    i && i.setValue(e, t) && this._onDidChangeContext.fire(new GN(e));
  }
  removeContext(e) {
    this._isDisposed || this.getContextValuesContainer(this._myContextId).removeValue(e) && this._onDidChangeContext.fire(new GN(e));
  }
  getContext(e) {
    return this._isDisposed ? Rd.INSTANCE : this.getContextValuesContainer(dj(e));
  }
  dispose() {
    super.dispose(), this._isDisposed = !0;
  }
}
let aS = class extends H4 {
  constructor(e) {
    super(0), this._contexts = /* @__PURE__ */ new Map(), this._lastContextId = 0;
    const t = this._register(new rS(this._myContextId, e, this._onDidChangeContext));
    this._contexts.set(this._myContextId, t);
  }
  getContextValuesContainer(e) {
    return this._isDisposed ? Rd.INSTANCE : this._contexts.get(e) || Rd.INSTANCE;
  }
  createChildContext(e = this._myContextId) {
    if (this._isDisposed)
      throw new Error("ContextKeyService has been disposed");
    const t = ++this._lastContextId;
    return this._contexts.set(t, new gx(t, this.getContextValuesContainer(e))), t;
  }
  disposeContext(e) {
    this._isDisposed || this._contexts.delete(e);
  }
};
aS = oj([
  rj(0, Vt)
], aS);
class hj extends H4 {
  constructor(e, t) {
    if (super(e.createChildContext()), this._parentChangeListener = this._register(new Zr()), this._parent = e, this._updateParentChangeListener(), this._domNode = t, this._domNode.hasAttribute(sf)) {
      let i = "";
      this._domNode.classList && (i = Array.from(this._domNode.classList.values()).join(", ")), console.error(`Element already has context attribute${i ? ": " + i : ""}`);
    }
    this._domNode.setAttribute(sf, String(this._myContextId));
  }
  _updateParentChangeListener() {
    this._parentChangeListener.value = this._parent.onDidChangeContext((e) => {
      const i = this._parent.getContextValuesContainer(this._myContextId).value;
      cj(e, i) || this._onDidChangeContext.fire(e);
    });
  }
  dispose() {
    this._isDisposed || (this._parent.disposeContext(this._myContextId), this._domNode.removeAttribute(sf), super.dispose());
  }
  getContextValuesContainer(e) {
    return this._isDisposed ? Rd.INSTANCE : this._parent.getContextValuesContainer(e);
  }
  createChildContext(e = this._myContextId) {
    if (this._isDisposed)
      throw new Error("ScopedContextKeyService has been disposed");
    return this._parent.createChildContext(e);
  }
  disposeContext(e) {
    this._isDisposed || this._parent.disposeContext(e);
  }
}
function dj(s) {
  for (; s; ) {
    if (s.hasAttribute(sf)) {
      const e = s.getAttribute(sf);
      return e ? parseInt(e, 10) : NaN;
    }
    s = s.parentElement;
  }
  return 0;
}
function uj(s, e, t) {
  s.get(nt).createKey(String(e), fj(t));
}
function fj(s) {
  return y2(s, (e) => {
    if (typeof e == "object" && e.$mid === 1)
      return Te.revive(e).toString();
    if (e instanceof Te)
      return e.toString();
  });
}
Sn.registerCommand("_setContext", uj);
Sn.registerCommand({
  id: "getContextKeyInfo",
  handler() {
    return [...de.all()].sort((s, e) => s.key.localeCompare(e.key));
  },
  metadata: {
    description: p("getContextKeyInfo", "A command that returns information about context keys"),
    args: []
  }
});
Sn.registerCommand("_generateContextKeyInfo", function() {
  const s = [], e = /* @__PURE__ */ new Set();
  for (const t of de.all())
    e.has(t.key) || (e.add(t.key), s.push(t));
  s.sort((t, i) => t.key.localeCompare(i.key)), console.log(JSON.stringify(s, void 0, 2));
});
let gj = class {
  constructor(e, t) {
    this.key = e, this.data = t, this.incoming = /* @__PURE__ */ new Map(), this.outgoing = /* @__PURE__ */ new Map();
  }
};
class YN {
  constructor(e) {
    this._hashFn = e, this._nodes = /* @__PURE__ */ new Map();
  }
  roots() {
    const e = [];
    for (const t of this._nodes.values())
      t.outgoing.size === 0 && e.push(t);
    return e;
  }
  insertEdge(e, t) {
    const i = this.lookupOrInsertNode(e), n = this.lookupOrInsertNode(t);
    i.outgoing.set(n.key, n), n.incoming.set(i.key, i);
  }
  removeNode(e) {
    const t = this._hashFn(e);
    this._nodes.delete(t);
    for (const i of this._nodes.values())
      i.outgoing.delete(t), i.incoming.delete(t);
  }
  lookupOrInsertNode(e) {
    const t = this._hashFn(e);
    let i = this._nodes.get(t);
    return i || (i = new gj(t, e), this._nodes.set(t, i)), i;
  }
  isEmpty() {
    return this._nodes.size === 0;
  }
  toString() {
    const e = [];
    for (const [t, i] of this._nodes)
      e.push(`${t}
	(-> incoming)[${[...i.incoming.keys()].join(", ")}]
	(outgoing ->)[${[...i.outgoing.keys()].join(",")}]
`);
    return e.join(`
`);
  }
  /**
   * This is brute force and slow and **only** be used
   * to trouble shoot.
   */
  findCycleSlow() {
    for (const [e, t] of this._nodes) {
      const i = /* @__PURE__ */ new Set([e]), n = this._findCycle(t, i);
      if (n)
        return n;
    }
  }
  _findCycle(e, t) {
    for (const [i, n] of e.outgoing) {
      if (t.has(i))
        return [...t, i].join(" -> ");
      t.add(i);
      const o = this._findCycle(n, t);
      if (o)
        return o;
      t.delete(i);
    }
  }
}
class jd {
  constructor(...e) {
    this._entries = /* @__PURE__ */ new Map();
    for (const [t, i] of e)
      this.set(t, i);
  }
  set(e, t) {
    const i = this._entries.get(e);
    return this._entries.set(e, t), i;
  }
  get(e) {
    return this._entries.get(e);
  }
}
const mj = !1;
class QN extends Error {
  constructor(e) {
    super("cyclic dependency between services"), this.message = e.findCycleSlow() ?? `UNABLE to detect cycle, dumping graph: 
${e.toString()}`;
  }
}
class D_ {
  constructor(e = new jd(), t = !1, i, n = mj) {
    this._services = e, this._strict = t, this._parent = i, this._enableTracing = n, this._isDisposed = !1, this._servicesToMaybeDispose = /* @__PURE__ */ new Set(), this._children = /* @__PURE__ */ new Set(), this._activeInstantiations = /* @__PURE__ */ new Set(), this._services.set(ot, this), this._globalGraph = n ? (i == null ? void 0 : i._globalGraph) ?? new YN((o) => o) : void 0;
  }
  dispose() {
    if (!this._isDisposed) {
      this._isDisposed = !0, Ri(this._children), this._children.clear();
      for (const e of this._servicesToMaybeDispose)
        A2(e) && e.dispose();
      this._servicesToMaybeDispose.clear();
    }
  }
  _throwIfDisposed() {
    if (this._isDisposed)
      throw new Error("InstantiationService has been disposed");
  }
  createChild(e, t) {
    this._throwIfDisposed();
    const i = this, n = new class extends D_ {
      dispose() {
        i._children.delete(n), super.dispose();
      }
    }(e, this._strict, this, this._enableTracing);
    return this._children.add(n), t == null || t.add(n), n;
  }
  invokeFunction(e, ...t) {
    this._throwIfDisposed();
    const i = of.traceInvocation(this._enableTracing, e);
    let n = !1;
    try {
      return e({
        get: (r) => {
          if (n)
            throw vL("service accessor is only valid during the invocation of its target method");
          const a = this._getOrCreateServiceInstance(r, i);
          if (!a)
            throw new Error(`[invokeFunction] unknown service '${r}'`);
          return a;
        }
      }, ...t);
    } finally {
      n = !0, i.stop();
    }
  }
  createInstance(e, ...t) {
    this._throwIfDisposed();
    let i, n;
    return e instanceof Ro ? (i = of.traceCreation(this._enableTracing, e.ctor), n = this._createInstance(e.ctor, e.staticArguments.concat(t), i)) : (i = of.traceCreation(this._enableTracing, e), n = this._createInstance(e, t, i)), i.stop(), n;
  }
  _createInstance(e, t = [], i) {
    const n = io.getServiceDependencies(e).sort((a, l) => a.index - l.index), o = [];
    for (const a of n) {
      const l = this._getOrCreateServiceInstance(a.id, i);
      l || this._throwIfStrict(`[createInstance] ${e.name} depends on UNKNOWN service ${a.id}.`, !1), o.push(l);
    }
    const r = n.length > 0 ? n[0].index : t.length;
    if (t.length !== r) {
      console.trace(`[createInstance] First service dependency of ${e.name} at position ${r + 1} conflicts with ${t.length} static arguments`);
      const a = r - t.length;
      a > 0 ? t = t.concat(new Array(a)) : t = t.slice(0, r);
    }
    return Reflect.construct(e, t.concat(o));
  }
  _setCreatedServiceInstance(e, t) {
    if (this._services.get(e) instanceof Ro)
      this._services.set(e, t);
    else if (this._parent)
      this._parent._setCreatedServiceInstance(e, t);
    else
      throw new Error("illegalState - setting UNKNOWN service instance");
  }
  _getServiceInstanceOrDescriptor(e) {
    const t = this._services.get(e);
    return !t && this._parent ? this._parent._getServiceInstanceOrDescriptor(e) : t;
  }
  _getOrCreateServiceInstance(e, t) {
    this._globalGraph && this._globalGraphImplicitDependency && this._globalGraph.insertEdge(this._globalGraphImplicitDependency, String(e));
    const i = this._getServiceInstanceOrDescriptor(e);
    return i instanceof Ro ? this._safeCreateAndCacheServiceInstance(e, i, t.branch(e, !0)) : (t.branch(e, !1), i);
  }
  _safeCreateAndCacheServiceInstance(e, t, i) {
    if (this._activeInstantiations.has(e))
      throw new Error(`illegal state - RECURSIVELY instantiating service '${e}'`);
    this._activeInstantiations.add(e);
    try {
      return this._createAndCacheServiceInstance(e, t, i);
    } finally {
      this._activeInstantiations.delete(e);
    }
  }
  _createAndCacheServiceInstance(e, t, i) {
    var l;
    const n = new YN((c) => c.id.toString());
    let o = 0;
    const r = [{ id: e, desc: t, _trace: i }], a = /* @__PURE__ */ new Set();
    for (; r.length; ) {
      const c = r.pop();
      if (!a.has(String(c.id))) {
        if (a.add(String(c.id)), n.lookupOrInsertNode(c), o++ > 1e3)
          throw new QN(n);
        for (const h of io.getServiceDependencies(c.desc.ctor)) {
          const d = this._getServiceInstanceOrDescriptor(h.id);
          if (d || this._throwIfStrict(`[createInstance] ${e} depends on ${h.id} which is NOT registered.`, !0), (l = this._globalGraph) == null || l.insertEdge(String(c.id), String(h.id)), d instanceof Ro) {
            const u = { id: h.id, desc: d, _trace: c._trace.branch(h.id, !0) };
            n.insertEdge(c, u), r.push(u);
          }
        }
      }
    }
    for (; ; ) {
      const c = n.roots();
      if (c.length === 0) {
        if (!n.isEmpty())
          throw new QN(n);
        break;
      }
      for (const { data: h } of c) {
        if (this._getServiceInstanceOrDescriptor(h.id) instanceof Ro) {
          const u = this._createServiceInstanceWithOwner(h.id, h.desc.ctor, h.desc.staticArguments, h.desc.supportsDelayedInstantiation, h._trace);
          this._setCreatedServiceInstance(h.id, u);
        }
        n.removeNode(h);
      }
    }
    return this._getServiceInstanceOrDescriptor(e);
  }
  _createServiceInstanceWithOwner(e, t, i = [], n, o) {
    if (this._services.get(e) instanceof Ro)
      return this._createServiceInstance(e, t, i, n, o, this._servicesToMaybeDispose);
    if (this._parent)
      return this._parent._createServiceInstanceWithOwner(e, t, i, n, o);
    throw new Error(`illegalState - creating UNKNOWN service instance ${t.name}`);
  }
  _createServiceInstance(e, t, i = [], n, o, r) {
    if (n) {
      const a = new D_(void 0, this._strict, this, this._enableTracing);
      a._globalGraphImplicitDependency = String(e);
      const l = /* @__PURE__ */ new Map(), c = new v6(() => {
        const h = a._createInstance(t, i, o);
        for (const [d, u] of l) {
          const f = h[d];
          if (typeof f == "function")
            for (const g of u)
              g.disposable = f.apply(h, g.listener);
        }
        return l.clear(), r.add(h), h;
      });
      return new Proxy(/* @__PURE__ */ Object.create(null), {
        get(h, d) {
          if (!c.isInitialized && typeof d == "string" && (d.startsWith("onDid") || d.startsWith("onWill"))) {
            let g = l.get(d);
            return g || (g = new An(), l.set(d, g)), (_, b, C) => {
              if (c.isInitialized)
                return c.value[d](_, b, C);
              {
                const v = { listener: [_, b, C], disposable: void 0 }, w = g.push(v);
                return ke(() => {
                  var L;
                  w(), (L = v.disposable) == null || L.dispose();
                });
              }
            };
          }
          if (d in h)
            return h[d];
          const u = c.value;
          let f = u[d];
          return typeof f != "function" || (f = f.bind(u), h[d] = f), f;
        },
        set(h, d, u) {
          return c.value[d] = u, !0;
        },
        getPrototypeOf(h) {
          return t.prototype;
        }
      });
    } else {
      const a = this._createInstance(t, i, o);
      return r.add(a), a;
    }
  }
  _throwIfStrict(e, t) {
    if (t && console.warn(e), this._strict)
      throw new Error(e);
  }
}
const Kn = class Kn {
  static traceInvocation(e, t) {
    return e ? new Kn(2, t.name || new Error().stack.split(`
`).slice(3, 4).join(`
`)) : Kn._None;
  }
  static traceCreation(e, t) {
    return e ? new Kn(1, t.name) : Kn._None;
  }
  constructor(e, t) {
    this.type = e, this.name = t, this._start = Date.now(), this._dep = [];
  }
  branch(e, t) {
    const i = new Kn(3, e.toString());
    return this._dep.push([e, t, i]), i;
  }
  stop() {
    const e = Date.now() - this._start;
    Kn._totals += e;
    let t = !1;
    function i(o, r) {
      const a = [], l = new Array(o + 1).join("	");
      for (const [c, h, d] of r._dep)
        if (h && d) {
          t = !0, a.push(`${l}CREATES -> ${c}`);
          const u = i(o + 1, d);
          u && a.push(u);
        } else
          a.push(`${l}uses -> ${c}`);
      return a.join(`
`);
    }
    const n = [
      `${this.type === 1 ? "CREATE" : "CALL"} ${this.name}`,
      `${i(1, this)}`,
      `DONE, took ${e.toFixed(2)}ms (grand total ${Kn._totals.toFixed(2)}ms)`
    ];
    (e > 2 || t) && Kn.all.add(n.join(`
`));
  }
};
Kn.all = /* @__PURE__ */ new Set(), Kn._None = new class extends Kn {
  constructor() {
    super(0, null);
  }
  stop() {
  }
  branch() {
    return this;
  }
}(), Kn._totals = 0;
let of = Kn;
const pj = /* @__PURE__ */ new Set([
  Ne.inMemory,
  Ne.vscodeSourceControl,
  Ne.walkThrough,
  Ne.walkThroughSnippet,
  Ne.vscodeChatCodeBlock
]);
class _j {
  constructor() {
    this._byResource = new ts(), this._byOwner = /* @__PURE__ */ new Map();
  }
  set(e, t, i) {
    let n = this._byResource.get(e);
    n || (n = /* @__PURE__ */ new Map(), this._byResource.set(e, n)), n.set(t, i);
    let o = this._byOwner.get(t);
    o || (o = new ts(), this._byOwner.set(t, o)), o.set(e, i);
  }
  get(e, t) {
    const i = this._byResource.get(e);
    return i == null ? void 0 : i.get(t);
  }
  delete(e, t) {
    let i = !1, n = !1;
    const o = this._byResource.get(e);
    o && (i = o.delete(t));
    const r = this._byOwner.get(t);
    if (r && (n = r.delete(e)), i !== n)
      throw new Error("illegal state");
    return i && n;
  }
  values(e) {
    var t, i;
    return typeof e == "string" ? ((t = this._byOwner.get(e)) == null ? void 0 : t.values()) ?? Ye.empty() : Te.isUri(e) ? ((i = this._byResource.get(e)) == null ? void 0 : i.values()) ?? Ye.empty() : Ye.map(Ye.concat(...this._byOwner.values()), (n) => n[1]);
  }
}
class bj {
  constructor(e) {
    this.errors = 0, this.infos = 0, this.warnings = 0, this.unknowns = 0, this._data = new ts(), this._service = e, this._subscription = e.onMarkerChanged(this._update, this);
  }
  dispose() {
    this._subscription.dispose();
  }
  _update(e) {
    for (const t of e) {
      const i = this._data.get(t);
      i && this._substract(i);
      const n = this._resourceStats(t);
      this._add(n), this._data.set(t, n);
    }
  }
  _resourceStats(e) {
    const t = { errors: 0, warnings: 0, infos: 0, unknowns: 0 };
    if (pj.has(e.scheme))
      return t;
    for (const { severity: i } of this._service.read({ resource: e }))
      i === us.Error ? t.errors += 1 : i === us.Warning ? t.warnings += 1 : i === us.Info ? t.infos += 1 : t.unknowns += 1;
    return t;
  }
  _substract(e) {
    this.errors -= e.errors, this.warnings -= e.warnings, this.infos -= e.infos, this.unknowns -= e.unknowns;
  }
  _add(e) {
    this.errors += e.errors, this.warnings += e.warnings, this.infos += e.infos, this.unknowns += e.unknowns;
  }
}
class ma {
  constructor() {
    this._onMarkerChanged = new O2({
      delay: 0,
      merge: ma._merge
    }), this.onMarkerChanged = this._onMarkerChanged.event, this._data = new _j(), this._stats = new bj(this);
  }
  dispose() {
    this._stats.dispose(), this._onMarkerChanged.dispose();
  }
  remove(e, t) {
    for (const i of t || [])
      this.changeOne(e, i, []);
  }
  changeOne(e, t, i) {
    if (B5(i))
      this._data.delete(t, e) && this._onMarkerChanged.fire([t]);
    else {
      const n = [];
      for (const o of i) {
        const r = ma._toMarker(e, t, o);
        r && n.push(r);
      }
      this._data.set(t, e, n), this._onMarkerChanged.fire([t]);
    }
  }
  static _toMarker(e, t, i) {
    let { code: n, severity: o, message: r, source: a, startLineNumber: l, startColumn: c, endLineNumber: h, endColumn: d, relatedInformation: u, tags: f } = i;
    if (r)
      return l = l > 0 ? l : 1, c = c > 0 ? c : 1, h = h >= l ? h : l, d = d > 0 ? d : c, {
        resource: t,
        owner: e,
        code: n,
        severity: o,
        message: r,
        source: a,
        startLineNumber: l,
        startColumn: c,
        endLineNumber: h,
        endColumn: d,
        relatedInformation: u,
        tags: f
      };
  }
  changeAll(e, t) {
    const i = [], n = this._data.values(e);
    if (n)
      for (const o of n) {
        const r = Ye.first(o);
        r && (i.push(r.resource), this._data.delete(r.resource, e));
      }
    if (Q1(t)) {
      const o = new ts();
      for (const { resource: r, marker: a } of t) {
        const l = ma._toMarker(e, r, a);
        if (!l)
          continue;
        const c = o.get(r);
        c ? c.push(l) : (o.set(r, [l]), i.push(r));
      }
      for (const [r, a] of o)
        this._data.set(r, e, a);
    }
    i.length > 0 && this._onMarkerChanged.fire(i);
  }
  read(e = /* @__PURE__ */ Object.create(null)) {
    let { owner: t, resource: i, severities: n, take: o } = e;
    if ((!o || o < 0) && (o = -1), t && i) {
      const r = this._data.get(i, t);
      if (r) {
        const a = [];
        for (const l of r)
          if (ma._accept(l, n)) {
            const c = a.push(l);
            if (o > 0 && c === o)
              break;
          }
        return a;
      } else
        return [];
    } else if (!t && !i) {
      const r = [];
      for (const a of this._data.values())
        for (const l of a)
          if (ma._accept(l, n)) {
            const c = r.push(l);
            if (o > 0 && c === o)
              return r;
          }
      return r;
    } else {
      const r = this._data.values(i ?? t), a = [];
      for (const l of r)
        for (const c of l)
          if (ma._accept(c, n)) {
            const h = a.push(c);
            if (o > 0 && h === o)
              return a;
          }
      return a;
    }
  }
  static _accept(e, t) {
    return t === void 0 || (t & e.severity) === e.severity;
  }
  // --- event debounce logic
  static _merge(e) {
    const t = new ts();
    for (const i of e)
      for (const n of i)
        t.set(n, !0);
    return Array.from(t.keys());
  }
}
class Cj extends q {
  get configurationModel() {
    return this._configurationModel;
  }
  constructor(e) {
    super(), this.logService = e, this._configurationModel = vi.createEmptyModel(this.logService);
  }
  reload() {
    return this.resetConfigurationModel(), this.configurationModel;
  }
  getConfigurationDefaultOverrides() {
    return {};
  }
  resetConfigurationModel() {
    this._configurationModel = vi.createEmptyModel(this.logService);
    const e = Li.as(Oc.Configuration).getConfigurationProperties();
    this.updateConfigurationModel(Object.keys(e), e);
  }
  updateConfigurationModel(e, t) {
    const i = this.getConfigurationDefaultOverrides();
    for (const n of e) {
      const o = i[n], r = t[n];
      o !== void 0 ? this._configurationModel.setValue(n, o) : r ? this._configurationModel.setValue(n, r.default) : this._configurationModel.removeValue(n);
    }
  }
}
const Zb = Ve("accessibilitySignalService"), We = class We {
  static register(e) {
    return new We(e.fileName);
  }
  constructor(e) {
    this.fileName = e;
  }
};
We.error = We.register({ fileName: "error.mp3" }), We.warning = We.register({ fileName: "warning.mp3" }), We.success = We.register({ fileName: "success.mp3" }), We.foldedArea = We.register({ fileName: "foldedAreas.mp3" }), We.break = We.register({ fileName: "break.mp3" }), We.quickFixes = We.register({ fileName: "quickFixes.mp3" }), We.taskCompleted = We.register({ fileName: "taskCompleted.mp3" }), We.taskFailed = We.register({ fileName: "taskFailed.mp3" }), We.terminalBell = We.register({ fileName: "terminalBell.mp3" }), We.diffLineInserted = We.register({ fileName: "diffLineInserted.mp3" }), We.diffLineDeleted = We.register({ fileName: "diffLineDeleted.mp3" }), We.diffLineModified = We.register({ fileName: "diffLineModified.mp3" }), We.chatRequestSent = We.register({ fileName: "chatRequestSent.mp3" }), We.chatResponseReceived1 = We.register({ fileName: "chatResponseReceived1.mp3" }), We.chatResponseReceived2 = We.register({ fileName: "chatResponseReceived2.mp3" }), We.chatResponseReceived3 = We.register({ fileName: "chatResponseReceived3.mp3" }), We.chatResponseReceived4 = We.register({ fileName: "chatResponseReceived4.mp3" }), We.clear = We.register({ fileName: "clear.mp3" }), We.save = We.register({ fileName: "save.mp3" }), We.format = We.register({ fileName: "format.mp3" }), We.voiceRecordingStarted = We.register({ fileName: "voiceRecordingStarted.mp3" }), We.voiceRecordingStopped = We.register({ fileName: "voiceRecordingStopped.mp3" }), We.progress = We.register({ fileName: "progress.mp3" });
let Dt = We;
class wj {
  constructor(e) {
    this.randomOneOf = e;
  }
}
const Le = class Le {
  constructor(e, t, i, n, o, r) {
    this.sound = e, this.name = t, this.legacySoundSettingsKey = i, this.settingsKey = n, this.legacyAnnouncementSettingsKey = o, this.announcementMessage = r;
  }
  static register(e) {
    const t = new wj("randomOneOf" in e.sound ? e.sound.randomOneOf : [e.sound]), i = new Le(t, e.name, e.legacySoundSettingsKey, e.settingsKey, e.legacyAnnouncementSettingsKey, e.announcementMessage);
    return Le._signals.add(i), i;
  }
};
Le._signals = /* @__PURE__ */ new Set(), Le.errorAtPosition = Le.register({
  name: p("accessibilitySignals.positionHasError.name", "Error at Position"),
  sound: Dt.error,
  announcementMessage: p("accessibility.signals.positionHasError", "Error"),
  settingsKey: "accessibility.signals.positionHasError",
  delaySettingsKey: "accessibility.signalOptions.delays.errorAtPosition"
}), Le.warningAtPosition = Le.register({
  name: p("accessibilitySignals.positionHasWarning.name", "Warning at Position"),
  sound: Dt.warning,
  announcementMessage: p("accessibility.signals.positionHasWarning", "Warning"),
  settingsKey: "accessibility.signals.positionHasWarning",
  delaySettingsKey: "accessibility.signalOptions.delays.warningAtPosition"
}), Le.errorOnLine = Le.register({
  name: p("accessibilitySignals.lineHasError.name", "Error on Line"),
  sound: Dt.error,
  legacySoundSettingsKey: "audioCues.lineHasError",
  legacyAnnouncementSettingsKey: "accessibility.alert.error",
  announcementMessage: p("accessibility.signals.lineHasError", "Error on Line"),
  settingsKey: "accessibility.signals.lineHasError"
}), Le.warningOnLine = Le.register({
  name: p("accessibilitySignals.lineHasWarning.name", "Warning on Line"),
  sound: Dt.warning,
  legacySoundSettingsKey: "audioCues.lineHasWarning",
  legacyAnnouncementSettingsKey: "accessibility.alert.warning",
  announcementMessage: p("accessibility.signals.lineHasWarning", "Warning on Line"),
  settingsKey: "accessibility.signals.lineHasWarning"
}), Le.foldedArea = Le.register({
  name: p("accessibilitySignals.lineHasFoldedArea.name", "Folded Area on Line"),
  sound: Dt.foldedArea,
  legacySoundSettingsKey: "audioCues.lineHasFoldedArea",
  legacyAnnouncementSettingsKey: "accessibility.alert.foldedArea",
  announcementMessage: p("accessibility.signals.lineHasFoldedArea", "Folded"),
  settingsKey: "accessibility.signals.lineHasFoldedArea"
}), Le.break = Le.register({
  name: p("accessibilitySignals.lineHasBreakpoint.name", "Breakpoint on Line"),
  sound: Dt.break,
  legacySoundSettingsKey: "audioCues.lineHasBreakpoint",
  legacyAnnouncementSettingsKey: "accessibility.alert.breakpoint",
  announcementMessage: p("accessibility.signals.lineHasBreakpoint", "Breakpoint"),
  settingsKey: "accessibility.signals.lineHasBreakpoint"
}), Le.inlineSuggestion = Le.register({
  name: p("accessibilitySignals.lineHasInlineSuggestion.name", "Inline Suggestion on Line"),
  sound: Dt.quickFixes,
  legacySoundSettingsKey: "audioCues.lineHasInlineSuggestion",
  settingsKey: "accessibility.signals.lineHasInlineSuggestion"
}), Le.terminalQuickFix = Le.register({
  name: p("accessibilitySignals.terminalQuickFix.name", "Terminal Quick Fix"),
  sound: Dt.quickFixes,
  legacySoundSettingsKey: "audioCues.terminalQuickFix",
  legacyAnnouncementSettingsKey: "accessibility.alert.terminalQuickFix",
  announcementMessage: p("accessibility.signals.terminalQuickFix", "Quick Fix"),
  settingsKey: "accessibility.signals.terminalQuickFix"
}), Le.onDebugBreak = Le.register({
  name: p("accessibilitySignals.onDebugBreak.name", "Debugger Stopped on Breakpoint"),
  sound: Dt.break,
  legacySoundSettingsKey: "audioCues.onDebugBreak",
  legacyAnnouncementSettingsKey: "accessibility.alert.onDebugBreak",
  announcementMessage: p("accessibility.signals.onDebugBreak", "Breakpoint"),
  settingsKey: "accessibility.signals.onDebugBreak"
}), Le.noInlayHints = Le.register({
  name: p("accessibilitySignals.noInlayHints", "No Inlay Hints on Line"),
  sound: Dt.error,
  legacySoundSettingsKey: "audioCues.noInlayHints",
  legacyAnnouncementSettingsKey: "accessibility.alert.noInlayHints",
  announcementMessage: p("accessibility.signals.noInlayHints", "No Inlay Hints"),
  settingsKey: "accessibility.signals.noInlayHints"
}), Le.taskCompleted = Le.register({
  name: p("accessibilitySignals.taskCompleted", "Task Completed"),
  sound: Dt.taskCompleted,
  legacySoundSettingsKey: "audioCues.taskCompleted",
  legacyAnnouncementSettingsKey: "accessibility.alert.taskCompleted",
  announcementMessage: p("accessibility.signals.taskCompleted", "Task Completed"),
  settingsKey: "accessibility.signals.taskCompleted"
}), Le.taskFailed = Le.register({
  name: p("accessibilitySignals.taskFailed", "Task Failed"),
  sound: Dt.taskFailed,
  legacySoundSettingsKey: "audioCues.taskFailed",
  legacyAnnouncementSettingsKey: "accessibility.alert.taskFailed",
  announcementMessage: p("accessibility.signals.taskFailed", "Task Failed"),
  settingsKey: "accessibility.signals.taskFailed"
}), Le.terminalCommandFailed = Le.register({
  name: p("accessibilitySignals.terminalCommandFailed", "Terminal Command Failed"),
  sound: Dt.error,
  legacySoundSettingsKey: "audioCues.terminalCommandFailed",
  legacyAnnouncementSettingsKey: "accessibility.alert.terminalCommandFailed",
  announcementMessage: p("accessibility.signals.terminalCommandFailed", "Command Failed"),
  settingsKey: "accessibility.signals.terminalCommandFailed"
}), Le.terminalCommandSucceeded = Le.register({
  name: p("accessibilitySignals.terminalCommandSucceeded", "Terminal Command Succeeded"),
  sound: Dt.success,
  announcementMessage: p("accessibility.signals.terminalCommandSucceeded", "Command Succeeded"),
  settingsKey: "accessibility.signals.terminalCommandSucceeded"
}), Le.terminalBell = Le.register({
  name: p("accessibilitySignals.terminalBell", "Terminal Bell"),
  sound: Dt.terminalBell,
  legacySoundSettingsKey: "audioCues.terminalBell",
  legacyAnnouncementSettingsKey: "accessibility.alert.terminalBell",
  announcementMessage: p("accessibility.signals.terminalBell", "Terminal Bell"),
  settingsKey: "accessibility.signals.terminalBell"
}), Le.notebookCellCompleted = Le.register({
  name: p("accessibilitySignals.notebookCellCompleted", "Notebook Cell Completed"),
  sound: Dt.taskCompleted,
  legacySoundSettingsKey: "audioCues.notebookCellCompleted",
  legacyAnnouncementSettingsKey: "accessibility.alert.notebookCellCompleted",
  announcementMessage: p("accessibility.signals.notebookCellCompleted", "Notebook Cell Completed"),
  settingsKey: "accessibility.signals.notebookCellCompleted"
}), Le.notebookCellFailed = Le.register({
  name: p("accessibilitySignals.notebookCellFailed", "Notebook Cell Failed"),
  sound: Dt.taskFailed,
  legacySoundSettingsKey: "audioCues.notebookCellFailed",
  legacyAnnouncementSettingsKey: "accessibility.alert.notebookCellFailed",
  announcementMessage: p("accessibility.signals.notebookCellFailed", "Notebook Cell Failed"),
  settingsKey: "accessibility.signals.notebookCellFailed"
}), Le.diffLineInserted = Le.register({
  name: p("accessibilitySignals.diffLineInserted", "Diff Line Inserted"),
  sound: Dt.diffLineInserted,
  legacySoundSettingsKey: "audioCues.diffLineInserted",
  settingsKey: "accessibility.signals.diffLineInserted"
}), Le.diffLineDeleted = Le.register({
  name: p("accessibilitySignals.diffLineDeleted", "Diff Line Deleted"),
  sound: Dt.diffLineDeleted,
  legacySoundSettingsKey: "audioCues.diffLineDeleted",
  settingsKey: "accessibility.signals.diffLineDeleted"
}), Le.diffLineModified = Le.register({
  name: p("accessibilitySignals.diffLineModified", "Diff Line Modified"),
  sound: Dt.diffLineModified,
  legacySoundSettingsKey: "audioCues.diffLineModified",
  settingsKey: "accessibility.signals.diffLineModified"
}), Le.chatRequestSent = Le.register({
  name: p("accessibilitySignals.chatRequestSent", "Chat Request Sent"),
  sound: Dt.chatRequestSent,
  legacySoundSettingsKey: "audioCues.chatRequestSent",
  legacyAnnouncementSettingsKey: "accessibility.alert.chatRequestSent",
  announcementMessage: p("accessibility.signals.chatRequestSent", "Chat Request Sent"),
  settingsKey: "accessibility.signals.chatRequestSent"
}), Le.chatResponseReceived = Le.register({
  name: p("accessibilitySignals.chatResponseReceived", "Chat Response Received"),
  legacySoundSettingsKey: "audioCues.chatResponseReceived",
  sound: {
    randomOneOf: [
      Dt.chatResponseReceived1,
      Dt.chatResponseReceived2,
      Dt.chatResponseReceived3,
      Dt.chatResponseReceived4
    ]
  },
  settingsKey: "accessibility.signals.chatResponseReceived"
}), Le.progress = Le.register({
  name: p("accessibilitySignals.progress", "Progress"),
  sound: Dt.progress,
  legacySoundSettingsKey: "audioCues.chatResponsePending",
  legacyAnnouncementSettingsKey: "accessibility.alert.progress",
  announcementMessage: p("accessibility.signals.progress", "Progress"),
  settingsKey: "accessibility.signals.progress"
}), Le.clear = Le.register({
  name: p("accessibilitySignals.clear", "Clear"),
  sound: Dt.clear,
  legacySoundSettingsKey: "audioCues.clear",
  legacyAnnouncementSettingsKey: "accessibility.alert.clear",
  announcementMessage: p("accessibility.signals.clear", "Clear"),
  settingsKey: "accessibility.signals.clear"
}), Le.save = Le.register({
  name: p("accessibilitySignals.save", "Save"),
  sound: Dt.save,
  legacySoundSettingsKey: "audioCues.save",
  legacyAnnouncementSettingsKey: "accessibility.alert.save",
  announcementMessage: p("accessibility.signals.save", "Save"),
  settingsKey: "accessibility.signals.save"
}), Le.format = Le.register({
  name: p("accessibilitySignals.format", "Format"),
  sound: Dt.format,
  legacySoundSettingsKey: "audioCues.format",
  legacyAnnouncementSettingsKey: "accessibility.alert.format",
  announcementMessage: p("accessibility.signals.format", "Format"),
  settingsKey: "accessibility.signals.format"
}), Le.voiceRecordingStarted = Le.register({
  name: p("accessibilitySignals.voiceRecordingStarted", "Voice Recording Started"),
  sound: Dt.voiceRecordingStarted,
  legacySoundSettingsKey: "audioCues.voiceRecordingStarted",
  settingsKey: "accessibility.signals.voiceRecordingStarted"
}), Le.voiceRecordingStopped = Le.register({
  name: p("accessibilitySignals.voiceRecordingStopped", "Voice Recording Stopped"),
  sound: Dt.voiceRecordingStopped,
  legacySoundSettingsKey: "audioCues.voiceRecordingStopped",
  settingsKey: "accessibility.signals.voiceRecordingStopped"
});
let Ao = Le;
class vj extends q {
  constructor(e, t = []) {
    super(), this.logger = new j7([e, ...t]), this._register(e.onDidChangeLogLevel((i) => this.setLevel(i)));
  }
  get onDidChangeLogLevel() {
    return this.logger.onDidChangeLogLevel;
  }
  setLevel(e) {
    this.logger.setLevel(e);
  }
  getLevel() {
    return this.logger.getLevel();
  }
  trace(e, ...t) {
    this.logger.trace(e, ...t);
  }
  debug(e, ...t) {
    this.logger.debug(e, ...t);
  }
  info(e, ...t) {
    this.logger.info(e, ...t);
  }
  warn(e, ...t) {
    this.logger.warn(e, ...t);
  }
  error(e, ...t) {
    this.logger.error(e, ...t);
  }
}
const yj = [];
function Sj() {
  return yj.slice(0);
}
class Lj {
  getParseResult(e) {
  }
}
var Xo = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, qt = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
class kj {
  constructor(e) {
    this.disposed = !1, this.model = e, this._onWillDispose = new O();
  }
  get textEditorModel() {
    return this.model;
  }
  dispose() {
    this.disposed = !0, this._onWillDispose.fire();
  }
}
let lS = class {
  constructor(e) {
    this.modelService = e;
  }
  createModelReference(e) {
    const t = this.modelService.getModel(e);
    return t ? Promise.resolve(new sO(new kj(t))) : Promise.reject(new Error("Model not found"));
  }
};
lS = Xo([
  qt(0, cn)
], lS);
const A1 = class A1 {
  show() {
    return A1.NULL_PROGRESS_RUNNER;
  }
  async showWhile(e, t) {
    await e;
  }
};
A1.NULL_PROGRESS_RUNNER = {
  done: () => {
  },
  total: () => {
  },
  worked: () => {
  }
};
let cS = A1;
class xj {
  withProgress(e, t, i) {
    return t({
      report: () => {
      }
    });
  }
}
class Dj {
  constructor() {
    this.isExtensionDevelopment = !1, this.isBuilt = !1;
  }
}
class Ej {
  async confirm(e) {
    return {
      confirmed: this.doConfirm(e.message, e.detail),
      checkboxChecked: !1
      // unsupported
    };
  }
  doConfirm(e, t) {
    let i = e;
    return t && (i = i + `

` + t), ut.confirm(i);
  }
  async prompt(e) {
    var n;
    let t;
    if (this.doConfirm(e.message, e.detail)) {
      const o = [...e.buttons ?? []];
      e.cancelButton && typeof e.cancelButton != "string" && typeof e.cancelButton != "boolean" && o.push(e.cancelButton), t = await ((n = o[0]) == null ? void 0 : n.run({ checkboxChecked: !1 }));
    }
    return { result: t };
  }
  async error(e, t) {
    await this.prompt({ type: Jt.Error, message: e, detail: t });
  }
}
const Lf = class Lf {
  info(e) {
    return this.notify({ severity: Jt.Info, message: e });
  }
  warn(e) {
    return this.notify({ severity: Jt.Warning, message: e });
  }
  error(e) {
    return this.notify({ severity: Jt.Error, message: e });
  }
  notify(e) {
    switch (e.severity) {
      case Jt.Error:
        console.error(e.message);
        break;
      case Jt.Warning:
        console.warn(e.message);
        break;
      default:
        console.log(e.message);
        break;
    }
    return Lf.NO_OP;
  }
  prompt(e, t, i, n) {
    return Lf.NO_OP;
  }
  status(e, t) {
    return q.None;
  }
};
Lf.NO_OP = new pF();
let hS = Lf, dS = class {
  constructor(e) {
    this._onWillExecuteCommand = new O(), this._onDidExecuteCommand = new O(), this.onDidExecuteCommand = this._onDidExecuteCommand.event, this._instantiationService = e;
  }
  executeCommand(e, ...t) {
    const i = Sn.getCommand(e);
    if (!i)
      return Promise.reject(new Error(`command '${e}' not found`));
    try {
      this._onWillExecuteCommand.fire({ commandId: e, args: t });
      const n = this._instantiationService.invokeFunction.apply(this._instantiationService, [i.handler, ...t]);
      return this._onDidExecuteCommand.fire({ commandId: e, args: t }), Promise.resolve(n);
    } catch (n) {
      return Promise.reject(n);
    }
  }
};
dS = Xo([
  qt(0, ot)
], dS);
let Ad = class extends AV {
  constructor(e, t, i, n, o, r) {
    super(e, t, i, n, o), this._cachedResolver = null, this._dynamicKeybindings = [], this._domNodeListeners = [];
    const a = (f) => {
      const g = new he();
      g.add($(f, ee.KEY_DOWN, (m) => {
        const _ = new Lt(m);
        this._dispatch(_, _.target) && (_.preventDefault(), _.stopPropagation());
      })), g.add($(f, ee.KEY_UP, (m) => {
        const _ = new Lt(m);
        this._singleModifierDispatch(_, _.target) && _.preventDefault();
      })), this._domNodeListeners.push(new Ij(f, g));
    }, l = (f) => {
      for (let g = 0; g < this._domNodeListeners.length; g++) {
        const m = this._domNodeListeners[g];
        m.domNode === f && (this._domNodeListeners.splice(g, 1), m.dispose());
      }
    }, c = (f) => {
      f.getOption(
        61
        /* EditorOption.inDiffEditor */
      ) || a(f.getContainerDomNode());
    }, h = (f) => {
      f.getOption(
        61
        /* EditorOption.inDiffEditor */
      ) || l(f.getContainerDomNode());
    };
    this._register(r.onCodeEditorAdd(c)), this._register(r.onCodeEditorRemove(h)), r.listCodeEditors().forEach(c);
    const d = (f) => {
      a(f.getContainerDomNode());
    }, u = (f) => {
      l(f.getContainerDomNode());
    };
    this._register(r.onDiffEditorAdd(d)), this._register(r.onDiffEditorRemove(u)), r.listDiffEditors().forEach(d);
  }
  addDynamicKeybinding(e, t, i, n) {
    return Wo(Sn.registerCommand(e, i), this.addDynamicKeybindings([{
      keybinding: t,
      command: e,
      when: n
    }]));
  }
  addDynamicKeybindings(e) {
    const t = e.map((i) => ({
      keybinding: Vw(i.keybinding, Es),
      command: i.command ?? null,
      commandArgs: i.commandArgs,
      when: i.when,
      weight1: 1e3,
      weight2: 0,
      extensionId: null,
      isBuiltinExtension: !1
    }));
    return this._dynamicKeybindings = this._dynamicKeybindings.concat(t), this.updateResolver(), ke(() => {
      for (let i = 0; i < this._dynamicKeybindings.length; i++)
        if (this._dynamicKeybindings[i] === t[0]) {
          this._dynamicKeybindings.splice(i, t.length), this.updateResolver();
          return;
        }
    });
  }
  updateResolver() {
    this._cachedResolver = null, this._onDidUpdateKeybindings.fire();
  }
  _getResolver() {
    if (!this._cachedResolver) {
      const e = this._toNormalizedKeybindingItems(Dg.getDefaultKeybindings(), !0), t = this._toNormalizedKeybindingItems(this._dynamicKeybindings, !1);
      this._cachedResolver = new Ku(e, t, (i) => this._log(i));
    }
    return this._cachedResolver;
  }
  _documentHasFocus() {
    return ut.document.hasFocus();
  }
  _toNormalizedKeybindingItems(e, t) {
    const i = [];
    let n = 0;
    for (const o of e) {
      const r = o.when || void 0, a = o.keybinding;
      if (!a)
        i[n++] = new xI(void 0, o.command, o.commandArgs, r, t, null, !1);
      else {
        const l = Zf.resolveKeybinding(a, Es);
        for (const c of l)
          i[n++] = new xI(c, o.command, o.commandArgs, r, t, null, !1);
      }
    }
    return i;
  }
  resolveKeyboardEvent(e) {
    const t = new mc(e.ctrlKey, e.shiftKey, e.altKey, e.metaKey, e.keyCode);
    return new Zf([t], Es);
  }
};
Ad = Xo([
  qt(0, nt),
  qt(1, ss),
  qt(2, Ac),
  qt(3, fo),
  qt(4, uo),
  qt(5, ri)
], Ad);
class Ij extends q {
  constructor(e, t) {
    super(), this.domNode = e, this._register(t);
  }
}
function XN(s) {
  return s && typeof s == "object" && (!s.overrideIdentifier || typeof s.overrideIdentifier == "string") && (!s.resource || s.resource instanceof Te);
}
let E_ = class {
  constructor(e) {
    this.logService = e, this._onDidChangeConfiguration = new O(), this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
    const t = new Cj(e);
    this._configuration = new Ib(t.reload(), vi.createEmptyModel(e), vi.createEmptyModel(e), vi.createEmptyModel(e), vi.createEmptyModel(e), vi.createEmptyModel(e), new ts(), vi.createEmptyModel(e), new ts(), e), t.dispose();
  }
  getValue(e, t) {
    const i = typeof e == "string" ? e : void 0, n = XN(e) ? e : XN(t) ? t : {};
    return this._configuration.getValue(i, n, void 0);
  }
  updateValues(e) {
    const t = { data: this._configuration.toData() }, i = [];
    for (const n of e) {
      const [o, r] = n;
      this.getValue(o) !== r && (this._configuration.updateValue(o, r), i.push(o));
    }
    if (i.length > 0) {
      const n = new IV({ keys: i, overrides: [] }, t, this._configuration, void 0, this.logService);
      n.source = 8, this._onDidChangeConfiguration.fire(n);
    }
    return Promise.resolve();
  }
  updateValue(e, t, i, n) {
    return this.updateValues([[e, t]]);
  }
  inspect(e, t = {}) {
    return this._configuration.inspect(e, t, void 0);
  }
};
E_ = Xo([
  qt(0, uo)
], E_);
let uS = class {
  constructor(e, t, i) {
    this.configurationService = e, this.modelService = t, this.languageService = i, this._onDidChangeConfiguration = new O(), this.configurationService.onDidChangeConfiguration((n) => {
      this._onDidChangeConfiguration.fire({ affectedKeys: n.affectedKeys, affectsConfiguration: (o, r) => n.affectsConfiguration(r) });
    });
  }
  getValue(e, t, i) {
    const n = V.isIPosition(t) ? t : null, o = n ? typeof i == "string" ? i : void 0 : typeof t == "string" ? t : void 0, r = e ? this.getLanguage(e, n) : void 0;
    return typeof o > "u" ? this.configurationService.getValue({
      resource: e,
      overrideIdentifier: r
    }) : this.configurationService.getValue(o, {
      resource: e,
      overrideIdentifier: r
    });
  }
  getLanguage(e, t) {
    const i = this.modelService.getModel(e);
    return i ? t ? i.getLanguageIdAtPosition(t.lineNumber, t.column) : i.getLanguageId() : this.languageService.guessLanguageIdByFilepathOrFirstLine(e);
  }
};
uS = Xo([
  qt(0, Vt),
  qt(1, cn),
  qt(2, gi)
], uS);
let fS = class {
  constructor(e) {
    this.configurationService = e;
  }
  getEOL(e, t) {
    const i = this.configurationService.getValue("files.eol", { overrideIdentifier: t, resource: e });
    return i && typeof i == "string" && i !== "auto" ? i : wn || He ? `
` : `\r
`;
  }
};
fS = Xo([
  qt(0, Vt)
], fS);
class Nj {
  publicLog2() {
  }
}
const kf = class kf {
  constructor() {
    const e = Te.from({ scheme: kf.SCHEME, authority: "model", path: "/" });
    this.workspace = { id: ZV, folders: [new jV({ uri: e, name: "", index: 0 })] };
  }
  getWorkspace() {
    return this.workspace;
  }
  getWorkspaceFolder(e) {
    return e && e.scheme === kf.SCHEME ? this.workspace.folders[0] : null;
  }
};
kf.SCHEME = "inmemory";
let gS = kf;
function I_(s, e, t) {
  if (!e || !(s instanceof E_))
    return;
  const i = [];
  Object.keys(e).forEach((n) => {
    SV(n) && i.push([`editor.${n}`, e[n]]), t && LV(n) && i.push([`diffEditor.${n}`, e[n]]);
  }), i.length > 0 && s.updateValues(i);
}
let mS = class {
  constructor(e) {
    this._modelService = e;
  }
  hasPreviewHandler() {
    return !1;
  }
  async apply(e, t) {
    const i = Array.isArray(e) ? e : Lk.convert(e), n = /* @__PURE__ */ new Map();
    for (const a of i) {
      if (!(a instanceof Ql))
        throw new Error("bad edit - only text edits are supported");
      const l = this._modelService.getModel(a.resource);
      if (!l)
        throw new Error("bad edit - model not found");
      if (typeof a.versionId == "number" && l.getVersionId() !== a.versionId)
        throw new Error("bad state - model changed in the meantime");
      let c = n.get(l);
      c || (c = [], n.set(l, c)), c.push(xV.replaceMove(R.lift(a.textEdit.range), a.textEdit.text));
    }
    let o = 0, r = 0;
    for (const [a, l] of n)
      a.pushStackElement(), a.pushEditOperations([], l, () => []), a.pushStackElement(), r += 1, o += l.length;
    return {
      ariaSummary: Pw(iy.bulkEditServiceSummary, o, r),
      isApplied: o > 0
    };
  }
};
mS = Xo([
  qt(0, cn)
], mS);
class Tj {
  getUriLabel(e, t) {
    return e.scheme === "file" ? e.fsPath : e.path;
  }
  getUriBasenameLabel(e) {
    return wk(e);
  }
}
let pS = class extends pV {
  constructor(e, t) {
    super(e), this._codeEditorService = t;
  }
  showContextView(e, t, i) {
    if (!t) {
      const n = this._codeEditorService.getFocusedCodeEditor() || this._codeEditorService.getActiveCodeEditor();
      n && (t = n.getContainerDomNode());
    }
    return super.showContextView(e, t, i);
  }
};
pS = Xo([
  qt(0, Xa),
  qt(1, ri)
], pS);
class Mj {
  constructor() {
    this._neverEmitter = new O(), this.onDidChangeTrust = this._neverEmitter.event;
  }
  isWorkspaceTrusted() {
    return !0;
  }
}
class Rj extends ay {
  constructor() {
    super();
  }
}
class Aj extends vj {
  constructor() {
    super(new q7());
  }
}
let _S = class extends _y {
  constructor(e, t, i, n, o, r) {
    super(e, t, i, n, o, r), this.configure({ blockMouse: !1 });
  }
};
_S = Xo([
  qt(0, Ac),
  qt(1, fo),
  qt(2, Pg),
  qt(3, Ai),
  qt(4, Rc),
  qt(5, nt)
], _S);
const bS = {
  amdModuleId: "vs/editor/common/services/editorSimpleWorker",
  esmModuleLocation: void 0,
  label: "editorWorkerService"
};
let CS = class extends bv {
  constructor(e, t, i, n, o) {
    super(bS, e, t, i, n, o);
  }
};
CS = Xo([
  qt(0, cn),
  qt(1, ik),
  qt(2, uo),
  qt(3, Zo),
  qt(4, gt)
], CS);
class Pj {
  async playSignal(e, t) {
  }
}
Ge(
  uo,
  Aj,
  0
  /* InstantiationType.Eager */
);
Ge(
  Vt,
  E_,
  0
  /* InstantiationType.Eager */
);
Ge(
  ik,
  uS,
  0
  /* InstantiationType.Eager */
);
Ge(
  rR,
  fS,
  0
  /* InstantiationType.Eager */
);
Ge(
  qV,
  gS,
  0
  /* InstantiationType.Eager */
);
Ge(
  VV,
  Tj,
  0
  /* InstantiationType.Eager */
);
Ge(
  Ac,
  Nj,
  0
  /* InstantiationType.Eager */
);
Ge(
  dR,
  Ej,
  0
  /* InstantiationType.Eager */
);
Ge(
  _R,
  Dj,
  0
  /* InstantiationType.Eager */
);
Ge(
  fo,
  hS,
  0
  /* InstantiationType.Eager */
);
Ge(
  Bc,
  ma,
  0
  /* InstantiationType.Eager */
);
Ge(
  gi,
  Rj,
  0
  /* InstantiationType.Eager */
);
Ge(
  Vs,
  tj,
  0
  /* InstantiationType.Eager */
);
Ge(
  cn,
  Ty,
  0
  /* InstantiationType.Eager */
);
Ge(
  HA,
  yy,
  0
  /* InstantiationType.Eager */
);
Ge(
  nt,
  aS,
  0
  /* InstantiationType.Eager */
);
Ge(
  HV,
  xj,
  0
  /* InstantiationType.Eager */
);
Ge(
  xk,
  cS,
  0
  /* InstantiationType.Eager */
);
Ge(
  Fb,
  rz,
  0
  /* InstantiationType.Eager */
);
Ge(
  Hg,
  CS,
  0
  /* InstantiationType.Eager */
);
Ge(
  wV,
  mS,
  0
  /* InstantiationType.Eager */
);
Ge(
  YV,
  Mj,
  0
  /* InstantiationType.Eager */
);
Ge(
  ab,
  lS,
  0
  /* InstantiationType.Eager */
);
Ge(
  go,
  eS,
  0
  /* InstantiationType.Eager */
);
Ge(
  Qo,
  uq,
  0
  /* InstantiationType.Eager */
);
Ge(
  ss,
  dS,
  0
  /* InstantiationType.Eager */
);
Ge(
  Ai,
  Ad,
  0
  /* InstantiationType.Eager */
);
Ge(
  Vb,
  Qy,
  0
  /* InstantiationType.Eager */
);
Ge(
  Pg,
  pS,
  0
  /* InstantiationType.Eager */
);
Ge(
  Og,
  vy,
  0
  /* InstantiationType.Eager */
);
Ge(
  fx,
  oS,
  0
  /* InstantiationType.Eager */
);
Ge(
  ea,
  _S,
  0
  /* InstantiationType.Eager */
);
Ge(
  Rc,
  tS,
  0
  /* InstantiationType.Eager */
);
Ge(
  Zb,
  Pj,
  0
  /* InstantiationType.Eager */
);
Ge(
  o4,
  Lj,
  0
  /* InstantiationType.Eager */
);
var fe;
(function(s) {
  const e = new jd();
  for (const [l, c] of XD())
    e.set(l, c);
  const t = new D_(e, !0);
  e.set(ot, t);
  function i(l) {
    n || r({});
    const c = e.get(l);
    if (!c)
      throw new Error("Missing service " + l);
    return c instanceof Ro ? t.invokeFunction((h) => h.get(l)) : c;
  }
  s.get = i;
  let n = !1;
  const o = new O();
  function r(l) {
    if (n)
      return t;
    n = !0;
    for (const [h, d] of XD())
      e.get(h) || e.set(h, d);
    for (const h in l)
      if (l.hasOwnProperty(h)) {
        const d = Ve(h);
        e.get(d) instanceof Ro && e.set(d, l[h]);
      }
    const c = Sj();
    for (const h of c)
      try {
        t.createInstance(h);
      } catch (d) {
        ht(d);
      }
    return o.fire(), t;
  }
  s.initialize = r;
  function a(l) {
    if (n)
      return l();
    const c = new he(), h = c.add(o.event(() => {
      h.dispose(), c.add(l());
    }));
    return c;
  }
  s.withServices = a;
})(fe || (fe = {}));
function Oj(s, e) {
  return new Fj(s, e);
}
class Fj extends Vp {
  constructor(e, t) {
    const i = {
      amdModuleId: bS.amdModuleId,
      esmModuleLocation: bS.esmModuleLocation,
      label: t.label
    };
    super(i, t.keepIdleModels || !1, e), this._foreignModuleId = t.moduleId, this._foreignModuleCreateData = t.createData || null, this._foreignModuleHost = t.host || null, this._foreignProxy = null;
  }
  // foreign host request
  fhr(e, t) {
    if (!this._foreignModuleHost || typeof this._foreignModuleHost[e] != "function")
      return Promise.reject(new Error("Missing method " + e + " or missing main thread foreign host."));
    try {
      return Promise.resolve(this._foreignModuleHost[e].apply(this._foreignModuleHost, t));
    } catch (i) {
      return Promise.reject(i);
    }
  }
  _getForeignProxy() {
    return this._foreignProxy || (this._foreignProxy = this._getProxy().then((e) => {
      const t = this._foreignModuleHost ? NC(this._foreignModuleHost) : [];
      return e.$loadForeignModule(this._foreignModuleId, this._foreignModuleCreateData, t).then((i) => {
        this._foreignModuleCreateData = null;
        const n = (a, l) => e.$fmr(a, l), o = (a, l) => function() {
          const c = Array.prototype.slice.call(arguments, 0);
          return l(a, c);
        }, r = {};
        for (const a of i)
          r[a] = o(a, n);
        return r;
      });
    })), this._foreignProxy;
  }
  getProxy() {
    return this._getForeignProxy();
  }
  withSyncedResources(e) {
    return this.workerWithSyncedResources(e).then((t) => this.getProxy());
  }
}
const mx = {
  ICodeEditor: "vs.editor.ICodeEditor",
  IDiffEditor: "vs.editor.IDiffEditor"
};
class Ns {
  constructor(e, t, i, n) {
    this.startColumn = e, this.endColumn = t, this.className = i, this.type = n, this._lineDecorationBrand = void 0;
  }
  static _equals(e, t) {
    return e.startColumn === t.startColumn && e.endColumn === t.endColumn && e.className === t.className && e.type === t.type;
  }
  static equalsArr(e, t) {
    const i = e.length, n = t.length;
    if (i !== n)
      return !1;
    for (let o = 0; o < i; o++)
      if (!Ns._equals(e[o], t[o]))
        return !1;
    return !0;
  }
  static extractWrapped(e, t, i) {
    if (e.length === 0)
      return e;
    const n = t + 1, o = i + 1, r = i - t, a = [];
    let l = 0;
    for (const c of e)
      c.endColumn <= n || c.startColumn >= o || (a[l++] = new Ns(Math.max(1, c.startColumn - n + 1), Math.min(r + 1, c.endColumn - n + 1), c.className, c.type));
    return a;
  }
  static filter(e, t, i, n) {
    if (e.length === 0)
      return [];
    const o = [];
    let r = 0;
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a], h = c.range;
      if (h.endLineNumber < t || h.startLineNumber > t || h.isEmpty() && (c.type === 0 || c.type === 3))
        continue;
      const d = h.startLineNumber === t ? h.startColumn : i, u = h.endLineNumber === t ? h.endColumn : n;
      o[r++] = new Ns(d, u, c.inlineClassName, c.type);
    }
    return o;
  }
  static _typeCompare(e, t) {
    const i = [2, 0, 1, 3];
    return i[e] - i[t];
  }
  static compare(e, t) {
    if (e.startColumn !== t.startColumn)
      return e.startColumn - t.startColumn;
    if (e.endColumn !== t.endColumn)
      return e.endColumn - t.endColumn;
    const i = Ns._typeCompare(e.type, t.type);
    return i !== 0 ? i : e.className !== t.className ? e.className < t.className ? -1 : 1 : 0;
  }
}
class JN {
  constructor(e, t, i, n) {
    this.startOffset = e, this.endOffset = t, this.className = i, this.metadata = n;
  }
}
class N_ {
  constructor() {
    this.stopOffsets = [], this.classNames = [], this.metadata = [], this.count = 0;
  }
  static _metadata(e) {
    let t = 0;
    for (let i = 0, n = e.length; i < n; i++)
      t |= e[i];
    return t;
  }
  consumeLowerThan(e, t, i) {
    for (; this.count > 0 && this.stopOffsets[0] < e; ) {
      let n = 0;
      for (; n + 1 < this.count && this.stopOffsets[n] === this.stopOffsets[n + 1]; )
        n++;
      i.push(new JN(t, this.stopOffsets[n], this.classNames.join(" "), N_._metadata(this.metadata))), t = this.stopOffsets[n] + 1, this.stopOffsets.splice(0, n + 1), this.classNames.splice(0, n + 1), this.metadata.splice(0, n + 1), this.count -= n + 1;
    }
    return this.count > 0 && t < e && (i.push(new JN(t, e - 1, this.classNames.join(" "), N_._metadata(this.metadata))), t = e), t;
  }
  insert(e, t, i) {
    if (this.count === 0 || this.stopOffsets[this.count - 1] <= e)
      this.stopOffsets.push(e), this.classNames.push(t), this.metadata.push(i);
    else
      for (let n = 0; n < this.count; n++)
        if (this.stopOffsets[n] >= e) {
          this.stopOffsets.splice(n, 0, e), this.classNames.splice(n, 0, t), this.metadata.splice(n, 0, i);
          break;
        }
    this.count++;
  }
}
class Bj {
  /**
   * Normalize line decorations. Overlapping decorations will generate multiple segments
   */
  static normalize(e, t) {
    if (t.length === 0)
      return [];
    const i = [], n = new N_();
    let o = 0;
    for (let r = 0, a = t.length; r < a; r++) {
      const l = t[r];
      let c = l.startColumn, h = l.endColumn;
      const d = l.className, u = l.type === 1 ? 2 : l.type === 2 ? 4 : 0;
      if (c > 1) {
        const m = e.charCodeAt(c - 2);
        hi(m) && c--;
      }
      if (h > 1) {
        const m = e.charCodeAt(h - 2);
        hi(m) && h--;
      }
      const f = c - 1, g = h - 2;
      o = n.consumeLowerThan(f, o, i), n.count === 0 && (o = f), n.insert(g, d, u);
    }
    return n.consumeLowerThan(1073741824, o, i), i;
  }
}
class di {
  constructor(e, t, i, n) {
    this.endIndex = e, this.type = t, this.metadata = i, this.containsRTL = n, this._linePartBrand = void 0;
  }
  isWhitespace() {
    return !!(this.metadata & 1);
  }
  isPseudoAfter() {
    return !!(this.metadata & 4);
  }
}
class z4 {
  constructor(e, t) {
    this.startOffset = e, this.endOffset = t;
  }
  equals(e) {
    return this.startOffset === e.startOffset && this.endOffset === e.endOffset;
  }
}
class Gd {
  constructor(e, t, i, n, o, r, a, l, c, h, d, u, f, g, m, _, b, C, v) {
    this.useMonospaceOptimizations = e, this.canUseHalfwidthRightwardsArrow = t, this.lineContent = i, this.continuesWithWrappedLine = n, this.isBasicASCII = o, this.containsRTL = r, this.fauxIndentLength = a, this.lineTokens = l, this.lineDecorations = c.sort(Ns.compare), this.tabSize = h, this.startVisibleColumn = d, this.spaceWidth = u, this.stopRenderingLineAfter = m, this.renderWhitespace = _ === "all" ? 4 : _ === "boundary" ? 1 : _ === "selection" ? 2 : _ === "trailing" ? 3 : 0, this.renderControlCharacters = b, this.fontLigatures = C, this.selectionsOnLine = v && v.sort((L, k) => L.startOffset < k.startOffset ? -1 : 1);
    const w = Math.abs(g - u), S = Math.abs(f - u);
    w < S ? (this.renderSpaceWidth = g, this.renderSpaceCharCode = 11825) : (this.renderSpaceWidth = f, this.renderSpaceCharCode = 183);
  }
  sameSelection(e) {
    if (this.selectionsOnLine === null)
      return e === null;
    if (e === null || e.length !== this.selectionsOnLine.length)
      return !1;
    for (let t = 0; t < this.selectionsOnLine.length; t++)
      if (!this.selectionsOnLine[t].equals(e[t]))
        return !1;
    return !0;
  }
  equals(e) {
    return this.useMonospaceOptimizations === e.useMonospaceOptimizations && this.canUseHalfwidthRightwardsArrow === e.canUseHalfwidthRightwardsArrow && this.lineContent === e.lineContent && this.continuesWithWrappedLine === e.continuesWithWrappedLine && this.isBasicASCII === e.isBasicASCII && this.containsRTL === e.containsRTL && this.fauxIndentLength === e.fauxIndentLength && this.tabSize === e.tabSize && this.startVisibleColumn === e.startVisibleColumn && this.spaceWidth === e.spaceWidth && this.renderSpaceWidth === e.renderSpaceWidth && this.renderSpaceCharCode === e.renderSpaceCharCode && this.stopRenderingLineAfter === e.stopRenderingLineAfter && this.renderWhitespace === e.renderWhitespace && this.renderControlCharacters === e.renderControlCharacters && this.fontLigatures === e.fontLigatures && Ns.equalsArr(this.lineDecorations, e.lineDecorations) && this.lineTokens.equals(e.lineTokens) && this.sameSelection(e.selectionsOnLine);
  }
}
class U4 {
  constructor(e, t) {
    this.partIndex = e, this.charIndex = t;
  }
}
class Po {
  static getPartIndex(e) {
    return (e & 4294901760) >>> 16;
  }
  static getCharIndex(e) {
    return (e & 65535) >>> 0;
  }
  constructor(e, t) {
    this.length = e, this._data = new Uint32Array(this.length), this._horizontalOffset = new Uint32Array(this.length);
  }
  setColumnInfo(e, t, i, n) {
    const o = (t << 16 | i << 0) >>> 0;
    this._data[e - 1] = o, this._horizontalOffset[e - 1] = n;
  }
  getHorizontalOffset(e) {
    return this._horizontalOffset.length === 0 ? 0 : this._horizontalOffset[e - 1];
  }
  charOffsetToPartData(e) {
    return this.length === 0 ? 0 : e < 0 ? this._data[0] : e >= this.length ? this._data[this.length - 1] : this._data[e];
  }
  getDomPosition(e) {
    const t = this.charOffsetToPartData(e - 1), i = Po.getPartIndex(t), n = Po.getCharIndex(t);
    return new U4(i, n);
  }
  getColumn(e, t) {
    return this.partDataToCharOffset(e.partIndex, t, e.charIndex) + 1;
  }
  partDataToCharOffset(e, t, i) {
    if (this.length === 0)
      return 0;
    const n = (e << 16 | i << 0) >>> 0;
    let o = 0, r = this.length - 1;
    for (; o + 1 < r; ) {
      const m = o + r >>> 1, _ = this._data[m];
      if (_ === n)
        return m;
      _ > n ? r = m : o = m;
    }
    if (o === r)
      return o;
    const a = this._data[o], l = this._data[r];
    if (a === n)
      return o;
    if (l === n)
      return r;
    const c = Po.getPartIndex(a), h = Po.getCharIndex(a), d = Po.getPartIndex(l);
    let u;
    c !== d ? u = t : u = Po.getCharIndex(l);
    const f = i - h, g = u - i;
    return f <= g ? o : r;
  }
}
class wS {
  constructor(e, t, i) {
    this._renderLineOutputBrand = void 0, this.characterMapping = e, this.containsRTL = t, this.containsForeignElements = i;
  }
}
function px(s, e) {
  if (s.lineContent.length === 0) {
    if (s.lineDecorations.length > 0) {
      e.appendString("<span>");
      let t = 0, i = 0, n = 0;
      for (const r of s.lineDecorations)
        (r.type === 1 || r.type === 2) && (e.appendString('<span class="'), e.appendString(r.className), e.appendString('"></span>'), r.type === 1 && (n |= 1, t++), r.type === 2 && (n |= 2, i++));
      e.appendString("</span>");
      const o = new Po(1, t + i);
      return o.setColumnInfo(1, t, 0, 0), new wS(o, !1, n);
    }
    return e.appendString("<span><span></span></span>"), new wS(
      new Po(0, 0),
      !1,
      0
      /* ForeignElementType.None */
    );
  }
  return jj(Hj(s), e);
}
class Wj {
  constructor(e, t, i, n) {
    this.characterMapping = e, this.html = t, this.containsRTL = i, this.containsForeignElements = n;
  }
}
function Yb(s) {
  const e = new bb(1e4), t = px(s, e);
  return new Wj(t.characterMapping, e.build(), t.containsRTL, t.containsForeignElements);
}
class Vj {
  constructor(e, t, i, n, o, r, a, l, c, h, d, u, f, g, m, _) {
    this.fontIsMonospace = e, this.canUseHalfwidthRightwardsArrow = t, this.lineContent = i, this.len = n, this.isOverflowing = o, this.overflowingCharCount = r, this.parts = a, this.containsForeignElements = l, this.fauxIndentLength = c, this.tabSize = h, this.startVisibleColumn = d, this.containsRTL = u, this.spaceWidth = f, this.renderSpaceCharCode = g, this.renderWhitespace = m, this.renderControlCharacters = _;
  }
}
function Hj(s) {
  const e = s.lineContent;
  let t, i, n;
  s.stopRenderingLineAfter !== -1 && s.stopRenderingLineAfter < e.length ? (t = !0, i = e.length - s.stopRenderingLineAfter, n = s.stopRenderingLineAfter) : (t = !1, i = 0, n = e.length);
  let o = zj(e, s.containsRTL, s.lineTokens, s.fauxIndentLength, n);
  s.renderControlCharacters && !s.isBasicASCII && (o = $j(e, o)), (s.renderWhitespace === 4 || s.renderWhitespace === 1 || s.renderWhitespace === 2 && s.selectionsOnLine || s.renderWhitespace === 3 && !s.continuesWithWrappedLine) && (o = Kj(s, e, n, o));
  let r = 0;
  if (s.lineDecorations.length > 0) {
    for (let a = 0, l = s.lineDecorations.length; a < l; a++) {
      const c = s.lineDecorations[a];
      c.type === 3 || c.type === 1 ? r |= 1 : c.type === 2 && (r |= 2);
    }
    o = qj(e, n, o, s.lineDecorations);
  }
  return s.containsRTL || (o = Uj(e, o, !s.isBasicASCII || s.fontLigatures)), new Vj(s.useMonospaceOptimizations, s.canUseHalfwidthRightwardsArrow, e, n, t, i, o, r, s.fauxIndentLength, s.tabSize, s.startVisibleColumn, s.containsRTL, s.spaceWidth, s.renderSpaceCharCode, s.renderWhitespace, s.renderControlCharacters);
}
function zj(s, e, t, i, n) {
  const o = [];
  let r = 0;
  i > 0 && (o[r++] = new di(i, "", 0, !1));
  let a = i;
  for (let l = 0, c = t.getCount(); l < c; l++) {
    const h = t.getEndOffset(l);
    if (h <= i)
      continue;
    const d = t.getClassName(l);
    if (h >= n) {
      const f = e ? Af(s.substring(a, n)) : !1;
      o[r++] = new di(n, d, 0, f);
      break;
    }
    const u = e ? Af(s.substring(a, h)) : !1;
    o[r++] = new di(h, d, 0, u), a = h;
  }
  return o;
}
function Uj(s, e, t) {
  let i = 0;
  const n = [];
  let o = 0;
  if (t)
    for (let r = 0, a = e.length; r < a; r++) {
      const l = e[r], c = l.endIndex;
      if (i + 50 < c) {
        const h = l.type, d = l.metadata, u = l.containsRTL;
        let f = -1, g = i;
        for (let m = i; m < c; m++)
          s.charCodeAt(m) === 32 && (f = m), f !== -1 && m - g >= 50 && (n[o++] = new di(f + 1, h, d, u), g = f + 1, f = -1);
        g !== c && (n[o++] = new di(c, h, d, u));
      } else
        n[o++] = l;
      i = c;
    }
  else
    for (let r = 0, a = e.length; r < a; r++) {
      const l = e[r], c = l.endIndex, h = c - i;
      if (h > 50) {
        const d = l.type, u = l.metadata, f = l.containsRTL, g = Math.ceil(
          h / 50
          /* Constants.LongToken */
        );
        for (let m = 1; m < g; m++) {
          const _ = i + m * 50;
          n[o++] = new di(_, d, u, f);
        }
        n[o++] = new di(c, d, u, f);
      } else
        n[o++] = l;
      i = c;
    }
  return n;
}
function $4(s) {
  return s < 32 ? s !== 9 : s === 127 || s >= 8234 && s <= 8238 || s >= 8294 && s <= 8297 || s >= 8206 && s <= 8207 || s === 1564;
}
function $j(s, e) {
  const t = [];
  let i = new di(0, "", 0, !1), n = 0;
  for (const o of e) {
    const r = o.endIndex;
    for (; n < r; n++) {
      const a = s.charCodeAt(n);
      $4(a) && (n > i.endIndex && (i = new di(n, o.type, o.metadata, o.containsRTL), t.push(i)), i = new di(n + 1, "mtkcontrol", o.metadata, !1), t.push(i));
    }
    n > i.endIndex && (i = new di(r, o.type, o.metadata, o.containsRTL), t.push(i));
  }
  return t;
}
function Kj(s, e, t, i) {
  const n = s.continuesWithWrappedLine, o = s.fauxIndentLength, r = s.tabSize, a = s.startVisibleColumn, l = s.useMonospaceOptimizations, c = s.selectionsOnLine, h = s.renderWhitespace === 1, d = s.renderWhitespace === 3, u = s.renderSpaceWidth !== s.spaceWidth, f = [];
  let g = 0, m = 0, _ = i[m].type, b = i[m].containsRTL, C = i[m].endIndex;
  const v = i.length;
  let w = !1, S = On(e), L;
  S === -1 ? (w = !0, S = t, L = t) : L = Ec(e);
  let k = !1, D = 0, E = c && c[D], U = a % r;
  for (let B = o; B < t; B++) {
    const W = e.charCodeAt(B);
    E && B >= E.endOffset && (D++, E = c && c[D]);
    let A;
    if (B < S || B > L)
      A = !0;
    else if (W === 9)
      A = !0;
    else if (W === 32)
      if (h)
        if (k)
          A = !0;
        else {
          const K = B + 1 < t ? e.charCodeAt(B + 1) : 0;
          A = K === 32 || K === 9;
        }
      else
        A = !0;
    else
      A = !1;
    if (A && c && (A = !!E && E.startOffset <= B && E.endOffset > B), A && d && (A = w || B > L), A && b && B >= S && B <= L && (A = !1), k) {
      if (!A || !l && U >= r) {
        if (u) {
          const K = g > 0 ? f[g - 1].endIndex : o;
          for (let Y = K + 1; Y <= B; Y++)
            f[g++] = new di(Y, "mtkw", 1, !1);
        } else
          f[g++] = new di(B, "mtkw", 1, !1);
        U = U % r;
      }
    } else
      (B === C || A && B > o) && (f[g++] = new di(B, _, 0, b), U = U % r);
    for (W === 9 ? U = r : za(W) ? U += 2 : U++, k = A; B === C && (m++, m < v); )
      _ = i[m].type, b = i[m].containsRTL, C = i[m].endIndex;
  }
  let P = !1;
  if (k)
    if (n && h) {
      const B = t > 0 ? e.charCodeAt(t - 1) : 0, W = t > 1 ? e.charCodeAt(t - 2) : 0;
      B === 32 && W !== 32 && W !== 9 || (P = !0);
    } else
      P = !0;
  if (P)
    if (u) {
      const B = g > 0 ? f[g - 1].endIndex : o;
      for (let W = B + 1; W <= t; W++)
        f[g++] = new di(W, "mtkw", 1, !1);
    } else
      f[g++] = new di(t, "mtkw", 1, !1);
  else
    f[g++] = new di(t, _, 0, b);
  return f;
}
function qj(s, e, t, i) {
  i.sort(Ns.compare);
  const n = Bj.normalize(s, i), o = n.length;
  let r = 0;
  const a = [];
  let l = 0, c = 0;
  for (let d = 0, u = t.length; d < u; d++) {
    const f = t[d], g = f.endIndex, m = f.type, _ = f.metadata, b = f.containsRTL;
    for (; r < o && n[r].startOffset < g; ) {
      const C = n[r];
      if (C.startOffset > c && (c = C.startOffset, a[l++] = new di(c, m, _, b)), C.endOffset + 1 <= g)
        c = C.endOffset + 1, a[l++] = new di(c, m + " " + C.className, _ | C.metadata, b), r++;
      else {
        c = g, a[l++] = new di(c, m + " " + C.className, _ | C.metadata, b);
        break;
      }
    }
    g > c && (c = g, a[l++] = new di(c, m, _, b));
  }
  const h = t[t.length - 1].endIndex;
  if (r < o && n[r].startOffset === h)
    for (; r < o && n[r].startOffset === h; ) {
      const d = n[r];
      a[l++] = new di(c, d.className, d.metadata, !1), r++;
    }
  return a;
}
function jj(s, e) {
  const t = s.fontIsMonospace, i = s.canUseHalfwidthRightwardsArrow, n = s.containsForeignElements, o = s.lineContent, r = s.len, a = s.isOverflowing, l = s.overflowingCharCount, c = s.parts, h = s.fauxIndentLength, d = s.tabSize, u = s.startVisibleColumn, f = s.containsRTL, g = s.spaceWidth, m = s.renderSpaceCharCode, _ = s.renderWhitespace, b = s.renderControlCharacters, C = new Po(r + 1, c.length);
  let v = !1, w = 0, S = u, L = 0, k = 0, D = 0;
  f ? e.appendString('<span dir="ltr">') : e.appendString("<span>");
  for (let E = 0, U = c.length; E < U; E++) {
    const P = c[E], B = P.endIndex, W = P.type, A = P.containsRTL, K = _ !== 0 && P.isWhitespace(), Y = K && !t && (W === "mtkw" || !n), Q = w === B && P.isPseudoAfter();
    if (L = 0, e.appendString("<span "), A && e.appendString('style="unicode-bidi:isolate" '), e.appendString('class="'), e.appendString(Y ? "mtkz" : W), e.appendASCIICharCode(
      34
      /* CharCode.DoubleQuote */
    ), K) {
      let ne = 0;
      {
        let ie = w, me = S;
        for (; ie < B; ie++) {
          const vt = (o.charCodeAt(ie) === 9 ? d - me % d : 1) | 0;
          ne += vt, ie >= h && (me += vt);
        }
      }
      for (Y && (e.appendString(' style="width:'), e.appendString(String(g * ne)), e.appendString('px"')), e.appendASCIICharCode(
        62
        /* CharCode.GreaterThan */
      ); w < B; w++) {
        C.setColumnInfo(w + 1, E - D, L, k), D = 0;
        const ie = o.charCodeAt(w);
        let me, _e;
        if (ie === 9) {
          me = d - S % d | 0, _e = me, !i || _e > 1 ? e.appendCharCode(8594) : e.appendCharCode(65515);
          for (let vt = 2; vt <= _e; vt++)
            e.appendCharCode(160);
        } else
          me = 2, _e = 1, e.appendCharCode(m), e.appendCharCode(8204);
        L += me, k += _e, w >= h && (S += _e);
      }
    } else
      for (e.appendASCIICharCode(
        62
        /* CharCode.GreaterThan */
      ); w < B; w++) {
        C.setColumnInfo(w + 1, E - D, L, k), D = 0;
        const ne = o.charCodeAt(w);
        let ie = 1, me = 1;
        switch (ne) {
          case 9:
            ie = d - S % d, me = ie;
            for (let _e = 1; _e <= ie; _e++)
              e.appendCharCode(160);
            break;
          case 32:
            e.appendCharCode(160);
            break;
          case 60:
            e.appendString("&lt;");
            break;
          case 62:
            e.appendString("&gt;");
            break;
          case 38:
            e.appendString("&amp;");
            break;
          case 0:
            b ? e.appendCharCode(9216) : e.appendString("&#00;");
            break;
          case 65279:
          case 8232:
          case 8233:
          case 133:
            e.appendCharCode(65533);
            break;
          default:
            za(ne) && me++, b && ne < 32 ? e.appendCharCode(9216 + ne) : b && ne === 127 ? e.appendCharCode(9249) : b && $4(ne) ? (e.appendString("[U+"), e.appendString(Gj(ne)), e.appendString("]"), ie = 8, me = ie) : e.appendCharCode(ne);
        }
        L += ie, k += me, w >= h && (S += me);
      }
    Q ? D++ : D = 0, w >= r && !v && P.isPseudoAfter() && (v = !0, C.setColumnInfo(w + 1, E, L, k)), e.appendString("</span>");
  }
  return v || C.setColumnInfo(r + 1, c.length - 1, L, k), a && (e.appendString('<span class="mtkoverflow">'), e.appendString(p("showMore", "Show more ({0})", Zj(l))), e.appendString("</span>")), e.appendString("</span>"), new wS(C, f, n);
}
function Gj(s) {
  return s.toString(16).toUpperCase().padStart(4, "0");
}
function Zj(s) {
  return s < 1024 ? p("overflow.chars", "{0} chars", s) : s < 1024 * 1024 ? `${(s / 1024).toFixed(1)} KB` : `${(s / 1024 / 1024).toFixed(1)} MB`;
}
class eT {
  constructor(e, t, i, n) {
    this._viewportBrand = void 0, this.top = e | 0, this.left = t | 0, this.width = i | 0, this.height = n | 0;
  }
}
class Yj {
  constructor(e, t) {
    this.tabSize = e, this.data = t;
  }
}
class _x {
  constructor(e, t, i, n, o, r, a) {
    this._viewLineDataBrand = void 0, this.content = e, this.continuesWithWrappedLine = t, this.minColumn = i, this.maxColumn = n, this.startVisibleColumn = o, this.tokens = r, this.inlineDecorations = a;
  }
}
class ns {
  constructor(e, t, i, n, o, r, a, l, c, h) {
    this.minColumn = e, this.maxColumn = t, this.content = i, this.continuesWithWrappedLine = n, this.isBasicASCII = ns.isBasicASCII(i, r), this.containsRTL = ns.containsRTL(i, this.isBasicASCII, o), this.tokens = a, this.inlineDecorations = l, this.tabSize = c, this.startVisibleColumn = h;
  }
  static isBasicASCII(e, t) {
    return t ? ML(e) : !0;
  }
  static containsRTL(e, t, i) {
    return !t && i ? Af(e) : !1;
  }
}
class rf {
  constructor(e, t, i) {
    this.range = e, this.inlineClassName = t, this.type = i;
  }
}
class Qj {
  constructor(e, t, i, n) {
    this.startOffset = e, this.endOffset = t, this.inlineClassName = i, this.inlineClassNameAffectsLetterSpacing = n;
  }
  toInlineDecoration(e) {
    return new rf(
      new R(e, this.startOffset + 1, e, this.endOffset + 1),
      this.inlineClassName,
      this.inlineClassNameAffectsLetterSpacing ? 3 : 0
      /* InlineDecorationType.Regular */
    );
  }
}
class K4 {
  constructor(e, t) {
    this._viewModelDecorationBrand = void 0, this.range = e, this.options = t;
  }
}
class lg {
  constructor(e, t, i) {
    this.color = e, this.zIndex = t, this.data = i;
  }
  static compareByRenderingProps(e, t) {
    return e.zIndex === t.zIndex ? e.color < t.color ? -1 : e.color > t.color ? 1 : 0 : e.zIndex - t.zIndex;
  }
  static equals(e, t) {
    return e.color === t.color && e.zIndex === t.zIndex && oi(e.data, t.data);
  }
  static equalsArr(e, t) {
    return oi(e, t, lg.equals);
  }
}
function Xj(s) {
  return Array.isArray(s);
}
function Jj(s) {
  return !Xj(s);
}
function q4(s) {
  return typeof s == "string";
}
function tT(s) {
  return !q4(s);
}
function Ml(s) {
  return !s;
}
function qr(s, e) {
  return s.ignoreCase && e ? e.toLowerCase() : e;
}
function iT(s) {
  return s.replace(/[&<>'"_]/g, "-");
}
function eG(s, e) {
  console.log(`${s.languageId}: ${e}`);
}
function St(s, e) {
  return new Error(`${s.languageId}: ${e}`);
}
function ya(s, e, t, i, n) {
  const o = /\$((\$)|(#)|(\d\d?)|[sS](\d\d?)|@(\w+))/g;
  let r = null;
  return e.replace(o, function(a, l, c, h, d, u, f, g, m) {
    return Ml(c) ? Ml(h) ? !Ml(d) && d < i.length ? qr(s, i[d]) : !Ml(f) && s && typeof s[f] == "string" ? s[f] : (r === null && (r = n.split("."), r.unshift(n)), !Ml(u) && u < r.length ? qr(s, r[u]) : "") : qr(s, t) : "$";
  });
}
function tG(s, e, t) {
  const i = /\$[sS](\d\d?)/g;
  let n = null;
  return e.replace(i, function(o, r) {
    return n === null && (n = t.split("."), n.unshift(t)), !Ml(r) && r < n.length ? qr(s, n[r]) : "";
  });
}
function Rm(s, e) {
  let t = e;
  for (; t && t.length > 0; ) {
    const i = s.tokenizer[t];
    if (i)
      return i;
    const n = t.lastIndexOf(".");
    n < 0 ? t = null : t = t.substr(0, n);
  }
  return null;
}
function iG(s, e) {
  let t = e;
  for (; t && t.length > 0; ) {
    if (s.stateNames[t])
      return !0;
    const n = t.lastIndexOf(".");
    n < 0 ? t = null : t = t.substr(0, n);
  }
  return !1;
}
var nG = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, sG = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, vS;
const j4 = 5, P1 = class P1 {
  static create(e, t) {
    return this._INSTANCE.create(e, t);
  }
  constructor(e) {
    this._maxCacheDepth = e, this._entries = /* @__PURE__ */ Object.create(null);
  }
  create(e, t) {
    if (e !== null && e.depth >= this._maxCacheDepth)
      return new rd(e, t);
    let i = rd.getStackElementId(e);
    i.length > 0 && (i += "|"), i += t;
    let n = this._entries[i];
    return n || (n = new rd(e, t), this._entries[i] = n, n);
  }
};
P1._INSTANCE = new P1(j4);
let cg = P1;
class rd {
  constructor(e, t) {
    this.parent = e, this.state = t, this.depth = (this.parent ? this.parent.depth : 0) + 1;
  }
  static getStackElementId(e) {
    let t = "";
    for (; e !== null; )
      t.length > 0 && (t += "|"), t += e.state, e = e.parent;
    return t;
  }
  static _equals(e, t) {
    for (; e !== null && t !== null; ) {
      if (e === t)
        return !0;
      if (e.state !== t.state)
        return !1;
      e = e.parent, t = t.parent;
    }
    return e === null && t === null;
  }
  equals(e) {
    return rd._equals(this, e);
  }
  push(e) {
    return cg.create(this, e);
  }
  pop() {
    return this.parent;
  }
  popall() {
    let e = this;
    for (; e.parent; )
      e = e.parent;
    return e;
  }
  switchTo(e) {
    return cg.create(this.parent, e);
  }
}
class Lh {
  constructor(e, t) {
    this.languageId = e, this.state = t;
  }
  equals(e) {
    return this.languageId === e.languageId && this.state.equals(e.state);
  }
  clone() {
    return this.state.clone() === this.state ? this : new Lh(this.languageId, this.state);
  }
}
const O1 = class O1 {
  static create(e, t) {
    return this._INSTANCE.create(e, t);
  }
  constructor(e) {
    this._maxCacheDepth = e, this._entries = /* @__PURE__ */ Object.create(null);
  }
  create(e, t) {
    if (t !== null)
      return new af(e, t);
    if (e !== null && e.depth >= this._maxCacheDepth)
      return new af(e, t);
    const i = rd.getStackElementId(e);
    let n = this._entries[i];
    return n || (n = new af(e, null), this._entries[i] = n, n);
  }
};
O1._INSTANCE = new O1(j4);
let Sa = O1;
class af {
  constructor(e, t) {
    this.stack = e, this.embeddedLanguageData = t;
  }
  clone() {
    return (this.embeddedLanguageData ? this.embeddedLanguageData.clone() : null) === this.embeddedLanguageData ? this : Sa.create(this.stack, this.embeddedLanguageData);
  }
  equals(e) {
    return !(e instanceof af) || !this.stack.equals(e.stack) ? !1 : this.embeddedLanguageData === null && e.embeddedLanguageData === null ? !0 : this.embeddedLanguageData === null || e.embeddedLanguageData === null ? !1 : this.embeddedLanguageData.equals(e.embeddedLanguageData);
  }
}
class oG {
  constructor() {
    this._tokens = [], this._languageId = null, this._lastTokenType = null, this._lastTokenLanguage = null;
  }
  enterLanguage(e) {
    this._languageId = e;
  }
  emit(e, t) {
    this._lastTokenType === t && this._lastTokenLanguage === this._languageId || (this._lastTokenType = t, this._lastTokenLanguage = this._languageId, this._tokens.push(new Rf(e, t, this._languageId)));
  }
  nestedLanguageTokenize(e, t, i, n) {
    const o = i.languageId, r = i.state, a = Yt.get(o);
    if (!a)
      return this.enterLanguage(o), this.emit(n, ""), r;
    const l = a.tokenize(e, t, r);
    if (n !== 0)
      for (const c of l.tokens)
        this._tokens.push(new Rf(c.offset + n, c.type, c.language));
    else
      this._tokens = this._tokens.concat(l.tokens);
    return this._lastTokenType = null, this._lastTokenLanguage = null, this._languageId = null, l.endState;
  }
  finalize(e) {
    return new xL(this._tokens, e);
  }
}
class T_ {
  constructor(e, t) {
    this._languageService = e, this._theme = t, this._prependTokens = null, this._tokens = [], this._currentLanguageId = 0, this._lastTokenMetadata = 0;
  }
  enterLanguage(e) {
    this._currentLanguageId = this._languageService.languageIdCodec.encodeLanguageId(e);
  }
  emit(e, t) {
    const i = this._theme.match(this._currentLanguageId, t) | 1024;
    this._lastTokenMetadata !== i && (this._lastTokenMetadata = i, this._tokens.push(e), this._tokens.push(i));
  }
  static _merge(e, t, i) {
    const n = e !== null ? e.length : 0, o = t.length, r = i !== null ? i.length : 0;
    if (n === 0 && o === 0 && r === 0)
      return new Uint32Array(0);
    if (n === 0 && o === 0)
      return i;
    if (o === 0 && r === 0)
      return e;
    const a = new Uint32Array(n + o + r);
    e !== null && a.set(e);
    for (let l = 0; l < o; l++)
      a[n + l] = t[l];
    return i !== null && a.set(i, n + o), a;
  }
  nestedLanguageTokenize(e, t, i, n) {
    const o = i.languageId, r = i.state, a = Yt.get(o);
    if (!a)
      return this.enterLanguage(o), this.emit(n, ""), r;
    const l = a.tokenizeEncoded(e, t, r);
    if (n !== 0)
      for (let c = 0, h = l.tokens.length; c < h; c += 2)
        l.tokens[c] += n;
    return this._prependTokens = T_._merge(this._prependTokens, this._tokens, l.tokens), this._tokens = [], this._currentLanguageId = 0, this._lastTokenMetadata = 0, l.endState;
  }
  finalize(e) {
    return new tb(T_._merge(this._prependTokens, this._tokens, null), e);
  }
}
let hg = vS = class extends q {
  constructor(e, t, i, n, o) {
    super(), this._configurationService = o, this._languageService = e, this._standaloneThemeService = t, this._languageId = i, this._lexer = n, this._embeddedLanguages = /* @__PURE__ */ Object.create(null), this.embeddedLoaded = Promise.resolve(void 0);
    let r = !1;
    this._register(Yt.onDidChange((a) => {
      if (r)
        return;
      let l = !1;
      for (let c = 0, h = a.changedLanguages.length; c < h; c++) {
        const d = a.changedLanguages[c];
        if (this._embeddedLanguages[d]) {
          l = !0;
          break;
        }
      }
      l && (r = !0, Yt.handleChange([this._languageId]), r = !1);
    })), this._maxTokenizationLineLength = this._configurationService.getValue("editor.maxTokenizationLineLength", {
      overrideIdentifier: this._languageId
    }), this._register(this._configurationService.onDidChangeConfiguration((a) => {
      a.affectsConfiguration("editor.maxTokenizationLineLength") && (this._maxTokenizationLineLength = this._configurationService.getValue("editor.maxTokenizationLineLength", {
        overrideIdentifier: this._languageId
      }));
    }));
  }
  getLoadStatus() {
    const e = [];
    for (const t in this._embeddedLanguages) {
      const i = Yt.get(t);
      if (i) {
        if (i instanceof vS) {
          const n = i.getLoadStatus();
          n.loaded === !1 && e.push(n.promise);
        }
        continue;
      }
      Yt.isResolved(t) || e.push(Yt.getOrCreate(t));
    }
    return e.length === 0 ? {
      loaded: !0
    } : {
      loaded: !1,
      promise: Promise.all(e).then((t) => {
      })
    };
  }
  getInitialState() {
    const e = cg.create(null, this._lexer.start);
    return Sa.create(e, null);
  }
  tokenize(e, t, i) {
    if (e.length >= this._maxTokenizationLineLength)
      return cA(this._languageId, i);
    const n = new oG(), o = this._tokenize(e, t, i, n);
    return n.finalize(o);
  }
  tokenizeEncoded(e, t, i) {
    if (e.length >= this._maxTokenizationLineLength)
      return Sk(this._languageService.languageIdCodec.encodeLanguageId(this._languageId), i);
    const n = new T_(this._languageService, this._standaloneThemeService.getColorTheme().tokenTheme), o = this._tokenize(e, t, i, n);
    return n.finalize(o);
  }
  _tokenize(e, t, i, n) {
    return i.embeddedLanguageData ? this._nestedTokenize(e, t, i, 0, n) : this._myTokenize(e, t, i, 0, n);
  }
  _findLeavingNestedLanguageOffset(e, t) {
    let i = this._lexer.tokenizer[t.stack.state];
    if (!i && (i = Rm(this._lexer, t.stack.state), !i))
      throw St(this._lexer, "tokenizer state is not defined: " + t.stack.state);
    let n = -1, o = !1;
    for (const r of i) {
      if (!tT(r.action) || r.action.nextEmbedded !== "@pop")
        continue;
      o = !0;
      let a = r.resolveRegex(t.stack.state);
      const l = a.source;
      if (l.substr(0, 4) === "^(?:" && l.substr(l.length - 1, 1) === ")") {
        const h = (a.ignoreCase ? "i" : "") + (a.unicode ? "u" : "");
        a = new RegExp(l.substr(4, l.length - 5), h);
      }
      const c = e.search(a);
      c === -1 || c !== 0 && r.matchOnlyAtLineStart || (n === -1 || c < n) && (n = c);
    }
    if (!o)
      throw St(this._lexer, 'no rule containing nextEmbedded: "@pop" in tokenizer embedded state: ' + t.stack.state);
    return n;
  }
  _nestedTokenize(e, t, i, n, o) {
    const r = this._findLeavingNestedLanguageOffset(e, i);
    if (r === -1) {
      const c = o.nestedLanguageTokenize(e, t, i.embeddedLanguageData, n);
      return Sa.create(i.stack, new Lh(i.embeddedLanguageData.languageId, c));
    }
    const a = e.substring(0, r);
    a.length > 0 && o.nestedLanguageTokenize(a, !1, i.embeddedLanguageData, n);
    const l = e.substring(r);
    return this._myTokenize(l, t, i, n + r, o);
  }
  _safeRuleName(e) {
    return e ? e.name : "(unknown)";
  }
  _myTokenize(e, t, i, n, o) {
    o.enterLanguage(this._languageId);
    const r = e.length, a = t && this._lexer.includeLF ? e + `
` : e, l = a.length;
    let c = i.embeddedLanguageData, h = i.stack, d = 0, u = null, f = !0;
    for (; f || d < l; ) {
      const g = d, m = h.depth, _ = u ? u.groups.length : 0, b = h.state;
      let C = null, v = null, w = null, S = null, L = null;
      if (u) {
        C = u.matches;
        const E = u.groups.shift();
        v = E.matched, w = E.action, S = u.rule, u.groups.length === 0 && (u = null);
      } else {
        if (!f && d >= l)
          break;
        f = !1;
        let E = this._lexer.tokenizer[b];
        if (!E && (E = Rm(this._lexer, b), !E))
          throw St(this._lexer, "tokenizer state is not defined: " + b);
        const U = a.substr(d);
        for (const P of E)
          if ((d === 0 || !P.matchOnlyAtLineStart) && (C = U.match(P.resolveRegex(b)), C)) {
            v = C[0], w = P.action;
            break;
          }
      }
      if (C || (C = [""], v = ""), w || (d < l && (C = [a.charAt(d)], v = C[0]), w = this._lexer.defaultToken), v === null)
        break;
      for (d += v.length; Jj(w) && tT(w) && w.test; )
        w = w.test(v, C, b, d === l);
      let k = null;
      if (typeof w == "string" || Array.isArray(w))
        k = w;
      else if (w.group)
        k = w.group;
      else if (w.token !== null && w.token !== void 0) {
        if (w.tokenSubst ? k = ya(this._lexer, w.token, v, C, b) : k = w.token, w.nextEmbedded)
          if (w.nextEmbedded === "@pop") {
            if (!c)
              throw St(this._lexer, "cannot pop embedded language if not inside one");
            c = null;
          } else {
            if (c)
              throw St(this._lexer, "cannot enter embedded language from within an embedded language");
            L = ya(this._lexer, w.nextEmbedded, v, C, b);
          }
        if (w.goBack && (d = Math.max(0, d - w.goBack)), w.switchTo && typeof w.switchTo == "string") {
          let E = ya(this._lexer, w.switchTo, v, C, b);
          if (E[0] === "@" && (E = E.substr(1)), Rm(this._lexer, E))
            h = h.switchTo(E);
          else
            throw St(this._lexer, "trying to switch to a state '" + E + "' that is undefined in rule: " + this._safeRuleName(S));
        } else {
          if (w.transform && typeof w.transform == "function")
            throw St(this._lexer, "action.transform not supported");
          if (w.next)
            if (w.next === "@push") {
              if (h.depth >= this._lexer.maxStack)
                throw St(this._lexer, "maximum tokenizer stack size reached: [" + h.state + "," + h.parent.state + ",...]");
              h = h.push(b);
            } else if (w.next === "@pop") {
              if (h.depth <= 1)
                throw St(this._lexer, "trying to pop an empty stack in rule: " + this._safeRuleName(S));
              h = h.pop();
            } else if (w.next === "@popall")
              h = h.popall();
            else {
              let E = ya(this._lexer, w.next, v, C, b);
              if (E[0] === "@" && (E = E.substr(1)), Rm(this._lexer, E))
                h = h.push(E);
              else
                throw St(this._lexer, "trying to set a next state '" + E + "' that is undefined in rule: " + this._safeRuleName(S));
            }
        }
        w.log && typeof w.log == "string" && eG(this._lexer, this._lexer.languageId + ": " + ya(this._lexer, w.log, v, C, b));
      }
      if (k === null)
        throw St(this._lexer, "lexer rule has no well-defined action in rule: " + this._safeRuleName(S));
      const D = (E) => {
        const U = this._languageService.getLanguageIdByLanguageName(E) || this._languageService.getLanguageIdByMimeType(E) || E, P = this._getNestedEmbeddedLanguageData(U);
        if (d < l) {
          const B = e.substr(d);
          return this._nestedTokenize(B, t, Sa.create(h, P), n + d, o);
        } else
          return Sa.create(h, P);
      };
      if (Array.isArray(k)) {
        if (u && u.groups.length > 0)
          throw St(this._lexer, "groups cannot be nested: " + this._safeRuleName(S));
        if (C.length !== k.length + 1)
          throw St(this._lexer, "matched number of groups does not match the number of actions in rule: " + this._safeRuleName(S));
        let E = 0;
        for (let U = 1; U < C.length; U++)
          E += C[U].length;
        if (E !== v.length)
          throw St(this._lexer, "with groups, all characters should be matched in consecutive groups in rule: " + this._safeRuleName(S));
        u = {
          rule: S,
          matches: C,
          groups: []
        };
        for (let U = 0; U < k.length; U++)
          u.groups[U] = {
            action: k[U],
            matched: C[U + 1]
          };
        d -= v.length;
        continue;
      } else {
        if (k === "@rematch" && (d -= v.length, v = "", C = null, k = "", L !== null))
          return D(L);
        if (v.length === 0) {
          if (l === 0 || m !== h.depth || b !== h.state || (u ? u.groups.length : 0) !== _)
            continue;
          throw St(this._lexer, "no progress in tokenizer in rule: " + this._safeRuleName(S));
        }
        let E = null;
        if (q4(k) && k.indexOf("@brackets") === 0) {
          const U = k.substr(9), P = rG(this._lexer, v);
          if (!P)
            throw St(this._lexer, "@brackets token returned but no bracket defined as: " + v);
          E = iT(P.token + U);
        } else {
          const U = k === "" ? "" : k + this._lexer.tokenPostfix;
          E = iT(U);
        }
        g < r && o.emit(g + n, E);
      }
      if (L !== null)
        return D(L);
    }
    return Sa.create(h, c);
  }
  _getNestedEmbeddedLanguageData(e) {
    if (!this._languageService.isRegisteredLanguageId(e))
      return new Lh(e, jf);
    e !== this._languageId && (this._languageService.requestBasicLanguageFeatures(e), Yt.getOrCreate(e), this._embeddedLanguages[e] = !0);
    const t = Yt.get(e);
    return t ? new Lh(e, t.getInitialState()) : new Lh(e, jf);
  }
};
hg = vS = nG([
  sG(4, Vt)
], hg);
function rG(s, e) {
  if (!e)
    return null;
  e = qr(s, e);
  const t = s.brackets;
  for (const i of t) {
    if (i.open === e)
      return {
        token: i.token,
        bracketType: 1
        /* monarchCommon.MonarchBracket.Open */
      };
    if (i.close === e)
      return {
        token: i.token,
        bracketType: -1
        /* monarchCommon.MonarchBracket.Close */
      };
  }
  return null;
}
const uC = Pc("standaloneColorizer", { createHTML: (s) => s });
class bx {
  static colorizeElement(e, t, i, n) {
    n = n || {};
    const o = n.theme || "vs", r = n.mimeType || i.getAttribute("lang") || i.getAttribute("data-lang");
    if (!r)
      return console.error("Mode not detected"), Promise.resolve();
    const a = t.getLanguageIdByMimeType(r) || r;
    e.setTheme(o);
    const l = i.firstChild ? i.firstChild.nodeValue : "";
    i.className += " " + o;
    const c = (h) => {
      const d = (uC == null ? void 0 : uC.createHTML(h)) ?? h;
      i.innerHTML = d;
    };
    return this.colorize(t, l || "", a, n).then(c, (h) => console.error(h));
  }
  static async colorize(e, t, i, n) {
    const o = e.languageIdCodec;
    let r = 4;
    n && typeof n.tabSize == "number" && (r = n.tabSize), AL(t) && (t = t.substr(1));
    const a = Vd(t);
    if (!e.isRegisteredLanguageId(i))
      return nT(a, r, o);
    const l = await Yt.getOrCreate(i);
    return l ? aG(a, r, l, o) : nT(a, r, o);
  }
  static colorizeLine(e, t, i, n, o = 4) {
    const r = ns.isBasicASCII(e, t), a = ns.containsRTL(e, r, i);
    return Yb(new Gd(!1, !0, e, !1, r, a, 0, n, [], o, 0, 0, 0, 0, -1, "none", !1, !1, null)).html;
  }
  static colorizeModelLine(e, t, i = 4) {
    const n = e.getLineContent(t);
    e.tokenization.forceTokenization(t);
    const r = e.tokenization.getLineTokens(t).inflate();
    return this.colorizeLine(n, e.mightContainNonBasicASCII(), e.mightContainRTL(), r, i);
  }
}
function aG(s, e, t, i) {
  return new Promise((n, o) => {
    const r = () => {
      const a = lG(s, e, t, i);
      if (t instanceof hg) {
        const l = t.getLoadStatus();
        if (l.loaded === !1) {
          l.promise.then(r, o);
          return;
        }
      }
      n(a);
    };
    r();
  });
}
function nT(s, e, t) {
  let i = [];
  const o = new Uint32Array(2);
  o[0] = 0, o[1] = 33587200;
  for (let r = 0, a = s.length; r < a; r++) {
    const l = s[r];
    o[0] = l.length;
    const c = new Si(o, l, t), h = ns.isBasicASCII(
      l,
      /* check for basic ASCII */
      !0
    ), d = ns.containsRTL(
      l,
      h,
      /* check for RTL */
      !0
    ), u = Yb(new Gd(!1, !0, l, !1, h, d, 0, c, [], e, 0, 0, 0, 0, -1, "none", !1, !1, null));
    i = i.concat(u.html), i.push("<br/>");
  }
  return i.join("");
}
function lG(s, e, t, i) {
  let n = [], o = t.getInitialState();
  for (let r = 0, a = s.length; r < a; r++) {
    const l = s[r], c = t.tokenizeEncoded(l, !0, o);
    Si.convertToEndOffset(c.tokens, l.length);
    const h = new Si(c.tokens, l, i), d = ns.isBasicASCII(
      l,
      /* check for basic ASCII */
      !0
    ), u = ns.containsRTL(
      l,
      d,
      /* check for RTL */
      !0
    ), f = Yb(new Gd(!1, !0, l, !1, d, u, 0, h.inflate(), [], e, 0, 0, 0, 0, -1, "none", !1, !1, null));
    n = n.concat(f.html), n.push("<br/>"), o = c.endState;
  }
  return n.join("");
}
var cG = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, hG = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, dd;
let M_ = (dd = class {
  constructor(e, t) {
  }
  dispose() {
  }
}, dd.ID = "editor.contrib.markerDecorations", dd);
M_ = cG([
  hG(1, HA)
], M_);
AM(
  M_.ID,
  M_,
  0
  /* EditorContributionInstantiation.Eager */
);
class G4 extends q {
  constructor(e, t) {
    super(), this._onDidChange = this._register(new O()), this.onDidChange = this._onDidChange.event, this._referenceDomElement = e, this._width = -1, this._height = -1, this._resizeObserver = null, this.measureReferenceDomElement(!1, t);
  }
  dispose() {
    this.stopObserving(), super.dispose();
  }
  getWidth() {
    return this._width;
  }
  getHeight() {
    return this._height;
  }
  startObserving() {
    if (!this._resizeObserver && this._referenceDomElement) {
      let e = null;
      const t = () => {
        e ? this.observe({ width: e.width, height: e.height }) : this.observe();
      };
      let i = !1, n = !1;
      const o = () => {
        if (i && !n)
          try {
            i = !1, n = !0, t();
          } finally {
            Wn(ue(this._referenceDomElement), () => {
              n = !1, o();
            });
          }
      };
      this._resizeObserver = new ResizeObserver((r) => {
        r && r[0] && r[0].contentRect ? e = { width: r[0].contentRect.width, height: r[0].contentRect.height } : e = null, i = !0, o();
      }), this._resizeObserver.observe(this._referenceDomElement);
    }
  }
  stopObserving() {
    this._resizeObserver && (this._resizeObserver.disconnect(), this._resizeObserver = null);
  }
  observe(e) {
    this.measureReferenceDomElement(!0, e);
  }
  measureReferenceDomElement(e, t) {
    let i = 0, n = 0;
    t ? (i = t.width, n = t.height) : this._referenceDomElement && (i = this._referenceDomElement.clientWidth, n = this._referenceDomElement.clientHeight), i = Math.max(5, i), n = Math.max(5, n), (this._width !== i || this._height !== n) && (this._width = i, this._height = n, e && this._onDidChange.fire());
  }
}
const Bh = class Bh {
  constructor(e, t) {
    this.key = e, this.migrate = t;
  }
  apply(e) {
    const t = Bh._read(e, this.key), i = (o) => Bh._read(e, o), n = (o, r) => Bh._write(e, o, r);
    this.migrate(t, i, n);
  }
  static _read(e, t) {
    if (typeof e > "u")
      return;
    const i = t.indexOf(".");
    if (i >= 0) {
      const n = t.substring(0, i);
      return this._read(e[n], t.substring(i + 1));
    }
    return e[t];
  }
  static _write(e, t, i) {
    const n = t.indexOf(".");
    if (n >= 0) {
      const o = t.substring(0, n);
      e[o] = e[o] || {}, this._write(e[o], t.substring(n + 1), i);
      return;
    }
    e[t] = i;
  }
};
Bh.items = [];
let dg = Bh;
function po(s, e) {
  dg.items.push(new dg(s, e));
}
function Vn(s, e) {
  po(s, (t, i, n) => {
    if (typeof t < "u") {
      for (const [o, r] of e)
        if (t === o) {
          n(s, r);
          return;
        }
    }
  });
}
function dG(s) {
  dg.items.forEach((e) => e.apply(s));
}
Vn("wordWrap", [[!0, "on"], [!1, "off"]]);
Vn("lineNumbers", [[!0, "on"], [!1, "off"]]);
Vn("cursorBlinking", [["visible", "solid"]]);
Vn("renderWhitespace", [[!0, "boundary"], [!1, "none"]]);
Vn("renderLineHighlight", [[!0, "line"], [!1, "none"]]);
Vn("acceptSuggestionOnEnter", [[!0, "on"], [!1, "off"]]);
Vn("tabCompletion", [[!1, "off"], [!0, "onlySnippets"]]);
Vn("hover", [[!0, { enabled: !0 }], [!1, { enabled: !1 }]]);
Vn("parameterHints", [[!0, { enabled: !0 }], [!1, { enabled: !1 }]]);
Vn("autoIndent", [[!1, "advanced"], [!0, "full"]]);
Vn("matchBrackets", [[!0, "always"], [!1, "never"]]);
Vn("renderFinalNewline", [[!0, "on"], [!1, "off"]]);
Vn("cursorSmoothCaretAnimation", [[!0, "on"], [!1, "off"]]);
Vn("occurrencesHighlight", [[!0, "singleFile"], [!1, "off"]]);
Vn("wordBasedSuggestions", [[!0, "matchingDocuments"], [!1, "off"]]);
po("autoClosingBrackets", (s, e, t) => {
  s === !1 && (t("autoClosingBrackets", "never"), typeof e("autoClosingQuotes") > "u" && t("autoClosingQuotes", "never"), typeof e("autoSurround") > "u" && t("autoSurround", "never"));
});
po("renderIndentGuides", (s, e, t) => {
  typeof s < "u" && (t("renderIndentGuides", void 0), typeof e("guides.indentation") > "u" && t("guides.indentation", !!s));
});
po("highlightActiveIndentGuide", (s, e, t) => {
  typeof s < "u" && (t("highlightActiveIndentGuide", void 0), typeof e("guides.highlightActiveIndentation") > "u" && t("guides.highlightActiveIndentation", !!s));
});
const uG = {
  method: "showMethods",
  function: "showFunctions",
  constructor: "showConstructors",
  deprecated: "showDeprecated",
  field: "showFields",
  variable: "showVariables",
  class: "showClasses",
  struct: "showStructs",
  interface: "showInterfaces",
  module: "showModules",
  property: "showProperties",
  event: "showEvents",
  operator: "showOperators",
  unit: "showUnits",
  value: "showValues",
  constant: "showConstants",
  enum: "showEnums",
  enumMember: "showEnumMembers",
  keyword: "showKeywords",
  text: "showWords",
  color: "showColors",
  file: "showFiles",
  reference: "showReferences",
  folder: "showFolders",
  typeParameter: "showTypeParameters",
  snippet: "showSnippets"
};
po("suggest.filteredTypes", (s, e, t) => {
  if (s && typeof s == "object") {
    for (const i of Object.entries(uG))
      s[i[0]] === !1 && typeof e(`suggest.${i[1]}`) > "u" && t(`suggest.${i[1]}`, !1);
    t("suggest.filteredTypes", void 0);
  }
});
po("quickSuggestions", (s, e, t) => {
  if (typeof s == "boolean") {
    const i = s ? "on" : "off";
    t("quickSuggestions", { comments: i, strings: i, other: i });
  }
});
po("experimental.stickyScroll.enabled", (s, e, t) => {
  typeof s == "boolean" && (t("experimental.stickyScroll.enabled", void 0), typeof e("stickyScroll.enabled") > "u" && t("stickyScroll.enabled", s));
});
po("experimental.stickyScroll.maxLineCount", (s, e, t) => {
  typeof s == "number" && (t("experimental.stickyScroll.maxLineCount", void 0), typeof e("stickyScroll.maxLineCount") > "u" && t("stickyScroll.maxLineCount", s));
});
po("codeActionsOnSave", (s, e, t) => {
  if (s && typeof s == "object") {
    let i = !1;
    const n = {};
    for (const o of Object.entries(s))
      typeof o[1] == "boolean" ? (i = !0, n[o[0]] = o[1] ? "explicit" : "never") : n[o[0]] = o[1];
    i && t("codeActionsOnSave", n);
  }
});
po("codeActionWidget.includeNearbyQuickfixes", (s, e, t) => {
  typeof s == "boolean" && (t("codeActionWidget.includeNearbyQuickfixes", void 0), typeof e("codeActionWidget.includeNearbyQuickFixes") > "u" && t("codeActionWidget.includeNearbyQuickFixes", s));
});
po("lightbulb.enabled", (s, e, t) => {
  typeof s == "boolean" && t("lightbulb.enabled", s ? void 0 : "off");
});
class fG {
  constructor() {
    this._tabFocus = !1, this._onDidChangeTabFocus = new O(), this.onDidChangeTabFocus = this._onDidChangeTabFocus.event;
  }
  getTabFocusMode() {
    return this._tabFocus;
  }
  setTabFocusMode(e) {
    this._tabFocus = e, this._onDidChangeTabFocus.fire(this._tabFocus);
  }
}
const R_ = new fG();
var gG = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, mG = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let yS = class extends q {
  constructor(e, t, i, n, o) {
    super(), this._accessibilityService = o, this._onDidChange = this._register(new O()), this.onDidChange = this._onDidChange.event, this._onDidChangeFast = this._register(new O()), this.onDidChangeFast = this._onDidChangeFast.event, this._isDominatedByLongLines = !1, this._viewLineCount = 1, this._lineNumbersDigitCount = 1, this._reservedHeight = 0, this._glyphMarginDecorationLaneCount = 1, this._computeOptionsMemory = new M2(), this.isSimpleWidget = e, this.contextMenuId = t, this._containerObserver = this._register(new G4(n, i.dimension)), this._targetWindowId = ue(n).vscodeWindowId, this._rawOptions = sT(i), this._validatedOptions = La.validateOptions(this._rawOptions), this.options = this._computeOptions(), this.options.get(
      13
      /* EditorOption.automaticLayout */
    ) && this._containerObserver.startObserving(), this._register(Ca.onDidChangeZoomLevel(() => this._recomputeOptions())), this._register(R_.onDidChangeTabFocus(() => this._recomputeOptions())), this._register(this._containerObserver.onDidChange(() => this._recomputeOptions())), this._register(ev.onDidChange(() => this._recomputeOptions())), this._register(Np.getInstance(ue(n)).onDidChange(() => this._recomputeOptions())), this._register(this._accessibilityService.onDidChangeScreenReaderOptimized(() => this._recomputeOptions()));
  }
  _recomputeOptions() {
    const e = this._computeOptions(), t = La.checkEquals(this.options, e);
    t !== null && (this.options = e, this._onDidChangeFast.fire(t), this._onDidChange.fire(t));
  }
  _computeOptions() {
    const e = this._readEnvConfiguration(), t = Zl.createFromValidatedSettings(this._validatedOptions, e.pixelRatio, this.isSimpleWidget), i = this._readFontInfo(t), n = {
      memory: this._computeOptionsMemory,
      outerWidth: e.outerWidth,
      outerHeight: e.outerHeight - this._reservedHeight,
      fontInfo: i,
      extraEditorClassName: e.extraEditorClassName,
      isDominatedByLongLines: this._isDominatedByLongLines,
      viewLineCount: this._viewLineCount,
      lineNumbersDigitCount: this._lineNumbersDigitCount,
      emptySelectionClipboard: e.emptySelectionClipboard,
      pixelRatio: e.pixelRatio,
      tabFocusMode: R_.getTabFocusMode(),
      accessibilitySupport: e.accessibilitySupport,
      glyphMarginDecorationLaneCount: this._glyphMarginDecorationLaneCount
    };
    return La.computeOptions(this._validatedOptions, n);
  }
  _readEnvConfiguration() {
    return {
      extraEditorClassName: _G(),
      outerWidth: this._containerObserver.getWidth(),
      outerHeight: this._containerObserver.getHeight(),
      emptySelectionClipboard: nb || As,
      pixelRatio: Np.getInstance(PD(this._targetWindowId, !0).window).value,
      accessibilitySupport: this._accessibilityService.isScreenReaderOptimized() ? 2 : this._accessibilityService.getAccessibilitySupport()
    };
  }
  _readFontInfo(e) {
    return ev.readFontInfo(PD(this._targetWindowId, !0).window, e);
  }
  getRawOptions() {
    return this._rawOptions;
  }
  updateOptions(e) {
    const t = sT(e);
    La.applyUpdate(this._rawOptions, t) && (this._validatedOptions = La.validateOptions(this._rawOptions), this._recomputeOptions());
  }
  observeContainer(e) {
    this._containerObserver.observe(e);
  }
  setIsDominatedByLongLines(e) {
    this._isDominatedByLongLines !== e && (this._isDominatedByLongLines = e, this._recomputeOptions());
  }
  setModelLineCount(e) {
    const t = pG(e);
    this._lineNumbersDigitCount !== t && (this._lineNumbersDigitCount = t, this._recomputeOptions());
  }
  setViewLineCount(e) {
    this._viewLineCount !== e && (this._viewLineCount = e, this._recomputeOptions());
  }
  setReservedHeight(e) {
    this._reservedHeight !== e && (this._reservedHeight = e, this._recomputeOptions());
  }
  setGlyphMarginDecorationLaneCount(e) {
    this._glyphMarginDecorationLaneCount !== e && (this._glyphMarginDecorationLaneCount = e, this._recomputeOptions());
  }
};
yS = gG([
  mG(4, go)
], yS);
function pG(s) {
  let e = 0;
  for (; s; )
    s = Math.floor(s / 10), e++;
  return e || 1;
}
function _G() {
  let s = "";
  return !Ua && !iM && (s += "no-user-select "), Ua && (s += "no-minimap-shadow ", s += "enable-user-select "), He && (s += "mac "), s;
}
class bG {
  constructor() {
    this._values = [];
  }
  _read(e) {
    return this._values[e];
  }
  get(e) {
    return this._values[e];
  }
  _write(e, t) {
    this._values[e] = t;
  }
}
class CG {
  constructor() {
    this._values = [];
  }
  _read(e) {
    if (e >= this._values.length)
      throw new Error("Cannot read uninitialized value");
    return this._values[e];
  }
  get(e) {
    return this._read(e);
  }
  _write(e, t) {
    this._values[e] = t;
  }
}
class La {
  static validateOptions(e) {
    const t = new bG();
    for (const i of ch) {
      const n = i.name === "_never_" ? void 0 : e[i.name];
      t._write(i.id, i.validate(n));
    }
    return t;
  }
  static computeOptions(e, t) {
    const i = new CG();
    for (const n of ch)
      i._write(n.id, n.compute(t, i, e._read(n.id)));
    return i;
  }
  static _deepEquals(e, t) {
    if (typeof e != "object" || typeof t != "object" || !e || !t)
      return e === t;
    if (Array.isArray(e) || Array.isArray(t))
      return Array.isArray(e) && Array.isArray(t) ? oi(e, t) : !1;
    if (Object.keys(e).length !== Object.keys(t).length)
      return !1;
    for (const i in e)
      if (!La._deepEquals(e[i], t[i]))
        return !1;
    return !0;
  }
  static checkEquals(e, t) {
    const i = [];
    let n = !1;
    for (const o of ch) {
      const r = !La._deepEquals(e._read(o.id), t._read(o.id));
      i[o.id] = r, r && (n = !0);
    }
    return n ? new T2(i) : null;
  }
  /**
   * Returns true if something changed.
   * Modifies `options`.
  */
  static applyUpdate(e, t) {
    let i = !1;
    for (const n of ch)
      if (t.hasOwnProperty(n.name)) {
        const o = n.applyUpdate(e[n.name], t[n.name]);
        e[n.name] = o.newValue, i = i || o.didChange;
      }
    return i;
  }
}
function sT(s) {
  const e = fa(s);
  return dG(e), e;
}
var Na;
(function(s) {
  const e = { total: 0, min: Number.MAX_VALUE, max: 0 }, t = { ...e }, i = { ...e }, n = { ...e };
  let o = 0;
  const r = {
    keydown: 0,
    input: 0,
    render: 0
  };
  function a() {
    b(), performance.mark("inputlatency/start"), performance.mark("keydown/start"), r.keydown = 1, queueMicrotask(l);
  }
  s.onKeyDown = a;
  function l() {
    r.keydown === 1 && (performance.mark("keydown/end"), r.keydown = 2);
  }
  function c() {
    performance.mark("input/start"), r.input = 1, _();
  }
  s.onBeforeInput = c;
  function h() {
    r.input === 0 && c(), queueMicrotask(d);
  }
  s.onInput = h;
  function d() {
    r.input === 1 && (performance.mark("input/end"), r.input = 2);
  }
  function u() {
    b();
  }
  s.onKeyUp = u;
  function f() {
    b();
  }
  s.onSelectionChange = f;
  function g() {
    r.keydown === 2 && r.input === 2 && r.render === 0 && (performance.mark("render/start"), r.render = 1, queueMicrotask(m), _());
  }
  s.onRenderStart = g;
  function m() {
    r.render === 1 && (performance.mark("render/end"), r.render = 2);
  }
  function _() {
    setTimeout(b);
  }
  function b() {
    r.keydown === 2 && r.input === 2 && r.render === 2 && (performance.mark("inputlatency/end"), performance.measure("keydown", "keydown/start", "keydown/end"), performance.measure("input", "input/start", "input/end"), performance.measure("render", "render/start", "render/end"), performance.measure("inputlatency", "inputlatency/start", "inputlatency/end"), C("keydown", e), C("input", t), C("render", i), C("inputlatency", n), o++, v());
  }
  function C(k, D) {
    const E = performance.getEntriesByName(k)[0].duration;
    D.total += E, D.min = Math.min(D.min, E), D.max = Math.max(D.max, E);
  }
  function v() {
    performance.clearMarks("keydown/start"), performance.clearMarks("keydown/end"), performance.clearMarks("input/start"), performance.clearMarks("input/end"), performance.clearMarks("render/start"), performance.clearMarks("render/end"), performance.clearMarks("inputlatency/start"), performance.clearMarks("inputlatency/end"), performance.clearMeasures("keydown"), performance.clearMeasures("input"), performance.clearMeasures("render"), performance.clearMeasures("inputlatency"), r.keydown = 0, r.input = 0, r.render = 0;
  }
  function w() {
    if (o === 0)
      return;
    const k = {
      keydown: S(e),
      input: S(t),
      render: S(i),
      total: S(n),
      sampleCount: o
    };
    return L(e), L(t), L(i), L(n), o = 0, k;
  }
  s.getAndClearMeasurements = w;
  function S(k) {
    return {
      average: k.total / o,
      max: k.max,
      min: k.min
    };
  }
  function L(k) {
    k.total = 0, k.min = Number.MAX_VALUE, k.max = 0;
  }
})(Na || (Na = {}));
class Qb {
  constructor(e, t) {
    this.x = e, this.y = t, this._pageCoordinatesBrand = void 0;
  }
  toClientCoordinates(e) {
    return new Z4(this.x - e.scrollX, this.y - e.scrollY);
  }
}
class Z4 {
  constructor(e, t) {
    this.clientX = e, this.clientY = t, this._clientCoordinatesBrand = void 0;
  }
  toPageCoordinates(e) {
    return new Qb(this.clientX + e.scrollX, this.clientY + e.scrollY);
  }
}
class wG {
  constructor(e, t, i, n) {
    this.x = e, this.y = t, this.width = i, this.height = n, this._editorPagePositionBrand = void 0;
  }
}
class vG {
  constructor(e, t) {
    this.x = e, this.y = t, this._positionRelativeToEditorBrand = void 0;
  }
}
function Cx(s) {
  const e = gs(s);
  return new wG(e.left, e.top, e.width, e.height);
}
function wx(s, e, t) {
  const i = e.width / s.offsetWidth, n = e.height / s.offsetHeight, o = (t.x - e.x) / i, r = (t.y - e.y) / n;
  return new vG(o, r);
}
class Za extends to {
  constructor(e, t, i) {
    super(ue(i), e), this._editorMouseEventBrand = void 0, this.isFromPointerCapture = t, this.pos = new Qb(this.posx, this.posy), this.editorPos = Cx(i), this.relativePos = wx(i, this.editorPos, this.pos);
  }
}
class yG {
  constructor(e) {
    this._editorViewDomNode = e;
  }
  _create(e) {
    return new Za(e, !1, this._editorViewDomNode);
  }
  onContextMenu(e, t) {
    return $(e, "contextmenu", (i) => {
      t(this._create(i));
    });
  }
  onMouseUp(e, t) {
    return $(e, "mouseup", (i) => {
      t(this._create(i));
    });
  }
  onMouseDown(e, t) {
    return $(e, ee.MOUSE_DOWN, (i) => {
      t(this._create(i));
    });
  }
  onPointerDown(e, t) {
    return $(e, ee.POINTER_DOWN, (i) => {
      t(this._create(i), i.pointerId);
    });
  }
  onMouseLeave(e, t) {
    return $(e, ee.MOUSE_LEAVE, (i) => {
      t(this._create(i));
    });
  }
  onMouseMove(e, t) {
    return $(e, "mousemove", (i) => t(this._create(i)));
  }
}
class SG {
  constructor(e) {
    this._editorViewDomNode = e;
  }
  _create(e) {
    return new Za(e, !1, this._editorViewDomNode);
  }
  onPointerUp(e, t) {
    return $(e, "pointerup", (i) => {
      t(this._create(i));
    });
  }
  onPointerDown(e, t) {
    return $(e, ee.POINTER_DOWN, (i) => {
      t(this._create(i), i.pointerId);
    });
  }
  onPointerLeave(e, t) {
    return $(e, ee.POINTER_LEAVE, (i) => {
      t(this._create(i));
    });
  }
  onPointerMove(e, t) {
    return $(e, "pointermove", (i) => t(this._create(i)));
  }
}
class LG extends q {
  constructor(e) {
    super(), this._editorViewDomNode = e, this._globalPointerMoveMonitor = this._register(new kb()), this._keydownListener = null;
  }
  startMonitoring(e, t, i, n, o) {
    this._keydownListener = fi(e.ownerDocument, "keydown", (r) => {
      r.toKeyCodeChord().isModifierKey() || this._globalPointerMoveMonitor.stopMonitoring(!0, r.browserEvent);
    }, !0), this._globalPointerMoveMonitor.startMonitoring(e, t, i, (r) => {
      n(new Za(r, !0, this._editorViewDomNode));
    }, (r) => {
      this._keydownListener.dispose(), o(r);
    });
  }
  stopMonitoring() {
    this._globalPointerMoveMonitor.stopMonitoring(!0);
  }
}
class Kg extends q {
  constructor() {
    super(), this._shouldRender = !0;
  }
  shouldRender() {
    return this._shouldRender;
  }
  forceShouldRender() {
    this._shouldRender = !0;
  }
  setShouldRender() {
    this._shouldRender = !0;
  }
  onDidRender() {
    this._shouldRender = !1;
  }
  // --- begin event handlers
  onCompositionStart(e) {
    return !1;
  }
  onCompositionEnd(e) {
    return !1;
  }
  onConfigurationChanged(e) {
    return !1;
  }
  onCursorStateChanged(e) {
    return !1;
  }
  onDecorationsChanged(e) {
    return !1;
  }
  onFlushed(e) {
    return !1;
  }
  onFocusChanged(e) {
    return !1;
  }
  onLanguageConfigurationChanged(e) {
    return !1;
  }
  onLineMappingChanged(e) {
    return !1;
  }
  onLinesChanged(e) {
    return !1;
  }
  onLinesDeleted(e) {
    return !1;
  }
  onLinesInserted(e) {
    return !1;
  }
  onRevealRangeRequest(e) {
    return !1;
  }
  onScrollChanged(e) {
    return !1;
  }
  onThemeChanged(e) {
    return !1;
  }
  onTokensChanged(e) {
    return !1;
  }
  onTokensColorsChanged(e) {
    return !1;
  }
  onZonesChanged(e) {
    return !1;
  }
  // --- end event handlers
  handleEvents(e) {
    let t = !1;
    for (let i = 0, n = e.length; i < n; i++) {
      const o = e[i];
      switch (o.type) {
        case 0:
          this.onCompositionStart(o) && (t = !0);
          break;
        case 1:
          this.onCompositionEnd(o) && (t = !0);
          break;
        case 2:
          this.onConfigurationChanged(o) && (t = !0);
          break;
        case 3:
          this.onCursorStateChanged(o) && (t = !0);
          break;
        case 4:
          this.onDecorationsChanged(o) && (t = !0);
          break;
        case 5:
          this.onFlushed(o) && (t = !0);
          break;
        case 6:
          this.onFocusChanged(o) && (t = !0);
          break;
        case 7:
          this.onLanguageConfigurationChanged(o) && (t = !0);
          break;
        case 8:
          this.onLineMappingChanged(o) && (t = !0);
          break;
        case 9:
          this.onLinesChanged(o) && (t = !0);
          break;
        case 10:
          this.onLinesDeleted(o) && (t = !0);
          break;
        case 11:
          this.onLinesInserted(o) && (t = !0);
          break;
        case 12:
          this.onRevealRangeRequest(o) && (t = !0);
          break;
        case 13:
          this.onScrollChanged(o) && (t = !0);
          break;
        case 15:
          this.onTokensChanged(o) && (t = !0);
          break;
        case 14:
          this.onThemeChanged(o) && (t = !0);
          break;
        case 16:
          this.onTokensColorsChanged(o) && (t = !0);
          break;
        case 17:
          this.onZonesChanged(o) && (t = !0);
          break;
        default:
          console.info("View received unknown event: "), console.info(o);
      }
    }
    t && (this._shouldRender = !0);
  }
}
class Hn extends Kg {
  constructor(e) {
    super(), this._context = e, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), super.dispose();
  }
}
class ho {
  static write(e, t) {
    e.setAttribute("data-mprt", String(t));
  }
  static read(e) {
    const t = e.getAttribute("data-mprt");
    return t === null ? 0 : parseInt(t, 10);
  }
  static collect(e, t) {
    const i = [];
    let n = 0;
    for (; e && e !== e.ownerDocument.body && e !== t; )
      e.nodeType === e.ELEMENT_NODE && (i[n++] = this.read(e)), e = e.parentElement;
    const o = new Uint8Array(n);
    for (let r = 0; r < n; r++)
      o[r] = i[n - r - 1];
    return o;
  }
}
class kG {
  constructor(e, t) {
    this._restrictedRenderingContextBrand = void 0, this._viewLayout = e, this.viewportData = t, this.scrollWidth = this._viewLayout.getScrollWidth(), this.scrollHeight = this._viewLayout.getScrollHeight(), this.visibleRange = this.viewportData.visibleRange, this.bigNumbersDelta = this.viewportData.bigNumbersDelta;
    const i = this._viewLayout.getCurrentViewport();
    this.scrollTop = i.top, this.scrollLeft = i.left, this.viewportWidth = i.width, this.viewportHeight = i.height;
  }
  getScrolledTopFromAbsoluteTop(e) {
    return e - this.scrollTop;
  }
  getVerticalOffsetForLineNumber(e, t) {
    return this._viewLayout.getVerticalOffsetForLineNumber(e, t);
  }
  getVerticalOffsetAfterLineNumber(e, t) {
    return this._viewLayout.getVerticalOffsetAfterLineNumber(e, t);
  }
  getDecorationsInViewport() {
    return this.viewportData.getDecorationsInViewport();
  }
}
class xG extends kG {
  constructor(e, t, i) {
    super(e, t), this._renderingContextBrand = void 0, this._viewLines = i;
  }
  linesVisibleRangesForRange(e, t) {
    return this._viewLines.linesVisibleRangesForRange(e, t);
  }
  visibleRangeForPosition(e) {
    return this._viewLines.visibleRangeForPosition(e);
  }
}
class DG {
  constructor(e, t, i, n) {
    this.outsideRenderedLine = e, this.lineNumber = t, this.ranges = i, this.continuesOnNextLine = n;
  }
}
class Xb {
  static from(e) {
    const t = new Array(e.length);
    for (let i = 0, n = e.length; i < n; i++) {
      const o = e[i];
      t[i] = new Xb(o.left, o.width);
    }
    return t;
  }
  constructor(e, t) {
    this._horizontalRangeBrand = void 0, this.left = Math.round(e), this.width = Math.round(t);
  }
  toString() {
    return `[${this.left},${this.width}]`;
  }
}
class ic {
  constructor(e, t) {
    this._floatHorizontalRangeBrand = void 0, this.left = e, this.width = t;
  }
  toString() {
    return `[${this.left},${this.width}]`;
  }
  static compare(e, t) {
    return e.left - t.left;
  }
}
class EG {
  constructor(e, t) {
    this.outsideRenderedLine = e, this.originalLeft = t, this.left = Math.round(this.originalLeft);
  }
}
class oT {
  constructor(e, t) {
    this.outsideRenderedLine = e, this.ranges = t;
  }
}
class dp {
  static _createRange() {
    return this._handyReadyRange || (this._handyReadyRange = document.createRange()), this._handyReadyRange;
  }
  static _detachRange(e, t) {
    e.selectNodeContents(t);
  }
  static _readClientRects(e, t, i, n, o) {
    const r = this._createRange();
    try {
      return r.setStart(e, t), r.setEnd(i, n), r.getClientRects();
    } catch {
      return null;
    } finally {
      this._detachRange(r, o);
    }
  }
  static _mergeAdjacentRanges(e) {
    if (e.length === 1)
      return e;
    e.sort(ic.compare);
    const t = [];
    let i = 0, n = e[0];
    for (let o = 1, r = e.length; o < r; o++) {
      const a = e[o];
      n.left + n.width + 0.9 >= a.left ? n.width = Math.max(n.width, a.left + a.width - n.left) : (t[i++] = n, n = a);
    }
    return t[i++] = n, t;
  }
  static _createHorizontalRangesFromClientRects(e, t, i) {
    if (!e || e.length === 0)
      return null;
    const n = [];
    for (let o = 0, r = e.length; o < r; o++) {
      const a = e[o];
      n[o] = new ic(Math.max(0, (a.left - t) / i), a.width / i);
    }
    return this._mergeAdjacentRanges(n);
  }
  static readHorizontalRanges(e, t, i, n, o, r) {
    const l = e.children.length - 1;
    if (0 > l)
      return null;
    if (t = Math.min(l, Math.max(0, t)), n = Math.min(l, Math.max(0, n)), t === n && i === o && i === 0 && !e.children[t].firstChild) {
      const u = e.children[t].getClientRects();
      return r.markDidDomLayout(), this._createHorizontalRangesFromClientRects(u, r.clientRectDeltaLeft, r.clientRectScale);
    }
    t !== n && n > 0 && o === 0 && (n--, o = 1073741824);
    let c = e.children[t].firstChild, h = e.children[n].firstChild;
    if ((!c || !h) && (!c && i === 0 && t > 0 && (c = e.children[t - 1].firstChild, i = 1073741824), !h && o === 0 && n > 0 && (h = e.children[n - 1].firstChild, o = 1073741824)), !c || !h)
      return null;
    i = Math.min(c.textContent.length, Math.max(0, i)), o = Math.min(h.textContent.length, Math.max(0, o));
    const d = this._readClientRects(c, i, h, o, r.endNode);
    return r.markDidDomLayout(), this._createHorizontalRangesFromClientRects(d, r.clientRectDeltaLeft, r.clientRectScale);
  }
}
const IG = /* @__PURE__ */ (function() {
  return Cp ? !0 : !(wn || As || Ua);
})();
let ad = !0;
class rT {
  constructor(e, t) {
    this.themeType = t;
    const i = e.options, n = i.get(
      50
      /* EditorOption.fontInfo */
    );
    i.get(
      38
      /* EditorOption.experimentalWhitespaceRendering */
    ) === "off" ? this.renderWhitespace = i.get(
      100
      /* EditorOption.renderWhitespace */
    ) : this.renderWhitespace = "none", this.renderControlCharacters = i.get(
      95
      /* EditorOption.renderControlCharacters */
    ), this.spaceWidth = n.spaceWidth, this.middotWidth = n.middotWidth, this.wsmiddotWidth = n.wsmiddotWidth, this.useMonospaceOptimizations = n.isMonospace && !i.get(
      33
      /* EditorOption.disableMonospaceOptimizations */
    ), this.canUseHalfwidthRightwardsArrow = n.canUseHalfwidthRightwardsArrow, this.lineHeight = i.get(
      67
      /* EditorOption.lineHeight */
    ), this.stopRenderingLineAfter = i.get(
      118
      /* EditorOption.stopRenderingLineAfter */
    ), this.fontLigatures = i.get(
      51
      /* EditorOption.fontLigatures */
    );
  }
  equals(e) {
    return this.themeType === e.themeType && this.renderWhitespace === e.renderWhitespace && this.renderControlCharacters === e.renderControlCharacters && this.spaceWidth === e.spaceWidth && this.middotWidth === e.middotWidth && this.wsmiddotWidth === e.wsmiddotWidth && this.useMonospaceOptimizations === e.useMonospaceOptimizations && this.canUseHalfwidthRightwardsArrow === e.canUseHalfwidthRightwardsArrow && this.lineHeight === e.lineHeight && this.stopRenderingLineAfter === e.stopRenderingLineAfter && this.fontLigatures === e.fontLigatures;
  }
}
const F1 = class F1 {
  constructor(e) {
    this._options = e, this._isMaybeInvalid = !0, this._renderedViewLine = null;
  }
  // --- begin IVisibleLineData
  getDomNode() {
    return this._renderedViewLine && this._renderedViewLine.domNode ? this._renderedViewLine.domNode.domNode : null;
  }
  setDomNode(e) {
    if (this._renderedViewLine)
      this._renderedViewLine.domNode = je(e);
    else
      throw new Error("I have no rendered view line to set the dom node to...");
  }
  onContentChanged() {
    this._isMaybeInvalid = !0;
  }
  onTokensChanged() {
    this._isMaybeInvalid = !0;
  }
  onDecorationsChanged() {
    this._isMaybeInvalid = !0;
  }
  onOptionsChanged(e) {
    this._isMaybeInvalid = !0, this._options = e;
  }
  onSelectionChanged() {
    return Gh(this._options.themeType) || this._options.renderWhitespace === "selection" ? (this._isMaybeInvalid = !0, !0) : !1;
  }
  renderLine(e, t, i, n, o) {
    if (this._isMaybeInvalid === !1)
      return !1;
    this._isMaybeInvalid = !1;
    const r = n.getViewLineRenderingData(e), a = this._options, l = Ns.filter(r.inlineDecorations, e, r.minColumn, r.maxColumn);
    let c = null;
    if (Gh(a.themeType) || this._options.renderWhitespace === "selection") {
      const f = n.selections;
      for (const g of f) {
        if (g.endLineNumber < e || g.startLineNumber > e)
          continue;
        const m = g.startLineNumber === e ? g.startColumn : r.minColumn, _ = g.endLineNumber === e ? g.endColumn : r.maxColumn;
        m < _ && (Gh(a.themeType) && l.push(new Ns(
          m,
          _,
          "inline-selected-text",
          0
          /* InlineDecorationType.Regular */
        )), this._options.renderWhitespace === "selection" && (c || (c = []), c.push(new z4(m - 1, _ - 1))));
      }
    }
    const h = new Gd(a.useMonospaceOptimizations, a.canUseHalfwidthRightwardsArrow, r.content, r.continuesWithWrappedLine, r.isBasicASCII, r.containsRTL, r.minColumn - 1, r.tokens, l, r.tabSize, r.startVisibleColumn, a.spaceWidth, a.middotWidth, a.wsmiddotWidth, a.stopRenderingLineAfter, a.renderWhitespace, a.renderControlCharacters, a.fontLigatures !== gc.OFF, c);
    if (this._renderedViewLine && this._renderedViewLine.input.equals(h))
      return !1;
    o.appendString('<div style="top:'), o.appendString(String(t)), o.appendString("px;height:"), o.appendString(String(i)), o.appendString('px;" class="'), o.appendString(F1.CLASS_NAME), o.appendString('">');
    const d = px(h, o);
    o.appendString("</div>");
    let u = null;
    return ad && IG && r.isBasicASCII && a.useMonospaceOptimizations && d.containsForeignElements === 0 && (u = new Am(this._renderedViewLine ? this._renderedViewLine.domNode : null, h, d.characterMapping)), u || (u = Q4(this._renderedViewLine ? this._renderedViewLine.domNode : null, h, d.characterMapping, d.containsRTL, d.containsForeignElements)), this._renderedViewLine = u, !0;
  }
  layoutLine(e, t, i) {
    this._renderedViewLine && this._renderedViewLine.domNode && (this._renderedViewLine.domNode.setTop(t), this._renderedViewLine.domNode.setHeight(i));
  }
  // --- end IVisibleLineData
  getWidth(e) {
    return this._renderedViewLine ? this._renderedViewLine.getWidth(e) : 0;
  }
  getWidthIsFast() {
    return this._renderedViewLine ? this._renderedViewLine.getWidthIsFast() : !0;
  }
  needsMonospaceFontCheck() {
    return this._renderedViewLine ? this._renderedViewLine instanceof Am : !1;
  }
  monospaceAssumptionsAreValid() {
    return this._renderedViewLine && this._renderedViewLine instanceof Am ? this._renderedViewLine.monospaceAssumptionsAreValid() : ad;
  }
  onMonospaceAssumptionsInvalidated() {
    this._renderedViewLine && this._renderedViewLine instanceof Am && (this._renderedViewLine = this._renderedViewLine.toSlowRenderedLine());
  }
  getVisibleRangesForRange(e, t, i, n) {
    if (!this._renderedViewLine)
      return null;
    t = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, t)), i = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, i));
    const o = this._renderedViewLine.input.stopRenderingLineAfter;
    if (o !== -1 && t > o + 1 && i > o + 1)
      return new oT(!0, [new ic(this.getWidth(n), 0)]);
    o !== -1 && t > o + 1 && (t = o + 1), o !== -1 && i > o + 1 && (i = o + 1);
    const r = this._renderedViewLine.getVisibleRangesForRange(e, t, i, n);
    return r && r.length > 0 ? new oT(!1, r) : null;
  }
  getColumnOfNodeOffset(e, t) {
    return this._renderedViewLine ? this._renderedViewLine.getColumnOfNodeOffset(e, t) : 1;
  }
};
F1.CLASS_NAME = "view-line";
let Nr = F1;
class Am {
  constructor(e, t, i) {
    this._cachedWidth = -1, this.domNode = e, this.input = t;
    const n = Math.floor(
      t.lineContent.length / 300
      /* Constants.MaxMonospaceDistance */
    );
    if (n > 0) {
      this._keyColumnPixelOffsetCache = new Float32Array(n);
      for (let o = 0; o < n; o++)
        this._keyColumnPixelOffsetCache[o] = -1;
    } else
      this._keyColumnPixelOffsetCache = null;
    this._characterMapping = i, this._charWidth = t.spaceWidth;
  }
  getWidth(e) {
    if (!this.domNode || this.input.lineContent.length < 300) {
      const t = this._characterMapping.getHorizontalOffset(this._characterMapping.length);
      return Math.round(this._charWidth * t);
    }
    return this._cachedWidth === -1 && (this._cachedWidth = this._getReadingTarget(this.domNode).offsetWidth, e == null || e.markDidDomLayout()), this._cachedWidth;
  }
  getWidthIsFast() {
    return this.input.lineContent.length < 300 || this._cachedWidth !== -1;
  }
  monospaceAssumptionsAreValid() {
    if (!this.domNode)
      return ad;
    if (this.input.lineContent.length < 300) {
      const e = this.getWidth(null), t = this.domNode.domNode.firstChild.offsetWidth;
      Math.abs(e - t) >= 2 && (console.warn("monospace assumptions have been violated, therefore disabling monospace optimizations!"), ad = !1);
    }
    return ad;
  }
  toSlowRenderedLine() {
    return Q4(
      this.domNode,
      this.input,
      this._characterMapping,
      !1,
      0
      /* ForeignElementType.None */
    );
  }
  getVisibleRangesForRange(e, t, i, n) {
    const o = this._getColumnPixelOffset(e, t, n), r = this._getColumnPixelOffset(e, i, n);
    return [new ic(o, r - o)];
  }
  _getColumnPixelOffset(e, t, i) {
    if (t <= 300) {
      const c = this._characterMapping.getHorizontalOffset(t);
      return this._charWidth * c;
    }
    const n = Math.floor(
      (t - 1) / 300
      /* Constants.MaxMonospaceDistance */
    ) - 1, o = (n + 1) * 300 + 1;
    let r = -1;
    if (this._keyColumnPixelOffsetCache && (r = this._keyColumnPixelOffsetCache[n], r === -1 && (r = this._actualReadPixelOffset(e, o, i), this._keyColumnPixelOffsetCache[n] = r)), r === -1) {
      const c = this._characterMapping.getHorizontalOffset(t);
      return this._charWidth * c;
    }
    const a = this._characterMapping.getHorizontalOffset(o), l = this._characterMapping.getHorizontalOffset(t);
    return r + this._charWidth * (l - a);
  }
  _getReadingTarget(e) {
    return e.domNode.firstChild;
  }
  _actualReadPixelOffset(e, t, i) {
    if (!this.domNode)
      return -1;
    const n = this._characterMapping.getDomPosition(t), o = dp.readHorizontalRanges(this._getReadingTarget(this.domNode), n.partIndex, n.charIndex, n.partIndex, n.charIndex, i);
    return !o || o.length === 0 ? -1 : o[0].left;
  }
  getColumnOfNodeOffset(e, t) {
    return X4(this._characterMapping, e, t);
  }
}
class Y4 {
  constructor(e, t, i, n, o) {
    if (this.domNode = e, this.input = t, this._characterMapping = i, this._isWhitespaceOnly = /^\s*$/.test(t.lineContent), this._containsForeignElements = o, this._cachedWidth = -1, this._pixelOffsetCache = null, !n || this._characterMapping.length === 0) {
      this._pixelOffsetCache = new Float32Array(Math.max(2, this._characterMapping.length + 1));
      for (let r = 0, a = this._characterMapping.length; r <= a; r++)
        this._pixelOffsetCache[r] = -1;
    }
  }
  // --- Reading from the DOM methods
  _getReadingTarget(e) {
    return e.domNode.firstChild;
  }
  /**
   * Width of the line in pixels
   */
  getWidth(e) {
    return this.domNode ? (this._cachedWidth === -1 && (this._cachedWidth = this._getReadingTarget(this.domNode).offsetWidth, e == null || e.markDidDomLayout()), this._cachedWidth) : 0;
  }
  getWidthIsFast() {
    return this._cachedWidth !== -1;
  }
  /**
   * Visible ranges for a model range
   */
  getVisibleRangesForRange(e, t, i, n) {
    if (!this.domNode)
      return null;
    if (this._pixelOffsetCache !== null) {
      const o = this._readPixelOffset(this.domNode, e, t, n);
      if (o === -1)
        return null;
      const r = this._readPixelOffset(this.domNode, e, i, n);
      return r === -1 ? null : [new ic(o, r - o)];
    }
    return this._readVisibleRangesForRange(this.domNode, e, t, i, n);
  }
  _readVisibleRangesForRange(e, t, i, n, o) {
    if (i === n) {
      const r = this._readPixelOffset(e, t, i, o);
      return r === -1 ? null : [new ic(r, 0)];
    } else
      return this._readRawVisibleRangesForRange(e, i, n, o);
  }
  _readPixelOffset(e, t, i, n) {
    if (this._characterMapping.length === 0) {
      if (this._containsForeignElements === 0 || this._containsForeignElements === 2)
        return 0;
      if (this._containsForeignElements === 1)
        return this.getWidth(n);
      const o = this._getReadingTarget(e);
      return o.firstChild ? (n.markDidDomLayout(), o.firstChild.offsetWidth) : 0;
    }
    if (this._pixelOffsetCache !== null) {
      const o = this._pixelOffsetCache[i];
      if (o !== -1)
        return o;
      const r = this._actualReadPixelOffset(e, t, i, n);
      return this._pixelOffsetCache[i] = r, r;
    }
    return this._actualReadPixelOffset(e, t, i, n);
  }
  _actualReadPixelOffset(e, t, i, n) {
    if (this._characterMapping.length === 0) {
      const l = dp.readHorizontalRanges(this._getReadingTarget(e), 0, 0, 0, 0, n);
      return !l || l.length === 0 ? -1 : l[0].left;
    }
    if (i === this._characterMapping.length && this._isWhitespaceOnly && this._containsForeignElements === 0)
      return this.getWidth(n);
    const o = this._characterMapping.getDomPosition(i), r = dp.readHorizontalRanges(this._getReadingTarget(e), o.partIndex, o.charIndex, o.partIndex, o.charIndex, n);
    if (!r || r.length === 0)
      return -1;
    const a = r[0].left;
    if (this.input.isBasicASCII) {
      const l = this._characterMapping.getHorizontalOffset(i), c = Math.round(this.input.spaceWidth * l);
      if (Math.abs(c - a) <= 1)
        return c;
    }
    return a;
  }
  _readRawVisibleRangesForRange(e, t, i, n) {
    if (t === 1 && i === this._characterMapping.length)
      return [new ic(0, this.getWidth(n))];
    const o = this._characterMapping.getDomPosition(t), r = this._characterMapping.getDomPosition(i);
    return dp.readHorizontalRanges(this._getReadingTarget(e), o.partIndex, o.charIndex, r.partIndex, r.charIndex, n);
  }
  /**
   * Returns the column for the text found at a specific offset inside a rendered dom node
   */
  getColumnOfNodeOffset(e, t) {
    return X4(this._characterMapping, e, t);
  }
}
class NG extends Y4 {
  _readVisibleRangesForRange(e, t, i, n, o) {
    const r = super._readVisibleRangesForRange(e, t, i, n, o);
    if (!r || r.length === 0 || i === n || i === 1 && n === this._characterMapping.length)
      return r;
    if (!this.input.containsRTL) {
      const a = this._readPixelOffset(e, t, n, o);
      if (a !== -1) {
        const l = r[r.length - 1];
        l.left < a && (l.width = a - l.left);
      }
    }
    return r;
  }
}
const Q4 = /* @__PURE__ */ (function() {
  return nb ? TG : MG;
})();
function TG(s, e, t, i, n) {
  return new NG(s, e, t, i, n);
}
function MG(s, e, t, i, n) {
  return new Y4(s, e, t, i, n);
}
function X4(s, e, t) {
  const i = e.textContent.length;
  let n = -1;
  for (; e; )
    e = e.previousSibling, n++;
  return s.getColumn(new U4(n, t), i);
}
class ug {
  /**
   * Get the visible column at the position. If we get to a non-whitespace character first
   * or past the end of string then return -1.
   *
   * **Note** `position` and the return value are 0-based.
   */
  static whitespaceVisibleColumn(e, t, i) {
    const n = e.length;
    let o = 0, r = -1, a = -1;
    for (let l = 0; l < n; l++) {
      if (l === t)
        return [r, a, o];
      switch (o % i === 0 && (r = l, a = o), e.charCodeAt(l)) {
        case 32:
          o += 1;
          break;
        case 9:
          o = ii.nextRenderTabStop(o, i);
          break;
        default:
          return [-1, -1, -1];
      }
    }
    return t === n ? [r, a, o] : [-1, -1, -1];
  }
  /**
   * Return the position that should result from a move left, right or to the
   * nearest tab, if atomic tabs are enabled. Left and right are used for the
   * arrow key movements, nearest is used for mouse selection. It returns
   * -1 if atomic tabs are not relevant and you should fall back to normal
   * behaviour.
   *
   * **Note**: `position` and the return value are 0-based.
   */
  static atomicPosition(e, t, i, n) {
    const o = e.length, [r, a, l] = ug.whitespaceVisibleColumn(e, t, i);
    if (l === -1)
      return -1;
    let c;
    switch (n) {
      case 0:
        c = !0;
        break;
      case 1:
        c = !1;
        break;
      case 2:
        if (l % i === 0)
          return t;
        c = l % i <= i / 2;
        break;
    }
    if (c) {
      if (r === -1)
        return -1;
      let u = a;
      for (let f = r; f < o; ++f) {
        if (u === a + i)
          return r;
        switch (e.charCodeAt(f)) {
          case 32:
            u += 1;
            break;
          case 9:
            u = ii.nextRenderTabStop(u, i);
            break;
          default:
            return -1;
        }
      }
      return u === a + i ? r : -1;
    }
    const h = ii.nextRenderTabStop(l, i);
    let d = l;
    for (let u = t; u < o; u++) {
      if (d === h)
        return u;
      switch (e.charCodeAt(u)) {
        case 32:
          d += 1;
          break;
        case 9:
          d = ii.nextRenderTabStop(d, i);
          break;
        default:
          return -1;
      }
    }
    return d === h ? o : -1;
  }
}
class ua {
  constructor(e = null) {
    this.hitTarget = e, this.type = 0;
  }
}
class J4 {
  get hitTarget() {
    return this.spanNode;
  }
  constructor(e, t, i) {
    this.position = e, this.spanNode = t, this.injectedText = i, this.type = 1;
  }
}
var Rl;
(function(s) {
  function e(t, i, n) {
    const o = t.getPositionFromDOMInfo(i, n);
    return o ? new J4(o, i, null) : new ua(i);
  }
  s.createFromDOMInfo = e;
})(Rl || (Rl = {}));
class RG {
  constructor(e, t) {
    this.lastViewCursorsRenderData = e, this.lastTextareaPosition = t;
  }
}
class $i {
  static _deduceRage(e, t = null) {
    return !t && e ? new R(e.lineNumber, e.column, e.lineNumber, e.column) : t ?? null;
  }
  static createUnknown(e, t, i) {
    return { type: 0, element: e, mouseColumn: t, position: i, range: this._deduceRage(i) };
  }
  static createTextarea(e, t) {
    return { type: 1, element: e, mouseColumn: t, position: null, range: null };
  }
  static createMargin(e, t, i, n, o, r) {
    return { type: e, element: t, mouseColumn: i, position: n, range: o, detail: r };
  }
  static createViewZone(e, t, i, n, o) {
    return { type: e, element: t, mouseColumn: i, position: n, range: this._deduceRage(n), detail: o };
  }
  static createContentText(e, t, i, n, o) {
    return { type: 6, element: e, mouseColumn: t, position: i, range: this._deduceRage(i, n), detail: o };
  }
  static createContentEmpty(e, t, i, n) {
    return { type: 7, element: e, mouseColumn: t, position: i, range: this._deduceRage(i), detail: n };
  }
  static createContentWidget(e, t, i) {
    return { type: 9, element: e, mouseColumn: t, position: null, range: null, detail: i };
  }
  static createScrollbar(e, t, i) {
    return { type: 11, element: e, mouseColumn: t, position: i, range: this._deduceRage(i) };
  }
  static createOverlayWidget(e, t, i) {
    return { type: 12, element: e, mouseColumn: t, position: null, range: null, detail: i };
  }
  static createOutsideEditor(e, t, i, n) {
    return { type: 13, element: null, mouseColumn: e, position: t, range: this._deduceRage(t), outsidePosition: i, outsideDistance: n };
  }
  static _typeToString(e) {
    return e === 1 ? "TEXTAREA" : e === 2 ? "GUTTER_GLYPH_MARGIN" : e === 3 ? "GUTTER_LINE_NUMBERS" : e === 4 ? "GUTTER_LINE_DECORATIONS" : e === 5 ? "GUTTER_VIEW_ZONE" : e === 6 ? "CONTENT_TEXT" : e === 7 ? "CONTENT_EMPTY" : e === 8 ? "CONTENT_VIEW_ZONE" : e === 9 ? "CONTENT_WIDGET" : e === 10 ? "OVERVIEW_RULER" : e === 11 ? "SCROLLBAR" : e === 12 ? "OVERLAY_WIDGET" : "UNKNOWN";
  }
  static toString(e) {
    return this._typeToString(e.type) + ": " + e.position + " - " + e.range + " - " + JSON.stringify(e.detail);
  }
}
class Qi {
  static isTextArea(e) {
    return e.length === 2 && e[0] === 3 && e[1] === 7;
  }
  static isChildOfViewLines(e) {
    return e.length >= 4 && e[0] === 3 && e[3] === 8;
  }
  static isStrictChildOfViewLines(e) {
    return e.length > 4 && e[0] === 3 && e[3] === 8;
  }
  static isChildOfScrollableElement(e) {
    return e.length >= 2 && e[0] === 3 && e[1] === 6;
  }
  static isChildOfMinimap(e) {
    return e.length >= 2 && e[0] === 3 && e[1] === 9;
  }
  static isChildOfContentWidgets(e) {
    return e.length >= 4 && e[0] === 3 && e[3] === 1;
  }
  static isChildOfOverflowGuard(e) {
    return e.length >= 1 && e[0] === 3;
  }
  static isChildOfOverflowingContentWidgets(e) {
    return e.length >= 1 && e[0] === 2;
  }
  static isChildOfOverlayWidgets(e) {
    return e.length >= 2 && e[0] === 3 && e[1] === 4;
  }
  static isChildOfOverflowingOverlayWidgets(e) {
    return e.length >= 1 && e[0] === 5;
  }
}
class Pd {
  constructor(e, t, i) {
    this.viewModel = e.viewModel;
    const n = e.configuration.options;
    this.layoutInfo = n.get(
      146
      /* EditorOption.layoutInfo */
    ), this.viewDomNode = t.viewDomNode, this.lineHeight = n.get(
      67
      /* EditorOption.lineHeight */
    ), this.stickyTabStops = n.get(
      117
      /* EditorOption.stickyTabStops */
    ), this.typicalHalfwidthCharacterWidth = n.get(
      50
      /* EditorOption.fontInfo */
    ).typicalHalfwidthCharacterWidth, this.lastRenderData = i, this._context = e, this._viewHelper = t;
  }
  getZoneAtCoord(e) {
    return Pd.getZoneAtCoord(this._context, e);
  }
  static getZoneAtCoord(e, t) {
    const i = e.viewLayout.getWhitespaceAtVerticalOffset(t);
    if (i) {
      const n = i.verticalOffset + i.height / 2, o = e.viewModel.getLineCount();
      let r = null, a, l = null;
      return i.afterLineNumber !== o && (l = new V(i.afterLineNumber + 1, 1)), i.afterLineNumber > 0 && (r = new V(i.afterLineNumber, e.viewModel.getLineMaxColumn(i.afterLineNumber))), l === null ? a = r : r === null ? a = l : t < n ? a = r : a = l, {
        viewZoneId: i.id,
        afterLineNumber: i.afterLineNumber,
        positionBefore: r,
        positionAfter: l,
        position: a
      };
    }
    return null;
  }
  getFullLineRangeAtCoord(e) {
    if (this._context.viewLayout.isAfterLines(e)) {
      const n = this._context.viewModel.getLineCount(), o = this._context.viewModel.getLineMaxColumn(n);
      return {
        range: new R(n, o, n, o),
        isAfterLines: !0
      };
    }
    const t = this._context.viewLayout.getLineNumberAtVerticalOffset(e), i = this._context.viewModel.getLineMaxColumn(t);
    return {
      range: new R(t, 1, t, i),
      isAfterLines: !1
    };
  }
  getLineNumberAtVerticalOffset(e) {
    return this._context.viewLayout.getLineNumberAtVerticalOffset(e);
  }
  isAfterLines(e) {
    return this._context.viewLayout.isAfterLines(e);
  }
  isInTopPadding(e) {
    return this._context.viewLayout.isInTopPadding(e);
  }
  isInBottomPadding(e) {
    return this._context.viewLayout.isInBottomPadding(e);
  }
  getVerticalOffsetForLineNumber(e) {
    return this._context.viewLayout.getVerticalOffsetForLineNumber(e);
  }
  findAttribute(e, t) {
    return Pd._findAttribute(e, t, this._viewHelper.viewDomNode);
  }
  static _findAttribute(e, t, i) {
    for (; e && e !== e.ownerDocument.body; ) {
      if (e.hasAttribute && e.hasAttribute(t))
        return e.getAttribute(t);
      if (e === i)
        return null;
      e = e.parentNode;
    }
    return null;
  }
  getLineWidth(e) {
    return this._viewHelper.getLineWidth(e);
  }
  visibleRangeForPosition(e, t) {
    return this._viewHelper.visibleRangeForPosition(e, t);
  }
  getPositionFromDOMInfo(e, t) {
    return this._viewHelper.getPositionFromDOMInfo(e, t);
  }
  getCurrentScrollTop() {
    return this._context.viewLayout.getCurrentScrollTop();
  }
  getCurrentScrollLeft() {
    return this._context.viewLayout.getCurrentScrollLeft();
  }
}
class AG {
  constructor(e, t, i, n) {
    this.editorPos = t, this.pos = i, this.relativePos = n, this.mouseVerticalOffset = Math.max(0, e.getCurrentScrollTop() + this.relativePos.y), this.mouseContentHorizontalOffset = e.getCurrentScrollLeft() + this.relativePos.x - e.layoutInfo.contentLeft, this.isInMarginArea = this.relativePos.x < e.layoutInfo.contentLeft && this.relativePos.x >= e.layoutInfo.glyphMarginLeft, this.isInContentArea = !this.isInMarginArea, this.mouseColumn = Math.max(0, Ui._getMouseColumn(this.mouseContentHorizontalOffset, e.typicalHalfwidthCharacterWidth));
  }
}
class PG extends AG {
  get target() {
    return this._useHitTestTarget ? this.hitTestResult.value.hitTarget : this._eventTarget;
  }
  get targetPath() {
    return this._targetPathCacheElement !== this.target && (this._targetPathCacheElement = this.target, this._targetPathCacheValue = ho.collect(this.target, this._ctx.viewDomNode)), this._targetPathCacheValue;
  }
  constructor(e, t, i, n, o) {
    super(e, t, i, n), this.hitTestResult = new Ha(() => Ui.doHitTest(this._ctx, this)), this._targetPathCacheElement = null, this._targetPathCacheValue = new Uint8Array(0), this._ctx = e, this._eventTarget = o;
    const r = !!this._eventTarget;
    this._useHitTestTarget = !r;
  }
  toString() {
    return `pos(${this.pos.x},${this.pos.y}), editorPos(${this.editorPos.x},${this.editorPos.y}), relativePos(${this.relativePos.x},${this.relativePos.y}), mouseVerticalOffset: ${this.mouseVerticalOffset}, mouseContentHorizontalOffset: ${this.mouseContentHorizontalOffset}
	target: ${this.target ? this.target.outerHTML : null}`;
  }
  get wouldBenefitFromHitTestTargetSwitch() {
    return !this._useHitTestTarget && this.hitTestResult.value.hitTarget !== null && this.target !== this.hitTestResult.value.hitTarget;
  }
  switchToHitTestTarget() {
    this._useHitTestTarget = !0;
  }
  _getMouseColumn(e = null) {
    return e && e.column < this._ctx.viewModel.getLineMaxColumn(e.lineNumber) ? ii.visibleColumnFromColumn(this._ctx.viewModel.getLineContent(e.lineNumber), e.column, this._ctx.viewModel.model.getOptions().tabSize) + 1 : this.mouseColumn;
  }
  fulfillUnknown(e = null) {
    return $i.createUnknown(this.target, this._getMouseColumn(e), e);
  }
  fulfillTextarea() {
    return $i.createTextarea(this.target, this._getMouseColumn());
  }
  fulfillMargin(e, t, i, n) {
    return $i.createMargin(e, this.target, this._getMouseColumn(t), t, i, n);
  }
  fulfillViewZone(e, t, i) {
    return $i.createViewZone(e, this.target, this._getMouseColumn(t), t, i);
  }
  fulfillContentText(e, t, i) {
    return $i.createContentText(this.target, this._getMouseColumn(e), e, t, i);
  }
  fulfillContentEmpty(e, t) {
    return $i.createContentEmpty(this.target, this._getMouseColumn(e), e, t);
  }
  fulfillContentWidget(e) {
    return $i.createContentWidget(this.target, this._getMouseColumn(), e);
  }
  fulfillScrollbar(e) {
    return $i.createScrollbar(this.target, this._getMouseColumn(e), e);
  }
  fulfillOverlayWidget(e) {
    return $i.createOverlayWidget(this.target, this._getMouseColumn(), e);
  }
}
const aT = { isAfterLines: !0 };
function fC(s) {
  return {
    isAfterLines: !1,
    horizontalDistanceToText: s
  };
}
class Ui {
  constructor(e, t) {
    this._context = e, this._viewHelper = t;
  }
  mouseTargetIsWidget(e) {
    const t = e.target, i = ho.collect(t, this._viewHelper.viewDomNode);
    return !!(Qi.isChildOfContentWidgets(i) || Qi.isChildOfOverflowingContentWidgets(i) || Qi.isChildOfOverlayWidgets(i) || Qi.isChildOfOverflowingOverlayWidgets(i));
  }
  createMouseTarget(e, t, i, n, o) {
    const r = new Pd(this._context, this._viewHelper, e), a = new PG(r, t, i, n, o);
    try {
      const l = Ui._createMouseTarget(r, a);
      if (l.type === 6 && r.stickyTabStops && l.position !== null) {
        const c = Ui._snapToSoftTabBoundary(l.position, r.viewModel), h = R.fromPositions(c, c).plusRange(l.range);
        return a.fulfillContentText(c, h, l.detail);
      }
      return l;
    } catch {
      return a.fulfillUnknown();
    }
  }
  static _createMouseTarget(e, t) {
    if (t.target === null)
      return t.fulfillUnknown();
    const i = t;
    let n = null;
    return !Qi.isChildOfOverflowGuard(t.targetPath) && !Qi.isChildOfOverflowingContentWidgets(t.targetPath) && !Qi.isChildOfOverflowingOverlayWidgets(t.targetPath) && (n = n || t.fulfillUnknown()), n = n || Ui._hitTestContentWidget(e, i), n = n || Ui._hitTestOverlayWidget(e, i), n = n || Ui._hitTestMinimap(e, i), n = n || Ui._hitTestScrollbarSlider(e, i), n = n || Ui._hitTestViewZone(e, i), n = n || Ui._hitTestMargin(e, i), n = n || Ui._hitTestViewCursor(e, i), n = n || Ui._hitTestTextArea(e, i), n = n || Ui._hitTestViewLines(e, i), n = n || Ui._hitTestScrollbar(e, i), n || t.fulfillUnknown();
  }
  static _hitTestContentWidget(e, t) {
    if (Qi.isChildOfContentWidgets(t.targetPath) || Qi.isChildOfOverflowingContentWidgets(t.targetPath)) {
      const i = e.findAttribute(t.target, "widgetId");
      return i ? t.fulfillContentWidget(i) : t.fulfillUnknown();
    }
    return null;
  }
  static _hitTestOverlayWidget(e, t) {
    if (Qi.isChildOfOverlayWidgets(t.targetPath) || Qi.isChildOfOverflowingOverlayWidgets(t.targetPath)) {
      const i = e.findAttribute(t.target, "widgetId");
      return i ? t.fulfillOverlayWidget(i) : t.fulfillUnknown();
    }
    return null;
  }
  static _hitTestViewCursor(e, t) {
    if (t.target) {
      const i = e.lastRenderData.lastViewCursorsRenderData;
      for (const n of i)
        if (t.target === n.domNode)
          return t.fulfillContentText(n.position, null, { mightBeForeignElement: !1, injectedText: null });
    }
    if (t.isInContentArea) {
      const i = e.lastRenderData.lastViewCursorsRenderData, n = t.mouseContentHorizontalOffset, o = t.mouseVerticalOffset;
      for (const r of i) {
        if (n < r.contentLeft || n > r.contentLeft + r.width)
          continue;
        const a = e.getVerticalOffsetForLineNumber(r.position.lineNumber);
        if (a <= o && o <= a + r.height)
          return t.fulfillContentText(r.position, null, { mightBeForeignElement: !1, injectedText: null });
      }
    }
    return null;
  }
  static _hitTestViewZone(e, t) {
    const i = e.getZoneAtCoord(t.mouseVerticalOffset);
    if (i) {
      const n = t.isInContentArea ? 8 : 5;
      return t.fulfillViewZone(n, i.position, i);
    }
    return null;
  }
  static _hitTestTextArea(e, t) {
    return Qi.isTextArea(t.targetPath) ? e.lastRenderData.lastTextareaPosition ? t.fulfillContentText(e.lastRenderData.lastTextareaPosition, null, { mightBeForeignElement: !1, injectedText: null }) : t.fulfillTextarea() : null;
  }
  static _hitTestMargin(e, t) {
    if (t.isInMarginArea) {
      const i = e.getFullLineRangeAtCoord(t.mouseVerticalOffset), n = i.range.getStartPosition();
      let o = Math.abs(t.relativePos.x);
      const r = {
        isAfterLines: i.isAfterLines,
        glyphMarginLeft: e.layoutInfo.glyphMarginLeft,
        glyphMarginWidth: e.layoutInfo.glyphMarginWidth,
        lineNumbersWidth: e.layoutInfo.lineNumbersWidth,
        offsetX: o
      };
      if (o -= e.layoutInfo.glyphMarginLeft, o <= e.layoutInfo.glyphMarginWidth) {
        const a = e.viewModel.coordinatesConverter.convertViewPositionToModelPosition(i.range.getStartPosition()), l = e.viewModel.glyphLanes.getLanesAtLine(a.lineNumber);
        return r.glyphMarginLane = l[Math.floor(o / e.lineHeight)], t.fulfillMargin(2, n, i.range, r);
      }
      return o -= e.layoutInfo.glyphMarginWidth, o <= e.layoutInfo.lineNumbersWidth ? t.fulfillMargin(3, n, i.range, r) : (o -= e.layoutInfo.lineNumbersWidth, t.fulfillMargin(4, n, i.range, r));
    }
    return null;
  }
  static _hitTestViewLines(e, t) {
    if (!Qi.isChildOfViewLines(t.targetPath))
      return null;
    if (e.isInTopPadding(t.mouseVerticalOffset))
      return t.fulfillContentEmpty(new V(1, 1), aT);
    if (e.isAfterLines(t.mouseVerticalOffset) || e.isInBottomPadding(t.mouseVerticalOffset)) {
      const n = e.viewModel.getLineCount(), o = e.viewModel.getLineMaxColumn(n);
      return t.fulfillContentEmpty(new V(n, o), aT);
    }
    if (Qi.isStrictChildOfViewLines(t.targetPath)) {
      const n = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset);
      if (e.viewModel.getLineLength(n) === 0) {
        const r = e.getLineWidth(n), a = fC(t.mouseContentHorizontalOffset - r);
        return t.fulfillContentEmpty(new V(n, 1), a);
      }
      const o = e.getLineWidth(n);
      if (t.mouseContentHorizontalOffset >= o) {
        const r = fC(t.mouseContentHorizontalOffset - o), a = new V(n, e.viewModel.getLineMaxColumn(n));
        return t.fulfillContentEmpty(a, r);
      }
    }
    const i = t.hitTestResult.value;
    return i.type === 1 ? Ui.createMouseTargetFromHitTestPosition(e, t, i.spanNode, i.position, i.injectedText) : t.wouldBenefitFromHitTestTargetSwitch ? (t.switchToHitTestTarget(), this._createMouseTarget(e, t)) : t.fulfillUnknown();
  }
  static _hitTestMinimap(e, t) {
    if (Qi.isChildOfMinimap(t.targetPath)) {
      const i = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset), n = e.viewModel.getLineMaxColumn(i);
      return t.fulfillScrollbar(new V(i, n));
    }
    return null;
  }
  static _hitTestScrollbarSlider(e, t) {
    if (Qi.isChildOfScrollableElement(t.targetPath) && t.target && t.target.nodeType === 1) {
      const i = t.target.className;
      if (i && /\b(slider|scrollbar)\b/.test(i)) {
        const n = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset), o = e.viewModel.getLineMaxColumn(n);
        return t.fulfillScrollbar(new V(n, o));
      }
    }
    return null;
  }
  static _hitTestScrollbar(e, t) {
    if (Qi.isChildOfScrollableElement(t.targetPath)) {
      const i = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset), n = e.viewModel.getLineMaxColumn(i);
      return t.fulfillScrollbar(new V(i, n));
    }
    return null;
  }
  getMouseColumn(e) {
    const t = this._context.configuration.options, i = t.get(
      146
      /* EditorOption.layoutInfo */
    ), n = this._context.viewLayout.getCurrentScrollLeft() + e.x - i.contentLeft;
    return Ui._getMouseColumn(n, t.get(
      50
      /* EditorOption.fontInfo */
    ).typicalHalfwidthCharacterWidth);
  }
  static _getMouseColumn(e, t) {
    return e < 0 ? 1 : Math.round(e / t) + 1;
  }
  static createMouseTargetFromHitTestPosition(e, t, i, n, o) {
    const r = n.lineNumber, a = n.column, l = e.getLineWidth(r);
    if (t.mouseContentHorizontalOffset > l) {
      const b = fC(t.mouseContentHorizontalOffset - l);
      return t.fulfillContentEmpty(n, b);
    }
    const c = e.visibleRangeForPosition(r, a);
    if (!c)
      return t.fulfillUnknown(n);
    const h = c.left;
    if (Math.abs(t.mouseContentHorizontalOffset - h) < 1)
      return t.fulfillContentText(n, null, { mightBeForeignElement: !!o, injectedText: o });
    const d = [];
    if (d.push({ offset: c.left, column: a }), a > 1) {
      const b = e.visibleRangeForPosition(r, a - 1);
      b && d.push({ offset: b.left, column: a - 1 });
    }
    const u = e.viewModel.getLineMaxColumn(r);
    if (a < u) {
      const b = e.visibleRangeForPosition(r, a + 1);
      b && d.push({ offset: b.left, column: a + 1 });
    }
    d.sort((b, C) => b.offset - C.offset);
    const f = t.pos.toClientCoordinates(ue(e.viewDomNode)), g = i.getBoundingClientRect(), m = g.left <= f.clientX && f.clientX <= g.right;
    let _ = null;
    for (let b = 1; b < d.length; b++) {
      const C = d[b - 1], v = d[b];
      if (C.offset <= t.mouseContentHorizontalOffset && t.mouseContentHorizontalOffset <= v.offset) {
        _ = new R(r, C.column, r, v.column);
        const w = Math.abs(C.offset - t.mouseContentHorizontalOffset), S = Math.abs(v.offset - t.mouseContentHorizontalOffset);
        n = w < S ? new V(r, C.column) : new V(r, v.column);
        break;
      }
    }
    return t.fulfillContentText(n, _, { mightBeForeignElement: !m || !!o, injectedText: o });
  }
  /**
   * Most probably WebKit browsers and Edge
   */
  static _doHitTestWithCaretRangeFromPoint(e, t) {
    const i = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset), n = e.getVerticalOffsetForLineNumber(i), o = n + e.lineHeight;
    if (!(i === e.viewModel.getLineCount() && t.mouseVerticalOffset > o)) {
      const a = Math.floor((n + o) / 2);
      let l = t.pos.y + (a - t.mouseVerticalOffset);
      l <= t.editorPos.y && (l = t.editorPos.y + 1), l >= t.editorPos.y + t.editorPos.height && (l = t.editorPos.y + t.editorPos.height - 1);
      const c = new Qb(t.pos.x, l), h = this._actualDoHitTestWithCaretRangeFromPoint(e, c.toClientCoordinates(ue(e.viewDomNode)));
      if (h.type === 1)
        return h;
    }
    return this._actualDoHitTestWithCaretRangeFromPoint(e, t.pos.toClientCoordinates(ue(e.viewDomNode)));
  }
  static _actualDoHitTestWithCaretRangeFromPoint(e, t) {
    const i = bd(e.viewDomNode);
    let n;
    if (i ? typeof i.caretRangeFromPoint > "u" ? n = OG(i, t.clientX, t.clientY) : n = i.caretRangeFromPoint(t.clientX, t.clientY) : n = e.viewDomNode.ownerDocument.caretRangeFromPoint(t.clientX, t.clientY), !n || !n.startContainer)
      return new ua();
    const o = n.startContainer;
    if (o.nodeType === o.TEXT_NODE) {
      const r = o.parentNode, a = r ? r.parentNode : null, l = a ? a.parentNode : null;
      return (l && l.nodeType === l.ELEMENT_NODE ? l.className : null) === Nr.CLASS_NAME ? Rl.createFromDOMInfo(e, r, n.startOffset) : new ua(o.parentNode);
    } else if (o.nodeType === o.ELEMENT_NODE) {
      const r = o.parentNode, a = r ? r.parentNode : null;
      return (a && a.nodeType === a.ELEMENT_NODE ? a.className : null) === Nr.CLASS_NAME ? Rl.createFromDOMInfo(e, o, o.textContent.length) : new ua(o);
    }
    return new ua();
  }
  /**
   * Most probably Gecko
   */
  static _doHitTestWithCaretPositionFromPoint(e, t) {
    const i = e.viewDomNode.ownerDocument.caretPositionFromPoint(t.clientX, t.clientY);
    if (i.offsetNode.nodeType === i.offsetNode.TEXT_NODE) {
      const n = i.offsetNode.parentNode, o = n ? n.parentNode : null, r = o ? o.parentNode : null;
      return (r && r.nodeType === r.ELEMENT_NODE ? r.className : null) === Nr.CLASS_NAME ? Rl.createFromDOMInfo(e, i.offsetNode.parentNode, i.offset) : new ua(i.offsetNode.parentNode);
    }
    if (i.offsetNode.nodeType === i.offsetNode.ELEMENT_NODE) {
      const n = i.offsetNode.parentNode, o = n && n.nodeType === n.ELEMENT_NODE ? n.className : null, r = n ? n.parentNode : null, a = r && r.nodeType === r.ELEMENT_NODE ? r.className : null;
      if (o === Nr.CLASS_NAME) {
        const l = i.offsetNode.childNodes[Math.min(i.offset, i.offsetNode.childNodes.length - 1)];
        if (l)
          return Rl.createFromDOMInfo(e, l, 0);
      } else if (a === Nr.CLASS_NAME)
        return Rl.createFromDOMInfo(e, i.offsetNode, 0);
    }
    return new ua(i.offsetNode);
  }
  static _snapToSoftTabBoundary(e, t) {
    const i = t.getLineContent(e.lineNumber), { tabSize: n } = t.model.getOptions(), o = ug.atomicPosition(
      i,
      e.column - 1,
      n,
      2
      /* Direction.Nearest */
    );
    return o !== -1 ? new V(e.lineNumber, o + 1) : e;
  }
  static doHitTest(e, t) {
    let i = new ua();
    if (typeof e.viewDomNode.ownerDocument.caretRangeFromPoint == "function" ? i = this._doHitTestWithCaretRangeFromPoint(e, t) : e.viewDomNode.ownerDocument.caretPositionFromPoint && (i = this._doHitTestWithCaretPositionFromPoint(e, t.pos.toClientCoordinates(ue(e.viewDomNode)))), i.type === 1) {
      const n = e.viewModel.getInjectedTextAt(i.position), o = e.viewModel.normalizePosition(
        i.position,
        2
        /* PositionAffinity.None */
      );
      (n || !o.equals(i.position)) && (i = new J4(o, i.spanNode, n));
    }
    return i;
  }
}
function OG(s, e, t) {
  const i = document.createRange();
  let n = s.elementFromPoint(e, t);
  if (n !== null) {
    for (; n && n.firstChild && n.firstChild.nodeType !== n.firstChild.TEXT_NODE && n.lastChild && n.lastChild.firstChild; )
      n = n.lastChild;
    const o = n.getBoundingClientRect(), r = ue(n), a = r.getComputedStyle(n, null).getPropertyValue("font-style"), l = r.getComputedStyle(n, null).getPropertyValue("font-variant"), c = r.getComputedStyle(n, null).getPropertyValue("font-weight"), h = r.getComputedStyle(n, null).getPropertyValue("font-size"), d = r.getComputedStyle(n, null).getPropertyValue("line-height"), u = r.getComputedStyle(n, null).getPropertyValue("font-family"), f = `${a} ${l} ${c} ${h}/${d} ${u}`, g = n.innerText;
    let m = o.left, _ = 0, b;
    if (e > o.left + o.width)
      _ = g.length;
    else {
      const C = SS.getInstance();
      for (let v = 0; v < g.length + 1; v++) {
        if (b = C.getCharWidth(g.charAt(v), f) / 2, m += b, e < m) {
          _ = v;
          break;
        }
        m += b;
      }
    }
    i.setStart(n.firstChild, _), i.setEnd(n.firstChild, _);
  }
  return i;
}
const Hl = class Hl {
  static getInstance() {
    return Hl._INSTANCE || (Hl._INSTANCE = new Hl()), Hl._INSTANCE;
  }
  constructor() {
    this._cache = {}, this._canvas = document.createElement("canvas");
  }
  getCharWidth(e, t) {
    const i = e + t;
    if (this._cache[i])
      return this._cache[i];
    const n = this._canvas.getContext("2d");
    n.font = t;
    const r = n.measureText(e).width;
    return this._cache[i] = r, r;
  }
};
Hl._INSTANCE = null;
let SS = Hl;
class vx extends Kg {
  constructor(e, t, i) {
    super(), this._mouseLeaveMonitor = null, this._context = e, this.viewController = t, this.viewHelper = i, this.mouseTargetFactory = new Ui(this._context, i), this._mouseDownOperation = this._register(new FG(this._context, this.viewController, this.viewHelper, this.mouseTargetFactory, (r, a) => this._createMouseTarget(r, a), (r) => this._getMouseColumn(r))), this.lastMouseLeaveTime = -1, this._height = this._context.configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    ).height;
    const n = new yG(this.viewHelper.viewDomNode);
    this._register(n.onContextMenu(this.viewHelper.viewDomNode, (r) => this._onContextMenu(r, !0))), this._register(n.onMouseMove(this.viewHelper.viewDomNode, (r) => {
      this._onMouseMove(r), this._mouseLeaveMonitor || (this._mouseLeaveMonitor = $(this.viewHelper.viewDomNode.ownerDocument, "mousemove", (a) => {
        this.viewHelper.viewDomNode.contains(a.target) || this._onMouseLeave(new Za(a, !1, this.viewHelper.viewDomNode));
      }));
    })), this._register(n.onMouseUp(this.viewHelper.viewDomNode, (r) => this._onMouseUp(r))), this._register(n.onMouseLeave(this.viewHelper.viewDomNode, (r) => this._onMouseLeave(r)));
    let o = 0;
    this._register(n.onPointerDown(this.viewHelper.viewDomNode, (r, a) => {
      o = a;
    })), this._register($(this.viewHelper.viewDomNode, ee.POINTER_UP, (r) => {
      this._mouseDownOperation.onPointerUp();
    })), this._register(n.onMouseDown(this.viewHelper.viewDomNode, (r) => this._onMouseDown(r, o))), this._setupMouseWheelZoomListener(), this._context.addEventHandler(this);
  }
  _setupMouseWheelZoomListener() {
    const e = jp.INSTANCE;
    let t = 0, i = Ca.getZoomLevel(), n = !1, o = 0;
    const r = (l) => {
      if (this.viewController.emitMouseWheel(l), !this._context.configuration.options.get(
        76
        /* EditorOption.mouseWheelZoom */
      ))
        return;
      const c = new pc(l);
      if (e.acceptStandardWheelEvent(c), e.isPhysicalMouseWheel()) {
        if (a(l)) {
          const h = Ca.getZoomLevel(), d = c.deltaY > 0 ? 1 : -1;
          Ca.setZoomLevel(h + d), c.preventDefault(), c.stopPropagation();
        }
      } else
        Date.now() - t > 50 && (i = Ca.getZoomLevel(), n = a(l), o = 0), t = Date.now(), o += c.deltaY, n && (Ca.setZoomLevel(i + o / 5), c.preventDefault(), c.stopPropagation());
    };
    this._register($(this.viewHelper.viewDomNode, ee.MOUSE_WHEEL, r, { capture: !0, passive: !1 }));
    function a(l) {
      return He ? (l.metaKey || l.ctrlKey) && !l.shiftKey && !l.altKey : l.ctrlKey && !l.metaKey && !l.shiftKey && !l.altKey;
    }
  }
  dispose() {
    this._context.removeEventHandler(this), this._mouseLeaveMonitor && (this._mouseLeaveMonitor.dispose(), this._mouseLeaveMonitor = null), super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    if (e.hasChanged(
      146
      /* EditorOption.layoutInfo */
    )) {
      const t = this._context.configuration.options.get(
        146
        /* EditorOption.layoutInfo */
      ).height;
      this._height !== t && (this._height = t, this._mouseDownOperation.onHeightChanged());
    }
    return !1;
  }
  onCursorStateChanged(e) {
    return this._mouseDownOperation.onCursorStateChanged(e), !1;
  }
  onFocusChanged(e) {
    return !1;
  }
  // --- end event handlers
  getTargetAtClientPoint(e, t) {
    const n = new Z4(e, t).toPageCoordinates(ue(this.viewHelper.viewDomNode)), o = Cx(this.viewHelper.viewDomNode);
    if (n.y < o.y || n.y > o.y + o.height || n.x < o.x || n.x > o.x + o.width)
      return null;
    const r = wx(this.viewHelper.viewDomNode, o, n);
    return this.mouseTargetFactory.createMouseTarget(this.viewHelper.getLastRenderData(), o, n, r, null);
  }
  _createMouseTarget(e, t) {
    let i = e.target;
    if (!this.viewHelper.viewDomNode.contains(i)) {
      const n = bd(this.viewHelper.viewDomNode);
      n && (i = n.elementsFromPoint(e.posx, e.posy).find((o) => this.viewHelper.viewDomNode.contains(o)));
    }
    return this.mouseTargetFactory.createMouseTarget(this.viewHelper.getLastRenderData(), e.editorPos, e.pos, e.relativePos, t ? i : null);
  }
  _getMouseColumn(e) {
    return this.mouseTargetFactory.getMouseColumn(e.relativePos);
  }
  _onContextMenu(e, t) {
    this.viewController.emitContextMenu({
      event: e,
      target: this._createMouseTarget(e, t)
    });
  }
  _onMouseMove(e) {
    this.mouseTargetFactory.mouseTargetIsWidget(e) || e.preventDefault(), !(this._mouseDownOperation.isActive() || e.timestamp < this.lastMouseLeaveTime) && this.viewController.emitMouseMove({
      event: e,
      target: this._createMouseTarget(e, !0)
    });
  }
  _onMouseLeave(e) {
    this._mouseLeaveMonitor && (this._mouseLeaveMonitor.dispose(), this._mouseLeaveMonitor = null), this.lastMouseLeaveTime = (/* @__PURE__ */ new Date()).getTime(), this.viewController.emitMouseLeave({
      event: e,
      target: null
    });
  }
  _onMouseUp(e) {
    this.viewController.emitMouseUp({
      event: e,
      target: this._createMouseTarget(e, !0)
    });
  }
  _onMouseDown(e, t) {
    const i = this._createMouseTarget(e, !0), n = i.type === 6 || i.type === 7, o = i.type === 2 || i.type === 3 || i.type === 4, r = i.type === 3, a = this._context.configuration.options.get(
      110
      /* EditorOption.selectOnLineNumbers */
    ), l = i.type === 8 || i.type === 5, c = i.type === 9;
    let h = e.leftButton || e.middleButton;
    He && e.leftButton && e.ctrlKey && (h = !1);
    const d = () => {
      e.preventDefault(), this.viewHelper.focusTextArea();
    };
    if (h && (n || r && a))
      d(), this._mouseDownOperation.start(i.type, e, t);
    else if (o)
      e.preventDefault();
    else if (l) {
      const u = i.detail;
      h && this.viewHelper.shouldSuppressMouseDownOnViewZone(u.viewZoneId) && (d(), this._mouseDownOperation.start(i.type, e, t), e.preventDefault());
    } else c && this.viewHelper.shouldSuppressMouseDownOnWidget(i.detail) && (d(), e.preventDefault());
    this.viewController.emitMouseDown({
      event: e,
      target: i
    });
  }
}
class FG extends q {
  constructor(e, t, i, n, o, r) {
    super(), this._context = e, this._viewController = t, this._viewHelper = i, this._mouseTargetFactory = n, this._createMouseTarget = o, this._getMouseColumn = r, this._mouseMoveMonitor = this._register(new LG(this._viewHelper.viewDomNode)), this._topBottomDragScrolling = this._register(new BG(this._context, this._viewHelper, this._mouseTargetFactory, (a, l, c) => this._dispatchMouse(a, l, c))), this._mouseState = new LS(), this._currentSelection = new ft(1, 1, 1, 1), this._isActive = !1, this._lastMouseEvent = null;
  }
  dispose() {
    super.dispose();
  }
  isActive() {
    return this._isActive;
  }
  _onMouseDownThenMove(e) {
    this._lastMouseEvent = e, this._mouseState.setModifiers(e);
    const t = this._findMousePosition(e, !1);
    t && (this._mouseState.isDragAndDrop ? this._viewController.emitMouseDrag({
      event: e,
      target: t
    }) : t.type === 13 && (t.outsidePosition === "above" || t.outsidePosition === "below") ? this._topBottomDragScrolling.start(t, e) : (this._topBottomDragScrolling.stop(), this._dispatchMouse(
      t,
      !0,
      1
      /* NavigationCommandRevealType.Minimal */
    )));
  }
  start(e, t, i) {
    this._lastMouseEvent = t, this._mouseState.setStartedOnLineNumbers(
      e === 3
      /* MouseTargetType.GUTTER_LINE_NUMBERS */
    ), this._mouseState.setStartButtons(t), this._mouseState.setModifiers(t);
    const n = this._findMousePosition(t, !0);
    if (!n || !n.position)
      return;
    this._mouseState.trySetCount(t.detail, n.position), t.detail = this._mouseState.count;
    const o = this._context.configuration.options;
    if (!o.get(
      92
      /* EditorOption.readOnly */
    ) && o.get(
      35
      /* EditorOption.dragAndDrop */
    ) && !o.get(
      22
      /* EditorOption.columnSelection */
    ) && !this._mouseState.altKey && t.detail < 2 && !this._isActive && !this._currentSelection.isEmpty() && n.type === 6 && n.position && this._currentSelection.containsPosition(n.position)) {
      this._mouseState.isDragAndDrop = !0, this._isActive = !0, this._mouseMoveMonitor.startMonitoring(this._viewHelper.viewLinesDomNode, i, t.buttons, (r) => this._onMouseDownThenMove(r), (r) => {
        const a = this._findMousePosition(this._lastMouseEvent, !1);
        wr(r) ? this._viewController.emitMouseDropCanceled() : this._viewController.emitMouseDrop({
          event: this._lastMouseEvent,
          target: a ? this._createMouseTarget(this._lastMouseEvent, !0) : null
          // Ignoring because position is unknown, e.g., Content View Zone
        }), this._stop();
      });
      return;
    }
    this._mouseState.isDragAndDrop = !1, this._dispatchMouse(
      n,
      t.shiftKey,
      1
      /* NavigationCommandRevealType.Minimal */
    ), this._isActive || (this._isActive = !0, this._mouseMoveMonitor.startMonitoring(this._viewHelper.viewLinesDomNode, i, t.buttons, (r) => this._onMouseDownThenMove(r), () => this._stop()));
  }
  _stop() {
    this._isActive = !1, this._topBottomDragScrolling.stop();
  }
  onHeightChanged() {
    this._mouseMoveMonitor.stopMonitoring();
  }
  onPointerUp() {
    this._mouseMoveMonitor.stopMonitoring();
  }
  onCursorStateChanged(e) {
    this._currentSelection = e.selections[0];
  }
  _getPositionOutsideEditor(e) {
    const t = e.editorPos, i = this._context.viewModel, n = this._context.viewLayout, o = this._getMouseColumn(e);
    if (e.posy < t.y) {
      const a = t.y - e.posy, l = Math.max(n.getCurrentScrollTop() - a, 0), c = Pd.getZoneAtCoord(this._context, l);
      if (c) {
        const d = this._helpPositionJumpOverViewZone(c);
        if (d)
          return $i.createOutsideEditor(o, d, "above", a);
      }
      const h = n.getLineNumberAtVerticalOffset(l);
      return $i.createOutsideEditor(o, new V(h, 1), "above", a);
    }
    if (e.posy > t.y + t.height) {
      const a = e.posy - t.y - t.height, l = n.getCurrentScrollTop() + e.relativePos.y, c = Pd.getZoneAtCoord(this._context, l);
      if (c) {
        const d = this._helpPositionJumpOverViewZone(c);
        if (d)
          return $i.createOutsideEditor(o, d, "below", a);
      }
      const h = n.getLineNumberAtVerticalOffset(l);
      return $i.createOutsideEditor(o, new V(h, i.getLineMaxColumn(h)), "below", a);
    }
    const r = n.getLineNumberAtVerticalOffset(n.getCurrentScrollTop() + e.relativePos.y);
    if (e.posx < t.x) {
      const a = t.x - e.posx;
      return $i.createOutsideEditor(o, new V(r, 1), "left", a);
    }
    if (e.posx > t.x + t.width) {
      const a = e.posx - t.x - t.width;
      return $i.createOutsideEditor(o, new V(r, i.getLineMaxColumn(r)), "right", a);
    }
    return null;
  }
  _findMousePosition(e, t) {
    const i = this._getPositionOutsideEditor(e);
    if (i)
      return i;
    const n = this._createMouseTarget(e, t);
    if (!n.position)
      return null;
    if (n.type === 8 || n.type === 5) {
      const r = this._helpPositionJumpOverViewZone(n.detail);
      if (r)
        return $i.createViewZone(n.type, n.element, n.mouseColumn, r, n.detail);
    }
    return n;
  }
  _helpPositionJumpOverViewZone(e) {
    const t = new V(this._currentSelection.selectionStartLineNumber, this._currentSelection.selectionStartColumn), i = e.positionBefore, n = e.positionAfter;
    return i && n ? i.isBefore(t) ? i : n : null;
  }
  _dispatchMouse(e, t, i) {
    e.position && this._viewController.dispatchMouse({
      position: e.position,
      mouseColumn: e.mouseColumn,
      startedOnLineNumbers: this._mouseState.startedOnLineNumbers,
      revealType: i,
      inSelectionMode: t,
      mouseDownCount: this._mouseState.count,
      altKey: this._mouseState.altKey,
      ctrlKey: this._mouseState.ctrlKey,
      metaKey: this._mouseState.metaKey,
      shiftKey: this._mouseState.shiftKey,
      leftButton: this._mouseState.leftButton,
      middleButton: this._mouseState.middleButton,
      onInjectedText: e.type === 6 && e.detail.injectedText !== null
    });
  }
}
class BG extends q {
  constructor(e, t, i, n) {
    super(), this._context = e, this._viewHelper = t, this._mouseTargetFactory = i, this._dispatchMouse = n, this._operation = null;
  }
  dispose() {
    super.dispose(), this.stop();
  }
  start(e, t) {
    this._operation ? this._operation.setPosition(e, t) : this._operation = new WG(this._context, this._viewHelper, this._mouseTargetFactory, this._dispatchMouse, e, t);
  }
  stop() {
    this._operation && (this._operation.dispose(), this._operation = null);
  }
}
class WG extends q {
  constructor(e, t, i, n, o, r) {
    super(), this._context = e, this._viewHelper = t, this._mouseTargetFactory = i, this._dispatchMouse = n, this._position = o, this._mouseEvent = r, this._lastTime = Date.now(), this._animationFrameDisposable = Wn(ue(r.browserEvent), () => this._execute());
  }
  dispose() {
    this._animationFrameDisposable.dispose(), super.dispose();
  }
  setPosition(e, t) {
    this._position = e, this._mouseEvent = t;
  }
  /**
   * update internal state and return elapsed ms since last time
   */
  _tick() {
    const e = Date.now(), t = e - this._lastTime;
    return this._lastTime = e, t;
  }
  /**
   * get the number of lines per second to auto-scroll
   */
  _getScrollSpeed() {
    const e = this._context.configuration.options.get(
      67
      /* EditorOption.lineHeight */
    ), t = this._context.configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    ).height / e, i = this._position.outsideDistance / e;
    return i <= 1.5 ? Math.max(30, t * (1 + i)) : i <= 3 ? Math.max(60, t * (2 + i)) : Math.max(200, t * (7 + i));
  }
  _execute() {
    const e = this._context.configuration.options.get(
      67
      /* EditorOption.lineHeight */
    ), t = this._getScrollSpeed(), i = this._tick(), n = t * (i / 1e3) * e, o = this._position.outsidePosition === "above" ? -n : n;
    this._context.viewModel.viewLayout.deltaScrollNow(0, o), this._viewHelper.renderNow();
    const r = this._context.viewLayout.getLinesViewportData(), a = this._position.outsidePosition === "above" ? r.startLineNumber : r.endLineNumber;
    let l;
    {
      const c = Cx(this._viewHelper.viewDomNode), h = this._context.configuration.options.get(
        146
        /* EditorOption.layoutInfo */
      ).horizontalScrollbarHeight, d = new Qb(this._mouseEvent.pos.x, c.y + c.height - h - 0.1), u = wx(this._viewHelper.viewDomNode, c, d);
      l = this._mouseTargetFactory.createMouseTarget(this._viewHelper.getLastRenderData(), c, d, u, null);
    }
    (!l.position || l.position.lineNumber !== a) && (this._position.outsidePosition === "above" ? l = $i.createOutsideEditor(this._position.mouseColumn, new V(a, 1), "above", this._position.outsideDistance) : l = $i.createOutsideEditor(this._position.mouseColumn, new V(a, this._context.viewModel.getLineMaxColumn(a)), "below", this._position.outsideDistance)), this._dispatchMouse(
      l,
      !0,
      2
      /* NavigationCommandRevealType.None */
    ), this._animationFrameDisposable = Wn(ue(l.element), () => this._execute());
  }
}
const B1 = class B1 {
  // ms
  get altKey() {
    return this._altKey;
  }
  get ctrlKey() {
    return this._ctrlKey;
  }
  get metaKey() {
    return this._metaKey;
  }
  get shiftKey() {
    return this._shiftKey;
  }
  get leftButton() {
    return this._leftButton;
  }
  get middleButton() {
    return this._middleButton;
  }
  get startedOnLineNumbers() {
    return this._startedOnLineNumbers;
  }
  constructor() {
    this._altKey = !1, this._ctrlKey = !1, this._metaKey = !1, this._shiftKey = !1, this._leftButton = !1, this._middleButton = !1, this._startedOnLineNumbers = !1, this._lastMouseDownPosition = null, this._lastMouseDownPositionEqualCount = 0, this._lastMouseDownCount = 0, this._lastSetMouseDownCountTime = 0, this.isDragAndDrop = !1;
  }
  get count() {
    return this._lastMouseDownCount;
  }
  setModifiers(e) {
    this._altKey = e.altKey, this._ctrlKey = e.ctrlKey, this._metaKey = e.metaKey, this._shiftKey = e.shiftKey;
  }
  setStartButtons(e) {
    this._leftButton = e.leftButton, this._middleButton = e.middleButton;
  }
  setStartedOnLineNumbers(e) {
    this._startedOnLineNumbers = e;
  }
  trySetCount(e, t) {
    const i = (/* @__PURE__ */ new Date()).getTime();
    i - this._lastSetMouseDownCountTime > B1.CLEAR_MOUSE_DOWN_COUNT_TIME && (e = 1), this._lastSetMouseDownCountTime = i, e > this._lastMouseDownCount + 1 && (e = this._lastMouseDownCount + 1), this._lastMouseDownPosition && this._lastMouseDownPosition.equals(t) ? this._lastMouseDownPositionEqualCount++ : this._lastMouseDownPositionEqualCount = 1, this._lastMouseDownPosition = t, this._lastMouseDownCount = Math.min(e, this._lastMouseDownPositionEqualCount);
  }
};
B1.CLEAR_MOUSE_DOWN_COUNT_TIME = 400;
let LS = B1;
const Wh = class Wh {
  constructor(e, t, i, n, o) {
    this.value = e, this.selectionStart = t, this.selectionEnd = i, this.selection = n, this.newlineCountBeforeSelection = o;
  }
  toString() {
    return `[ <${this.value}>, selectionStart: ${this.selectionStart}, selectionEnd: ${this.selectionEnd}]`;
  }
  static readFromTextArea(e, t) {
    const i = e.getValue(), n = e.getSelectionStart(), o = e.getSelectionEnd();
    let r;
    if (t) {
      const a = i.substring(0, n), l = t.value.substring(0, t.selectionStart);
      a === l && (r = t.newlineCountBeforeSelection);
    }
    return new Wh(i, n, o, null, r);
  }
  collapseSelection() {
    return this.selectionStart === this.value.length ? this : new Wh(this.value, this.value.length, this.value.length, null, void 0);
  }
  writeToTextArea(e, t, i) {
    t.setValue(e, this.value), i && t.setSelectionRange(e, this.selectionStart, this.selectionEnd);
  }
  deduceEditorPosition(e) {
    var n, o, r, a;
    if (e <= this.selectionStart) {
      const l = this.value.substring(e, this.selectionStart);
      return this._finishDeduceEditorPosition(((n = this.selection) == null ? void 0 : n.getStartPosition()) ?? null, l, -1);
    }
    if (e >= this.selectionEnd) {
      const l = this.value.substring(this.selectionEnd, e);
      return this._finishDeduceEditorPosition(((o = this.selection) == null ? void 0 : o.getEndPosition()) ?? null, l, 1);
    }
    const t = this.value.substring(this.selectionStart, e);
    if (t.indexOf("…") === -1)
      return this._finishDeduceEditorPosition(((r = this.selection) == null ? void 0 : r.getStartPosition()) ?? null, t, 1);
    const i = this.value.substring(e, this.selectionEnd);
    return this._finishDeduceEditorPosition(((a = this.selection) == null ? void 0 : a.getEndPosition()) ?? null, i, -1);
  }
  _finishDeduceEditorPosition(e, t, i) {
    let n = 0, o = -1;
    for (; (o = t.indexOf(`
`, o + 1)) !== -1; )
      n++;
    return [e, i * t.length, n];
  }
  static deduceInput(e, t, i) {
    if (!e)
      return {
        text: "",
        replacePrevCharCnt: 0,
        replaceNextCharCnt: 0,
        positionDelta: 0
      };
    const n = Math.min(Fw(e.value, t.value), e.selectionStart, t.selectionStart), o = Math.min(Bw(e.value, t.value), e.value.length - e.selectionEnd, t.value.length - t.selectionEnd);
    e.value.substring(n, e.value.length - o);
    const r = t.value.substring(n, t.value.length - o), a = e.selectionStart - n, l = e.selectionEnd - n, c = t.selectionStart - n, h = t.selectionEnd - n;
    if (c === h) {
      const u = e.selectionStart - n;
      return {
        text: r,
        replacePrevCharCnt: u,
        replaceNextCharCnt: 0,
        positionDelta: 0
      };
    }
    const d = l - a;
    return {
      text: r,
      replacePrevCharCnt: d,
      replaceNextCharCnt: 0,
      positionDelta: 0
    };
  }
  static deduceAndroidCompositionInput(e, t) {
    if (!e)
      return {
        text: "",
        replacePrevCharCnt: 0,
        replaceNextCharCnt: 0,
        positionDelta: 0
      };
    if (e.value === t.value)
      return {
        text: "",
        replacePrevCharCnt: 0,
        replaceNextCharCnt: 0,
        positionDelta: t.selectionEnd - e.selectionEnd
      };
    const i = Math.min(Fw(e.value, t.value), e.selectionEnd), n = Math.min(Bw(e.value, t.value), e.value.length - e.selectionEnd), o = e.value.substring(i, e.value.length - n), r = t.value.substring(i, t.value.length - n);
    e.selectionStart - i;
    const a = e.selectionEnd - i;
    t.selectionStart - i;
    const l = t.selectionEnd - i;
    return {
      text: r,
      replacePrevCharCnt: a,
      replaceNextCharCnt: o.length - a,
      positionDelta: l - r.length
    };
  }
};
Wh.EMPTY = new Wh("", 0, 0, null, void 0);
let Ki = Wh;
class kh {
  static _getPageOfLine(e, t) {
    return Math.floor((e - 1) / t);
  }
  static _getRangeForPage(e, t) {
    const i = e * t, n = i + 1, o = i + t;
    return new R(n, 1, o + 1, 1);
  }
  static fromEditorSelection(e, t, i, n) {
    const r = kh._getPageOfLine(t.startLineNumber, i), a = kh._getRangeForPage(r, i), l = kh._getPageOfLine(t.endLineNumber, i), c = kh._getRangeForPage(l, i);
    let h = a.intersectRanges(new R(1, 1, t.startLineNumber, t.startColumn));
    if (n && e.getValueLengthInRange(
      h,
      1
      /* EndOfLinePreference.LF */
    ) > 500) {
      const b = e.modifyPosition(h.getEndPosition(), -500);
      h = R.fromPositions(b, h.getEndPosition());
    }
    const d = e.getValueInRange(
      h,
      1
      /* EndOfLinePreference.LF */
    ), u = e.getLineCount(), f = e.getLineMaxColumn(u);
    let g = c.intersectRanges(new R(t.endLineNumber, t.endColumn, u, f));
    if (n && e.getValueLengthInRange(
      g,
      1
      /* EndOfLinePreference.LF */
    ) > 500) {
      const b = e.modifyPosition(g.getStartPosition(), 500);
      g = R.fromPositions(g.getStartPosition(), b);
    }
    const m = e.getValueInRange(
      g,
      1
      /* EndOfLinePreference.LF */
    );
    let _;
    if (r === l || r + 1 === l)
      _ = e.getValueInRange(
        t,
        1
        /* EndOfLinePreference.LF */
      );
    else {
      const b = a.intersectRanges(t), C = c.intersectRanges(t);
      _ = e.getValueInRange(
        b,
        1
        /* EndOfLinePreference.LF */
      ) + "…" + e.getValueInRange(
        C,
        1
        /* EndOfLinePreference.LF */
      );
    }
    return n && _.length > 2 * 500 && (_ = _.substring(0, 500) + "…" + _.substring(_.length - 500, _.length)), new Ki(d + _ + m, d.length, d.length + _.length, t, h.endLineNumber - h.startLineNumber);
  }
}
var VG = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, lT = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, A_;
(function(s) {
  s.Tap = "-monaco-textarea-synthetic-tap";
})(A_ || (A_ = {}));
const W1 = class W1 {
  constructor() {
    this._lastState = null;
  }
  set(e, t) {
    this._lastState = { lastCopiedValue: e, data: t };
  }
  get(e) {
    return this._lastState && this._lastState.lastCopiedValue === e ? this._lastState.data : (this._lastState = null, null);
  }
};
W1.INSTANCE = new W1();
let P_ = W1;
class HG {
  constructor() {
    this._lastTypeTextLength = 0;
  }
  handleCompositionUpdate(e) {
    e = e || "";
    const t = {
      text: e,
      replacePrevCharCnt: this._lastTypeTextLength,
      replaceNextCharCnt: 0,
      positionDelta: 0
    };
    return this._lastTypeTextLength = e.length, t;
  }
}
let kS = class extends q {
  get textAreaState() {
    return this._textAreaState;
  }
  constructor(e, t, i, n, o, r) {
    super(), this._host = e, this._textArea = t, this._OS = i, this._browser = n, this._accessibilityService = o, this._logService = r, this._onFocus = this._register(new O()), this.onFocus = this._onFocus.event, this._onBlur = this._register(new O()), this.onBlur = this._onBlur.event, this._onKeyDown = this._register(new O()), this.onKeyDown = this._onKeyDown.event, this._onKeyUp = this._register(new O()), this.onKeyUp = this._onKeyUp.event, this._onCut = this._register(new O()), this.onCut = this._onCut.event, this._onPaste = this._register(new O()), this.onPaste = this._onPaste.event, this._onType = this._register(new O()), this.onType = this._onType.event, this._onCompositionStart = this._register(new O()), this.onCompositionStart = this._onCompositionStart.event, this._onCompositionUpdate = this._register(new O()), this.onCompositionUpdate = this._onCompositionUpdate.event, this._onCompositionEnd = this._register(new O()), this.onCompositionEnd = this._onCompositionEnd.event, this._onSelectionChangeRequest = this._register(new O()), this.onSelectionChangeRequest = this._onSelectionChangeRequest.event, this._asyncFocusGainWriteScreenReaderContent = this._register(new Zr()), this._asyncTriggerCut = this._register(new sn(() => this._onCut.fire(), 0)), this._textAreaState = Ki.EMPTY, this._selectionChangeListener = null, this._accessibilityService.isScreenReaderOptimized() && this.writeNativeTextAreaContent("ctor"), this._register(J.runAndSubscribe(this._accessibilityService.onDidChangeScreenReaderOptimized, () => {
      this._accessibilityService.isScreenReaderOptimized() && !this._asyncFocusGainWriteScreenReaderContent.value ? this._asyncFocusGainWriteScreenReaderContent.value = this._register(new sn(() => this.writeNativeTextAreaContent("asyncFocusGain"), 0)) : this._asyncFocusGainWriteScreenReaderContent.clear();
    })), this._hasFocus = !1, this._currentComposition = null;
    let a = null;
    this._register(this._textArea.onKeyDown((l) => {
      const c = new Lt(l);
      (c.keyCode === 114 || this._currentComposition && c.keyCode === 1) && c.stopPropagation(), c.equals(
        9
        /* KeyCode.Escape */
      ) && c.preventDefault(), a = c, this._onKeyDown.fire(c);
    })), this._register(this._textArea.onKeyUp((l) => {
      const c = new Lt(l);
      this._onKeyUp.fire(c);
    })), this._register(this._textArea.onCompositionStart((l) => {
      const c = new HG();
      if (this._currentComposition) {
        this._currentComposition = c;
        return;
      }
      if (this._currentComposition = c, this._OS === 2 && a && a.equals(
        114
        /* KeyCode.KEY_IN_COMPOSITION */
      ) && this._textAreaState.selectionStart === this._textAreaState.selectionEnd && this._textAreaState.selectionStart > 0 && this._textAreaState.value.substr(this._textAreaState.selectionStart - 1, 1) === l.data && (a.code === "ArrowRight" || a.code === "ArrowLeft")) {
        c.handleCompositionUpdate("x"), this._onCompositionStart.fire({ data: l.data });
        return;
      }
      if (this._browser.isAndroid) {
        this._onCompositionStart.fire({ data: l.data });
        return;
      }
      this._onCompositionStart.fire({ data: l.data });
    })), this._register(this._textArea.onCompositionUpdate((l) => {
      const c = this._currentComposition;
      if (!c)
        return;
      if (this._browser.isAndroid) {
        const d = Ki.readFromTextArea(this._textArea, this._textAreaState), u = Ki.deduceAndroidCompositionInput(this._textAreaState, d);
        this._textAreaState = d, this._onType.fire(u), this._onCompositionUpdate.fire(l);
        return;
      }
      const h = c.handleCompositionUpdate(l.data);
      this._textAreaState = Ki.readFromTextArea(this._textArea, this._textAreaState), this._onType.fire(h), this._onCompositionUpdate.fire(l);
    })), this._register(this._textArea.onCompositionEnd((l) => {
      const c = this._currentComposition;
      if (!c)
        return;
      if (this._currentComposition = null, this._browser.isAndroid) {
        const d = Ki.readFromTextArea(this._textArea, this._textAreaState), u = Ki.deduceAndroidCompositionInput(this._textAreaState, d);
        this._textAreaState = d, this._onType.fire(u), this._onCompositionEnd.fire();
        return;
      }
      const h = c.handleCompositionUpdate(l.data);
      this._textAreaState = Ki.readFromTextArea(this._textArea, this._textAreaState), this._onType.fire(h), this._onCompositionEnd.fire();
    })), this._register(this._textArea.onInput((l) => {
      if (this._textArea.setIgnoreSelectionChangeTime("received input event"), this._currentComposition)
        return;
      const c = Ki.readFromTextArea(this._textArea, this._textAreaState), h = Ki.deduceInput(
        this._textAreaState,
        c,
        /*couldBeEmojiInput*/
        this._OS === 2
        /* OperatingSystem.Macintosh */
      );
      h.replacePrevCharCnt === 0 && h.text.length === 1 && (hi(h.text.charCodeAt(0)) || h.text.charCodeAt(0) === 127) || (this._textAreaState = c, (h.text !== "" || h.replacePrevCharCnt !== 0 || h.replaceNextCharCnt !== 0 || h.positionDelta !== 0) && this._onType.fire(h));
    })), this._register(this._textArea.onCut((l) => {
      this._textArea.setIgnoreSelectionChangeTime("received cut event"), this._ensureClipboardGetsEditorSelection(l), this._asyncTriggerCut.schedule();
    })), this._register(this._textArea.onCopy((l) => {
      this._ensureClipboardGetsEditorSelection(l);
    })), this._register(this._textArea.onPaste((l) => {
      if (this._textArea.setIgnoreSelectionChangeTime("received paste event"), l.preventDefault(), !l.clipboardData)
        return;
      let [c, h] = cT.getTextData(l.clipboardData);
      c && (h = h || P_.INSTANCE.get(c), this._onPaste.fire({
        text: c,
        metadata: h
      }));
    })), this._register(this._textArea.onFocus(() => {
      const l = this._hasFocus;
      this._setHasFocus(!0), this._accessibilityService.isScreenReaderOptimized() && this._browser.isSafari && !l && this._hasFocus && (this._asyncFocusGainWriteScreenReaderContent.value || (this._asyncFocusGainWriteScreenReaderContent.value = new sn(() => this.writeNativeTextAreaContent("asyncFocusGain"), 0)), this._asyncFocusGainWriteScreenReaderContent.value.schedule());
    })), this._register(this._textArea.onBlur(() => {
      this._currentComposition && (this._currentComposition = null, this.writeNativeTextAreaContent("blurWithoutCompositionEnd"), this._onCompositionEnd.fire()), this._setHasFocus(!1);
    })), this._register(this._textArea.onSyntheticTap(() => {
      this._browser.isAndroid && this._currentComposition && (this._currentComposition = null, this.writeNativeTextAreaContent("tapWithoutCompositionEnd"), this._onCompositionEnd.fire());
    }));
  }
  _installSelectionChangeListener() {
    let e = 0;
    return $(this._textArea.ownerDocument, "selectionchange", (t) => {
      if (Na.onSelectionChange(), !this._hasFocus || this._currentComposition || !this._browser.isChrome)
        return;
      const i = Date.now(), n = i - e;
      if (e = i, n < 5)
        return;
      const o = i - this._textArea.getIgnoreSelectionChangeTime();
      if (this._textArea.resetSelectionChangeTime(), o < 100 || !this._textAreaState.selection)
        return;
      const r = this._textArea.getValue();
      if (this._textAreaState.value !== r)
        return;
      const a = this._textArea.getSelectionStart(), l = this._textArea.getSelectionEnd();
      if (this._textAreaState.selectionStart === a && this._textAreaState.selectionEnd === l)
        return;
      const c = this._textAreaState.deduceEditorPosition(a), h = this._host.deduceModelPosition(c[0], c[1], c[2]), d = this._textAreaState.deduceEditorPosition(l), u = this._host.deduceModelPosition(d[0], d[1], d[2]), f = new ft(h.lineNumber, h.column, u.lineNumber, u.column);
      this._onSelectionChangeRequest.fire(f);
    });
  }
  dispose() {
    super.dispose(), this._selectionChangeListener && (this._selectionChangeListener.dispose(), this._selectionChangeListener = null);
  }
  focusTextArea() {
    this._setHasFocus(!0), this.refreshFocusState();
  }
  isFocused() {
    return this._hasFocus;
  }
  refreshFocusState() {
    this._setHasFocus(this._textArea.hasFocus());
  }
  _setHasFocus(e) {
    this._hasFocus !== e && (this._hasFocus = e, this._selectionChangeListener && (this._selectionChangeListener.dispose(), this._selectionChangeListener = null), this._hasFocus && (this._selectionChangeListener = this._installSelectionChangeListener()), this._hasFocus && this.writeNativeTextAreaContent("focusgain"), this._hasFocus ? this._onFocus.fire() : this._onBlur.fire());
  }
  _setAndWriteTextAreaState(e, t) {
    this._hasFocus || (t = t.collapseSelection()), t.writeToTextArea(e, this._textArea, this._hasFocus), this._textAreaState = t;
  }
  writeNativeTextAreaContent(e) {
    !this._accessibilityService.isScreenReaderOptimized() && e === "render" || this._currentComposition || (this._logService.trace(`writeTextAreaState(reason: ${e})`), this._setAndWriteTextAreaState(e, this._host.getScreenReaderContent()));
  }
  _ensureClipboardGetsEditorSelection(e) {
    const t = this._host.getDataToCopy(), i = {
      version: 1,
      isFromEmptySelection: t.isFromEmptySelection,
      multicursorText: t.multicursorText,
      mode: t.mode
    };
    P_.INSTANCE.set(
      // When writing "LINE\r\n" to the clipboard and then pasting,
      // Firefox pastes "LINE\n", so let's work around this quirk
      this._browser.isFirefox ? t.text.replace(/\r\n/g, `
`) : t.text,
      i
    ), e.preventDefault(), e.clipboardData && cT.setTextData(e.clipboardData, t.text, t.html, i);
  }
};
kS = VG([
  lT(4, go),
  lT(5, uo)
], kS);
const cT = {
  getTextData(s) {
    const e = s.getData(Dr.text);
    let t = null;
    const i = s.getData("vscode-editor-data");
    if (typeof i == "string")
      try {
        t = JSON.parse(i), t.version !== 1 && (t = null);
      } catch {
      }
    return e.length === 0 && t === null && s.files.length > 0 ? [Array.prototype.slice.call(s.files, 0).map((o) => o.name).join(`
`), null] : [e, t];
  },
  setTextData(s, e, t, i) {
    s.setData(Dr.text, e), typeof t == "string" && s.setData("text/html", t), s.setData("vscode-editor-data", JSON.stringify(i));
  }
};
class zG extends q {
  get ownerDocument() {
    return this._actual.ownerDocument;
  }
  constructor(e) {
    super(), this._actual = e, this.onKeyDown = this._register(new Re(this._actual, "keydown")).event, this.onKeyUp = this._register(new Re(this._actual, "keyup")).event, this.onCompositionStart = this._register(new Re(this._actual, "compositionstart")).event, this.onCompositionUpdate = this._register(new Re(this._actual, "compositionupdate")).event, this.onCompositionEnd = this._register(new Re(this._actual, "compositionend")).event, this.onBeforeInput = this._register(new Re(this._actual, "beforeinput")).event, this.onInput = this._register(new Re(this._actual, "input")).event, this.onCut = this._register(new Re(this._actual, "cut")).event, this.onCopy = this._register(new Re(this._actual, "copy")).event, this.onPaste = this._register(new Re(this._actual, "paste")).event, this.onFocus = this._register(new Re(this._actual, "focus")).event, this.onBlur = this._register(new Re(this._actual, "blur")).event, this._onSyntheticTap = this._register(new O()), this.onSyntheticTap = this._onSyntheticTap.event, this._ignoreSelectionChangeTime = 0, this._register(this.onKeyDown(() => Na.onKeyDown())), this._register(this.onBeforeInput(() => Na.onBeforeInput())), this._register(this.onInput(() => Na.onInput())), this._register(this.onKeyUp(() => Na.onKeyUp())), this._register($(this._actual, A_.Tap, () => this._onSyntheticTap.fire()));
  }
  hasFocus() {
    const e = bd(this._actual);
    return e ? e.activeElement === this._actual : this._actual.isConnected ? Gi() === this._actual : !1;
  }
  setIgnoreSelectionChangeTime(e) {
    this._ignoreSelectionChangeTime = Date.now();
  }
  getIgnoreSelectionChangeTime() {
    return this._ignoreSelectionChangeTime;
  }
  resetSelectionChangeTime() {
    this._ignoreSelectionChangeTime = 0;
  }
  getValue() {
    return this._actual.value;
  }
  setValue(e, t) {
    const i = this._actual;
    i.value !== t && (this.setIgnoreSelectionChangeTime("setValue"), i.value = t);
  }
  getSelectionStart() {
    return this._actual.selectionDirection === "backward" ? this._actual.selectionEnd : this._actual.selectionStart;
  }
  getSelectionEnd() {
    return this._actual.selectionDirection === "backward" ? this._actual.selectionStart : this._actual.selectionEnd;
  }
  setSelectionRange(e, t, i) {
    const n = this._actual;
    let o = null;
    const r = bd(n);
    r ? o = r.activeElement : o = Gi();
    const a = ue(o), l = o === n, c = n.selectionStart, h = n.selectionEnd;
    if (l && c === t && h === i) {
      As && a.parent !== a && n.focus();
      return;
    }
    if (l) {
      this.setIgnoreSelectionChangeTime("setSelectionRange"), n.setSelectionRange(t, i), As && a.parent !== a && n.focus();
      return;
    }
    try {
      const d = c7(n);
      this.setIgnoreSelectionChangeTime("setSelectionRange"), n.focus(), n.setSelectionRange(t, i), h7(n, d);
    } catch {
    }
  }
}
class UG extends vx {
  constructor(e, t, i) {
    super(e, t, i), this._register(an.addTarget(this.viewHelper.linesContentDomNode)), this._register($(this.viewHelper.linesContentDomNode, bt.Tap, (o) => this.onTap(o))), this._register($(this.viewHelper.linesContentDomNode, bt.Change, (o) => this.onChange(o))), this._register($(this.viewHelper.linesContentDomNode, bt.Contextmenu, (o) => this._onContextMenu(new Za(o, !1, this.viewHelper.viewDomNode), !1))), this._lastPointerType = "mouse", this._register($(this.viewHelper.linesContentDomNode, "pointerdown", (o) => {
      const r = o.pointerType;
      if (r === "mouse") {
        this._lastPointerType = "mouse";
        return;
      } else r === "touch" ? this._lastPointerType = "touch" : this._lastPointerType = "pen";
    }));
    const n = new SG(this.viewHelper.viewDomNode);
    this._register(n.onPointerMove(this.viewHelper.viewDomNode, (o) => this._onMouseMove(o))), this._register(n.onPointerUp(this.viewHelper.viewDomNode, (o) => this._onMouseUp(o))), this._register(n.onPointerLeave(this.viewHelper.viewDomNode, (o) => this._onMouseLeave(o))), this._register(n.onPointerDown(this.viewHelper.viewDomNode, (o, r) => this._onMouseDown(o, r)));
  }
  onTap(e) {
    !e.initialTarget || !this.viewHelper.linesContentDomNode.contains(e.initialTarget) || (e.preventDefault(), this.viewHelper.focusTextArea(), this._dispatchGesture(
      e,
      /*inSelectionMode*/
      !1
    ));
  }
  onChange(e) {
    this._lastPointerType === "touch" && this._context.viewModel.viewLayout.deltaScrollNow(-e.translationX, -e.translationY), this._lastPointerType === "pen" && this._dispatchGesture(
      e,
      /*inSelectionMode*/
      !0
    );
  }
  _dispatchGesture(e, t) {
    const i = this._createMouseTarget(new Za(e, !1, this.viewHelper.viewDomNode), !1);
    i.position && this.viewController.dispatchMouse({
      position: i.position,
      mouseColumn: i.position.column,
      startedOnLineNumbers: !1,
      revealType: 1,
      mouseDownCount: e.tapCount,
      inSelectionMode: t,
      altKey: !1,
      ctrlKey: !1,
      metaKey: !1,
      shiftKey: !1,
      leftButton: !1,
      middleButton: !1,
      onInjectedText: i.type === 6 && i.detail.injectedText !== null
    });
  }
  _onMouseDown(e, t) {
    e.browserEvent.pointerType !== "touch" && super._onMouseDown(e, t);
  }
}
class $G extends vx {
  constructor(e, t, i) {
    super(e, t, i), this._register(an.addTarget(this.viewHelper.linesContentDomNode)), this._register($(this.viewHelper.linesContentDomNode, bt.Tap, (n) => this.onTap(n))), this._register($(this.viewHelper.linesContentDomNode, bt.Change, (n) => this.onChange(n))), this._register($(this.viewHelper.linesContentDomNode, bt.Contextmenu, (n) => this._onContextMenu(new Za(n, !1, this.viewHelper.viewDomNode), !1)));
  }
  onTap(e) {
    e.preventDefault(), this.viewHelper.focusTextArea();
    const t = this._createMouseTarget(new Za(e, !1, this.viewHelper.viewDomNode), !1);
    if (t.position) {
      const i = document.createEvent("CustomEvent");
      i.initEvent(A_.Tap, !1, !0), this.viewHelper.dispatchTextAreaEvent(i), this.viewController.moveTo(
        t.position,
        1
        /* NavigationCommandRevealType.Minimal */
      );
    }
  }
  onChange(e) {
    this._context.viewModel.viewLayout.deltaScrollNow(-e.translationX, -e.translationY);
  }
}
class KG extends q {
  constructor(e, t, i) {
    super(), (fc || aP && x2) && nM.pointerEvents ? this.handler = this._register(new UG(e, t, i)) : ut.TouchEvent ? this.handler = this._register(new $G(e, t, i)) : this.handler = this._register(new vx(e, t, i));
  }
  getTargetAtClientPoint(e, t) {
    return this.handler.getTargetAtClientPoint(e, t);
  }
}
class Hc extends Kg {
}
const V1 = class V1 extends Hc {
  constructor(e) {
    super(), this._context = e, this._readConfig(), this._lastCursorModelPosition = new V(1, 1), this._renderResult = null, this._activeLineNumber = 1, this._context.addEventHandler(this);
  }
  _readConfig() {
    const e = this._context.configuration.options;
    this._lineHeight = e.get(
      67
      /* EditorOption.lineHeight */
    );
    const t = e.get(
      68
      /* EditorOption.lineNumbers */
    );
    this._renderLineNumbers = t.renderType, this._renderCustomLineNumbers = t.renderFn, this._renderFinalNewline = e.get(
      96
      /* EditorOption.renderFinalNewline */
    );
    const i = e.get(
      146
      /* EditorOption.layoutInfo */
    );
    this._lineNumbersLeft = i.lineNumbersLeft, this._lineNumbersWidth = i.lineNumbersWidth;
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    return this._readConfig(), !0;
  }
  onCursorStateChanged(e) {
    const t = e.selections[0].getPosition();
    this._lastCursorModelPosition = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(t);
    let i = !1;
    return this._activeLineNumber !== t.lineNumber && (this._activeLineNumber = t.lineNumber, i = !0), (this._renderLineNumbers === 2 || this._renderLineNumbers === 3) && (i = !0), i;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  onDecorationsChanged(e) {
    return e.affectsLineNumber;
  }
  // --- end event handlers
  _getLineRenderLineNumber(e) {
    const t = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new V(e, 1));
    if (t.column !== 1)
      return "";
    const i = t.lineNumber;
    if (this._renderCustomLineNumbers)
      return this._renderCustomLineNumbers(i);
    if (this._renderLineNumbers === 2) {
      const n = Math.abs(this._lastCursorModelPosition.lineNumber - i);
      return n === 0 ? '<span class="relative-current-line-number">' + i + "</span>" : String(n);
    }
    if (this._renderLineNumbers === 3) {
      if (this._lastCursorModelPosition.lineNumber === i || i % 10 === 0)
        return String(i);
      const n = this._context.viewModel.getLineCount();
      return i === n ? String(i) : "";
    }
    return String(i);
  }
  prepareRender(e) {
    if (this._renderLineNumbers === 0) {
      this._renderResult = null;
      return;
    }
    const t = wn ? this._lineHeight % 2 === 0 ? " lh-even" : " lh-odd" : "", i = e.visibleRange.startLineNumber, n = e.visibleRange.endLineNumber, o = this._context.viewModel.getDecorationsInViewport(e.visibleRange).filter((c) => !!c.options.lineNumberClassName);
    o.sort((c, h) => R.compareRangesUsingEnds(c.range, h.range));
    let r = 0;
    const a = this._context.viewModel.getLineCount(), l = [];
    for (let c = i; c <= n; c++) {
      const h = c - i;
      let d = this._getLineRenderLineNumber(c), u = "";
      for (; r < o.length && o[r].range.endLineNumber < c; )
        r++;
      for (let f = r; f < o.length; f++) {
        const { range: g, options: m } = o[f];
        g.startLineNumber <= c && (u += " " + m.lineNumberClassName);
      }
      if (!d && !u) {
        l[h] = "";
        continue;
      }
      c === a && this._context.viewModel.getLineLength(c) === 0 && (this._renderFinalNewline === "off" && (d = ""), this._renderFinalNewline === "dimmed" && (u += " dimmed-line-number")), c === this._activeLineNumber && (u += " active-line-number"), l[h] = `<div class="${V1.CLASS_NAME}${t}${u}" style="left:${this._lineNumbersLeft}px;width:${this._lineNumbersWidth}px;">${d}</div>`;
    }
    this._renderResult = l;
  }
  render(e, t) {
    if (!this._renderResult)
      return "";
    const i = t - e;
    return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
  }
};
V1.CLASS_NAME = "line-numbers";
let O_ = V1;
Jr((s, e) => {
  const t = s.getColor(Lz), i = s.getColor(Bz);
  i ? e.addRule(`.monaco-editor .line-numbers.dimmed-line-number { color: ${i}; }`) : t && e.addRule(`.monaco-editor .line-numbers.dimmed-line-number { color: ${t.transparent(0.4)}; }`);
});
const Vh = class Vh extends Hn {
  constructor(e) {
    super(e);
    const t = this._context.configuration.options, i = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    this._canUseLayerHinting = !t.get(
      32
      /* EditorOption.disableLayerHinting */
    ), this._contentLeft = i.contentLeft, this._glyphMarginLeft = i.glyphMarginLeft, this._glyphMarginWidth = i.glyphMarginWidth, this._domNode = je(document.createElement("div")), this._domNode.setClassName(Vh.OUTER_CLASS_NAME), this._domNode.setPosition("absolute"), this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true"), this._glyphMarginBackgroundDomNode = je(document.createElement("div")), this._glyphMarginBackgroundDomNode.setClassName(Vh.CLASS_NAME), this._domNode.appendChild(this._glyphMarginBackgroundDomNode);
  }
  dispose() {
    super.dispose();
  }
  getDomNode() {
    return this._domNode;
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    return this._canUseLayerHinting = !t.get(
      32
      /* EditorOption.disableLayerHinting */
    ), this._contentLeft = i.contentLeft, this._glyphMarginLeft = i.glyphMarginLeft, this._glyphMarginWidth = i.glyphMarginWidth, !0;
  }
  onScrollChanged(e) {
    return super.onScrollChanged(e) || e.scrollTopChanged;
  }
  // --- end event handlers
  prepareRender(e) {
  }
  render(e) {
    this._domNode.setLayerHinting(this._canUseLayerHinting), this._domNode.setContain("strict");
    const t = e.scrollTop - e.bigNumbersDelta;
    this._domNode.setTop(-t);
    const i = Math.min(e.scrollHeight, 1e6);
    this._domNode.setHeight(i), this._domNode.setWidth(this._contentLeft), this._glyphMarginBackgroundDomNode.setLeft(this._glyphMarginLeft), this._glyphMarginBackgroundDomNode.setWidth(this._glyphMarginWidth), this._glyphMarginBackgroundDomNode.setHeight(i);
  }
};
Vh.CLASS_NAME = "glyph-margin", Vh.OUTER_CLASS_NAME = "margin";
let F_ = Vh;
const ld = "monaco-mouse-cursor-text";
var qG = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, hT = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
class jG {
  constructor(e, t, i, n, o) {
    this._context = e, this.modelLineNumber = t, this.distanceToModelLineStart = i, this.widthOfHiddenLineTextBefore = n, this.distanceToModelLineEnd = o, this._visibleTextAreaBrand = void 0, this.startPosition = null, this.endPosition = null, this.visibleTextareaStart = null, this.visibleTextareaEnd = null, this._previousPresentation = null;
  }
  prepareRender(e) {
    const t = new V(this.modelLineNumber, this.distanceToModelLineStart + 1), i = new V(this.modelLineNumber, this._context.viewModel.model.getLineMaxColumn(this.modelLineNumber) - this.distanceToModelLineEnd);
    this.startPosition = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(t), this.endPosition = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(i), this.startPosition.lineNumber === this.endPosition.lineNumber ? (this.visibleTextareaStart = e.visibleRangeForPosition(this.startPosition), this.visibleTextareaEnd = e.visibleRangeForPosition(this.endPosition)) : (this.visibleTextareaStart = null, this.visibleTextareaEnd = null);
  }
  definePresentation(e) {
    return this._previousPresentation || (e ? this._previousPresentation = e : this._previousPresentation = {
      foreground: 1,
      italic: !1,
      bold: !1,
      underline: !1,
      strikethrough: !1
    }), this._previousPresentation;
  }
}
const gC = As;
let xS = class extends Hn {
  constructor(e, t, i, n, o) {
    super(e), this._keybindingService = n, this._instantiationService = o, this._primaryCursorPosition = new V(1, 1), this._primaryCursorVisibleRange = null, this._viewController = t, this._visibleRangeProvider = i, this._scrollLeft = 0, this._scrollTop = 0;
    const r = this._context.configuration.options, a = r.get(
      146
      /* EditorOption.layoutInfo */
    );
    this._setAccessibilityOptions(r), this._contentLeft = a.contentLeft, this._contentWidth = a.contentWidth, this._contentHeight = a.height, this._fontInfo = r.get(
      50
      /* EditorOption.fontInfo */
    ), this._lineHeight = r.get(
      67
      /* EditorOption.lineHeight */
    ), this._emptySelectionClipboard = r.get(
      37
      /* EditorOption.emptySelectionClipboard */
    ), this._copyWithSyntaxHighlighting = r.get(
      25
      /* EditorOption.copyWithSyntaxHighlighting */
    ), this._visibleTextArea = null, this._selections = [new ft(1, 1, 1, 1)], this._modelSelections = [new ft(1, 1, 1, 1)], this._lastRenderPosition = null, this.textArea = je(document.createElement("textarea")), ho.write(
      this.textArea,
      7
      /* PartFingerprint.TextArea */
    ), this.textArea.setClassName(`inputarea ${ld}`), this.textArea.setAttribute("wrap", this._textAreaWrapping && !this._visibleTextArea ? "on" : "off");
    const { tabSize: l } = this._context.viewModel.model.getOptions();
    this.textArea.domNode.style.tabSize = `${l * this._fontInfo.spaceWidth}px`, this.textArea.setAttribute("autocorrect", "off"), this.textArea.setAttribute("autocapitalize", "off"), this.textArea.setAttribute("autocomplete", "off"), this.textArea.setAttribute("spellcheck", "false"), this.textArea.setAttribute("aria-label", this._getAriaLabel(r)), this.textArea.setAttribute("aria-required", r.get(
      5
      /* EditorOption.ariaRequired */
    ) ? "true" : "false"), this.textArea.setAttribute("tabindex", String(r.get(
      125
      /* EditorOption.tabIndex */
    ))), this.textArea.setAttribute("role", "textbox"), this.textArea.setAttribute("aria-roledescription", p("editor", "editor")), this.textArea.setAttribute("aria-multiline", "true"), this.textArea.setAttribute("aria-autocomplete", r.get(
      92
      /* EditorOption.readOnly */
    ) ? "none" : "both"), this._ensureReadOnlyAttribute(), this.textAreaCover = je(document.createElement("div")), this.textAreaCover.setPosition("absolute");
    const c = {
      getLineCount: () => this._context.viewModel.getLineCount(),
      getLineMaxColumn: (u) => this._context.viewModel.getLineMaxColumn(u),
      getValueInRange: (u, f) => this._context.viewModel.getValueInRange(u, f),
      getValueLengthInRange: (u, f) => this._context.viewModel.getValueLengthInRange(u, f),
      modifyPosition: (u, f) => this._context.viewModel.modifyPosition(u, f)
    }, h = {
      getDataToCopy: () => {
        const u = this._context.viewModel.getPlainTextToCopy(this._modelSelections, this._emptySelectionClipboard, Fn), f = this._context.viewModel.model.getEOL(), g = this._emptySelectionClipboard && this._modelSelections.length === 1 && this._modelSelections[0].isEmpty(), m = Array.isArray(u) ? u : null, _ = Array.isArray(u) ? u.join(f) : u;
        let b, C = null;
        if (this._copyWithSyntaxHighlighting && _.length < 65536) {
          const v = this._context.viewModel.getRichTextToCopy(this._modelSelections, this._emptySelectionClipboard);
          v && (b = v.html, C = v.mode);
        }
        return {
          isFromEmptySelection: g,
          multicursorText: m,
          text: _,
          html: b,
          mode: C
        };
      },
      getScreenReaderContent: () => {
        if (this._accessibilitySupport === 1) {
          const u = this._selections[0];
          if (He && u.isEmpty()) {
            const g = u.getStartPosition();
            let m = this._getWordBeforePosition(g);
            if (m.length === 0 && (m = this._getCharacterBeforePosition(g)), m.length > 0)
              return new Ki(m, m.length, m.length, R.fromPositions(g), 0);
          }
          if (He && !u.isEmpty() && c.getValueLengthInRange(
            u,
            0
            /* EndOfLinePreference.TextDefined */
          ) < 500) {
            const g = c.getValueInRange(
              u,
              0
              /* EndOfLinePreference.TextDefined */
            );
            return new Ki(g, 0, g.length, u, 0);
          }
          if (Ua && !u.isEmpty()) {
            const g = "vscode-placeholder";
            return new Ki(g, 0, g.length, null, void 0);
          }
          return Ki.EMPTY;
        }
        if (yD) {
          const u = this._selections[0];
          if (u.isEmpty()) {
            const f = u.getStartPosition(), [g, m] = this._getAndroidWordAtPosition(f);
            if (g.length > 0)
              return new Ki(g, m, m, R.fromPositions(f), 0);
          }
          return Ki.EMPTY;
        }
        return kh.fromEditorSelection(
          c,
          this._selections[0],
          this._accessibilityPageSize,
          this._accessibilitySupport === 0
          /* AccessibilitySupport.Unknown */
        );
      },
      deduceModelPosition: (u, f, g) => this._context.viewModel.deduceModelPositionRelativeToViewPosition(u, f, g)
    }, d = this._register(new zG(this.textArea.domNode));
    this._textAreaInput = this._register(this._instantiationService.createInstance(kS, h, d, Es, {
      isAndroid: yD,
      isChrome: Lg,
      isFirefox: As,
      isSafari: Ua
    })), this._register(this._textAreaInput.onKeyDown((u) => {
      this._viewController.emitKeyDown(u);
    })), this._register(this._textAreaInput.onKeyUp((u) => {
      this._viewController.emitKeyUp(u);
    })), this._register(this._textAreaInput.onPaste((u) => {
      let f = !1, g = null, m = null;
      u.metadata && (f = this._emptySelectionClipboard && !!u.metadata.isFromEmptySelection, g = typeof u.metadata.multicursorText < "u" ? u.metadata.multicursorText : null, m = u.metadata.mode), this._viewController.paste(u.text, f, g, m);
    })), this._register(this._textAreaInput.onCut(() => {
      this._viewController.cut();
    })), this._register(this._textAreaInput.onType((u) => {
      u.replacePrevCharCnt || u.replaceNextCharCnt || u.positionDelta ? this._viewController.compositionType(u.text, u.replacePrevCharCnt, u.replaceNextCharCnt, u.positionDelta) : this._viewController.type(u.text);
    })), this._register(this._textAreaInput.onSelectionChangeRequest((u) => {
      this._viewController.setSelection(u);
    })), this._register(this._textAreaInput.onCompositionStart((u) => {
      const f = this.textArea.domNode, g = this._modelSelections[0], { distanceToModelLineStart: m, widthOfHiddenTextBefore: _ } = (() => {
        const C = f.value.substring(0, Math.min(f.selectionStart, f.selectionEnd)), v = C.lastIndexOf(`
`), w = C.substring(v + 1), S = w.lastIndexOf("	"), L = w.length - S - 1, k = g.getStartPosition(), D = Math.min(k.column - 1, L), E = k.column - 1 - D, U = w.substring(0, w.length - D), { tabSize: P } = this._context.viewModel.model.getOptions(), B = GG(this.textArea.domNode.ownerDocument, U, this._fontInfo, P);
        return { distanceToModelLineStart: E, widthOfHiddenTextBefore: B };
      })(), { distanceToModelLineEnd: b } = (() => {
        const C = f.value.substring(Math.max(f.selectionStart, f.selectionEnd)), v = C.indexOf(`
`), w = v === -1 ? C : C.substring(0, v), S = w.indexOf("	"), L = S === -1 ? w.length : w.length - S - 1, k = g.getEndPosition(), D = Math.min(this._context.viewModel.model.getLineMaxColumn(k.lineNumber) - k.column, L);
        return { distanceToModelLineEnd: this._context.viewModel.model.getLineMaxColumn(k.lineNumber) - k.column - D };
      })();
      this._context.viewModel.revealRange(
        "keyboard",
        !0,
        R.fromPositions(this._selections[0].getStartPosition()),
        0,
        1
        /* ScrollType.Immediate */
      ), this._visibleTextArea = new jG(this._context, g.startLineNumber, m, _, b), this.textArea.setAttribute("wrap", this._textAreaWrapping && !this._visibleTextArea ? "on" : "off"), this._visibleTextArea.prepareRender(this._visibleRangeProvider), this._render(), this.textArea.setClassName(`inputarea ${ld} ime-input`), this._viewController.compositionStart(), this._context.viewModel.onCompositionStart();
    })), this._register(this._textAreaInput.onCompositionUpdate((u) => {
      this._visibleTextArea && (this._visibleTextArea.prepareRender(this._visibleRangeProvider), this._render());
    })), this._register(this._textAreaInput.onCompositionEnd(() => {
      this._visibleTextArea = null, this.textArea.setAttribute("wrap", this._textAreaWrapping && !this._visibleTextArea ? "on" : "off"), this._render(), this.textArea.setClassName(`inputarea ${ld}`), this._viewController.compositionEnd(), this._context.viewModel.onCompositionEnd();
    })), this._register(this._textAreaInput.onFocus(() => {
      this._context.viewModel.setHasFocus(!0);
    })), this._register(this._textAreaInput.onBlur(() => {
      this._context.viewModel.setHasFocus(!1);
    })), this._register($u.onDidChange(() => {
      this._ensureReadOnlyAttribute();
    }));
  }
  writeScreenReaderContent(e) {
    this._textAreaInput.writeNativeTextAreaContent(e);
  }
  dispose() {
    super.dispose();
  }
  _getAndroidWordAtPosition(e) {
    const t = '`~!@#$%^&*()-=+[{]}\\|;:",.<>/?', i = this._context.viewModel.getLineContent(e.lineNumber), n = vd(t, []);
    let o = !0, r = e.column, a = !0, l = e.column, c = 0;
    for (; c < 50 && (o || a); ) {
      if (o && r <= 1 && (o = !1), o) {
        const h = i.charCodeAt(r - 2);
        n.get(h) !== 0 ? o = !1 : r--;
      }
      if (a && l > i.length && (a = !1), a) {
        const h = i.charCodeAt(l - 1);
        n.get(h) !== 0 ? a = !1 : l++;
      }
      c++;
    }
    return [i.substring(r - 1, l - 1), e.column - r];
  }
  _getWordBeforePosition(e) {
    const t = this._context.viewModel.getLineContent(e.lineNumber), i = vd(this._context.configuration.options.get(
      132
      /* EditorOption.wordSeparators */
    ), []);
    let n = e.column, o = 0;
    for (; n > 1; ) {
      const r = t.charCodeAt(n - 2);
      if (i.get(r) !== 0 || o > 50)
        return t.substring(n - 1, e.column - 1);
      o++, n--;
    }
    return t.substring(0, e.column - 1);
  }
  _getCharacterBeforePosition(e) {
    if (e.column > 1) {
      const i = this._context.viewModel.getLineContent(e.lineNumber).charAt(e.column - 2);
      if (!hi(i.charCodeAt(0)))
        return i;
    }
    return "";
  }
  _getAriaLabel(e) {
    var i, n, o;
    if (e.get(
      2
      /* EditorOption.accessibilitySupport */
    ) === 1) {
      const r = (i = this._keybindingService.lookupKeybinding("editor.action.toggleScreenReaderAccessibilityMode")) == null ? void 0 : i.getAriaLabel(), a = (n = this._keybindingService.lookupKeybinding("workbench.action.showCommands")) == null ? void 0 : n.getAriaLabel(), l = (o = this._keybindingService.lookupKeybinding("workbench.action.openGlobalKeybindings")) == null ? void 0 : o.getAriaLabel(), c = p("accessibilityModeOff", "The editor is not accessible at this time.");
      return r ? p("accessibilityOffAriaLabel", "{0} To enable screen reader optimized mode, use {1}", c, r) : a ? p("accessibilityOffAriaLabelNoKb", "{0} To enable screen reader optimized mode, open the quick pick with {1} and run the command Toggle Screen Reader Accessibility Mode, which is currently not triggerable via keyboard.", c, a) : l ? p("accessibilityOffAriaLabelNoKbs", "{0} Please assign a keybinding for the command Toggle Screen Reader Accessibility Mode by accessing the keybindings editor with {1} and run it.", c, l) : c;
    }
    return e.get(
      4
      /* EditorOption.ariaLabel */
    );
  }
  _setAccessibilityOptions(e) {
    this._accessibilitySupport = e.get(
      2
      /* EditorOption.accessibilitySupport */
    );
    const t = e.get(
      3
      /* EditorOption.accessibilityPageSize */
    );
    this._accessibilitySupport === 2 && t === xc.accessibilityPageSize.defaultValue ? this._accessibilityPageSize = 500 : this._accessibilityPageSize = t;
    const n = e.get(
      146
      /* EditorOption.layoutInfo */
    ).wrappingColumn;
    if (n !== -1 && this._accessibilitySupport !== 1) {
      const o = e.get(
        50
        /* EditorOption.fontInfo */
      );
      this._textAreaWrapping = !0, this._textAreaWidth = Math.round(n * o.typicalHalfwidthCharacterWidth);
    } else
      this._textAreaWrapping = !1, this._textAreaWidth = gC ? 0 : 1;
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    this._setAccessibilityOptions(t), this._contentLeft = i.contentLeft, this._contentWidth = i.contentWidth, this._contentHeight = i.height, this._fontInfo = t.get(
      50
      /* EditorOption.fontInfo */
    ), this._lineHeight = t.get(
      67
      /* EditorOption.lineHeight */
    ), this._emptySelectionClipboard = t.get(
      37
      /* EditorOption.emptySelectionClipboard */
    ), this._copyWithSyntaxHighlighting = t.get(
      25
      /* EditorOption.copyWithSyntaxHighlighting */
    ), this.textArea.setAttribute("wrap", this._textAreaWrapping && !this._visibleTextArea ? "on" : "off");
    const { tabSize: n } = this._context.viewModel.model.getOptions();
    return this.textArea.domNode.style.tabSize = `${n * this._fontInfo.spaceWidth}px`, this.textArea.setAttribute("aria-label", this._getAriaLabel(t)), this.textArea.setAttribute("aria-required", t.get(
      5
      /* EditorOption.ariaRequired */
    ) ? "true" : "false"), this.textArea.setAttribute("tabindex", String(t.get(
      125
      /* EditorOption.tabIndex */
    ))), (e.hasChanged(
      34
      /* EditorOption.domReadOnly */
    ) || e.hasChanged(
      92
      /* EditorOption.readOnly */
    )) && this._ensureReadOnlyAttribute(), e.hasChanged(
      2
      /* EditorOption.accessibilitySupport */
    ) && this._textAreaInput.writeNativeTextAreaContent("strategy changed"), !0;
  }
  onCursorStateChanged(e) {
    return this._selections = e.selections.slice(0), this._modelSelections = e.modelSelections.slice(0), this._textAreaInput.writeNativeTextAreaContent("selection changed"), !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return this._scrollLeft = e.scrollLeft, this._scrollTop = e.scrollTop, !0;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  // --- begin view API
  isFocused() {
    return this._textAreaInput.isFocused();
  }
  focusTextArea() {
    this._textAreaInput.focusTextArea();
  }
  getLastRenderData() {
    return this._lastRenderPosition;
  }
  setAriaOptions(e) {
    e.activeDescendant ? (this.textArea.setAttribute("aria-haspopup", "true"), this.textArea.setAttribute("aria-autocomplete", "list"), this.textArea.setAttribute("aria-activedescendant", e.activeDescendant)) : (this.textArea.setAttribute("aria-haspopup", "false"), this.textArea.setAttribute("aria-autocomplete", "both"), this.textArea.removeAttribute("aria-activedescendant")), e.role && this.textArea.setAttribute("role", e.role);
  }
  // --- end view API
  _ensureReadOnlyAttribute() {
    const e = this._context.configuration.options;
    !$u.enabled || e.get(
      34
      /* EditorOption.domReadOnly */
    ) && e.get(
      92
      /* EditorOption.readOnly */
    ) ? this.textArea.setAttribute("readonly", "true") : this.textArea.removeAttribute("readonly");
  }
  prepareRender(e) {
    var t;
    this._primaryCursorPosition = new V(this._selections[0].positionLineNumber, this._selections[0].positionColumn), this._primaryCursorVisibleRange = e.visibleRangeForPosition(this._primaryCursorPosition), (t = this._visibleTextArea) == null || t.prepareRender(e);
  }
  render(e) {
    this._textAreaInput.writeNativeTextAreaContent("render"), this._render();
  }
  _render() {
    if (this._visibleTextArea) {
      const i = this._visibleTextArea.visibleTextareaStart, n = this._visibleTextArea.visibleTextareaEnd, o = this._visibleTextArea.startPosition, r = this._visibleTextArea.endPosition;
      if (o && r && i && n && n.left >= this._scrollLeft && i.left <= this._scrollLeft + this._contentWidth) {
        const a = this._context.viewLayout.getVerticalOffsetForLineNumber(this._primaryCursorPosition.lineNumber) - this._scrollTop, l = this._newlinecount(this.textArea.domNode.value.substr(0, this.textArea.domNode.selectionStart));
        let c = this._visibleTextArea.widthOfHiddenLineTextBefore, h = this._contentLeft + i.left - this._scrollLeft, d = n.left - i.left + 1;
        if (h < this._contentLeft) {
          const b = this._contentLeft - h;
          h += b, c += b, d -= b;
        }
        d > this._contentWidth && (d = this._contentWidth);
        const u = this._context.viewModel.getViewLineData(o.lineNumber), f = u.tokens.findTokenIndexAtOffset(o.column - 1), g = u.tokens.findTokenIndexAtOffset(r.column - 1), m = f === g, _ = this._visibleTextArea.definePresentation(m ? u.tokens.getPresentation(f) : null);
        this.textArea.domNode.scrollTop = l * this._lineHeight, this.textArea.domNode.scrollLeft = c, this._doRender({
          lastRenderPosition: null,
          top: a,
          left: h,
          width: d,
          height: this._lineHeight,
          useCover: !1,
          color: (Yt.getColorMap() || [])[_.foreground],
          italic: _.italic,
          bold: _.bold,
          underline: _.underline,
          strikethrough: _.strikethrough
        });
      }
      return;
    }
    if (!this._primaryCursorVisibleRange) {
      this._renderAtTopLeft();
      return;
    }
    const e = this._contentLeft + this._primaryCursorVisibleRange.left - this._scrollLeft;
    if (e < this._contentLeft || e > this._contentLeft + this._contentWidth) {
      this._renderAtTopLeft();
      return;
    }
    const t = this._context.viewLayout.getVerticalOffsetForLineNumber(this._selections[0].positionLineNumber) - this._scrollTop;
    if (t < 0 || t > this._contentHeight) {
      this._renderAtTopLeft();
      return;
    }
    if (He || this._accessibilitySupport === 2) {
      this._doRender({
        lastRenderPosition: this._primaryCursorPosition,
        top: t,
        left: this._textAreaWrapping ? this._contentLeft : e,
        width: this._textAreaWidth,
        height: this._lineHeight,
        useCover: !1
      }), this.textArea.domNode.scrollLeft = this._primaryCursorVisibleRange.left;
      const i = this._textAreaInput.textAreaState.newlineCountBeforeSelection ?? this._newlinecount(this.textArea.domNode.value.substr(0, this.textArea.domNode.selectionStart));
      this.textArea.domNode.scrollTop = i * this._lineHeight;
      return;
    }
    this._doRender({
      lastRenderPosition: this._primaryCursorPosition,
      top: t,
      left: this._textAreaWrapping ? this._contentLeft : e,
      width: this._textAreaWidth,
      height: gC ? 0 : 1,
      useCover: !1
    });
  }
  _newlinecount(e) {
    let t = 0, i = -1;
    do {
      if (i = e.indexOf(`
`, i + 1), i === -1)
        break;
      t++;
    } while (!0);
    return t;
  }
  _renderAtTopLeft() {
    this._doRender({
      lastRenderPosition: null,
      top: 0,
      left: 0,
      width: this._textAreaWidth,
      height: gC ? 0 : 1,
      useCover: !0
    });
  }
  _doRender(e) {
    this._lastRenderPosition = e.lastRenderPosition;
    const t = this.textArea, i = this.textAreaCover;
    Fi(t, this._fontInfo), t.setTop(e.top), t.setLeft(e.left), t.setWidth(e.width), t.setHeight(e.height), t.setColor(e.color ? Z.Format.CSS.formatHex(e.color) : ""), t.setFontStyle(e.italic ? "italic" : ""), e.bold && t.setFontWeight("bold"), t.setTextDecoration(`${e.underline ? " underline" : ""}${e.strikethrough ? " line-through" : ""}`), i.setTop(e.useCover ? e.top : 0), i.setLeft(e.useCover ? e.left : 0), i.setWidth(e.useCover ? e.width : 0), i.setHeight(e.useCover ? e.height : 0);
    const n = this._context.configuration.options;
    n.get(
      57
      /* EditorOption.glyphMargin */
    ) ? i.setClassName("monaco-editor-background textAreaCover " + F_.OUTER_CLASS_NAME) : n.get(
      68
      /* EditorOption.lineNumbers */
    ).renderType !== 0 ? i.setClassName("monaco-editor-background textAreaCover " + O_.CLASS_NAME) : i.setClassName("monaco-editor-background textAreaCover");
  }
};
xS = qG([
  hT(3, Ai),
  hT(4, ot)
], xS);
function GG(s, e, t, i) {
  if (e.length === 0)
    return 0;
  const n = s.createElement("div");
  n.style.position = "absolute", n.style.top = "-50000px", n.style.width = "50000px";
  const o = s.createElement("span");
  Fi(o, t), o.style.whiteSpace = "pre", o.style.tabSize = `${i * t.spaceWidth}px`, o.append(e), n.appendChild(o), s.body.appendChild(n);
  const r = o.offsetWidth;
  return n.remove(), r;
}
const ZG = () => !0, YG = () => !1, QG = (s) => s === " " || s === "	";
class sh {
  static shouldRecreate(e) {
    return e.hasChanged(
      146
      /* EditorOption.layoutInfo */
    ) || e.hasChanged(
      132
      /* EditorOption.wordSeparators */
    ) || e.hasChanged(
      37
      /* EditorOption.emptySelectionClipboard */
    ) || e.hasChanged(
      77
      /* EditorOption.multiCursorMergeOverlapping */
    ) || e.hasChanged(
      79
      /* EditorOption.multiCursorPaste */
    ) || e.hasChanged(
      80
      /* EditorOption.multiCursorLimit */
    ) || e.hasChanged(
      6
      /* EditorOption.autoClosingBrackets */
    ) || e.hasChanged(
      7
      /* EditorOption.autoClosingComments */
    ) || e.hasChanged(
      11
      /* EditorOption.autoClosingQuotes */
    ) || e.hasChanged(
      9
      /* EditorOption.autoClosingDelete */
    ) || e.hasChanged(
      10
      /* EditorOption.autoClosingOvertype */
    ) || e.hasChanged(
      14
      /* EditorOption.autoSurround */
    ) || e.hasChanged(
      129
      /* EditorOption.useTabStops */
    ) || e.hasChanged(
      50
      /* EditorOption.fontInfo */
    ) || e.hasChanged(
      92
      /* EditorOption.readOnly */
    ) || e.hasChanged(
      131
      /* EditorOption.wordSegmenterLocales */
    );
  }
  constructor(e, t, i, n) {
    this.languageConfigurationService = n, this._cursorMoveConfigurationBrand = void 0, this._languageId = e;
    const o = i.options, r = o.get(
      146
      /* EditorOption.layoutInfo */
    ), a = o.get(
      50
      /* EditorOption.fontInfo */
    );
    this.readOnly = o.get(
      92
      /* EditorOption.readOnly */
    ), this.tabSize = t.tabSize, this.indentSize = t.indentSize, this.insertSpaces = t.insertSpaces, this.stickyTabStops = o.get(
      117
      /* EditorOption.stickyTabStops */
    ), this.lineHeight = a.lineHeight, this.typicalHalfwidthCharacterWidth = a.typicalHalfwidthCharacterWidth, this.pageSize = Math.max(1, Math.floor(r.height / this.lineHeight) - 2), this.useTabStops = o.get(
      129
      /* EditorOption.useTabStops */
    ), this.wordSeparators = o.get(
      132
      /* EditorOption.wordSeparators */
    ), this.emptySelectionClipboard = o.get(
      37
      /* EditorOption.emptySelectionClipboard */
    ), this.copyWithSyntaxHighlighting = o.get(
      25
      /* EditorOption.copyWithSyntaxHighlighting */
    ), this.multiCursorMergeOverlapping = o.get(
      77
      /* EditorOption.multiCursorMergeOverlapping */
    ), this.multiCursorPaste = o.get(
      79
      /* EditorOption.multiCursorPaste */
    ), this.multiCursorLimit = o.get(
      80
      /* EditorOption.multiCursorLimit */
    ), this.autoClosingBrackets = o.get(
      6
      /* EditorOption.autoClosingBrackets */
    ), this.autoClosingComments = o.get(
      7
      /* EditorOption.autoClosingComments */
    ), this.autoClosingQuotes = o.get(
      11
      /* EditorOption.autoClosingQuotes */
    ), this.autoClosingDelete = o.get(
      9
      /* EditorOption.autoClosingDelete */
    ), this.autoClosingOvertype = o.get(
      10
      /* EditorOption.autoClosingOvertype */
    ), this.autoSurround = o.get(
      14
      /* EditorOption.autoSurround */
    ), this.autoIndent = o.get(
      12
      /* EditorOption.autoIndent */
    ), this.wordSegmenterLocales = o.get(
      131
      /* EditorOption.wordSegmenterLocales */
    ), this.surroundingPairs = {}, this._electricChars = null, this.shouldAutoCloseBefore = {
      quote: this._getShouldAutoClose(e, this.autoClosingQuotes, !0),
      comment: this._getShouldAutoClose(e, this.autoClosingComments, !1),
      bracket: this._getShouldAutoClose(e, this.autoClosingBrackets, !1)
    }, this.autoClosingPairs = this.languageConfigurationService.getLanguageConfiguration(e).getAutoClosingPairs();
    const l = this.languageConfigurationService.getLanguageConfiguration(e).getSurroundingPairs();
    if (l)
      for (const h of l)
        this.surroundingPairs[h.open] = h.close;
    const c = this.languageConfigurationService.getLanguageConfiguration(e).comments;
    this.blockCommentStartToken = (c == null ? void 0 : c.blockCommentStartToken) ?? null;
  }
  get electricChars() {
    var e;
    if (!this._electricChars) {
      this._electricChars = {};
      const t = (e = this.languageConfigurationService.getLanguageConfiguration(this._languageId).electricCharacter) == null ? void 0 : e.getElectricCharacters();
      if (t)
        for (const i of t)
          this._electricChars[i] = !0;
    }
    return this._electricChars;
  }
  /**
   * Should return opening bracket type to match indentation with
   */
  onElectricCharacter(e, t, i) {
    const n = Ul(t, i - 1), o = this.languageConfigurationService.getLanguageConfiguration(n.languageId).electricCharacter;
    return o ? o.onElectricCharacter(e, n, i - n.firstCharOffset) : null;
  }
  normalizeIndentation(e) {
    return zA(e, this.indentSize, this.insertSpaces);
  }
  _getShouldAutoClose(e, t, i) {
    switch (t) {
      case "beforeWhitespace":
        return QG;
      case "languageDefined":
        return this._getLanguageDefinedShouldAutoClose(e, i);
      case "always":
        return ZG;
      case "never":
        return YG;
    }
  }
  _getLanguageDefinedShouldAutoClose(e, t) {
    const i = this.languageConfigurationService.getLanguageConfiguration(e).getAutoCloseBeforeSet(t);
    return (n) => i.indexOf(n) !== -1;
  }
  /**
   * Returns a visible column from a column.
   * @see {@link CursorColumns}
   */
  visibleColumnFromColumn(e, t) {
    return ii.visibleColumnFromColumn(e.getLineContent(t.lineNumber), t.column, this.tabSize);
  }
  /**
   * Returns a visible column from a column.
   * @see {@link CursorColumns}
   */
  columnFromVisibleColumn(e, t, i) {
    const n = ii.columnFromVisibleColumn(e.getLineContent(t), i, this.tabSize), o = e.getLineMinColumn(t);
    if (n < o)
      return o;
    const r = e.getLineMaxColumn(t);
    return n > r ? r : n;
  }
}
class Pe {
  static fromModelState(e) {
    return new XG(e);
  }
  static fromViewState(e) {
    return new JG(e);
  }
  static fromModelSelection(e) {
    const t = ft.liftSelection(e), i = new Ci(R.fromPositions(t.getSelectionStart()), 0, 0, t.getPosition(), 0);
    return Pe.fromModelState(i);
  }
  static fromModelSelections(e) {
    const t = [];
    for (let i = 0, n = e.length; i < n; i++)
      t[i] = this.fromModelSelection(e[i]);
    return t;
  }
  constructor(e, t) {
    this._cursorStateBrand = void 0, this.modelState = e, this.viewState = t;
  }
  equals(e) {
    return this.viewState.equals(e.viewState) && this.modelState.equals(e.modelState);
  }
}
class XG {
  constructor(e) {
    this.modelState = e, this.viewState = null;
  }
}
class JG {
  constructor(e) {
    this.modelState = null, this.viewState = e;
  }
}
class Ci {
  constructor(e, t, i, n, o) {
    this.selectionStart = e, this.selectionStartKind = t, this.selectionStartLeftoverVisibleColumns = i, this.position = n, this.leftoverVisibleColumns = o, this._singleCursorStateBrand = void 0, this.selection = Ci._computeSelection(this.selectionStart, this.position);
  }
  equals(e) {
    return this.selectionStartLeftoverVisibleColumns === e.selectionStartLeftoverVisibleColumns && this.leftoverVisibleColumns === e.leftoverVisibleColumns && this.selectionStartKind === e.selectionStartKind && this.position.equals(e.position) && this.selectionStart.equalsRange(e.selectionStart);
  }
  hasSelection() {
    return !this.selection.isEmpty() || !this.selectionStart.isEmpty();
  }
  move(e, t, i, n) {
    return e ? new Ci(this.selectionStart, this.selectionStartKind, this.selectionStartLeftoverVisibleColumns, new V(t, i), n) : new Ci(new R(t, i, t, i), 0, n, new V(t, i), n);
  }
  static _computeSelection(e, t) {
    return e.isEmpty() || !t.isBeforeOrEqual(e.getStartPosition()) ? ft.fromPositions(e.getStartPosition(), t) : ft.fromPositions(e.getEndPosition(), t);
  }
}
class yn {
  constructor(e, t, i) {
    this._editOperationResultBrand = void 0, this.type = e, this.commands = t, this.shouldPushStackElementBefore = i.shouldPushStackElementBefore, this.shouldPushStackElementAfter = i.shouldPushStackElementAfter;
  }
}
function Ya(s) {
  return s === "'" || s === '"' || s === "`";
}
class Al {
  static columnSelect(e, t, i, n, o, r) {
    const a = Math.abs(o - i) + 1, l = i > o, c = n > r, h = n < r, d = [];
    for (let u = 0; u < a; u++) {
      const f = i + (l ? -u : u), g = e.columnFromVisibleColumn(t, f, n), m = e.columnFromVisibleColumn(t, f, r), _ = e.visibleColumnFromColumn(t, new V(f, g)), b = e.visibleColumnFromColumn(t, new V(f, m));
      h && (_ > r || b < n) || c && (b > n || _ < r) || d.push(new Ci(new R(f, g, f, g), 0, 0, new V(f, m), 0));
    }
    if (d.length === 0)
      for (let u = 0; u < a; u++) {
        const f = i + (l ? -u : u), g = t.getLineMaxColumn(f);
        d.push(new Ci(new R(f, g, f, g), 0, 0, new V(f, g), 0));
      }
    return {
      viewStates: d,
      reversed: l,
      fromLineNumber: i,
      fromVisualColumn: n,
      toLineNumber: o,
      toVisualColumn: r
    };
  }
  static columnSelectLeft(e, t, i) {
    let n = i.toViewVisualColumn;
    return n > 0 && n--, Al.columnSelect(e, t, i.fromViewLineNumber, i.fromViewVisualColumn, i.toViewLineNumber, n);
  }
  static columnSelectRight(e, t, i) {
    let n = 0;
    const o = Math.min(i.fromViewLineNumber, i.toViewLineNumber), r = Math.max(i.fromViewLineNumber, i.toViewLineNumber);
    for (let l = o; l <= r; l++) {
      const c = t.getLineMaxColumn(l), h = e.visibleColumnFromColumn(t, new V(l, c));
      n = Math.max(n, h);
    }
    let a = i.toViewVisualColumn;
    return a < n && a++, this.columnSelect(e, t, i.fromViewLineNumber, i.fromViewVisualColumn, i.toViewLineNumber, a);
  }
  static columnSelectUp(e, t, i, n) {
    const o = n ? e.pageSize : 1, r = Math.max(1, i.toViewLineNumber - o);
    return this.columnSelect(e, t, i.fromViewLineNumber, i.fromViewVisualColumn, r, i.toViewVisualColumn);
  }
  static columnSelectDown(e, t, i, n) {
    const o = n ? e.pageSize : 1, r = Math.min(t.getLineCount(), i.toViewLineNumber + o);
    return this.columnSelect(e, t, i.fromViewLineNumber, i.fromViewVisualColumn, r, i.toViewVisualColumn);
  }
}
class Rn {
  constructor(e, t, i = !1) {
    this._range = e, this._text = t, this.insertsAutoWhitespace = i;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(this._range, this._text);
  }
  computeCursorState(e, t) {
    const n = t.getInverseEditOperations()[0].range;
    return ft.fromPositions(n.getEndPosition());
  }
}
class up {
  constructor(e, t, i = !1) {
    this._range = e, this._text = t, this.insertsAutoWhitespace = i;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(this._range, this._text);
  }
  computeCursorState(e, t) {
    const n = t.getInverseEditOperations()[0].range;
    return ft.fromPositions(n.getStartPosition());
  }
}
class B_ {
  constructor(e, t, i, n, o = !1) {
    this._range = e, this._text = t, this._columnDeltaOffset = n, this._lineNumberDeltaOffset = i, this.insertsAutoWhitespace = o;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(this._range, this._text);
  }
  computeCursorState(e, t) {
    const n = t.getInverseEditOperations()[0].range;
    return ft.fromPositions(n.getEndPosition().delta(this._lineNumberDeltaOffset, this._columnDeltaOffset));
  }
}
class eZ {
  constructor(e, t, i, n = !1) {
    this._range = e, this._text = t, this._initialSelection = i, this._forceMoveMarkers = n, this._selectionId = null;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(this._range, this._text, this._forceMoveMarkers), this._selectionId = t.trackSelection(this._initialSelection);
  }
  computeCursorState(e, t) {
    return t.getTrackedSelection(this._selectionId);
  }
}
class mC {
  constructor(e, t, i) {
    this._cursorPositionBrand = void 0, this.lineNumber = e, this.column = t, this.leftoverVisibleColumns = i;
  }
}
class st {
  static leftPosition(e, t) {
    if (t.column > e.getLineMinColumn(t.lineNumber))
      return t.delta(void 0, -Q2(e.getLineContent(t.lineNumber), t.column - 1));
    if (t.lineNumber > 1) {
      const i = t.lineNumber - 1;
      return new V(i, e.getLineMaxColumn(i));
    } else
      return t;
  }
  static leftPositionAtomicSoftTabs(e, t, i) {
    if (t.column <= e.getLineIndentColumn(t.lineNumber)) {
      const n = e.getLineMinColumn(t.lineNumber), o = e.getLineContent(t.lineNumber), r = ug.atomicPosition(
        o,
        t.column - 1,
        i,
        0
        /* Direction.Left */
      );
      if (r !== -1 && r + 1 >= n)
        return new V(t.lineNumber, r + 1);
    }
    return this.leftPosition(e, t);
  }
  static left(e, t, i) {
    const n = e.stickyTabStops ? st.leftPositionAtomicSoftTabs(t, i, e.tabSize) : st.leftPosition(t, i);
    return new mC(n.lineNumber, n.column, 0);
  }
  /**
   * @param noOfColumns Must be either `1`
   * or `Math.round(viewModel.getLineContent(viewLineNumber).length / 2)` (for half lines).
  */
  static moveLeft(e, t, i, n, o) {
    let r, a;
    if (i.hasSelection() && !n)
      r = i.selection.startLineNumber, a = i.selection.startColumn;
    else {
      const l = i.position.delta(void 0, -(o - 1)), c = t.normalizePosition(
        st.clipPositionColumn(l, t),
        0
        /* PositionAffinity.Left */
      ), h = st.left(e, t, c);
      r = h.lineNumber, a = h.column;
    }
    return i.move(n, r, a, 0);
  }
  /**
   * Adjusts the column so that it is within min/max of the line.
  */
  static clipPositionColumn(e, t) {
    return new V(e.lineNumber, st.clipRange(e.column, t.getLineMinColumn(e.lineNumber), t.getLineMaxColumn(e.lineNumber)));
  }
  static clipRange(e, t, i) {
    return e < t ? t : e > i ? i : e;
  }
  static rightPosition(e, t, i) {
    return i < e.getLineMaxColumn(t) ? i = i + TL(e.getLineContent(t), i - 1) : t < e.getLineCount() && (t = t + 1, i = e.getLineMinColumn(t)), new V(t, i);
  }
  static rightPositionAtomicSoftTabs(e, t, i, n, o) {
    if (i < e.getLineIndentColumn(t)) {
      const r = e.getLineContent(t), a = ug.atomicPosition(
        r,
        i - 1,
        n,
        1
        /* Direction.Right */
      );
      if (a !== -1)
        return new V(t, a + 1);
    }
    return this.rightPosition(e, t, i);
  }
  static right(e, t, i) {
    const n = e.stickyTabStops ? st.rightPositionAtomicSoftTabs(t, i.lineNumber, i.column, e.tabSize, e.indentSize) : st.rightPosition(t, i.lineNumber, i.column);
    return new mC(n.lineNumber, n.column, 0);
  }
  static moveRight(e, t, i, n, o) {
    let r, a;
    if (i.hasSelection() && !n)
      r = i.selection.endLineNumber, a = i.selection.endColumn;
    else {
      const l = i.position.delta(void 0, o - 1), c = t.normalizePosition(
        st.clipPositionColumn(l, t),
        1
        /* PositionAffinity.Right */
      ), h = st.right(e, t, c);
      r = h.lineNumber, a = h.column;
    }
    return i.move(n, r, a, 0);
  }
  static vertical(e, t, i, n, o, r, a, l) {
    const c = ii.visibleColumnFromColumn(t.getLineContent(i), n, e.tabSize) + o, h = t.getLineCount(), d = i === 1 && n === 1, u = i === h && n === t.getLineMaxColumn(i), f = r < i ? d : u;
    if (i = r, i < 1 ? (i = 1, a ? n = t.getLineMinColumn(i) : n = Math.min(t.getLineMaxColumn(i), n)) : i > h ? (i = h, a ? n = t.getLineMaxColumn(i) : n = Math.min(t.getLineMaxColumn(i), n)) : n = e.columnFromVisibleColumn(t, i, c), f ? o = 0 : o = c - ii.visibleColumnFromColumn(t.getLineContent(i), n, e.tabSize), l !== void 0) {
      const g = new V(i, n), m = t.normalizePosition(g, l);
      o = o + (n - m.column), i = m.lineNumber, n = m.column;
    }
    return new mC(i, n, o);
  }
  static down(e, t, i, n, o, r, a) {
    return this.vertical(
      e,
      t,
      i,
      n,
      o,
      i + r,
      a,
      4
      /* PositionAffinity.RightOfInjectedText */
    );
  }
  static moveDown(e, t, i, n, o) {
    let r, a;
    i.hasSelection() && !n ? (r = i.selection.endLineNumber, a = i.selection.endColumn) : (r = i.position.lineNumber, a = i.position.column);
    let l = 0, c;
    do
      if (c = st.down(e, t, r + l, a, i.leftoverVisibleColumns, o, !0), t.normalizePosition(
        new V(c.lineNumber, c.column),
        2
        /* PositionAffinity.None */
      ).lineNumber > r)
        break;
    while (l++ < 10 && r + l < t.getLineCount());
    return i.move(n, c.lineNumber, c.column, c.leftoverVisibleColumns);
  }
  static translateDown(e, t, i) {
    const n = i.selection, o = st.down(e, t, n.selectionStartLineNumber, n.selectionStartColumn, i.selectionStartLeftoverVisibleColumns, 1, !1), r = st.down(e, t, n.positionLineNumber, n.positionColumn, i.leftoverVisibleColumns, 1, !1);
    return new Ci(new R(o.lineNumber, o.column, o.lineNumber, o.column), 0, o.leftoverVisibleColumns, new V(r.lineNumber, r.column), r.leftoverVisibleColumns);
  }
  static up(e, t, i, n, o, r, a) {
    return this.vertical(
      e,
      t,
      i,
      n,
      o,
      i - r,
      a,
      3
      /* PositionAffinity.LeftOfInjectedText */
    );
  }
  static moveUp(e, t, i, n, o) {
    let r, a;
    i.hasSelection() && !n ? (r = i.selection.startLineNumber, a = i.selection.startColumn) : (r = i.position.lineNumber, a = i.position.column);
    const l = st.up(e, t, r, a, i.leftoverVisibleColumns, o, !0);
    return i.move(n, l.lineNumber, l.column, l.leftoverVisibleColumns);
  }
  static translateUp(e, t, i) {
    const n = i.selection, o = st.up(e, t, n.selectionStartLineNumber, n.selectionStartColumn, i.selectionStartLeftoverVisibleColumns, 1, !1), r = st.up(e, t, n.positionLineNumber, n.positionColumn, i.leftoverVisibleColumns, 1, !1);
    return new Ci(new R(o.lineNumber, o.column, o.lineNumber, o.column), 0, o.leftoverVisibleColumns, new V(r.lineNumber, r.column), r.leftoverVisibleColumns);
  }
  static _isBlankLine(e, t) {
    return e.getLineFirstNonWhitespaceColumn(t) === 0;
  }
  static moveToPrevBlankLine(e, t, i, n) {
    let o = i.position.lineNumber;
    for (; o > 1 && this._isBlankLine(t, o); )
      o--;
    for (; o > 1 && !this._isBlankLine(t, o); )
      o--;
    return i.move(n, o, t.getLineMinColumn(o), 0);
  }
  static moveToNextBlankLine(e, t, i, n) {
    const o = t.getLineCount();
    let r = i.position.lineNumber;
    for (; r < o && this._isBlankLine(t, r); )
      r++;
    for (; r < o && !this._isBlankLine(t, r); )
      r++;
    return i.move(n, r, t.getLineMinColumn(r), 0);
  }
  static moveToBeginningOfLine(e, t, i, n) {
    const o = i.position.lineNumber, r = t.getLineMinColumn(o), a = t.getLineFirstNonWhitespaceColumn(o) || r;
    let l;
    return i.position.column === a ? l = r : l = a, i.move(n, o, l, 0);
  }
  static moveToEndOfLine(e, t, i, n, o) {
    const r = i.position.lineNumber, a = t.getLineMaxColumn(r);
    return i.move(n, r, a, o ? 1073741824 - a : 0);
  }
  static moveToBeginningOfBuffer(e, t, i, n) {
    return i.move(n, 1, 1, 0);
  }
  static moveToEndOfBuffer(e, t, i, n) {
    const o = t.getLineCount(), r = t.getLineMaxColumn(o);
    return i.move(n, o, r, 0);
  }
}
class Lc {
  static deleteRight(e, t, i, n) {
    const o = [];
    let r = e !== 3;
    for (let a = 0, l = n.length; a < l; a++) {
      const c = n[a];
      let h = c;
      if (h.isEmpty()) {
        const d = c.getPosition(), u = st.right(t, i, d);
        h = new R(u.lineNumber, u.column, d.lineNumber, d.column);
      }
      if (h.isEmpty()) {
        o[a] = null;
        continue;
      }
      h.startLineNumber !== h.endLineNumber && (r = !0), o[a] = new Rn(h, "");
    }
    return [r, o];
  }
  static isAutoClosingPairDelete(e, t, i, n, o, r, a) {
    if (t === "never" && i === "never" || e === "never")
      return !1;
    for (let l = 0, c = r.length; l < c; l++) {
      const h = r[l], d = h.getPosition();
      if (!h.isEmpty())
        return !1;
      const u = o.getLineContent(d.lineNumber);
      if (d.column < 2 || d.column >= u.length + 1)
        return !1;
      const f = u.charAt(d.column - 2), g = n.get(f);
      if (!g)
        return !1;
      if (Ya(f)) {
        if (i === "never")
          return !1;
      } else if (t === "never")
        return !1;
      const m = u.charAt(d.column - 1);
      let _ = !1;
      for (const b of g)
        b.open === f && b.close === m && (_ = !0);
      if (!_)
        return !1;
      if (e === "auto") {
        let b = !1;
        for (let C = 0, v = a.length; C < v; C++) {
          const w = a[C];
          if (d.lineNumber === w.startLineNumber && d.column === w.startColumn) {
            b = !0;
            break;
          }
        }
        if (!b)
          return !1;
      }
    }
    return !0;
  }
  static _runAutoClosingPairDelete(e, t, i) {
    const n = [];
    for (let o = 0, r = i.length; o < r; o++) {
      const a = i[o].getPosition(), l = new R(a.lineNumber, a.column - 1, a.lineNumber, a.column + 1);
      n[o] = new Rn(l, "");
    }
    return [!0, n];
  }
  static deleteLeft(e, t, i, n, o) {
    if (this.isAutoClosingPairDelete(t.autoClosingDelete, t.autoClosingBrackets, t.autoClosingQuotes, t.autoClosingPairs.autoClosingPairsOpenByEnd, i, n, o))
      return this._runAutoClosingPairDelete(t, i, n);
    const r = [];
    let a = e !== 2;
    for (let l = 0, c = n.length; l < c; l++) {
      const h = Lc.getDeleteRange(n[l], i, t);
      if (h.isEmpty()) {
        r[l] = null;
        continue;
      }
      h.startLineNumber !== h.endLineNumber && (a = !0), r[l] = new Rn(h, "");
    }
    return [a, r];
  }
  static getDeleteRange(e, t, i) {
    if (!e.isEmpty())
      return e;
    const n = e.getPosition();
    if (i.useTabStops && n.column > 1) {
      const o = t.getLineContent(n.lineNumber), r = On(o), a = r === -1 ? (
        /* entire string is whitespace */
        o.length + 1
      ) : r + 1;
      if (n.column <= a) {
        const l = i.visibleColumnFromColumn(t, n), c = ii.prevIndentTabStop(l, i.indentSize), h = i.columnFromVisibleColumn(t, n.lineNumber, c);
        return new R(n.lineNumber, h, n.lineNumber, n.column);
      }
    }
    return R.fromPositions(Lc.getPositionAfterDeleteLeft(n, t), n);
  }
  static getPositionAfterDeleteLeft(e, t) {
    if (e.column > 1) {
      const i = s6(e.column - 1, t.getLineContent(e.lineNumber));
      return e.with(void 0, i + 1);
    } else if (e.lineNumber > 1) {
      const i = e.lineNumber - 1;
      return new V(i, t.getLineMaxColumn(i));
    } else
      return e;
  }
  static cut(e, t, i) {
    const n = [];
    let o = null;
    i.sort((r, a) => V.compare(r.getStartPosition(), a.getEndPosition()));
    for (let r = 0, a = i.length; r < a; r++) {
      const l = i[r];
      if (l.isEmpty())
        if (e.emptySelectionClipboard) {
          const c = l.getPosition();
          let h, d, u, f;
          c.lineNumber < t.getLineCount() ? (h = c.lineNumber, d = 1, u = c.lineNumber + 1, f = 1) : c.lineNumber > 1 && (o == null ? void 0 : o.endLineNumber) !== c.lineNumber ? (h = c.lineNumber - 1, d = t.getLineMaxColumn(c.lineNumber - 1), u = c.lineNumber, f = t.getLineMaxColumn(c.lineNumber)) : (h = c.lineNumber, d = 1, u = c.lineNumber, f = t.getLineMaxColumn(c.lineNumber));
          const g = new R(h, d, u, f);
          o = g, g.isEmpty() ? n[r] = null : n[r] = new Rn(g, "");
        } else
          n[r] = null;
      else
        n[r] = new Rn(l, "");
    }
    return new yn(0, n, {
      shouldPushStackElementBefore: !0,
      shouldPushStackElementAfter: !0
    });
  }
}
class Ut {
  static _createWord(e, t, i, n, o) {
    return { start: n, end: o, wordType: t, nextCharClass: i };
  }
  static _createIntlWord(e, t) {
    return { start: e.index, end: e.index + e.segment.length, wordType: 1, nextCharClass: t };
  }
  static _findPreviousWordOnLine(e, t, i) {
    const n = t.getLineContent(i.lineNumber);
    return this._doFindPreviousWordOnLine(n, e, i);
  }
  static _doFindPreviousWordOnLine(e, t, i) {
    let n = 0;
    const o = t.findPrevIntlWordBeforeOrAtOffset(e, i.column - 2);
    for (let r = i.column - 2; r >= 0; r--) {
      const a = e.charCodeAt(r), l = t.get(a);
      if (o && r === o.index)
        return this._createIntlWord(o, l);
      if (l === 0) {
        if (n === 2)
          return this._createWord(e, n, l, r + 1, this._findEndOfWord(e, t, n, r + 1));
        n = 1;
      } else if (l === 2) {
        if (n === 1)
          return this._createWord(e, n, l, r + 1, this._findEndOfWord(e, t, n, r + 1));
        n = 2;
      } else if (l === 1 && n !== 0)
        return this._createWord(e, n, l, r + 1, this._findEndOfWord(e, t, n, r + 1));
    }
    return n !== 0 ? this._createWord(e, n, 1, 0, this._findEndOfWord(e, t, n, 0)) : null;
  }
  static _findEndOfWord(e, t, i, n) {
    const o = t.findNextIntlWordAtOrAfterOffset(e, n), r = e.length;
    for (let a = n; a < r; a++) {
      const l = e.charCodeAt(a), c = t.get(l);
      if (o && a === o.index + o.segment.length || c === 1 || i === 1 && c === 2 || i === 2 && c === 0)
        return a;
    }
    return r;
  }
  static _findNextWordOnLine(e, t, i) {
    const n = t.getLineContent(i.lineNumber);
    return this._doFindNextWordOnLine(n, e, i);
  }
  static _doFindNextWordOnLine(e, t, i) {
    let n = 0;
    const o = e.length, r = t.findNextIntlWordAtOrAfterOffset(e, i.column - 1);
    for (let a = i.column - 1; a < o; a++) {
      const l = e.charCodeAt(a), c = t.get(l);
      if (r && a === r.index)
        return this._createIntlWord(r, c);
      if (c === 0) {
        if (n === 2)
          return this._createWord(e, n, c, this._findStartOfWord(e, t, n, a - 1), a);
        n = 1;
      } else if (c === 2) {
        if (n === 1)
          return this._createWord(e, n, c, this._findStartOfWord(e, t, n, a - 1), a);
        n = 2;
      } else if (c === 1 && n !== 0)
        return this._createWord(e, n, c, this._findStartOfWord(e, t, n, a - 1), a);
    }
    return n !== 0 ? this._createWord(e, n, 1, this._findStartOfWord(e, t, n, o - 1), o) : null;
  }
  static _findStartOfWord(e, t, i, n) {
    const o = t.findPrevIntlWordBeforeOrAtOffset(e, n);
    for (let r = n; r >= 0; r--) {
      const a = e.charCodeAt(r), l = t.get(a);
      if (o && r === o.index)
        return r;
      if (l === 1 || i === 1 && l === 2 || i === 2 && l === 0)
        return r + 1;
    }
    return 0;
  }
  static moveWordLeft(e, t, i, n, o) {
    let r = i.lineNumber, a = i.column;
    a === 1 && r > 1 && (r = r - 1, a = t.getLineMaxColumn(r));
    let l = Ut._findPreviousWordOnLine(e, t, new V(r, a));
    if (n === 0)
      return new V(r, l ? l.start + 1 : 1);
    if (n === 1)
      return !o && l && l.wordType === 2 && l.end - l.start === 1 && l.nextCharClass === 0 && (l = Ut._findPreviousWordOnLine(e, t, new V(r, l.start + 1))), new V(r, l ? l.start + 1 : 1);
    if (n === 3) {
      for (; l && l.wordType === 2; )
        l = Ut._findPreviousWordOnLine(e, t, new V(r, l.start + 1));
      return new V(r, l ? l.start + 1 : 1);
    }
    return l && a <= l.end + 1 && (l = Ut._findPreviousWordOnLine(e, t, new V(r, l.start + 1))), new V(r, l ? l.end + 1 : 1);
  }
  static _moveWordPartLeft(e, t) {
    const i = t.lineNumber, n = e.getLineMaxColumn(i);
    if (t.column === 1)
      return i > 1 ? new V(i - 1, e.getLineMaxColumn(i - 1)) : t;
    const o = e.getLineContent(i);
    for (let r = t.column - 1; r > 1; r--) {
      const a = o.charCodeAt(r - 2), l = o.charCodeAt(r - 1);
      if (a === 95 && l !== 95)
        return new V(i, r);
      if (a === 45 && l !== 45)
        return new V(i, r);
      if ((hh(a) || em(a)) && ga(l))
        return new V(i, r);
      if (ga(a) && ga(l) && r + 1 < n) {
        const c = o.charCodeAt(r);
        if (hh(c) || em(c))
          return new V(i, r);
      }
    }
    return new V(i, 1);
  }
  static moveWordRight(e, t, i, n) {
    let o = i.lineNumber, r = i.column, a = !1;
    r === t.getLineMaxColumn(o) && o < t.getLineCount() && (a = !0, o = o + 1, r = 1);
    let l = Ut._findNextWordOnLine(e, t, new V(o, r));
    if (n === 2)
      l && l.wordType === 2 && l.end - l.start === 1 && l.nextCharClass === 0 && (l = Ut._findNextWordOnLine(e, t, new V(o, l.end + 1))), l ? r = l.end + 1 : r = t.getLineMaxColumn(o);
    else if (n === 3) {
      for (a && (r = 0); l && (l.wordType === 2 || l.start + 1 <= r); )
        l = Ut._findNextWordOnLine(e, t, new V(o, l.end + 1));
      l ? r = l.start + 1 : r = t.getLineMaxColumn(o);
    } else
      l && !a && r >= l.start + 1 && (l = Ut._findNextWordOnLine(e, t, new V(o, l.end + 1))), l ? r = l.start + 1 : r = t.getLineMaxColumn(o);
    return new V(o, r);
  }
  static _moveWordPartRight(e, t) {
    const i = t.lineNumber, n = e.getLineMaxColumn(i);
    if (t.column === n)
      return i < e.getLineCount() ? new V(i + 1, 1) : t;
    const o = e.getLineContent(i);
    for (let r = t.column + 1; r < n; r++) {
      const a = o.charCodeAt(r - 2), l = o.charCodeAt(r - 1);
      if (a !== 95 && l === 95)
        return new V(i, r);
      if (a !== 45 && l === 45)
        return new V(i, r);
      if ((hh(a) || em(a)) && ga(l))
        return new V(i, r);
      if (ga(a) && ga(l) && r + 1 < n) {
        const c = o.charCodeAt(r);
        if (hh(c) || em(c))
          return new V(i, r);
      }
    }
    return new V(i, n);
  }
  static _deleteWordLeftWhitespace(e, t) {
    const i = e.getLineContent(t.lineNumber), n = t.column - 2, o = Ec(i, n);
    return o + 1 < n ? new R(t.lineNumber, o + 2, t.lineNumber, t.column) : null;
  }
  static deleteWordLeft(e, t) {
    const i = e.wordSeparators, n = e.model, o = e.selection, r = e.whitespaceHeuristics;
    if (!o.isEmpty())
      return o;
    if (Lc.isAutoClosingPairDelete(e.autoClosingDelete, e.autoClosingBrackets, e.autoClosingQuotes, e.autoClosingPairs.autoClosingPairsOpenByEnd, e.model, [e.selection], e.autoClosedCharacters)) {
      const d = e.selection.getPosition();
      return new R(d.lineNumber, d.column - 1, d.lineNumber, d.column + 1);
    }
    const a = new V(o.positionLineNumber, o.positionColumn);
    let l = a.lineNumber, c = a.column;
    if (l === 1 && c === 1)
      return null;
    if (r) {
      const d = this._deleteWordLeftWhitespace(n, a);
      if (d)
        return d;
    }
    let h = Ut._findPreviousWordOnLine(i, n, a);
    return t === 0 ? h ? c = h.start + 1 : c > 1 ? c = 1 : (l--, c = n.getLineMaxColumn(l)) : (h && c <= h.end + 1 && (h = Ut._findPreviousWordOnLine(i, n, new V(l, h.start + 1))), h ? c = h.end + 1 : c > 1 ? c = 1 : (l--, c = n.getLineMaxColumn(l))), new R(l, c, a.lineNumber, a.column);
  }
  static deleteInsideWord(e, t, i) {
    if (!i.isEmpty())
      return i;
    const n = new V(i.positionLineNumber, i.positionColumn), o = this._deleteInsideWordWhitespace(t, n);
    return o || this._deleteInsideWordDetermineDeleteRange(e, t, n);
  }
  static _charAtIsWhitespace(e, t) {
    const i = e.charCodeAt(t);
    return i === 32 || i === 9;
  }
  static _deleteInsideWordWhitespace(e, t) {
    const i = e.getLineContent(t.lineNumber), n = i.length;
    if (n === 0)
      return null;
    let o = Math.max(t.column - 2, 0);
    if (!this._charAtIsWhitespace(i, o))
      return null;
    let r = Math.min(t.column - 1, n - 1);
    if (!this._charAtIsWhitespace(i, r))
      return null;
    for (; o > 0 && this._charAtIsWhitespace(i, o - 1); )
      o--;
    for (; r + 1 < n && this._charAtIsWhitespace(i, r + 1); )
      r++;
    return new R(t.lineNumber, o + 1, t.lineNumber, r + 2);
  }
  static _deleteInsideWordDetermineDeleteRange(e, t, i) {
    const n = t.getLineContent(i.lineNumber), o = n.length;
    if (o === 0)
      return i.lineNumber > 1 ? new R(i.lineNumber - 1, t.getLineMaxColumn(i.lineNumber - 1), i.lineNumber, 1) : i.lineNumber < t.getLineCount() ? new R(i.lineNumber, 1, i.lineNumber + 1, 1) : new R(i.lineNumber, 1, i.lineNumber, 1);
    const r = (d) => d.start + 1 <= i.column && i.column <= d.end + 1, a = (d, u) => (d = Math.min(d, i.column), u = Math.max(u, i.column), new R(i.lineNumber, d, i.lineNumber, u)), l = (d) => {
      let u = d.start + 1, f = d.end + 1, g = !1;
      for (; f - 1 < o && this._charAtIsWhitespace(n, f - 1); )
        g = !0, f++;
      if (!g)
        for (; u > 1 && this._charAtIsWhitespace(n, u - 2); )
          u--;
      return a(u, f);
    }, c = Ut._findPreviousWordOnLine(e, t, i);
    if (c && r(c))
      return l(c);
    const h = Ut._findNextWordOnLine(e, t, i);
    return h && r(h) ? l(h) : c && h ? a(c.end + 1, h.start + 1) : c ? a(c.start + 1, c.end + 1) : h ? a(h.start + 1, h.end + 1) : a(1, o + 1);
  }
  static _deleteWordPartLeft(e, t) {
    if (!t.isEmpty())
      return t;
    const i = t.getPosition(), n = Ut._moveWordPartLeft(e, i);
    return new R(i.lineNumber, i.column, n.lineNumber, n.column);
  }
  static _findFirstNonWhitespaceChar(e, t) {
    const i = e.length;
    for (let n = t; n < i; n++) {
      const o = e.charAt(n);
      if (o !== " " && o !== "	")
        return n;
    }
    return i;
  }
  static _deleteWordRightWhitespace(e, t) {
    const i = e.getLineContent(t.lineNumber), n = t.column - 1, o = this._findFirstNonWhitespaceChar(i, n);
    return n + 1 < o ? new R(t.lineNumber, t.column, t.lineNumber, o + 1) : null;
  }
  static deleteWordRight(e, t) {
    const i = e.wordSeparators, n = e.model, o = e.selection, r = e.whitespaceHeuristics;
    if (!o.isEmpty())
      return o;
    const a = new V(o.positionLineNumber, o.positionColumn);
    let l = a.lineNumber, c = a.column;
    const h = n.getLineCount(), d = n.getLineMaxColumn(l);
    if (l === h && c === d)
      return null;
    if (r) {
      const f = this._deleteWordRightWhitespace(n, a);
      if (f)
        return f;
    }
    let u = Ut._findNextWordOnLine(i, n, a);
    return t === 2 ? u ? c = u.end + 1 : c < d || l === h ? c = d : (l++, u = Ut._findNextWordOnLine(i, n, new V(l, 1)), u ? c = u.start + 1 : c = n.getLineMaxColumn(l)) : (u && c >= u.start + 1 && (u = Ut._findNextWordOnLine(i, n, new V(l, u.end + 1))), u ? c = u.start + 1 : c < d || l === h ? c = d : (l++, u = Ut._findNextWordOnLine(i, n, new V(l, 1)), u ? c = u.start + 1 : c = n.getLineMaxColumn(l))), new R(l, c, a.lineNumber, a.column);
  }
  static _deleteWordPartRight(e, t) {
    if (!t.isEmpty())
      return t;
    const i = t.getPosition(), n = Ut._moveWordPartRight(e, i);
    return new R(i.lineNumber, i.column, n.lineNumber, n.column);
  }
  static _createWordAtPosition(e, t, i) {
    const n = new R(t, i.start + 1, t, i.end + 1);
    return {
      word: e.getValueInRange(n),
      startColumn: n.startColumn,
      endColumn: n.endColumn
    };
  }
  static getWordAtPosition(e, t, i, n) {
    const o = vd(t, i), r = Ut._findPreviousWordOnLine(o, e, n);
    if (r && r.wordType === 1 && r.start <= n.column - 1 && n.column - 1 <= r.end)
      return Ut._createWordAtPosition(e, n.lineNumber, r);
    const a = Ut._findNextWordOnLine(o, e, n);
    return a && a.wordType === 1 && a.start <= n.column - 1 && n.column - 1 <= a.end ? Ut._createWordAtPosition(e, n.lineNumber, a) : null;
  }
  static word(e, t, i, n, o) {
    const r = vd(e.wordSeparators, e.wordSegmenterLocales), a = Ut._findPreviousWordOnLine(r, t, o), l = Ut._findNextWordOnLine(r, t, o);
    if (!n) {
      let f, g;
      return a && a.wordType === 1 && a.start <= o.column - 1 && o.column - 1 <= a.end ? (f = a.start + 1, g = a.end + 1) : l && l.wordType === 1 && l.start <= o.column - 1 && o.column - 1 <= l.end ? (f = l.start + 1, g = l.end + 1) : (a ? f = a.end + 1 : f = 1, l ? g = l.start + 1 : g = t.getLineMaxColumn(o.lineNumber)), new Ci(new R(o.lineNumber, f, o.lineNumber, g), 1, 0, new V(o.lineNumber, g), 0);
    }
    let c, h;
    a && a.wordType === 1 && a.start < o.column - 1 && o.column - 1 < a.end ? (c = a.start + 1, h = a.end + 1) : l && l.wordType === 1 && l.start < o.column - 1 && o.column - 1 < l.end ? (c = l.start + 1, h = l.end + 1) : (c = o.column, h = o.column);
    const d = o.lineNumber;
    let u;
    if (i.selectionStart.containsPosition(o))
      u = i.selectionStart.endColumn;
    else if (o.isBeforeOrEqual(i.selectionStart.getStartPosition())) {
      u = c;
      const f = new V(d, u);
      i.selectionStart.containsPosition(f) && (u = i.selectionStart.endColumn);
    } else {
      u = h;
      const f = new V(d, u);
      i.selectionStart.containsPosition(f) && (u = i.selectionStart.startColumn);
    }
    return i.move(!0, d, u, 0);
  }
}
class Vi {
  static addCursorDown(e, t, i) {
    const n = [];
    let o = 0;
    for (let r = 0, a = t.length; r < a; r++) {
      const l = t[r];
      n[o++] = new Pe(l.modelState, l.viewState), i ? n[o++] = Pe.fromModelState(st.translateDown(e.cursorConfig, e.model, l.modelState)) : n[o++] = Pe.fromViewState(st.translateDown(e.cursorConfig, e, l.viewState));
    }
    return n;
  }
  static addCursorUp(e, t, i) {
    const n = [];
    let o = 0;
    for (let r = 0, a = t.length; r < a; r++) {
      const l = t[r];
      n[o++] = new Pe(l.modelState, l.viewState), i ? n[o++] = Pe.fromModelState(st.translateUp(e.cursorConfig, e.model, l.modelState)) : n[o++] = Pe.fromViewState(st.translateUp(e.cursorConfig, e, l.viewState));
    }
    return n;
  }
  static moveToBeginningOfLine(e, t, i) {
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o];
      n[o] = this._moveToLineStart(e, a, i);
    }
    return n;
  }
  static _moveToLineStart(e, t, i) {
    const n = t.viewState.position.column, o = t.modelState.position.column, r = n === o, a = t.viewState.position.lineNumber, l = e.getLineFirstNonWhitespaceColumn(a);
    return !r && !(n === l) ? this._moveToLineStartByView(e, t, i) : this._moveToLineStartByModel(e, t, i);
  }
  static _moveToLineStartByView(e, t, i) {
    return Pe.fromViewState(st.moveToBeginningOfLine(e.cursorConfig, e, t.viewState, i));
  }
  static _moveToLineStartByModel(e, t, i) {
    return Pe.fromModelState(st.moveToBeginningOfLine(e.cursorConfig, e.model, t.modelState, i));
  }
  static moveToEndOfLine(e, t, i, n) {
    const o = [];
    for (let r = 0, a = t.length; r < a; r++) {
      const l = t[r];
      o[r] = this._moveToLineEnd(e, l, i, n);
    }
    return o;
  }
  static _moveToLineEnd(e, t, i, n) {
    const o = t.viewState.position, r = e.getLineMaxColumn(o.lineNumber), a = o.column === r, l = t.modelState.position, c = e.model.getLineMaxColumn(l.lineNumber), h = r - o.column === c - l.column;
    return a || h ? this._moveToLineEndByModel(e, t, i, n) : this._moveToLineEndByView(e, t, i, n);
  }
  static _moveToLineEndByView(e, t, i, n) {
    return Pe.fromViewState(st.moveToEndOfLine(e.cursorConfig, e, t.viewState, i, n));
  }
  static _moveToLineEndByModel(e, t, i, n) {
    return Pe.fromModelState(st.moveToEndOfLine(e.cursorConfig, e.model, t.modelState, i, n));
  }
  static expandLineSelection(e, t) {
    const i = [];
    for (let n = 0, o = t.length; n < o; n++) {
      const r = t[n], a = r.modelState.selection.startLineNumber, l = e.model.getLineCount();
      let c = r.modelState.selection.endLineNumber, h;
      c === l ? h = e.model.getLineMaxColumn(l) : (c++, h = 1), i[n] = Pe.fromModelState(new Ci(new R(a, 1, a, 1), 0, 0, new V(c, h), 0));
    }
    return i;
  }
  static moveToBeginningOfBuffer(e, t, i) {
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o];
      n[o] = Pe.fromModelState(st.moveToBeginningOfBuffer(e.cursorConfig, e.model, a.modelState, i));
    }
    return n;
  }
  static moveToEndOfBuffer(e, t, i) {
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o];
      n[o] = Pe.fromModelState(st.moveToEndOfBuffer(e.cursorConfig, e.model, a.modelState, i));
    }
    return n;
  }
  static selectAll(e, t) {
    const i = e.model.getLineCount(), n = e.model.getLineMaxColumn(i);
    return Pe.fromModelState(new Ci(new R(1, 1, 1, 1), 0, 0, new V(i, n), 0));
  }
  static line(e, t, i, n, o) {
    const r = e.model.validatePosition(n), a = o ? e.coordinatesConverter.validateViewPosition(new V(o.lineNumber, o.column), r) : e.coordinatesConverter.convertModelPositionToViewPosition(r);
    if (!i) {
      const c = e.model.getLineCount();
      let h = r.lineNumber + 1, d = 1;
      return h > c && (h = c, d = e.model.getLineMaxColumn(h)), Pe.fromModelState(new Ci(new R(r.lineNumber, 1, h, d), 2, 0, new V(h, d), 0));
    }
    const l = t.modelState.selectionStart.getStartPosition().lineNumber;
    if (r.lineNumber < l)
      return Pe.fromViewState(t.viewState.move(!0, a.lineNumber, 1, 0));
    if (r.lineNumber > l) {
      const c = e.getLineCount();
      let h = a.lineNumber + 1, d = 1;
      return h > c && (h = c, d = e.getLineMaxColumn(h)), Pe.fromViewState(t.viewState.move(!0, h, d, 0));
    } else {
      const c = t.modelState.selectionStart.getEndPosition();
      return Pe.fromModelState(t.modelState.move(!0, c.lineNumber, c.column, 0));
    }
  }
  static word(e, t, i, n) {
    const o = e.model.validatePosition(n);
    return Pe.fromModelState(Ut.word(e.cursorConfig, e.model, t.modelState, i, o));
  }
  static cancelSelection(e, t) {
    if (!t.modelState.hasSelection())
      return new Pe(t.modelState, t.viewState);
    const i = t.viewState.position.lineNumber, n = t.viewState.position.column;
    return Pe.fromViewState(new Ci(new R(i, n, i, n), 0, 0, new V(i, n), 0));
  }
  static moveTo(e, t, i, n, o) {
    if (i) {
      if (t.modelState.selectionStartKind === 1)
        return this.word(e, t, i, n);
      if (t.modelState.selectionStartKind === 2)
        return this.line(e, t, i, n, o);
    }
    const r = e.model.validatePosition(n), a = o ? e.coordinatesConverter.validateViewPosition(new V(o.lineNumber, o.column), r) : e.coordinatesConverter.convertModelPositionToViewPosition(r);
    return Pe.fromViewState(t.viewState.move(i, a.lineNumber, a.column, 0));
  }
  static simpleMove(e, t, i, n, o, r) {
    switch (i) {
      case 0:
        return r === 4 ? this._moveHalfLineLeft(e, t, n) : this._moveLeft(e, t, n, o);
      case 1:
        return r === 4 ? this._moveHalfLineRight(e, t, n) : this._moveRight(e, t, n, o);
      case 2:
        return r === 2 ? this._moveUpByViewLines(e, t, n, o) : this._moveUpByModelLines(e, t, n, o);
      case 3:
        return r === 2 ? this._moveDownByViewLines(e, t, n, o) : this._moveDownByModelLines(e, t, n, o);
      case 4:
        return r === 2 ? t.map((a) => Pe.fromViewState(st.moveToPrevBlankLine(e.cursorConfig, e, a.viewState, n))) : t.map((a) => Pe.fromModelState(st.moveToPrevBlankLine(e.cursorConfig, e.model, a.modelState, n)));
      case 5:
        return r === 2 ? t.map((a) => Pe.fromViewState(st.moveToNextBlankLine(e.cursorConfig, e, a.viewState, n))) : t.map((a) => Pe.fromModelState(st.moveToNextBlankLine(e.cursorConfig, e.model, a.modelState, n)));
      case 6:
        return this._moveToViewMinColumn(e, t, n);
      case 7:
        return this._moveToViewFirstNonWhitespaceColumn(e, t, n);
      case 8:
        return this._moveToViewCenterColumn(e, t, n);
      case 9:
        return this._moveToViewMaxColumn(e, t, n);
      case 10:
        return this._moveToViewLastNonWhitespaceColumn(e, t, n);
      default:
        return null;
    }
  }
  static viewportMove(e, t, i, n, o) {
    const r = e.getCompletelyVisibleViewRange(), a = e.coordinatesConverter.convertViewRangeToModelRange(r);
    switch (i) {
      case 11: {
        const l = this._firstLineNumberInRange(e.model, a, o), c = e.model.getLineFirstNonWhitespaceColumn(l);
        return [this._moveToModelPosition(e, t[0], n, l, c)];
      }
      case 13: {
        const l = this._lastLineNumberInRange(e.model, a, o), c = e.model.getLineFirstNonWhitespaceColumn(l);
        return [this._moveToModelPosition(e, t[0], n, l, c)];
      }
      case 12: {
        const l = Math.round((a.startLineNumber + a.endLineNumber) / 2), c = e.model.getLineFirstNonWhitespaceColumn(l);
        return [this._moveToModelPosition(e, t[0], n, l, c)];
      }
      case 14: {
        const l = [];
        for (let c = 0, h = t.length; c < h; c++) {
          const d = t[c];
          l[c] = this.findPositionInViewportIfOutside(e, d, r, n);
        }
        return l;
      }
      default:
        return null;
    }
  }
  static findPositionInViewportIfOutside(e, t, i, n) {
    const o = t.viewState.position.lineNumber;
    if (i.startLineNumber <= o && o <= i.endLineNumber - 1)
      return new Pe(t.modelState, t.viewState);
    {
      let r;
      o > i.endLineNumber - 1 ? r = i.endLineNumber - 1 : o < i.startLineNumber ? r = i.startLineNumber : r = o;
      const a = st.vertical(e.cursorConfig, e, o, t.viewState.position.column, t.viewState.leftoverVisibleColumns, r, !1);
      return Pe.fromViewState(t.viewState.move(n, a.lineNumber, a.column, a.leftoverVisibleColumns));
    }
  }
  /**
   * Find the nth line start included in the range (from the start).
   */
  static _firstLineNumberInRange(e, t, i) {
    let n = t.startLineNumber;
    return t.startColumn !== e.getLineMinColumn(n) && n++, Math.min(t.endLineNumber, n + i - 1);
  }
  /**
   * Find the nth line start included in the range (from the end).
   */
  static _lastLineNumberInRange(e, t, i) {
    let n = t.startLineNumber;
    return t.startColumn !== e.getLineMinColumn(n) && n++, Math.max(n, t.endLineNumber - i + 1);
  }
  static _moveLeft(e, t, i, n) {
    return t.map((o) => Pe.fromViewState(st.moveLeft(e.cursorConfig, e, o.viewState, i, n)));
  }
  static _moveHalfLineLeft(e, t, i) {
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o], l = a.viewState.position.lineNumber, c = Math.round(e.getLineLength(l) / 2);
      n[o] = Pe.fromViewState(st.moveLeft(e.cursorConfig, e, a.viewState, i, c));
    }
    return n;
  }
  static _moveRight(e, t, i, n) {
    return t.map((o) => Pe.fromViewState(st.moveRight(e.cursorConfig, e, o.viewState, i, n)));
  }
  static _moveHalfLineRight(e, t, i) {
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o], l = a.viewState.position.lineNumber, c = Math.round(e.getLineLength(l) / 2);
      n[o] = Pe.fromViewState(st.moveRight(e.cursorConfig, e, a.viewState, i, c));
    }
    return n;
  }
  static _moveDownByViewLines(e, t, i, n) {
    const o = [];
    for (let r = 0, a = t.length; r < a; r++) {
      const l = t[r];
      o[r] = Pe.fromViewState(st.moveDown(e.cursorConfig, e, l.viewState, i, n));
    }
    return o;
  }
  static _moveDownByModelLines(e, t, i, n) {
    const o = [];
    for (let r = 0, a = t.length; r < a; r++) {
      const l = t[r];
      o[r] = Pe.fromModelState(st.moveDown(e.cursorConfig, e.model, l.modelState, i, n));
    }
    return o;
  }
  static _moveUpByViewLines(e, t, i, n) {
    const o = [];
    for (let r = 0, a = t.length; r < a; r++) {
      const l = t[r];
      o[r] = Pe.fromViewState(st.moveUp(e.cursorConfig, e, l.viewState, i, n));
    }
    return o;
  }
  static _moveUpByModelLines(e, t, i, n) {
    const o = [];
    for (let r = 0, a = t.length; r < a; r++) {
      const l = t[r];
      o[r] = Pe.fromModelState(st.moveUp(e.cursorConfig, e.model, l.modelState, i, n));
    }
    return o;
  }
  static _moveToViewPosition(e, t, i, n, o) {
    return Pe.fromViewState(t.viewState.move(i, n, o, 0));
  }
  static _moveToModelPosition(e, t, i, n, o) {
    return Pe.fromModelState(t.modelState.move(i, n, o, 0));
  }
  static _moveToViewMinColumn(e, t, i) {
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o], l = a.viewState.position.lineNumber, c = e.getLineMinColumn(l);
      n[o] = this._moveToViewPosition(e, a, i, l, c);
    }
    return n;
  }
  static _moveToViewFirstNonWhitespaceColumn(e, t, i) {
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o], l = a.viewState.position.lineNumber, c = e.getLineFirstNonWhitespaceColumn(l);
      n[o] = this._moveToViewPosition(e, a, i, l, c);
    }
    return n;
  }
  static _moveToViewCenterColumn(e, t, i) {
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o], l = a.viewState.position.lineNumber, c = Math.round((e.getLineMaxColumn(l) + e.getLineMinColumn(l)) / 2);
      n[o] = this._moveToViewPosition(e, a, i, l, c);
    }
    return n;
  }
  static _moveToViewMaxColumn(e, t, i) {
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o], l = a.viewState.position.lineNumber, c = e.getLineMaxColumn(l);
      n[o] = this._moveToViewPosition(e, a, i, l, c);
    }
    return n;
  }
  static _moveToViewLastNonWhitespaceColumn(e, t, i) {
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o], l = a.viewState.position.lineNumber, c = e.getLineLastNonWhitespaceColumn(l);
      n[o] = this._moveToViewPosition(e, a, i, l, c);
    }
    return n;
  }
}
var W_;
(function(s) {
  const e = function(i) {
    if (!_n(i))
      return !1;
    const n = i;
    return !(!Jn(n.to) || !fs(n.select) && !C2(n.select) || !fs(n.by) && !Jn(n.by) || !fs(n.value) && !Od(n.value));
  };
  s.metadata = {
    description: "Move cursor to a logical position in the view",
    args: [
      {
        name: "Cursor move argument object",
        description: `Property-value pairs that can be passed through this argument:
					* 'to': A mandatory logical position value providing where to move the cursor.
						\`\`\`
						'left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine',
						'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter'
						'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter'
						'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside'
						\`\`\`
					* 'by': Unit to move. Default is computed based on 'to' value.
						\`\`\`
						'line', 'wrappedLine', 'character', 'halfLine'
						\`\`\`
					* 'value': Number of units to move. Default is '1'.
					* 'select': If 'true' makes the selection. Default is 'false'.
				`,
        constraint: e,
        schema: {
          type: "object",
          required: ["to"],
          properties: {
            to: {
              type: "string",
              enum: ["left", "right", "up", "down", "prevBlankLine", "nextBlankLine", "wrappedLineStart", "wrappedLineEnd", "wrappedLineColumnCenter", "wrappedLineFirstNonWhitespaceCharacter", "wrappedLineLastNonWhitespaceCharacter", "viewPortTop", "viewPortCenter", "viewPortBottom", "viewPortIfOutside"]
            },
            by: {
              type: "string",
              enum: ["line", "wrappedLine", "character", "halfLine"]
            },
            value: {
              type: "number",
              default: 1
            },
            select: {
              type: "boolean",
              default: !1
            }
          }
        }
      }
    ]
  }, s.RawDirection = {
    Left: "left",
    Right: "right",
    Up: "up",
    Down: "down",
    PrevBlankLine: "prevBlankLine",
    NextBlankLine: "nextBlankLine",
    WrappedLineStart: "wrappedLineStart",
    WrappedLineFirstNonWhitespaceCharacter: "wrappedLineFirstNonWhitespaceCharacter",
    WrappedLineColumnCenter: "wrappedLineColumnCenter",
    WrappedLineEnd: "wrappedLineEnd",
    WrappedLineLastNonWhitespaceCharacter: "wrappedLineLastNonWhitespaceCharacter",
    ViewPortTop: "viewPortTop",
    ViewPortCenter: "viewPortCenter",
    ViewPortBottom: "viewPortBottom",
    ViewPortIfOutside: "viewPortIfOutside"
  }, s.RawUnit = {
    Line: "line",
    WrappedLine: "wrappedLine",
    Character: "character",
    HalfLine: "halfLine"
  };
  function t(i) {
    if (!i.to)
      return null;
    let n;
    switch (i.to) {
      case s.RawDirection.Left:
        n = 0;
        break;
      case s.RawDirection.Right:
        n = 1;
        break;
      case s.RawDirection.Up:
        n = 2;
        break;
      case s.RawDirection.Down:
        n = 3;
        break;
      case s.RawDirection.PrevBlankLine:
        n = 4;
        break;
      case s.RawDirection.NextBlankLine:
        n = 5;
        break;
      case s.RawDirection.WrappedLineStart:
        n = 6;
        break;
      case s.RawDirection.WrappedLineFirstNonWhitespaceCharacter:
        n = 7;
        break;
      case s.RawDirection.WrappedLineColumnCenter:
        n = 8;
        break;
      case s.RawDirection.WrappedLineEnd:
        n = 9;
        break;
      case s.RawDirection.WrappedLineLastNonWhitespaceCharacter:
        n = 10;
        break;
      case s.RawDirection.ViewPortTop:
        n = 11;
        break;
      case s.RawDirection.ViewPortBottom:
        n = 13;
        break;
      case s.RawDirection.ViewPortCenter:
        n = 12;
        break;
      case s.RawDirection.ViewPortIfOutside:
        n = 14;
        break;
      default:
        return null;
    }
    let o = 0;
    switch (i.by) {
      case s.RawUnit.Line:
        o = 1;
        break;
      case s.RawUnit.WrappedLine:
        o = 2;
        break;
      case s.RawUnit.Character:
        o = 3;
        break;
      case s.RawUnit.HalfLine:
        o = 4;
        break;
    }
    return {
      direction: n,
      unit: o,
      select: !!i.select,
      value: i.value || 1
    };
  }
  s.parse = t;
})(W_ || (W_ = {}));
class tZ {
  constructor(e, t, i) {
    this._indentRulesSupport = t, this._indentationLineProcessor = new e5(e, i);
  }
  /**
   * Apply the new indentation and return whether the indentation level should be increased after the given line number
   */
  shouldIncrease(e, t) {
    const i = this._indentationLineProcessor.getProcessedLine(e, t);
    return this._indentRulesSupport.shouldIncrease(i);
  }
  /**
   * Apply the new indentation and return whether the indentation level should be decreased after the given line number
   */
  shouldDecrease(e, t) {
    const i = this._indentationLineProcessor.getProcessedLine(e, t);
    return this._indentRulesSupport.shouldDecrease(i);
  }
  /**
   * Apply the new indentation and return whether the indentation level should remain unchanged at the given line number
   */
  shouldIgnore(e, t) {
    const i = this._indentationLineProcessor.getProcessedLine(e, t);
    return this._indentRulesSupport.shouldIgnore(i);
  }
  /**
   * Apply the new indentation and return whether the indentation level should increase on the line after the given line number
   */
  shouldIndentNextLine(e, t) {
    const i = this._indentationLineProcessor.getProcessedLine(e, t);
    return this._indentRulesSupport.shouldIndentNextLine(i);
  }
}
class yx {
  constructor(e, t) {
    this.model = e, this.indentationLineProcessor = new e5(e, t);
  }
  /**
   * Returns the processed text, stripped from the language configuration brackets within the string, comment and regex tokens, around the given range
   */
  getProcessedTokenContextAroundRange(e) {
    const t = this._getProcessedTokensBeforeRange(e), i = this._getProcessedTokensAfterRange(e), n = this._getProcessedPreviousLineTokens(e);
    return { beforeRangeProcessedTokens: t, afterRangeProcessedTokens: i, previousLineProcessedTokens: n };
  }
  _getProcessedTokensBeforeRange(e) {
    this.model.tokenization.forceTokenization(e.startLineNumber);
    const t = this.model.tokenization.getLineTokens(e.startLineNumber), i = Ul(t, e.startColumn - 1);
    let n;
    if (Sx(this.model, e.getStartPosition())) {
      const r = e.startColumn - 1 - i.firstCharOffset, a = i.firstCharOffset, l = a + r;
      n = t.sliceAndInflate(a, l, 0);
    } else {
      const r = e.startColumn - 1;
      n = t.sliceAndInflate(0, r, 0);
    }
    return this.indentationLineProcessor.getProcessedTokens(n);
  }
  _getProcessedTokensAfterRange(e) {
    const t = e.isEmpty() ? e.getStartPosition() : e.getEndPosition();
    this.model.tokenization.forceTokenization(t.lineNumber);
    const i = this.model.tokenization.getLineTokens(t.lineNumber), n = Ul(i, t.column - 1), o = t.column - 1 - n.firstCharOffset, r = n.firstCharOffset + o, a = n.firstCharOffset + n.getLineLength(), l = i.sliceAndInflate(r, a, 0);
    return this.indentationLineProcessor.getProcessedTokens(l);
  }
  _getProcessedPreviousLineTokens(e) {
    const t = (f) => {
      this.model.tokenization.forceTokenization(f);
      const g = this.model.tokenization.getLineTokens(f), m = this.model.getLineMaxColumn(f) - 1;
      return Ul(g, m);
    };
    this.model.tokenization.forceTokenization(e.startLineNumber);
    const i = this.model.tokenization.getLineTokens(e.startLineNumber), n = Ul(i, e.startColumn - 1), o = Si.createEmpty("", n.languageIdCodec), r = e.startLineNumber - 1;
    if (r === 0 || !(n.firstCharOffset === 0))
      return o;
    const c = t(r);
    if (!(n.languageId === c.languageId))
      return o;
    const d = c.toIViewLineTokens();
    return this.indentationLineProcessor.getProcessedTokens(d);
  }
}
class e5 {
  constructor(e, t) {
    this.model = e, this.languageConfigurationService = t;
  }
  /**
   * Get the processed line for the given line number and potentially adjust the indentation level.
   * Remove the language configuration brackets from the regex, string and comment tokens.
   */
  getProcessedLine(e, t) {
    var r, a;
    const i = (l, c) => {
      const h = en(l);
      return c + l.substring(h.length);
    };
    (a = (r = this.model.tokenization).forceTokenization) == null || a.call(r, e);
    const n = this.model.tokenization.getLineTokens(e);
    let o = this.getProcessedTokens(n).getLineContent();
    return t !== void 0 && (o = i(o, t)), o;
  }
  /**
   * Process the line with the given tokens, remove the language configuration brackets from the regex, string and comment tokens.
   */
  getProcessedTokens(e) {
    const t = (l) => l === 2 || l === 3 || l === 1, i = e.getLanguageId(0), o = this.languageConfigurationService.getLanguageConfiguration(i).bracketsNew.getBracketRegExp({ global: !0 }), r = [];
    return e.forEach((l) => {
      const c = e.getStandardTokenType(l);
      let h = e.getTokenText(l);
      t(c) && (h = h.replace(o, ""));
      const d = e.getMetadata(l);
      r.push({ text: h, metadata: d });
    }), Si.createFromTextAndMetadata(r, e.languageIdCodec);
  }
}
function Sx(s, e) {
  s.tokenization.forceTokenization(e.lineNumber);
  const t = s.tokenization.getLineTokens(e.lineNumber), i = Ul(t, e.column - 1), n = i.firstCharOffset === 0, o = t.getLanguageId(0) === i.languageId;
  return !n && !o;
}
function Lx(s, e, t, i) {
  e.tokenization.forceTokenization(t.startLineNumber);
  const n = e.getLanguageIdAtPosition(t.startLineNumber, t.startColumn), o = i.getLanguageConfiguration(n);
  if (!o)
    return null;
  const a = new yx(e, i).getProcessedTokenContextAroundRange(t), l = a.previousLineProcessedTokens.getLineContent(), c = a.beforeRangeProcessedTokens.getLineContent(), h = a.afterRangeProcessedTokens.getLineContent(), d = o.onEnter(s, l, c, h);
  if (!d)
    return null;
  const u = d.indentAction;
  let f = d.appendText;
  const g = d.removeText || 0;
  f ? u === nn.Indent && (f = "	" + f) : u === nn.Indent || u === nn.IndentOutdent ? f = "	" : f = "";
  let m = GM(e, t.startLineNumber, t.startColumn);
  return g && (m = m.substring(0, m.length - g)), {
    indentAction: u,
    appendText: f,
    removeText: g,
    indentation: m
  };
}
var iZ = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, nZ = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, fp;
const pC = /* @__PURE__ */ Object.create(null);
function dl(s, e) {
  if (e <= 0)
    return "";
  pC[s] || (pC[s] = ["", s]);
  const t = pC[s];
  for (let i = t.length; i <= e; i++)
    t[i] = t[i - 1] + s;
  return t[e];
}
let kc = fp = class {
  static unshiftIndent(e, t, i, n, o) {
    const r = ii.visibleColumnFromColumn(e, t, i);
    if (o) {
      const a = dl(" ", n), c = ii.prevIndentTabStop(r, n) / n;
      return dl(a, c);
    } else {
      const c = ii.prevRenderTabStop(r, i) / i;
      return dl("	", c);
    }
  }
  static shiftIndent(e, t, i, n, o) {
    const r = ii.visibleColumnFromColumn(e, t, i);
    if (o) {
      const a = dl(" ", n), c = ii.nextIndentTabStop(r, n) / n;
      return dl(a, c);
    } else {
      const c = ii.nextRenderTabStop(r, i) / i;
      return dl("	", c);
    }
  }
  constructor(e, t, i) {
    this._languageConfigurationService = i, this._opts = t, this._selection = e, this._selectionId = null, this._useLastEditRangeForCursorEndPosition = !1, this._selectionStartColumnStaysPut = !1;
  }
  _addEditOperation(e, t, i) {
    this._useLastEditRangeForCursorEndPosition ? e.addTrackedEditOperation(t, i) : e.addEditOperation(t, i);
  }
  getEditOperations(e, t) {
    const i = this._selection.startLineNumber;
    let n = this._selection.endLineNumber;
    this._selection.endColumn === 1 && i !== n && (n = n - 1);
    const { tabSize: o, indentSize: r, insertSpaces: a } = this._opts, l = i === n;
    if (this._opts.useTabStops) {
      this._selection.isEmpty() && /^\s*$/.test(e.getLineContent(i)) && (this._useLastEditRangeForCursorEndPosition = !0);
      let c = 0, h = 0;
      for (let d = i; d <= n; d++, c = h) {
        h = 0;
        const u = e.getLineContent(d);
        let f = On(u);
        if (this._opts.isUnshift && (u.length === 0 || f === 0) || !l && !this._opts.isUnshift && u.length === 0)
          continue;
        if (f === -1 && (f = u.length), d > 1 && ii.visibleColumnFromColumn(u, f + 1, o) % r !== 0 && e.tokenization.isCheapToTokenize(d - 1)) {
          const _ = Lx(this._opts.autoIndent, e, new R(d - 1, e.getLineMaxColumn(d - 1), d - 1, e.getLineMaxColumn(d - 1)), this._languageConfigurationService);
          if (_) {
            if (h = c, _.appendText)
              for (let b = 0, C = _.appendText.length; b < C && h < r && _.appendText.charCodeAt(b) === 32; b++)
                h++;
            _.removeText && (h = Math.max(0, h - _.removeText));
            for (let b = 0; b < h && !(f === 0 || u.charCodeAt(f - 1) !== 32); b++)
              f--;
          }
        }
        if (this._opts.isUnshift && f === 0)
          continue;
        let g;
        this._opts.isUnshift ? g = fp.unshiftIndent(u, f + 1, o, r, a) : g = fp.shiftIndent(u, f + 1, o, r, a), this._addEditOperation(t, new R(d, 1, d, f + 1), g), d === i && !this._selection.isEmpty() && (this._selectionStartColumnStaysPut = this._selection.startColumn <= f + 1);
      }
    } else {
      !this._opts.isUnshift && this._selection.isEmpty() && e.getLineLength(i) === 0 && (this._useLastEditRangeForCursorEndPosition = !0);
      const c = a ? dl(" ", r) : "	";
      for (let h = i; h <= n; h++) {
        const d = e.getLineContent(h);
        let u = On(d);
        if (!(this._opts.isUnshift && (d.length === 0 || u === 0)) && !(!l && !this._opts.isUnshift && d.length === 0) && (u === -1 && (u = d.length), !(this._opts.isUnshift && u === 0)))
          if (this._opts.isUnshift) {
            u = Math.min(u, r);
            for (let f = 0; f < u; f++)
              if (d.charCodeAt(f) === 9) {
                u = f + 1;
                break;
              }
            this._addEditOperation(t, new R(h, 1, h, u + 1), "");
          } else
            this._addEditOperation(t, new R(h, 1, h, 1), c), h === i && !this._selection.isEmpty() && (this._selectionStartColumnStaysPut = this._selection.startColumn === 1);
      }
    }
    this._selectionId = t.trackSelection(this._selection);
  }
  computeCursorState(e, t) {
    if (this._useLastEditRangeForCursorEndPosition) {
      const n = t.getInverseEditOperations()[0];
      return new ft(n.range.endLineNumber, n.range.endColumn, n.range.endLineNumber, n.range.endColumn);
    }
    const i = t.getTrackedSelection(this._selectionId);
    if (this._selectionStartColumnStaysPut) {
      const n = this._selection.startColumn;
      return i.startColumn <= n ? i : i.getDirection() === 0 ? new ft(i.startLineNumber, n, i.endLineNumber, i.endColumn) : new ft(i.endLineNumber, i.endColumn, i.startLineNumber, n);
    }
    return i;
  }
};
kc = fp = iZ([
  nZ(2, Zo)
], kc);
class sZ {
  constructor(e, t, i) {
    this._range = e, this._charBeforeSelection = t, this._charAfterSelection = i;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(new R(this._range.startLineNumber, this._range.startColumn, this._range.startLineNumber, this._range.startColumn), this._charBeforeSelection), t.addTrackedEditOperation(new R(this._range.endLineNumber, this._range.endColumn, this._range.endLineNumber, this._range.endColumn), this._charAfterSelection);
  }
  computeCursorState(e, t) {
    const i = t.getInverseEditOperations(), n = i[0].range, o = i[1].range;
    return new ft(n.endLineNumber, n.endColumn, o.endLineNumber, o.endColumn - this._charAfterSelection.length);
  }
}
class oZ {
  constructor(e, t, i) {
    this._position = e, this._text = t, this._charAfter = i;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(new R(this._position.lineNumber, this._position.column, this._position.lineNumber, this._position.column), this._text + this._charAfter);
  }
  computeCursorState(e, t) {
    const n = t.getInverseEditOperations()[0].range;
    return new ft(n.endLineNumber, n.startColumn, n.endLineNumber, n.endColumn - this._charAfter.length);
  }
}
function rZ(s, e, t) {
  const i = s.tokenization.getLanguageIdAtPosition(e, 0);
  if (e > 1) {
    let n, o = -1;
    for (n = e - 1; n >= 1; n--) {
      if (s.tokenization.getLanguageIdAtPosition(n, 0) !== i)
        return o;
      const r = s.getLineContent(n);
      if (t.shouldIgnore(n) || /^\s+$/.test(r) || r === "") {
        o = n;
        continue;
      }
      return n;
    }
  }
  return -1;
}
function V_(s, e, t, i = !0, n) {
  if (s < 4)
    return null;
  const o = n.getLanguageConfiguration(e.tokenization.getLanguageId()).indentRulesSupport;
  if (!o)
    return null;
  const r = new tZ(e, o, n);
  if (t <= 1)
    return {
      indentation: "",
      action: null
    };
  for (let l = t - 1; l > 0 && e.getLineContent(l) === ""; l--)
    if (l === 1)
      return {
        indentation: "",
        action: null
      };
  const a = rZ(e, t, r);
  if (a < 0)
    return null;
  if (a < 1)
    return {
      indentation: "",
      action: null
    };
  if (r.shouldIncrease(a) || r.shouldIndentNextLine(a)) {
    const l = e.getLineContent(a);
    return {
      indentation: en(l),
      action: nn.Indent,
      line: a
    };
  } else if (r.shouldDecrease(a)) {
    const l = e.getLineContent(a);
    return {
      indentation: en(l),
      action: null,
      line: a
    };
  } else {
    if (a === 1)
      return {
        indentation: en(e.getLineContent(a)),
        action: null,
        line: a
      };
    const l = a - 1, c = o.getIndentMetadata(e.getLineContent(l));
    if (!(c & 3) && c & 4) {
      let h = 0;
      for (let d = l - 1; d > 0; d--)
        if (!r.shouldIndentNextLine(d)) {
          h = d;
          break;
        }
      return {
        indentation: en(e.getLineContent(h + 1)),
        action: null,
        line: h + 1
      };
    }
    if (i)
      return {
        indentation: en(e.getLineContent(a)),
        action: null,
        line: a
      };
    for (let h = a; h > 0; h--) {
      if (r.shouldIncrease(h))
        return {
          indentation: en(e.getLineContent(h)),
          action: nn.Indent,
          line: h
        };
      if (r.shouldIndentNextLine(h)) {
        let d = 0;
        for (let u = h - 1; u > 0; u--)
          if (!r.shouldIndentNextLine(h)) {
            d = u;
            break;
          }
        return {
          indentation: en(e.getLineContent(d + 1)),
          action: null,
          line: d + 1
        };
      } else if (r.shouldDecrease(h))
        return {
          indentation: en(e.getLineContent(h)),
          action: null,
          line: h
        };
    }
    return {
      indentation: en(e.getLineContent(1)),
      action: null,
      line: 1
    };
  }
}
function aZ(s, e, t, i, n) {
  if (s < 4)
    return null;
  const o = e.getLanguageIdAtPosition(t.startLineNumber, t.startColumn), r = n.getLanguageConfiguration(o).indentRulesSupport;
  if (!r)
    return null;
  e.tokenization.forceTokenization(t.startLineNumber);
  const l = new yx(e, n).getProcessedTokenContextAroundRange(t), c = l.afterRangeProcessedTokens, h = l.beforeRangeProcessedTokens, d = en(h.getLineContent()), u = cZ(e, t.startLineNumber, h), f = Sx(e, t.getStartPosition()), g = e.getLineContent(t.startLineNumber), m = en(g), _ = V_(s, u, t.startLineNumber + 1, void 0, n);
  if (!_) {
    const C = f ? m : d;
    return {
      beforeEnter: C,
      afterEnter: C
    };
  }
  let b = f ? m : _.indentation;
  return _.action === nn.Indent && (b = i.shiftIndent(b)), r.shouldDecrease(c.getLineContent()) && (b = i.unshiftIndent(b)), {
    beforeEnter: f ? m : d,
    afterEnter: b
  };
}
function lZ(s, e, t, i, n, o) {
  const r = s.autoIndent;
  if (r < 4 || Sx(e, t.getStartPosition()))
    return null;
  const l = e.getLanguageIdAtPosition(t.startLineNumber, t.startColumn), c = o.getLanguageConfiguration(l).indentRulesSupport;
  if (!c)
    return null;
  const d = new yx(e, o).getProcessedTokenContextAroundRange(t), u = d.beforeRangeProcessedTokens.getLineContent(), f = d.afterRangeProcessedTokens.getLineContent(), g = u + f, m = u + i + f;
  if (!c.shouldDecrease(g) && c.shouldDecrease(m)) {
    const b = V_(r, e, t.startLineNumber, !1, o);
    if (!b)
      return null;
    let C = b.indentation;
    return b.action !== nn.Indent && (C = n.unshiftIndent(C)), C;
  }
  const _ = t.startLineNumber - 1;
  if (_ > 0) {
    const b = e.getLineContent(_);
    if (c.shouldIndentNextLine(b) && c.shouldIncrease(m)) {
      const C = V_(r, e, t.startLineNumber, !1, o), v = C == null ? void 0 : C.indentation;
      if (v !== void 0) {
        const w = e.getLineContent(t.startLineNumber), S = en(w), k = n.shiftIndent(v) === S, D = /^\s*$/.test(g), E = s.autoClosingPairs.autoClosingPairsOpenByEnd.get(i), P = E && E.length > 0 && D;
        if (k && P)
          return v;
      }
    }
  }
  return null;
}
function cZ(s, e, t) {
  return {
    tokenization: {
      getLineTokens: (n) => n === e ? t : s.tokenization.getLineTokens(n),
      getLanguageId: () => s.getLanguageId(),
      getLanguageIdAtPosition: (n, o) => s.getLanguageIdAtPosition(n, o)
    },
    getLineContent: (n) => n === e ? t.getLineContent() : s.getLineContent(n)
  };
}
class hZ {
  static getEdits(e, t, i, n, o) {
    if (!o && this._isAutoIndentType(e, t, i)) {
      const r = [];
      for (const l of i) {
        const c = this._findActualIndentationForSelection(e, t, l, n);
        if (c === null)
          return;
        r.push({ selection: l, indentation: c });
      }
      const a = DS.getAutoClosingPairClose(e, t, i, n, !1);
      return this._getIndentationAndAutoClosingPairEdits(e, t, r, n, a);
    }
  }
  static _isAutoIndentType(e, t, i) {
    if (e.autoIndent < 4)
      return !1;
    for (let n = 0, o = i.length; n < o; n++)
      if (!t.tokenization.isCheapToTokenize(i[n].getEndPosition().lineNumber))
        return !1;
    return !0;
  }
  static _findActualIndentationForSelection(e, t, i, n) {
    const o = lZ(e, t, i, n, {
      shiftIndent: (a) => Dx(e, a),
      unshiftIndent: (a) => H_(e, a)
    }, e.languageConfigurationService);
    if (o === null)
      return null;
    const r = GM(t, i.startLineNumber, i.startColumn);
    return o === e.normalizeIndentation(r) ? null : o;
  }
  static _getIndentationAndAutoClosingPairEdits(e, t, i, n, o) {
    const r = i.map(({ selection: l, indentation: c }) => {
      if (o !== null) {
        const h = this._getEditFromIndentationAndSelection(e, t, c, l, n, !1);
        return new vZ(h, l, n, o);
      } else {
        const h = this._getEditFromIndentationAndSelection(e, t, c, l, n, !0);
        return Cl(h.range, h.text, !1);
      }
    }), a = { shouldPushStackElementBefore: !0, shouldPushStackElementAfter: !1 };
    return new yn(4, r, a);
  }
  static _getEditFromIndentationAndSelection(e, t, i, n, o, r = !0) {
    const a = n.startLineNumber, l = t.getLineFirstNonWhitespaceColumn(a);
    let c = e.normalizeIndentation(i);
    if (l !== 0) {
      const d = t.getLineContent(a);
      c += d.substring(l - 1, n.startColumn - 1);
    }
    return c += r ? o : "", { range: new R(a, 1, n.endLineNumber, n.endColumn), text: c };
  }
}
class dZ {
  static getEdits(e, t, i, n, o, r) {
    if (i5(t, i, n, o, r))
      return this._runAutoClosingOvertype(e, n, r);
  }
  static _runAutoClosingOvertype(e, t, i) {
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const l = t[o].getPosition(), c = new R(l.lineNumber, l.column, l.lineNumber, l.column + 1);
      n[o] = new Rn(c, i);
    }
    return new yn(4, n, {
      shouldPushStackElementBefore: Jb(
        e,
        4
        /* EditOperationType.TypingOther */
      ),
      shouldPushStackElementAfter: !1
    });
  }
}
class uZ {
  static getEdits(e, t, i, n, o) {
    if (i5(e, t, i, n, o)) {
      const r = i.map((a) => new Rn(new R(a.positionLineNumber, a.positionColumn, a.positionLineNumber, a.positionColumn + 1), "", !1));
      return new yn(4, r, {
        shouldPushStackElementBefore: !0,
        shouldPushStackElementAfter: !1
      });
    }
  }
}
class DS {
  static getEdits(e, t, i, n, o, r) {
    if (!r) {
      const a = this.getAutoClosingPairClose(e, t, i, n, o);
      if (a !== null)
        return this._runAutoClosingOpenCharType(i, n, o, a);
    }
  }
  static _runAutoClosingOpenCharType(e, t, i, n) {
    const o = [];
    for (let r = 0, a = e.length; r < a; r++) {
      const l = e[r];
      o[r] = new wZ(l, t, !i, n);
    }
    return new yn(4, o, {
      shouldPushStackElementBefore: !0,
      shouldPushStackElementAfter: !1
    });
  }
  static getAutoClosingPairClose(e, t, i, n, o) {
    for (const g of i)
      if (!g.isEmpty())
        return null;
    const r = i.map((g) => {
      const m = g.getPosition();
      return o ? { lineNumber: m.lineNumber, beforeColumn: m.column - n.length, afterColumn: m.column } : { lineNumber: m.lineNumber, beforeColumn: m.column, afterColumn: m.column };
    }), a = this._findAutoClosingPairOpen(e, t, r.map((g) => new V(g.lineNumber, g.beforeColumn)), n);
    if (!a)
      return null;
    let l, c;
    if (Ya(n) ? (l = e.autoClosingQuotes, c = e.shouldAutoCloseBefore.quote) : (e.blockCommentStartToken ? a.open.includes(e.blockCommentStartToken) : !1) ? (l = e.autoClosingComments, c = e.shouldAutoCloseBefore.comment) : (l = e.autoClosingBrackets, c = e.shouldAutoCloseBefore.bracket), l === "never")
      return null;
    const d = this._findContainedAutoClosingPair(e, a), u = d ? d.close : "";
    let f = !0;
    for (const g of r) {
      const { lineNumber: m, beforeColumn: _, afterColumn: b } = g, C = t.getLineContent(m), v = C.substring(0, _ - 1), w = C.substring(b - 1);
      if (w.startsWith(u) || (f = !1), w.length > 0) {
        const D = w.charAt(0);
        if (!this._isBeforeClosingBrace(e, w) && !c(D))
          return null;
      }
      if (a.open.length === 1 && (n === "'" || n === '"') && l !== "always") {
        const D = vd(e.wordSeparators, []);
        if (v.length > 0) {
          const E = v.charCodeAt(v.length - 1);
          if (D.get(E) === 0)
            return null;
        }
      }
      if (!t.tokenization.isCheapToTokenize(m))
        return null;
      t.tokenization.forceTokenization(m);
      const S = t.tokenization.getLineTokens(m), L = Ul(S, _ - 1);
      if (!a.shouldAutoClose(L, _ - L.firstCharOffset))
        return null;
      const k = a.findNeutralCharacter();
      if (k) {
        const D = t.tokenization.getTokenTypeIfInsertingCharacter(m, _, k);
        if (!a.isOK(D))
          return null;
      }
    }
    return f ? a.close.substring(0, a.close.length - u.length) : a.close;
  }
  /**
   * Find another auto-closing pair that is contained by the one passed in.
   *
   * e.g. when having [(,)] and [(*,*)] as auto-closing pairs
   * this method will find [(,)] as a containment pair for [(*,*)]
   */
  static _findContainedAutoClosingPair(e, t) {
    if (t.open.length <= 1)
      return null;
    const i = t.close.charAt(t.close.length - 1), n = e.autoClosingPairs.autoClosingPairsCloseByEnd.get(i) || [];
    let o = null;
    for (const r of n)
      r.open !== t.open && t.open.includes(r.open) && t.close.endsWith(r.close) && (!o || r.open.length > o.open.length) && (o = r);
    return o;
  }
  /**
   * Determine if typing `ch` at all `positions` in the `model` results in an
   * auto closing open sequence being typed.
   *
   * Auto closing open sequences can consist of multiple characters, which
   * can lead to ambiguities. In such a case, the longest auto-closing open
   * sequence is returned.
   */
  static _findAutoClosingPairOpen(e, t, i, n) {
    const o = e.autoClosingPairs.autoClosingPairsOpenByEnd.get(n);
    if (!o)
      return null;
    let r = null;
    for (const a of o)
      if (r === null || a.open.length > r.open.length) {
        let l = !0;
        for (const c of i)
          if (t.getValueInRange(new R(c.lineNumber, c.column - a.open.length + 1, c.lineNumber, c.column)) + n !== a.open) {
            l = !1;
            break;
          }
        l && (r = a);
      }
    return r;
  }
  static _isBeforeClosingBrace(e, t) {
    const i = t.charAt(0), n = e.autoClosingPairs.autoClosingPairsOpenByStart.get(i) || [], o = e.autoClosingPairs.autoClosingPairsCloseByStart.get(i) || [], r = n.some((l) => t.startsWith(l.open)), a = o.some((l) => t.startsWith(l.close));
    return !r && a;
  }
}
class fZ {
  static getEdits(e, t, i, n, o) {
    if (!o && this._isSurroundSelectionType(e, t, i, n))
      return this._runSurroundSelectionType(e, i, n);
  }
  static _runSurroundSelectionType(e, t, i) {
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o], l = e.surroundingPairs[i];
      n[o] = new sZ(a, i, l);
    }
    return new yn(0, n, {
      shouldPushStackElementBefore: !0,
      shouldPushStackElementAfter: !0
    });
  }
  static _isSurroundSelectionType(e, t, i, n) {
    if (!n5(e, n) || !e.surroundingPairs.hasOwnProperty(n))
      return !1;
    const o = Ya(n);
    for (const r of i) {
      if (r.isEmpty())
        return !1;
      let a = !0;
      for (let l = r.startLineNumber; l <= r.endLineNumber; l++) {
        const c = t.getLineContent(l), h = l === r.startLineNumber ? r.startColumn - 1 : 0, d = l === r.endLineNumber ? r.endColumn - 1 : c.length, u = c.substring(h, d);
        if (/[^ \t]/.test(u)) {
          a = !1;
          break;
        }
      }
      if (a)
        return !1;
      if (o && r.startLineNumber === r.endLineNumber && r.startColumn + 1 === r.endColumn) {
        const l = t.getValueInRange(r);
        if (Ya(l))
          return !1;
      }
    }
    return !0;
  }
}
class gZ {
  static getEdits(e, t, i, n, o, r) {
    if (!r && this._isTypeInterceptorElectricChar(t, i, n)) {
      const a = this._typeInterceptorElectricChar(e, t, i, n[0], o);
      if (a)
        return a;
    }
  }
  static _isTypeInterceptorElectricChar(e, t, i) {
    return !!(i.length === 1 && t.tokenization.isCheapToTokenize(i[0].getEndPosition().lineNumber));
  }
  static _typeInterceptorElectricChar(e, t, i, n, o) {
    if (!t.electricChars.hasOwnProperty(o) || !n.isEmpty())
      return null;
    const r = n.getPosition();
    i.tokenization.forceTokenization(r.lineNumber);
    const a = i.tokenization.getLineTokens(r.lineNumber);
    let l;
    try {
      l = t.onElectricCharacter(o, a, r.column);
    } catch (c) {
      return ht(c), null;
    }
    if (!l)
      return null;
    if (l.matchOpenBracket) {
      const c = (a.getLineContent() + o).lastIndexOf(l.matchOpenBracket) + 1, h = i.bracketPairs.findMatchingBracketUp(
        l.matchOpenBracket,
        {
          lineNumber: r.lineNumber,
          column: c
        },
        500
        /* give at most 500ms to compute */
      );
      if (h) {
        if (h.startLineNumber === r.lineNumber)
          return null;
        const d = i.getLineContent(h.startLineNumber), u = en(d), f = t.normalizeIndentation(u), g = i.getLineContent(r.lineNumber), m = i.getLineFirstNonWhitespaceColumn(r.lineNumber) || r.column, _ = g.substring(m - 1, r.column - 1), b = f + _ + o, C = new R(r.lineNumber, 1, r.lineNumber, r.column), v = new Rn(C, b);
        return new yn(xx(b, e), [v], {
          shouldPushStackElementBefore: !1,
          shouldPushStackElementAfter: !0
        });
      }
    }
    return null;
  }
}
class mZ {
  static getEdits(e, t, i) {
    const n = [];
    for (let r = 0, a = t.length; r < a; r++)
      n[r] = new Rn(t[r], i);
    const o = xx(i, e);
    return new yn(o, n, {
      shouldPushStackElementBefore: Jb(e, o),
      shouldPushStackElementAfter: !1
    });
  }
}
class t5 {
  static getEdits(e, t, i, n, o) {
    if (!o && n === `
`) {
      const r = [];
      for (let a = 0, l = i.length; a < l; a++)
        r[a] = this._enter(e, t, !1, i[a]);
      return new yn(4, r, {
        shouldPushStackElementBefore: !0,
        shouldPushStackElementAfter: !1
      });
    }
  }
  static _enter(e, t, i, n) {
    if (e.autoIndent === 0)
      return Cl(n, `
`, i);
    if (!t.tokenization.isCheapToTokenize(n.getStartPosition().lineNumber) || e.autoIndent === 1) {
      const l = t.getLineContent(n.startLineNumber), c = en(l).substring(0, n.startColumn - 1);
      return Cl(n, `
` + e.normalizeIndentation(c), i);
    }
    const o = Lx(e.autoIndent, t, n, e.languageConfigurationService);
    if (o) {
      if (o.indentAction === nn.None)
        return Cl(n, `
` + e.normalizeIndentation(o.indentation + o.appendText), i);
      if (o.indentAction === nn.Indent)
        return Cl(n, `
` + e.normalizeIndentation(o.indentation + o.appendText), i);
      if (o.indentAction === nn.IndentOutdent) {
        const l = e.normalizeIndentation(o.indentation), c = e.normalizeIndentation(o.indentation + o.appendText), h = `
` + c + `
` + l;
        return i ? new up(n, h, !0) : new B_(n, h, -1, c.length - l.length, !0);
      } else if (o.indentAction === nn.Outdent) {
        const l = H_(e, o.indentation);
        return Cl(n, `
` + e.normalizeIndentation(l + o.appendText), i);
      }
    }
    const r = t.getLineContent(n.startLineNumber), a = en(r).substring(0, n.startColumn - 1);
    if (e.autoIndent >= 4) {
      const l = aZ(e.autoIndent, t, n, {
        unshiftIndent: (c) => H_(e, c),
        shiftIndent: (c) => Dx(e, c),
        normalizeIndentation: (c) => e.normalizeIndentation(c)
      }, e.languageConfigurationService);
      if (l) {
        let c = e.visibleColumnFromColumn(t, n.getEndPosition());
        const h = n.endColumn, d = t.getLineContent(n.endLineNumber), u = On(d);
        if (u >= 0 ? n = n.setEndPosition(n.endLineNumber, Math.max(n.endColumn, u + 1)) : n = n.setEndPosition(n.endLineNumber, t.getLineMaxColumn(n.endLineNumber)), i)
          return new up(n, `
` + e.normalizeIndentation(l.afterEnter), !0);
        {
          let f = 0;
          return h <= u + 1 && (e.insertSpaces || (c = Math.ceil(c / e.indentSize)), f = Math.min(c + 1 - e.normalizeIndentation(l.afterEnter).length - 1, 0)), new B_(n, `
` + e.normalizeIndentation(l.afterEnter), 0, f, !0);
        }
      }
    }
    return Cl(n, `
` + e.normalizeIndentation(a), i);
  }
  static lineInsertBefore(e, t, i) {
    if (t === null || i === null)
      return [];
    const n = [];
    for (let o = 0, r = i.length; o < r; o++) {
      let a = i[o].positionLineNumber;
      if (a === 1)
        n[o] = new up(new R(1, 1, 1, 1), `
`);
      else {
        a--;
        const l = t.getLineMaxColumn(a);
        n[o] = this._enter(e, t, !1, new R(a, l, a, l));
      }
    }
    return n;
  }
  static lineInsertAfter(e, t, i) {
    if (t === null || i === null)
      return [];
    const n = [];
    for (let o = 0, r = i.length; o < r; o++) {
      const a = i[o].positionLineNumber, l = t.getLineMaxColumn(a);
      n[o] = this._enter(e, t, !1, new R(a, l, a, l));
    }
    return n;
  }
  static lineBreakInsert(e, t, i) {
    const n = [];
    for (let o = 0, r = i.length; o < r; o++)
      n[o] = this._enter(e, t, !0, i[o]);
    return n;
  }
}
class pZ {
  static getEdits(e, t, i, n, o, r) {
    const a = this._distributePasteToCursors(e, i, n, o, r);
    return a ? (i = i.sort(R.compareRangesUsingStarts), this._distributedPaste(e, t, i, a)) : this._simplePaste(e, t, i, n, o);
  }
  static _distributePasteToCursors(e, t, i, n, o) {
    if (n || t.length === 1)
      return null;
    if (o && o.length === t.length)
      return o;
    if (e.multiCursorPaste === "spread") {
      i.charCodeAt(i.length - 1) === 10 && (i = i.substring(0, i.length - 1)), i.charCodeAt(i.length - 1) === 13 && (i = i.substring(0, i.length - 1));
      const r = Vd(i);
      if (r.length === t.length)
        return r;
    }
    return null;
  }
  static _distributedPaste(e, t, i, n) {
    const o = [];
    for (let r = 0, a = i.length; r < a; r++)
      o[r] = new Rn(i[r], n[r]);
    return new yn(0, o, {
      shouldPushStackElementBefore: !0,
      shouldPushStackElementAfter: !0
    });
  }
  static _simplePaste(e, t, i, n, o) {
    const r = [];
    for (let a = 0, l = i.length; a < l; a++) {
      const c = i[a], h = c.getPosition();
      if (o && !c.isEmpty() && (o = !1), o && n.indexOf(`
`) !== n.length - 1 && (o = !1), o) {
        const d = new R(h.lineNumber, 1, h.lineNumber, 1);
        r[a] = new eZ(d, n, c, !0);
      } else
        r[a] = new Rn(c, n);
    }
    return new yn(0, r, {
      shouldPushStackElementBefore: !0,
      shouldPushStackElementAfter: !0
    });
  }
}
class _Z {
  static getEdits(e, t, i, n, o, r, a, l) {
    const c = n.map((h) => this._compositionType(i, h, o, r, a, l));
    return new yn(4, c, {
      shouldPushStackElementBefore: Jb(
        e,
        4
        /* EditOperationType.TypingOther */
      ),
      shouldPushStackElementAfter: !1
    });
  }
  static _compositionType(e, t, i, n, o, r) {
    if (!t.isEmpty())
      return null;
    const a = t.getPosition(), l = Math.max(1, a.column - n), c = Math.min(e.getLineMaxColumn(a.lineNumber), a.column + o), h = new R(a.lineNumber, l, a.lineNumber, c);
    return e.getValueInRange(h) === i && r === 0 ? null : new B_(h, i, 0, r);
  }
}
class bZ {
  static getEdits(e, t, i) {
    const n = [];
    for (let r = 0, a = t.length; r < a; r++)
      n[r] = new Rn(t[r], i);
    const o = xx(i, e);
    return new yn(o, n, {
      shouldPushStackElementBefore: Jb(e, o),
      shouldPushStackElementAfter: !1
    });
  }
}
class CZ {
  static getCommands(e, t, i) {
    const n = [];
    for (let o = 0, r = i.length; o < r; o++) {
      const a = i[o];
      if (a.isEmpty()) {
        const l = t.getLineContent(a.startLineNumber);
        if (/^\s*$/.test(l) && t.tokenization.isCheapToTokenize(a.startLineNumber)) {
          let c = this._goodIndentForLine(e, t, a.startLineNumber);
          c = c || "	";
          const h = e.normalizeIndentation(c);
          if (!l.startsWith(h)) {
            n[o] = new Rn(new R(a.startLineNumber, 1, a.startLineNumber, l.length + 1), h, !0);
            continue;
          }
        }
        n[o] = this._replaceJumpToNextIndent(e, t, a, !0);
      } else {
        if (a.startLineNumber === a.endLineNumber) {
          const l = t.getLineMaxColumn(a.startLineNumber);
          if (a.startColumn !== 1 || a.endColumn !== l) {
            n[o] = this._replaceJumpToNextIndent(e, t, a, !1);
            continue;
          }
        }
        n[o] = new kc(a, {
          isUnshift: !1,
          tabSize: e.tabSize,
          indentSize: e.indentSize,
          insertSpaces: e.insertSpaces,
          useTabStops: e.useTabStops,
          autoIndent: e.autoIndent
        }, e.languageConfigurationService);
      }
    }
    return n;
  }
  static _goodIndentForLine(e, t, i) {
    let n = null, o = "";
    const r = V_(e.autoIndent, t, i, !1, e.languageConfigurationService);
    if (r)
      n = r.action, o = r.indentation;
    else if (i > 1) {
      let a;
      for (a = i - 1; a >= 1; a--) {
        const h = t.getLineContent(a);
        if (Ec(h) >= 0)
          break;
      }
      if (a < 1)
        return null;
      const l = t.getLineMaxColumn(a), c = Lx(e.autoIndent, t, new R(a, l, a, l), e.languageConfigurationService);
      c && (o = c.indentation + c.appendText);
    }
    return n && (n === nn.Indent && (o = Dx(e, o)), n === nn.Outdent && (o = H_(e, o)), o = e.normalizeIndentation(o)), o || null;
  }
  static _replaceJumpToNextIndent(e, t, i, n) {
    let o = "";
    const r = i.getStartPosition();
    if (e.insertSpaces) {
      const a = e.visibleColumnFromColumn(t, r), l = e.indentSize, c = l - a % l;
      for (let h = 0; h < c; h++)
        o += " ";
    } else
      o = "	";
    return new Rn(i, o, n);
  }
}
class kx extends B_ {
  constructor(e, t, i, n, o, r) {
    super(e, t, i, n), this._openCharacter = o, this._closeCharacter = r, this.closeCharacterRange = null, this.enclosingRange = null;
  }
  _computeCursorStateWithRange(e, t, i) {
    return this.closeCharacterRange = new R(t.startLineNumber, t.endColumn - this._closeCharacter.length, t.endLineNumber, t.endColumn), this.enclosingRange = new R(t.startLineNumber, t.endColumn - this._openCharacter.length - this._closeCharacter.length, t.endLineNumber, t.endColumn), super.computeCursorState(e, i);
  }
}
class wZ extends kx {
  constructor(e, t, i, n) {
    const o = (i ? t : "") + n, r = 0, a = -n.length;
    super(e, o, r, a, t, n);
  }
  computeCursorState(e, t) {
    const n = t.getInverseEditOperations()[0].range;
    return this._computeCursorStateWithRange(e, n, t);
  }
}
class vZ extends kx {
  constructor(e, t, i, n) {
    const o = i + n, r = 0, a = i.length;
    super(t, o, r, a, i, n), this._autoIndentationEdit = e, this._autoClosingEdit = { range: t, text: o };
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(this._autoIndentationEdit.range, this._autoIndentationEdit.text), t.addTrackedEditOperation(this._autoClosingEdit.range, this._autoClosingEdit.text);
  }
  computeCursorState(e, t) {
    const i = t.getInverseEditOperations();
    if (i.length !== 2)
      throw new Error("There should be two inverse edit operations!");
    const n = i[0].range, o = i[1].range, r = n.plusRange(o);
    return this._computeCursorStateWithRange(e, r, t);
  }
}
function xx(s, e) {
  return s === " " ? e === 5 || e === 6 ? 6 : 5 : 4;
}
function Jb(s, e) {
  return uT(s) && !uT(e) ? !0 : s === 5 ? !1 : dT(s) !== dT(e);
}
function dT(s) {
  return s === 6 || s === 5 ? "space" : s;
}
function uT(s) {
  return s === 4 || s === 5 || s === 6;
}
function i5(s, e, t, i, n) {
  if (s.autoClosingOvertype === "never" || !s.autoClosingPairs.autoClosingPairsCloseSingleChar.has(n))
    return !1;
  for (let o = 0, r = t.length; o < r; o++) {
    const a = t[o];
    if (!a.isEmpty())
      return !1;
    const l = a.getPosition(), c = e.getLineContent(l.lineNumber);
    if (c.charAt(l.column - 1) !== n)
      return !1;
    const d = Ya(n);
    if ((l.column > 2 ? c.charCodeAt(l.column - 2) : 0) === 92 && d)
      return !1;
    if (s.autoClosingOvertype === "auto") {
      let f = !1;
      for (let g = 0, m = i.length; g < m; g++) {
        const _ = i[g];
        if (l.lineNumber === _.startLineNumber && l.column === _.startColumn) {
          f = !0;
          break;
        }
      }
      if (!f)
        return !1;
    }
  }
  return !0;
}
function Cl(s, e, t) {
  return t ? new up(s, e, !0) : new Rn(s, e, !0);
}
function Dx(s, e, t) {
  return t = t || 1, kc.shiftIndent(e, e.length + t, s.tabSize, s.indentSize, s.insertSpaces);
}
function H_(s, e, t) {
  return t = t || 1, kc.unshiftIndent(e, e.length + t, s.tabSize, s.indentSize, s.insertSpaces);
}
function n5(s, e) {
  return Ya(e) ? s.autoSurround === "quotes" || s.autoSurround === "languageDefined" : s.autoSurround === "brackets" || s.autoSurround === "languageDefined";
}
class Pl {
  static indent(e, t, i) {
    if (t === null || i === null)
      return [];
    const n = [];
    for (let o = 0, r = i.length; o < r; o++)
      n[o] = new kc(i[o], {
        isUnshift: !1,
        tabSize: e.tabSize,
        indentSize: e.indentSize,
        insertSpaces: e.insertSpaces,
        useTabStops: e.useTabStops,
        autoIndent: e.autoIndent
      }, e.languageConfigurationService);
    return n;
  }
  static outdent(e, t, i) {
    const n = [];
    for (let o = 0, r = i.length; o < r; o++)
      n[o] = new kc(i[o], {
        isUnshift: !0,
        tabSize: e.tabSize,
        indentSize: e.indentSize,
        insertSpaces: e.insertSpaces,
        useTabStops: e.useTabStops,
        autoIndent: e.autoIndent
      }, e.languageConfigurationService);
    return n;
  }
  static paste(e, t, i, n, o, r) {
    return pZ.getEdits(e, t, i, n, o, r);
  }
  static tab(e, t, i) {
    return CZ.getCommands(e, t, i);
  }
  static compositionType(e, t, i, n, o, r, a, l) {
    return _Z.getEdits(e, t, i, n, o, r, a, l);
  }
  /**
   * This is very similar with typing, but the character is already in the text buffer!
   */
  static compositionEndWithInterceptors(e, t, i, n, o, r) {
    if (!n)
      return null;
    let a = null;
    for (const u of n)
      if (a === null)
        a = u.insertedText;
      else if (a !== u.insertedText)
        return null;
    if (!a || a.length !== 1)
      return null;
    const l = a;
    let c = !1;
    for (const u of n)
      if (u.deletedText.length !== 0) {
        c = !0;
        break;
      }
    if (c) {
      if (!n5(t, l) || !t.surroundingPairs.hasOwnProperty(l))
        return null;
      const u = Ya(l);
      for (const m of n)
        if (m.deletedSelectionStart !== 0 || m.deletedSelectionEnd !== m.deletedText.length || /^[ \t]+$/.test(m.deletedText) || u && Ya(m.deletedText))
          return null;
      const f = [];
      for (const m of o) {
        if (!m.isEmpty())
          return null;
        f.push(m.getPosition());
      }
      if (f.length !== n.length)
        return null;
      const g = [];
      for (let m = 0, _ = f.length; m < _; m++)
        g.push(new oZ(f[m], n[m].deletedText, t.surroundingPairs[l]));
      return new yn(4, g, {
        shouldPushStackElementBefore: !0,
        shouldPushStackElementAfter: !1
      });
    }
    const h = uZ.getEdits(t, i, o, r, l);
    if (h !== void 0)
      return h;
    const d = DS.getEdits(t, i, o, l, !0, !1);
    return d !== void 0 ? d : null;
  }
  static typeWithInterceptors(e, t, i, n, o, r, a) {
    const l = t5.getEdits(i, n, o, a, e);
    if (l !== void 0)
      return l;
    const c = hZ.getEdits(i, n, o, a, e);
    if (c !== void 0)
      return c;
    const h = dZ.getEdits(t, i, n, o, r, a);
    if (h !== void 0)
      return h;
    const d = DS.getEdits(i, n, o, a, !1, e);
    if (d !== void 0)
      return d;
    const u = fZ.getEdits(i, n, o, a, e);
    if (u !== void 0)
      return u;
    const f = gZ.getEdits(t, i, n, o, a, e);
    return f !== void 0 ? f : mZ.getEdits(t, o, a);
  }
  static typeWithoutInterceptors(e, t, i, n, o) {
    return bZ.getEdits(e, n, o);
  }
}
class yZ {
  constructor(e, t, i, n, o, r) {
    this.deletedText = e, this.deletedSelectionStart = t, this.deletedSelectionEnd = i, this.insertedText = n, this.insertedSelectionStart = o, this.insertedSelectionEnd = r;
  }
}
var se;
(function(s) {
  s.editorSimpleInput = new de("editorSimpleInput", !1, !0), s.editorTextFocus = new de("editorTextFocus", !1, p("editorTextFocus", "Whether the editor text has focus (cursor is blinking)")), s.focus = new de("editorFocus", !1, p("editorFocus", "Whether the editor or an editor widget has focus (e.g. focus is in the find widget)")), s.textInputFocus = new de("textInputFocus", !1, p("textInputFocus", "Whether an editor or a rich text input has focus (cursor is blinking)")), s.readOnly = new de("editorReadonly", !1, p("editorReadonly", "Whether the editor is read-only")), s.inDiffEditor = new de("inDiffEditor", !1, p("inDiffEditor", "Whether the context is a diff editor")), s.isEmbeddedDiffEditor = new de("isEmbeddedDiffEditor", !1, p("isEmbeddedDiffEditor", "Whether the context is an embedded diff editor")), s.inMultiDiffEditor = new de("inMultiDiffEditor", !1, p("inMultiDiffEditor", "Whether the context is a multi diff editor")), s.multiDiffEditorAllCollapsed = new de("multiDiffEditorAllCollapsed", void 0, p("multiDiffEditorAllCollapsed", "Whether all files in multi diff editor are collapsed")), s.hasChanges = new de("diffEditorHasChanges", !1, p("diffEditorHasChanges", "Whether the diff editor has changes")), s.comparingMovedCode = new de("comparingMovedCode", !1, p("comparingMovedCode", "Whether a moved code block is selected for comparison")), s.accessibleDiffViewerVisible = new de("accessibleDiffViewerVisible", !1, p("accessibleDiffViewerVisible", "Whether the accessible diff viewer is visible")), s.diffEditorRenderSideBySideInlineBreakpointReached = new de("diffEditorRenderSideBySideInlineBreakpointReached", !1, p("diffEditorRenderSideBySideInlineBreakpointReached", "Whether the diff editor render side by side inline breakpoint is reached")), s.diffEditorInlineMode = new de("diffEditorInlineMode", !1, p("diffEditorInlineMode", "Whether inline mode is active")), s.diffEditorOriginalWritable = new de("diffEditorOriginalWritable", !1, p("diffEditorOriginalWritable", "Whether modified is writable in the diff editor")), s.diffEditorModifiedWritable = new de("diffEditorModifiedWritable", !1, p("diffEditorModifiedWritable", "Whether modified is writable in the diff editor")), s.diffEditorOriginalUri = new de("diffEditorOriginalUri", "", p("diffEditorOriginalUri", "The uri of the original document")), s.diffEditorModifiedUri = new de("diffEditorModifiedUri", "", p("diffEditorModifiedUri", "The uri of the modified document")), s.columnSelection = new de("editorColumnSelection", !1, p("editorColumnSelection", "Whether `editor.columnSelection` is enabled")), s.writable = s.readOnly.toNegated(), s.hasNonEmptySelection = new de("editorHasSelection", !1, p("editorHasSelection", "Whether the editor has text selected")), s.hasOnlyEmptySelection = s.hasNonEmptySelection.toNegated(), s.hasMultipleSelections = new de("editorHasMultipleSelections", !1, p("editorHasMultipleSelections", "Whether the editor has multiple selections")), s.hasSingleSelection = s.hasMultipleSelections.toNegated(), s.tabMovesFocus = new de("editorTabMovesFocus", !1, p("editorTabMovesFocus", "Whether `Tab` will move focus out of the editor")), s.tabDoesNotMoveFocus = s.tabMovesFocus.toNegated(), s.isInEmbeddedEditor = new de("isInEmbeddedEditor", !1, !0), s.canUndo = new de("canUndo", !1, !0), s.canRedo = new de("canRedo", !1, !0), s.hoverVisible = new de("editorHoverVisible", !1, p("editorHoverVisible", "Whether the editor hover is visible")), s.hoverFocused = new de("editorHoverFocused", !1, p("editorHoverFocused", "Whether the editor hover is focused")), s.stickyScrollFocused = new de("stickyScrollFocused", !1, p("stickyScrollFocused", "Whether the sticky scroll is focused")), s.stickyScrollVisible = new de("stickyScrollVisible", !1, p("stickyScrollVisible", "Whether the sticky scroll is visible")), s.standaloneColorPickerVisible = new de("standaloneColorPickerVisible", !1, p("standaloneColorPickerVisible", "Whether the standalone color picker is visible")), s.standaloneColorPickerFocused = new de("standaloneColorPickerFocused", !1, p("standaloneColorPickerFocused", "Whether the standalone color picker is focused")), s.inCompositeEditor = new de("inCompositeEditor", void 0, p("inCompositeEditor", "Whether the editor is part of a larger editor (e.g. notebooks)")), s.notInCompositeEditor = s.inCompositeEditor.toNegated(), s.languageId = new de("editorLangId", "", p("editorLangId", "The language identifier of the editor")), s.hasCompletionItemProvider = new de("editorHasCompletionItemProvider", !1, p("editorHasCompletionItemProvider", "Whether the editor has a completion item provider")), s.hasCodeActionsProvider = new de("editorHasCodeActionsProvider", !1, p("editorHasCodeActionsProvider", "Whether the editor has a code actions provider")), s.hasCodeLensProvider = new de("editorHasCodeLensProvider", !1, p("editorHasCodeLensProvider", "Whether the editor has a code lens provider")), s.hasDefinitionProvider = new de("editorHasDefinitionProvider", !1, p("editorHasDefinitionProvider", "Whether the editor has a definition provider")), s.hasDeclarationProvider = new de("editorHasDeclarationProvider", !1, p("editorHasDeclarationProvider", "Whether the editor has a declaration provider")), s.hasImplementationProvider = new de("editorHasImplementationProvider", !1, p("editorHasImplementationProvider", "Whether the editor has an implementation provider")), s.hasTypeDefinitionProvider = new de("editorHasTypeDefinitionProvider", !1, p("editorHasTypeDefinitionProvider", "Whether the editor has a type definition provider")), s.hasHoverProvider = new de("editorHasHoverProvider", !1, p("editorHasHoverProvider", "Whether the editor has a hover provider")), s.hasDocumentHighlightProvider = new de("editorHasDocumentHighlightProvider", !1, p("editorHasDocumentHighlightProvider", "Whether the editor has a document highlight provider")), s.hasDocumentSymbolProvider = new de("editorHasDocumentSymbolProvider", !1, p("editorHasDocumentSymbolProvider", "Whether the editor has a document symbol provider")), s.hasReferenceProvider = new de("editorHasReferenceProvider", !1, p("editorHasReferenceProvider", "Whether the editor has a reference provider")), s.hasRenameProvider = new de("editorHasRenameProvider", !1, p("editorHasRenameProvider", "Whether the editor has a rename provider")), s.hasSignatureHelpProvider = new de("editorHasSignatureHelpProvider", !1, p("editorHasSignatureHelpProvider", "Whether the editor has a signature help provider")), s.hasInlayHintsProvider = new de("editorHasInlayHintsProvider", !1, p("editorHasInlayHintsProvider", "Whether the editor has an inline hints provider")), s.hasDocumentFormattingProvider = new de("editorHasDocumentFormattingProvider", !1, p("editorHasDocumentFormattingProvider", "Whether the editor has a document formatting provider")), s.hasDocumentSelectionFormattingProvider = new de("editorHasDocumentSelectionFormattingProvider", !1, p("editorHasDocumentSelectionFormattingProvider", "Whether the editor has a document selection formatting provider")), s.hasMultipleDocumentFormattingProvider = new de("editorHasMultipleDocumentFormattingProvider", !1, p("editorHasMultipleDocumentFormattingProvider", "Whether the editor has multiple document formatting providers")), s.hasMultipleDocumentSelectionFormattingProvider = new de("editorHasMultipleDocumentSelectionFormattingProvider", !1, p("editorHasMultipleDocumentSelectionFormattingProvider", "Whether the editor has multiple document selection formatting providers"));
})(se || (se = {}));
const ze = 0;
class Rt extends Cc {
  runEditorCommand(e, t, i) {
    const n = t._getViewModel();
    n && this.runCoreEditorCommand(n, i || {});
  }
}
var Ei;
(function(s) {
  const e = function(i) {
    if (!_n(i))
      return !1;
    const n = i;
    return !(!Jn(n.to) || !fs(n.by) && !Jn(n.by) || !fs(n.value) && !Od(n.value) || !fs(n.revealCursor) && !C2(n.revealCursor));
  };
  s.metadata = {
    description: "Scroll editor in the given direction",
    args: [
      {
        name: "Editor scroll argument object",
        description: "Property-value pairs that can be passed through this argument:\n					* 'to': A mandatory direction value.\n						```\n						'up', 'down'\n						```\n					* 'by': Unit to move. Default is computed based on 'to' value.\n						```\n						'line', 'wrappedLine', 'page', 'halfPage', 'editor'\n						```\n					* 'value': Number of units to move. Default is '1'.\n					* 'revealCursor': If 'true' reveals the cursor if it is outside view port.\n				",
        constraint: e,
        schema: {
          type: "object",
          required: ["to"],
          properties: {
            to: {
              type: "string",
              enum: ["up", "down"]
            },
            by: {
              type: "string",
              enum: ["line", "wrappedLine", "page", "halfPage", "editor"]
            },
            value: {
              type: "number",
              default: 1
            },
            revealCursor: {
              type: "boolean"
            }
          }
        }
      }
    ]
  }, s.RawDirection = {
    Up: "up",
    Right: "right",
    Down: "down",
    Left: "left"
  }, s.RawUnit = {
    Line: "line",
    WrappedLine: "wrappedLine",
    Page: "page",
    HalfPage: "halfPage",
    Editor: "editor",
    Column: "column"
  };
  function t(i) {
    let n;
    switch (i.to) {
      case s.RawDirection.Up:
        n = 1;
        break;
      case s.RawDirection.Right:
        n = 2;
        break;
      case s.RawDirection.Down:
        n = 3;
        break;
      case s.RawDirection.Left:
        n = 4;
        break;
      default:
        return null;
    }
    let o;
    switch (i.by) {
      case s.RawUnit.Line:
        o = 1;
        break;
      case s.RawUnit.WrappedLine:
        o = 2;
        break;
      case s.RawUnit.Page:
        o = 3;
        break;
      case s.RawUnit.HalfPage:
        o = 4;
        break;
      case s.RawUnit.Editor:
        o = 5;
        break;
      case s.RawUnit.Column:
        o = 6;
        break;
      default:
        o = 2;
    }
    const r = Math.floor(i.value || 1), a = !!i.revealCursor;
    return {
      direction: n,
      unit: o,
      value: r,
      revealCursor: a,
      select: !!i.select
    };
  }
  s.parse = t;
})(Ei || (Ei = {}));
var xh;
(function(s) {
  const e = function(t) {
    if (!_n(t))
      return !1;
    const i = t;
    return !(!Od(i.lineNumber) && !Jn(i.lineNumber) || !fs(i.at) && !Jn(i.at));
  };
  s.metadata = {
    description: "Reveal the given line at the given logical position",
    args: [
      {
        name: "Reveal line argument object",
        description: "Property-value pairs that can be passed through this argument:\n					* 'lineNumber': A mandatory line number value.\n					* 'at': Logical position at which line has to be revealed.\n						```\n						'top', 'center', 'bottom'\n						```\n				",
        constraint: e,
        schema: {
          type: "object",
          required: ["lineNumber"],
          properties: {
            lineNumber: {
              type: ["number", "string"]
            },
            at: {
              type: "string",
              enum: ["top", "center", "bottom"]
            }
          }
        }
      }
    ]
  }, s.RawAtArgument = {
    Top: "top",
    Center: "center",
    Bottom: "bottom"
  };
})(xh || (xh = {}));
class ES {
  constructor(e) {
    e.addImplementation(1e4, "code-editor", (t, i) => {
      const n = t.get(ri).getFocusedCodeEditor();
      return n && n.hasTextFocus() ? this._runEditorCommand(t, n, i) : !1;
    }), e.addImplementation(1e3, "generic-dom-input-textarea", (t, i) => {
      const n = Gi();
      return n && ["input", "textarea"].indexOf(n.tagName.toLowerCase()) >= 0 ? (this.runDOMCommand(n), !0) : !1;
    }), e.addImplementation(0, "generic-dom", (t, i) => {
      const n = t.get(ri).getActiveCodeEditor();
      return n ? (n.focus(), this._runEditorCommand(t, n, i)) : !1;
    });
  }
  _runEditorCommand(e, t, i) {
    const n = this.runEditorCommand(e, t, i);
    return n || !0;
  }
}
var ai;
(function(s) {
  class e extends Rt {
    constructor(C) {
      super(C), this._inSelectionMode = C.inSelectionMode;
    }
    runCoreEditorCommand(C, v) {
      if (!v.position)
        return;
      C.model.pushStackElement(), C.setCursorStates(v.source, 3, [
        Vi.moveTo(C, C.getPrimaryCursorState(), this._inSelectionMode, v.position, v.viewPosition)
      ]) && v.revealType !== 2 && C.revealAllCursors(v.source, !0, !0);
    }
  }
  s.MoveTo = ye(new e({
    id: "_moveTo",
    inSelectionMode: !1,
    precondition: void 0
  })), s.MoveToSelect = ye(new e({
    id: "_moveToSelect",
    inSelectionMode: !0,
    precondition: void 0
  }));
  class t extends Rt {
    runCoreEditorCommand(C, v) {
      C.model.pushStackElement();
      const w = this._getColumnSelectResult(C, C.getPrimaryCursorState(), C.getCursorColumnSelectData(), v);
      w !== null && (C.setCursorStates(v.source, 3, w.viewStates.map((S) => Pe.fromViewState(S))), C.setCursorColumnSelectData({
        isReal: !0,
        fromViewLineNumber: w.fromLineNumber,
        fromViewVisualColumn: w.fromVisualColumn,
        toViewLineNumber: w.toLineNumber,
        toViewVisualColumn: w.toVisualColumn
      }), w.reversed ? C.revealTopMostCursor(v.source) : C.revealBottomMostCursor(v.source));
    }
  }
  s.ColumnSelect = ye(new class extends t {
    constructor() {
      super({
        id: "columnSelect",
        precondition: void 0
      });
    }
    _getColumnSelectResult(b, C, v, w) {
      if (typeof w.position > "u" || typeof w.viewPosition > "u" || typeof w.mouseColumn > "u")
        return null;
      const S = b.model.validatePosition(w.position), L = b.coordinatesConverter.validateViewPosition(new V(w.viewPosition.lineNumber, w.viewPosition.column), S), k = w.doColumnSelect ? v.fromViewLineNumber : L.lineNumber, D = w.doColumnSelect ? v.fromViewVisualColumn : w.mouseColumn - 1;
      return Al.columnSelect(b.cursorConfig, b, k, D, L.lineNumber, w.mouseColumn - 1);
    }
  }()), s.CursorColumnSelectLeft = ye(new class extends t {
    constructor() {
      super({
        id: "cursorColumnSelectLeft",
        precondition: void 0,
        kbOpts: {
          weight: ze,
          kbExpr: se.textInputFocus,
          primary: 3599,
          linux: { primary: 0 }
        }
      });
    }
    _getColumnSelectResult(b, C, v, w) {
      return Al.columnSelectLeft(b.cursorConfig, b, v);
    }
  }()), s.CursorColumnSelectRight = ye(new class extends t {
    constructor() {
      super({
        id: "cursorColumnSelectRight",
        precondition: void 0,
        kbOpts: {
          weight: ze,
          kbExpr: se.textInputFocus,
          primary: 3601,
          linux: { primary: 0 }
        }
      });
    }
    _getColumnSelectResult(b, C, v, w) {
      return Al.columnSelectRight(b.cursorConfig, b, v);
    }
  }());
  class i extends t {
    constructor(C) {
      super(C), this._isPaged = C.isPaged;
    }
    _getColumnSelectResult(C, v, w, S) {
      return Al.columnSelectUp(C.cursorConfig, C, w, this._isPaged);
    }
  }
  s.CursorColumnSelectUp = ye(new i({
    isPaged: !1,
    id: "cursorColumnSelectUp",
    precondition: void 0,
    kbOpts: {
      weight: ze,
      kbExpr: se.textInputFocus,
      primary: 3600,
      linux: { primary: 0 }
    }
  })), s.CursorColumnSelectPageUp = ye(new i({
    isPaged: !0,
    id: "cursorColumnSelectPageUp",
    precondition: void 0,
    kbOpts: {
      weight: ze,
      kbExpr: se.textInputFocus,
      primary: 3595,
      linux: { primary: 0 }
    }
  }));
  class n extends t {
    constructor(C) {
      super(C), this._isPaged = C.isPaged;
    }
    _getColumnSelectResult(C, v, w, S) {
      return Al.columnSelectDown(C.cursorConfig, C, w, this._isPaged);
    }
  }
  s.CursorColumnSelectDown = ye(new n({
    isPaged: !1,
    id: "cursorColumnSelectDown",
    precondition: void 0,
    kbOpts: {
      weight: ze,
      kbExpr: se.textInputFocus,
      primary: 3602,
      linux: { primary: 0 }
    }
  })), s.CursorColumnSelectPageDown = ye(new n({
    isPaged: !0,
    id: "cursorColumnSelectPageDown",
    precondition: void 0,
    kbOpts: {
      weight: ze,
      kbExpr: se.textInputFocus,
      primary: 3596,
      linux: { primary: 0 }
    }
  }));
  class o extends Rt {
    constructor() {
      super({
        id: "cursorMove",
        precondition: void 0,
        metadata: W_.metadata
      });
    }
    runCoreEditorCommand(C, v) {
      const w = W_.parse(v);
      w && this._runCursorMove(C, v.source, w);
    }
    _runCursorMove(C, v, w) {
      C.model.pushStackElement(), C.setCursorStates(v, 3, o._move(C, C.getCursorStates(), w)), C.revealAllCursors(v, !0);
    }
    static _move(C, v, w) {
      const S = w.select, L = w.value;
      switch (w.direction) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
          return Vi.simpleMove(C, v, w.direction, S, L, w.unit);
        case 11:
        case 13:
        case 12:
        case 14:
          return Vi.viewportMove(C, v, w.direction, S, L);
        default:
          return null;
      }
    }
  }
  s.CursorMoveImpl = o, s.CursorMove = ye(new o());
  class r extends Rt {
    constructor(C) {
      super(C), this._staticArgs = C.args;
    }
    runCoreEditorCommand(C, v) {
      let w = this._staticArgs;
      this._staticArgs.value === -1 && (w = {
        direction: this._staticArgs.direction,
        unit: this._staticArgs.unit,
        select: this._staticArgs.select,
        value: v.pageSize || C.cursorConfig.pageSize
      }), C.model.pushStackElement(), C.setCursorStates(v.source, 3, Vi.simpleMove(C, C.getCursorStates(), w.direction, w.select, w.value, w.unit)), C.revealAllCursors(v.source, !0);
    }
  }
  s.CursorLeft = ye(new r({
    args: {
      direction: 0,
      unit: 0,
      select: !1,
      value: 1
    },
    id: "cursorLeft",
    precondition: void 0,
    kbOpts: {
      weight: ze,
      kbExpr: se.textInputFocus,
      primary: 15,
      mac: { primary: 15, secondary: [
        288
        /* KeyCode.KeyB */
      ] }
    }
  })), s.CursorLeftSelect = ye(new r({
    args: {
      direction: 0,
      unit: 0,
      select: !0,
      value: 1
    },
    id: "cursorLeftSelect",
    precondition: void 0,
    kbOpts: {
      weight: ze,
      kbExpr: se.textInputFocus,
      primary: 1039
      /* KeyCode.LeftArrow */
    }
  })), s.CursorRight = ye(new r({
    args: {
      direction: 1,
      unit: 0,
      select: !1,
      value: 1
    },
    id: "cursorRight",
    precondition: void 0,
    kbOpts: {
      weight: ze,
      kbExpr: se.textInputFocus,
      primary: 17,
      mac: { primary: 17, secondary: [
        292
        /* KeyCode.KeyF */
      ] }
    }
  })), s.CursorRightSelect = ye(new r({
    args: {
      direction: 1,
      unit: 0,
      select: !0,
      value: 1
    },
    id: "cursorRightSelect",
    precondition: void 0,
    kbOpts: {
      weight: ze,
      kbExpr: se.textInputFocus,
      primary: 1041
      /* KeyCode.RightArrow */
    }
  })), s.CursorUp = ye(new r({
    args: {
      direction: 2,
      unit: 2,
      select: !1,
      value: 1
    },
    id: "cursorUp",
    precondition: void 0,
    kbOpts: {
      weight: ze,
      kbExpr: se.textInputFocus,
      primary: 16,
      mac: { primary: 16, secondary: [
        302
        /* KeyCode.KeyP */
      ] }
    }
  })), s.CursorUpSelect = ye(new r({
    args: {
      direction: 2,
      unit: 2,
      select: !0,
      value: 1
    },
    id: "cursorUpSelect",
    precondition: void 0,
    kbOpts: {
      weight: ze,
      kbExpr: se.textInputFocus,
      primary: 1040,
      secondary: [
        3088
        /* KeyCode.UpArrow */
      ],
      mac: {
        primary: 1040
        /* KeyCode.UpArrow */
      },
      linux: {
        primary: 1040
        /* KeyCode.UpArrow */
      }
    }
  })), s.CursorPageUp = ye(new r({
    args: {
      direction: 2,
      unit: 2,
      select: !1,
      value: -1
      /* Constants.PAGE_SIZE_MARKER */
    },
    id: "cursorPageUp",
    precondition: void 0,
    kbOpts: {
      weight: ze,
      kbExpr: se.textInputFocus,
      primary: 11
      /* KeyCode.PageUp */
    }
  })), s.CursorPageUpSelect = ye(new r({
    args: {
      direction: 2,
      unit: 2,
      select: !0,
      value: -1
      /* Constants.PAGE_SIZE_MARKER */
    },
    id: "cursorPageUpSelect",
    precondition: void 0,
    kbOpts: {
      weight: ze,
      kbExpr: se.textInputFocus,
      primary: 1035
      /* KeyCode.PageUp */
    }
  })), s.CursorDown = ye(new r({
    args: {
      direction: 3,
      unit: 2,
      select: !1,
      value: 1
    },
    id: "cursorDown",
    precondition: void 0,
    kbOpts: {
      weight: ze,
      kbExpr: se.textInputFocus,
      primary: 18,
      mac: { primary: 18, secondary: [
        300
        /* KeyCode.KeyN */
      ] }
    }
  })), s.CursorDownSelect = ye(new r({
    args: {
      direction: 3,
      unit: 2,
      select: !0,
      value: 1
    },
    id: "cursorDownSelect",
    precondition: void 0,
    kbOpts: {
      weight: ze,
      kbExpr: se.textInputFocus,
      primary: 1042,
      secondary: [
        3090
        /* KeyCode.DownArrow */
      ],
      mac: {
        primary: 1042
        /* KeyCode.DownArrow */
      },
      linux: {
        primary: 1042
        /* KeyCode.DownArrow */
      }
    }
  })), s.CursorPageDown = ye(new r({
    args: {
      direction: 3,
      unit: 2,
      select: !1,
      value: -1
      /* Constants.PAGE_SIZE_MARKER */
    },
    id: "cursorPageDown",
    precondition: void 0,
    kbOpts: {
      weight: ze,
      kbExpr: se.textInputFocus,
      primary: 12
      /* KeyCode.PageDown */
    }
  })), s.CursorPageDownSelect = ye(new r({
    args: {
      direction: 3,
      unit: 2,
      select: !0,
      value: -1
      /* Constants.PAGE_SIZE_MARKER */
    },
    id: "cursorPageDownSelect",
    precondition: void 0,
    kbOpts: {
      weight: ze,
      kbExpr: se.textInputFocus,
      primary: 1036
      /* KeyCode.PageDown */
    }
  })), s.CreateCursor = ye(new class extends Rt {
    constructor() {
      super({
        id: "createCursor",
        precondition: void 0
      });
    }
    runCoreEditorCommand(b, C) {
      if (!C.position)
        return;
      let v;
      C.wholeLine ? v = Vi.line(b, b.getPrimaryCursorState(), !1, C.position, C.viewPosition) : v = Vi.moveTo(b, b.getPrimaryCursorState(), !1, C.position, C.viewPosition);
      const w = b.getCursorStates();
      if (w.length > 1) {
        const S = v.modelState ? v.modelState.position : null, L = v.viewState ? v.viewState.position : null;
        for (let k = 0, D = w.length; k < D; k++) {
          const E = w[k];
          if (!(S && !E.modelState.selection.containsPosition(S)) && !(L && !E.viewState.selection.containsPosition(L))) {
            w.splice(k, 1), b.model.pushStackElement(), b.setCursorStates(C.source, 3, w);
            return;
          }
        }
      }
      w.push(v), b.model.pushStackElement(), b.setCursorStates(C.source, 3, w);
    }
  }()), s.LastCursorMoveToSelect = ye(new class extends Rt {
    constructor() {
      super({
        id: "_lastCursorMoveToSelect",
        precondition: void 0
      });
    }
    runCoreEditorCommand(b, C) {
      if (!C.position)
        return;
      const v = b.getLastAddedCursorIndex(), w = b.getCursorStates(), S = w.slice(0);
      S[v] = Vi.moveTo(b, w[v], !0, C.position, C.viewPosition), b.model.pushStackElement(), b.setCursorStates(C.source, 3, S);
    }
  }());
  class a extends Rt {
    constructor(C) {
      super(C), this._inSelectionMode = C.inSelectionMode;
    }
    runCoreEditorCommand(C, v) {
      C.model.pushStackElement(), C.setCursorStates(v.source, 3, Vi.moveToBeginningOfLine(C, C.getCursorStates(), this._inSelectionMode)), C.revealAllCursors(v.source, !0);
    }
  }
  s.CursorHome = ye(new a({
    inSelectionMode: !1,
    id: "cursorHome",
    precondition: void 0,
    kbOpts: {
      weight: ze,
      kbExpr: se.textInputFocus,
      primary: 14,
      mac: { primary: 14, secondary: [
        2063
        /* KeyCode.LeftArrow */
      ] }
    }
  })), s.CursorHomeSelect = ye(new a({
    inSelectionMode: !0,
    id: "cursorHomeSelect",
    precondition: void 0,
    kbOpts: {
      weight: ze,
      kbExpr: se.textInputFocus,
      primary: 1038,
      mac: { primary: 1038, secondary: [
        3087
        /* KeyCode.LeftArrow */
      ] }
    }
  }));
  class l extends Rt {
    constructor(C) {
      super(C), this._inSelectionMode = C.inSelectionMode;
    }
    runCoreEditorCommand(C, v) {
      C.model.pushStackElement(), C.setCursorStates(v.source, 3, this._exec(C.getCursorStates())), C.revealAllCursors(v.source, !0);
    }
    _exec(C) {
      const v = [];
      for (let w = 0, S = C.length; w < S; w++) {
        const L = C[w], k = L.modelState.position.lineNumber;
        v[w] = Pe.fromModelState(L.modelState.move(this._inSelectionMode, k, 1, 0));
      }
      return v;
    }
  }
  s.CursorLineStart = ye(new l({
    inSelectionMode: !1,
    id: "cursorLineStart",
    precondition: void 0,
    kbOpts: {
      weight: ze,
      kbExpr: se.textInputFocus,
      primary: 0,
      mac: {
        primary: 287
        /* KeyCode.KeyA */
      }
    }
  })), s.CursorLineStartSelect = ye(new l({
    inSelectionMode: !0,
    id: "cursorLineStartSelect",
    precondition: void 0,
    kbOpts: {
      weight: ze,
      kbExpr: se.textInputFocus,
      primary: 0,
      mac: {
        primary: 1311
        /* KeyCode.KeyA */
      }
    }
  }));
  class c extends Rt {
    constructor(C) {
      super(C), this._inSelectionMode = C.inSelectionMode;
    }
    runCoreEditorCommand(C, v) {
      C.model.pushStackElement(), C.setCursorStates(v.source, 3, Vi.moveToEndOfLine(C, C.getCursorStates(), this._inSelectionMode, v.sticky || !1)), C.revealAllCursors(v.source, !0);
    }
  }
  s.CursorEnd = ye(new c({
    inSelectionMode: !1,
    id: "cursorEnd",
    precondition: void 0,
    kbOpts: {
      args: { sticky: !1 },
      weight: ze,
      kbExpr: se.textInputFocus,
      primary: 13,
      mac: { primary: 13, secondary: [
        2065
        /* KeyCode.RightArrow */
      ] }
    },
    metadata: {
      description: "Go to End",
      args: [{
        name: "args",
        schema: {
          type: "object",
          properties: {
            sticky: {
              description: p("stickydesc", "Stick to the end even when going to longer lines"),
              type: "boolean",
              default: !1
            }
          }
        }
      }]
    }
  })), s.CursorEndSelect = ye(new c({
    inSelectionMode: !0,
    id: "cursorEndSelect",
    precondition: void 0,
    kbOpts: {
      args: { sticky: !1 },
      weight: ze,
      kbExpr: se.textInputFocus,
      primary: 1037,
      mac: { primary: 1037, secondary: [
        3089
        /* KeyCode.RightArrow */
      ] }
    },
    metadata: {
      description: "Select to End",
      args: [{
        name: "args",
        schema: {
          type: "object",
          properties: {
            sticky: {
              description: p("stickydesc", "Stick to the end even when going to longer lines"),
              type: "boolean",
              default: !1
            }
          }
        }
      }]
    }
  }));
  class h extends Rt {
    constructor(C) {
      super(C), this._inSelectionMode = C.inSelectionMode;
    }
    runCoreEditorCommand(C, v) {
      C.model.pushStackElement(), C.setCursorStates(v.source, 3, this._exec(C, C.getCursorStates())), C.revealAllCursors(v.source, !0);
    }
    _exec(C, v) {
      const w = [];
      for (let S = 0, L = v.length; S < L; S++) {
        const k = v[S], D = k.modelState.position.lineNumber, E = C.model.getLineMaxColumn(D);
        w[S] = Pe.fromModelState(k.modelState.move(this._inSelectionMode, D, E, 0));
      }
      return w;
    }
  }
  s.CursorLineEnd = ye(new h({
    inSelectionMode: !1,
    id: "cursorLineEnd",
    precondition: void 0,
    kbOpts: {
      weight: ze,
      kbExpr: se.textInputFocus,
      primary: 0,
      mac: {
        primary: 291
        /* KeyCode.KeyE */
      }
    }
  })), s.CursorLineEndSelect = ye(new h({
    inSelectionMode: !0,
    id: "cursorLineEndSelect",
    precondition: void 0,
    kbOpts: {
      weight: ze,
      kbExpr: se.textInputFocus,
      primary: 0,
      mac: {
        primary: 1315
        /* KeyCode.KeyE */
      }
    }
  }));
  class d extends Rt {
    constructor(C) {
      super(C), this._inSelectionMode = C.inSelectionMode;
    }
    runCoreEditorCommand(C, v) {
      C.model.pushStackElement(), C.setCursorStates(v.source, 3, Vi.moveToBeginningOfBuffer(C, C.getCursorStates(), this._inSelectionMode)), C.revealAllCursors(v.source, !0);
    }
  }
  s.CursorTop = ye(new d({
    inSelectionMode: !1,
    id: "cursorTop",
    precondition: void 0,
    kbOpts: {
      weight: ze,
      kbExpr: se.textInputFocus,
      primary: 2062,
      mac: {
        primary: 2064
        /* KeyCode.UpArrow */
      }
    }
  })), s.CursorTopSelect = ye(new d({
    inSelectionMode: !0,
    id: "cursorTopSelect",
    precondition: void 0,
    kbOpts: {
      weight: ze,
      kbExpr: se.textInputFocus,
      primary: 3086,
      mac: {
        primary: 3088
        /* KeyCode.UpArrow */
      }
    }
  }));
  class u extends Rt {
    constructor(C) {
      super(C), this._inSelectionMode = C.inSelectionMode;
    }
    runCoreEditorCommand(C, v) {
      C.model.pushStackElement(), C.setCursorStates(v.source, 3, Vi.moveToEndOfBuffer(C, C.getCursorStates(), this._inSelectionMode)), C.revealAllCursors(v.source, !0);
    }
  }
  s.CursorBottom = ye(new u({
    inSelectionMode: !1,
    id: "cursorBottom",
    precondition: void 0,
    kbOpts: {
      weight: ze,
      kbExpr: se.textInputFocus,
      primary: 2061,
      mac: {
        primary: 2066
        /* KeyCode.DownArrow */
      }
    }
  })), s.CursorBottomSelect = ye(new u({
    inSelectionMode: !0,
    id: "cursorBottomSelect",
    precondition: void 0,
    kbOpts: {
      weight: ze,
      kbExpr: se.textInputFocus,
      primary: 3085,
      mac: {
        primary: 3090
        /* KeyCode.DownArrow */
      }
    }
  }));
  class f extends Rt {
    constructor() {
      super({
        id: "editorScroll",
        precondition: void 0,
        metadata: Ei.metadata
      });
    }
    determineScrollMethod(C) {
      const v = [
        6
        /* EditorScroll_.Unit.Column */
      ], w = [
        1,
        2,
        3,
        4,
        5,
        6
        /* EditorScroll_.Unit.Column */
      ], S = [
        4,
        2
        /* EditorScroll_.Direction.Right */
      ], L = [
        1,
        3
        /* EditorScroll_.Direction.Down */
      ];
      return v.includes(C.unit) && S.includes(C.direction) ? this._runHorizontalEditorScroll.bind(this) : w.includes(C.unit) && L.includes(C.direction) ? this._runVerticalEditorScroll.bind(this) : null;
    }
    runCoreEditorCommand(C, v) {
      const w = Ei.parse(v);
      if (!w)
        return;
      const S = this.determineScrollMethod(w);
      S && S(C, v.source, w);
    }
    _runVerticalEditorScroll(C, v, w) {
      const S = this._computeDesiredScrollTop(C, w);
      if (w.revealCursor) {
        const L = C.getCompletelyVisibleViewRangeAtScrollTop(S);
        C.setCursorStates(v, 3, [
          Vi.findPositionInViewportIfOutside(C, C.getPrimaryCursorState(), L, w.select)
        ]);
      }
      C.viewLayout.setScrollPosition(
        { scrollTop: S },
        0
        /* ScrollType.Smooth */
      );
    }
    _computeDesiredScrollTop(C, v) {
      if (v.unit === 1) {
        const L = C.viewLayout.getFutureViewport(), k = C.getCompletelyVisibleViewRangeAtScrollTop(L.top), D = C.coordinatesConverter.convertViewRangeToModelRange(k);
        let E;
        v.direction === 1 ? E = Math.max(1, D.startLineNumber - v.value) : E = Math.min(C.model.getLineCount(), D.startLineNumber + v.value);
        const U = C.coordinatesConverter.convertModelPositionToViewPosition(new V(E, 1));
        return C.viewLayout.getVerticalOffsetForLineNumber(U.lineNumber);
      }
      if (v.unit === 5) {
        let L = 0;
        return v.direction === 3 && (L = C.model.getLineCount() - C.cursorConfig.pageSize), C.viewLayout.getVerticalOffsetForLineNumber(L);
      }
      let w;
      v.unit === 3 ? w = C.cursorConfig.pageSize * v.value : v.unit === 4 ? w = Math.round(C.cursorConfig.pageSize / 2) * v.value : w = v.value;
      const S = (v.direction === 1 ? -1 : 1) * w;
      return C.viewLayout.getCurrentScrollTop() + S * C.cursorConfig.lineHeight;
    }
    _runHorizontalEditorScroll(C, v, w) {
      const S = this._computeDesiredScrollLeft(C, w);
      C.viewLayout.setScrollPosition(
        { scrollLeft: S },
        0
        /* ScrollType.Smooth */
      );
    }
    _computeDesiredScrollLeft(C, v) {
      const w = (v.direction === 4 ? -1 : 1) * v.value;
      return C.viewLayout.getCurrentScrollLeft() + w * C.cursorConfig.typicalHalfwidthCharacterWidth;
    }
  }
  s.EditorScrollImpl = f, s.EditorScroll = ye(new f()), s.ScrollLineUp = ye(new class extends Rt {
    constructor() {
      super({
        id: "scrollLineUp",
        precondition: void 0,
        kbOpts: {
          weight: ze,
          kbExpr: se.textInputFocus,
          primary: 2064,
          mac: {
            primary: 267
            /* KeyCode.PageUp */
          }
        }
      });
    }
    runCoreEditorCommand(b, C) {
      s.EditorScroll.runCoreEditorCommand(b, {
        to: Ei.RawDirection.Up,
        by: Ei.RawUnit.WrappedLine,
        value: 1,
        revealCursor: !1,
        select: !1,
        source: C.source
      });
    }
  }()), s.ScrollPageUp = ye(new class extends Rt {
    constructor() {
      super({
        id: "scrollPageUp",
        precondition: void 0,
        kbOpts: {
          weight: ze,
          kbExpr: se.textInputFocus,
          primary: 2059,
          win: {
            primary: 523
            /* KeyCode.PageUp */
          },
          linux: {
            primary: 523
            /* KeyCode.PageUp */
          }
        }
      });
    }
    runCoreEditorCommand(b, C) {
      s.EditorScroll.runCoreEditorCommand(b, {
        to: Ei.RawDirection.Up,
        by: Ei.RawUnit.Page,
        value: 1,
        revealCursor: !1,
        select: !1,
        source: C.source
      });
    }
  }()), s.ScrollEditorTop = ye(new class extends Rt {
    constructor() {
      super({
        id: "scrollEditorTop",
        precondition: void 0,
        kbOpts: {
          weight: ze,
          kbExpr: se.textInputFocus
        }
      });
    }
    runCoreEditorCommand(b, C) {
      s.EditorScroll.runCoreEditorCommand(b, {
        to: Ei.RawDirection.Up,
        by: Ei.RawUnit.Editor,
        value: 1,
        revealCursor: !1,
        select: !1,
        source: C.source
      });
    }
  }()), s.ScrollLineDown = ye(new class extends Rt {
    constructor() {
      super({
        id: "scrollLineDown",
        precondition: void 0,
        kbOpts: {
          weight: ze,
          kbExpr: se.textInputFocus,
          primary: 2066,
          mac: {
            primary: 268
            /* KeyCode.PageDown */
          }
        }
      });
    }
    runCoreEditorCommand(b, C) {
      s.EditorScroll.runCoreEditorCommand(b, {
        to: Ei.RawDirection.Down,
        by: Ei.RawUnit.WrappedLine,
        value: 1,
        revealCursor: !1,
        select: !1,
        source: C.source
      });
    }
  }()), s.ScrollPageDown = ye(new class extends Rt {
    constructor() {
      super({
        id: "scrollPageDown",
        precondition: void 0,
        kbOpts: {
          weight: ze,
          kbExpr: se.textInputFocus,
          primary: 2060,
          win: {
            primary: 524
            /* KeyCode.PageDown */
          },
          linux: {
            primary: 524
            /* KeyCode.PageDown */
          }
        }
      });
    }
    runCoreEditorCommand(b, C) {
      s.EditorScroll.runCoreEditorCommand(b, {
        to: Ei.RawDirection.Down,
        by: Ei.RawUnit.Page,
        value: 1,
        revealCursor: !1,
        select: !1,
        source: C.source
      });
    }
  }()), s.ScrollEditorBottom = ye(new class extends Rt {
    constructor() {
      super({
        id: "scrollEditorBottom",
        precondition: void 0,
        kbOpts: {
          weight: ze,
          kbExpr: se.textInputFocus
        }
      });
    }
    runCoreEditorCommand(b, C) {
      s.EditorScroll.runCoreEditorCommand(b, {
        to: Ei.RawDirection.Down,
        by: Ei.RawUnit.Editor,
        value: 1,
        revealCursor: !1,
        select: !1,
        source: C.source
      });
    }
  }()), s.ScrollLeft = ye(new class extends Rt {
    constructor() {
      super({
        id: "scrollLeft",
        precondition: void 0,
        kbOpts: {
          weight: ze,
          kbExpr: se.textInputFocus
        }
      });
    }
    runCoreEditorCommand(b, C) {
      s.EditorScroll.runCoreEditorCommand(b, {
        to: Ei.RawDirection.Left,
        by: Ei.RawUnit.Column,
        value: 2,
        revealCursor: !1,
        select: !1,
        source: C.source
      });
    }
  }()), s.ScrollRight = ye(new class extends Rt {
    constructor() {
      super({
        id: "scrollRight",
        precondition: void 0,
        kbOpts: {
          weight: ze,
          kbExpr: se.textInputFocus
        }
      });
    }
    runCoreEditorCommand(b, C) {
      s.EditorScroll.runCoreEditorCommand(b, {
        to: Ei.RawDirection.Right,
        by: Ei.RawUnit.Column,
        value: 2,
        revealCursor: !1,
        select: !1,
        source: C.source
      });
    }
  }());
  class g extends Rt {
    constructor(C) {
      super(C), this._inSelectionMode = C.inSelectionMode;
    }
    runCoreEditorCommand(C, v) {
      v.position && (C.model.pushStackElement(), C.setCursorStates(v.source, 3, [
        Vi.word(C, C.getPrimaryCursorState(), this._inSelectionMode, v.position)
      ]), v.revealType !== 2 && C.revealAllCursors(v.source, !0, !0));
    }
  }
  s.WordSelect = ye(new g({
    inSelectionMode: !1,
    id: "_wordSelect",
    precondition: void 0
  })), s.WordSelectDrag = ye(new g({
    inSelectionMode: !0,
    id: "_wordSelectDrag",
    precondition: void 0
  })), s.LastCursorWordSelect = ye(new class extends Rt {
    constructor() {
      super({
        id: "lastCursorWordSelect",
        precondition: void 0
      });
    }
    runCoreEditorCommand(b, C) {
      if (!C.position)
        return;
      const v = b.getLastAddedCursorIndex(), w = b.getCursorStates(), S = w.slice(0), L = w[v];
      S[v] = Vi.word(b, L, L.modelState.hasSelection(), C.position), b.model.pushStackElement(), b.setCursorStates(C.source, 3, S);
    }
  }());
  class m extends Rt {
    constructor(C) {
      super(C), this._inSelectionMode = C.inSelectionMode;
    }
    runCoreEditorCommand(C, v) {
      v.position && (C.model.pushStackElement(), C.setCursorStates(v.source, 3, [
        Vi.line(C, C.getPrimaryCursorState(), this._inSelectionMode, v.position, v.viewPosition)
      ]), v.revealType !== 2 && C.revealAllCursors(v.source, !1, !0));
    }
  }
  s.LineSelect = ye(new m({
    inSelectionMode: !1,
    id: "_lineSelect",
    precondition: void 0
  })), s.LineSelectDrag = ye(new m({
    inSelectionMode: !0,
    id: "_lineSelectDrag",
    precondition: void 0
  }));
  class _ extends Rt {
    constructor(C) {
      super(C), this._inSelectionMode = C.inSelectionMode;
    }
    runCoreEditorCommand(C, v) {
      if (!v.position)
        return;
      const w = C.getLastAddedCursorIndex(), S = C.getCursorStates(), L = S.slice(0);
      L[w] = Vi.line(C, S[w], this._inSelectionMode, v.position, v.viewPosition), C.model.pushStackElement(), C.setCursorStates(v.source, 3, L);
    }
  }
  s.LastCursorLineSelect = ye(new _({
    inSelectionMode: !1,
    id: "lastCursorLineSelect",
    precondition: void 0
  })), s.LastCursorLineSelectDrag = ye(new _({
    inSelectionMode: !0,
    id: "lastCursorLineSelectDrag",
    precondition: void 0
  })), s.CancelSelection = ye(new class extends Rt {
    constructor() {
      super({
        id: "cancelSelection",
        precondition: se.hasNonEmptySelection,
        kbOpts: {
          weight: ze,
          kbExpr: se.textInputFocus,
          primary: 9,
          secondary: [
            1033
            /* KeyCode.Escape */
          ]
        }
      });
    }
    runCoreEditorCommand(b, C) {
      b.model.pushStackElement(), b.setCursorStates(C.source, 3, [
        Vi.cancelSelection(b, b.getPrimaryCursorState())
      ]), b.revealAllCursors(C.source, !0);
    }
  }()), s.RemoveSecondaryCursors = ye(new class extends Rt {
    constructor() {
      super({
        id: "removeSecondaryCursors",
        precondition: se.hasMultipleSelections,
        kbOpts: {
          weight: ze + 1,
          kbExpr: se.textInputFocus,
          primary: 9,
          secondary: [
            1033
            /* KeyCode.Escape */
          ]
        }
      });
    }
    runCoreEditorCommand(b, C) {
      b.model.pushStackElement(), b.setCursorStates(C.source, 3, [
        b.getPrimaryCursorState()
      ]), b.revealAllCursors(C.source, !0), Xp(p("removedCursor", "Removed secondary cursors"));
    }
  }()), s.RevealLine = ye(new class extends Rt {
    constructor() {
      super({
        id: "revealLine",
        precondition: void 0,
        metadata: xh.metadata
      });
    }
    runCoreEditorCommand(b, C) {
      const v = C, w = v.lineNumber || 0;
      let S = typeof w == "number" ? w + 1 : parseInt(w) + 1;
      S < 1 && (S = 1);
      const L = b.model.getLineCount();
      S > L && (S = L);
      const k = new R(S, 1, S, b.model.getLineMaxColumn(S));
      let D = 0;
      if (v.at)
        switch (v.at) {
          case xh.RawAtArgument.Top:
            D = 3;
            break;
          case xh.RawAtArgument.Center:
            D = 1;
            break;
          case xh.RawAtArgument.Bottom:
            D = 4;
            break;
        }
      const E = b.coordinatesConverter.convertModelRangeToViewRange(k);
      b.revealRange(
        C.source,
        !1,
        E,
        D,
        0
        /* ScrollType.Smooth */
      );
    }
  }()), s.SelectAll = new class extends ES {
    constructor() {
      super(Y7);
    }
    runDOMCommand(b) {
      As && (b.focus(), b.select()), b.ownerDocument.execCommand("selectAll");
    }
    runEditorCommand(b, C, v) {
      const w = C._getViewModel();
      w && this.runCoreEditorCommand(w, v);
    }
    runCoreEditorCommand(b, C) {
      b.model.pushStackElement(), b.setCursorStates("keyboard", 3, [
        Vi.selectAll(b, b.getPrimaryCursorState())
      ]);
    }
  }(), s.SetSelection = ye(new class extends Rt {
    constructor() {
      super({
        id: "setSelection",
        precondition: void 0
      });
    }
    runCoreEditorCommand(b, C) {
      C.selection && (b.model.pushStackElement(), b.setCursorStates(C.source, 3, [
        Pe.fromModelSelection(C.selection)
      ]));
    }
  }());
})(ai || (ai = {}));
const SZ = et.and(se.textInputFocus, se.columnSelection);
function Zd(s, e) {
  Dg.registerKeybindingRule({
    id: s,
    primary: e,
    when: SZ,
    weight: ze + 1
  });
}
Zd(
  ai.CursorColumnSelectLeft.id,
  1039
  /* KeyCode.LeftArrow */
);
Zd(
  ai.CursorColumnSelectRight.id,
  1041
  /* KeyCode.RightArrow */
);
Zd(
  ai.CursorColumnSelectUp.id,
  1040
  /* KeyCode.UpArrow */
);
Zd(
  ai.CursorColumnSelectPageUp.id,
  1035
  /* KeyCode.PageUp */
);
Zd(
  ai.CursorColumnSelectDown.id,
  1042
  /* KeyCode.DownArrow */
);
Zd(
  ai.CursorColumnSelectPageDown.id,
  1036
  /* KeyCode.PageDown */
);
function fT(s) {
  return s.register(), s;
}
var gT;
(function(s) {
  class e extends Cc {
    runEditorCommand(i, n, o) {
      const r = n._getViewModel();
      r && this.runCoreEditingCommand(n, r, o || {});
    }
  }
  s.CoreEditingCommand = e, s.LineBreakInsert = ye(new class extends e {
    constructor() {
      super({
        id: "lineBreakInsert",
        precondition: se.writable,
        kbOpts: {
          weight: ze,
          kbExpr: se.textInputFocus,
          primary: 0,
          mac: {
            primary: 301
            /* KeyCode.KeyO */
          }
        }
      });
    }
    runCoreEditingCommand(t, i, n) {
      t.pushUndoStop(), t.executeCommands(this.id, t5.lineBreakInsert(i.cursorConfig, i.model, i.getCursorStates().map((o) => o.modelState.selection)));
    }
  }()), s.Outdent = ye(new class extends e {
    constructor() {
      super({
        id: "outdent",
        precondition: se.writable,
        kbOpts: {
          weight: ze,
          kbExpr: et.and(se.editorTextFocus, se.tabDoesNotMoveFocus),
          primary: 1026
          /* KeyCode.Tab */
        }
      });
    }
    runCoreEditingCommand(t, i, n) {
      t.pushUndoStop(), t.executeCommands(this.id, Pl.outdent(i.cursorConfig, i.model, i.getCursorStates().map((o) => o.modelState.selection))), t.pushUndoStop();
    }
  }()), s.Tab = ye(new class extends e {
    constructor() {
      super({
        id: "tab",
        precondition: se.writable,
        kbOpts: {
          weight: ze,
          kbExpr: et.and(se.editorTextFocus, se.tabDoesNotMoveFocus),
          primary: 2
          /* KeyCode.Tab */
        }
      });
    }
    runCoreEditingCommand(t, i, n) {
      t.pushUndoStop(), t.executeCommands(this.id, Pl.tab(i.cursorConfig, i.model, i.getCursorStates().map((o) => o.modelState.selection))), t.pushUndoStop();
    }
  }()), s.DeleteLeft = ye(new class extends e {
    constructor() {
      super({
        id: "deleteLeft",
        precondition: void 0,
        kbOpts: {
          weight: ze,
          kbExpr: se.textInputFocus,
          primary: 1,
          secondary: [
            1025
            /* KeyCode.Backspace */
          ],
          mac: { primary: 1, secondary: [
            1025,
            294,
            257
            /* KeyCode.Backspace */
          ] }
        }
      });
    }
    runCoreEditingCommand(t, i, n) {
      const [o, r] = Lc.deleteLeft(i.getPrevEditOperationType(), i.cursorConfig, i.model, i.getCursorStates().map((a) => a.modelState.selection), i.getCursorAutoClosedCharacters());
      o && t.pushUndoStop(), t.executeCommands(this.id, r), i.setPrevEditOperationType(
        2
        /* EditOperationType.DeletingLeft */
      );
    }
  }()), s.DeleteRight = ye(new class extends e {
    constructor() {
      super({
        id: "deleteRight",
        precondition: void 0,
        kbOpts: {
          weight: ze,
          kbExpr: se.textInputFocus,
          primary: 20,
          mac: { primary: 20, secondary: [
            290,
            276
            /* KeyCode.Delete */
          ] }
        }
      });
    }
    runCoreEditingCommand(t, i, n) {
      const [o, r] = Lc.deleteRight(i.getPrevEditOperationType(), i.cursorConfig, i.model, i.getCursorStates().map((a) => a.modelState.selection));
      o && t.pushUndoStop(), t.executeCommands(this.id, r), i.setPrevEditOperationType(
        3
        /* EditOperationType.DeletingRight */
      );
    }
  }()), s.Undo = new class extends ES {
    constructor() {
      super(PM);
    }
    runDOMCommand(t) {
      t.ownerDocument.execCommand("undo");
    }
    runEditorCommand(t, i, n) {
      if (!(!i.hasModel() || i.getOption(
        92
        /* EditorOption.readOnly */
      ) === !0))
        return i.getModel().undo();
    }
  }(), s.Redo = new class extends ES {
    constructor() {
      super(OM);
    }
    runDOMCommand(t) {
      t.ownerDocument.execCommand("redo");
    }
    runEditorCommand(t, i, n) {
      if (!(!i.hasModel() || i.getOption(
        92
        /* EditorOption.readOnly */
      ) === !0))
        return i.getModel().redo();
    }
  }();
})(gT || (gT = {}));
class mT extends _b {
  constructor(e, t, i) {
    super({
      id: e,
      precondition: void 0,
      metadata: i
    }), this._handlerId = t;
  }
  runCommand(e, t) {
    const i = e.get(ri).getFocusedCodeEditor();
    i && i.trigger("keyboard", this._handlerId, t);
  }
}
function zc(s, e) {
  fT(new mT("default:" + s, s)), fT(new mT(s, s, e));
}
zc("type", {
  description: "Type",
  args: [{
    name: "args",
    schema: {
      type: "object",
      required: ["text"],
      properties: {
        text: {
          type: "string"
        }
      }
    }
  }]
});
zc(
  "replacePreviousChar"
  /* Handler.ReplacePreviousChar */
);
zc(
  "compositionType"
  /* Handler.CompositionType */
);
zc(
  "compositionStart"
  /* Handler.CompositionStart */
);
zc(
  "compositionEnd"
  /* Handler.CompositionEnd */
);
zc(
  "paste"
  /* Handler.Paste */
);
zc(
  "cut"
  /* Handler.Cut */
);
class LZ {
  constructor(e, t, i, n) {
    this.configuration = e, this.viewModel = t, this.userInputEvents = i, this.commandDelegate = n;
  }
  paste(e, t, i, n) {
    this.commandDelegate.paste(e, t, i, n);
  }
  type(e) {
    this.commandDelegate.type(e);
  }
  compositionType(e, t, i, n) {
    this.commandDelegate.compositionType(e, t, i, n);
  }
  compositionStart() {
    this.commandDelegate.startComposition();
  }
  compositionEnd() {
    this.commandDelegate.endComposition();
  }
  cut() {
    this.commandDelegate.cut();
  }
  setSelection(e) {
    ai.SetSelection.runCoreEditorCommand(this.viewModel, {
      source: "keyboard",
      selection: e
    });
  }
  _validateViewColumn(e) {
    const t = this.viewModel.getLineMinColumn(e.lineNumber);
    return e.column < t ? new V(e.lineNumber, t) : e;
  }
  _hasMulticursorModifier(e) {
    switch (this.configuration.options.get(
      78
      /* EditorOption.multiCursorModifier */
    )) {
      case "altKey":
        return e.altKey;
      case "ctrlKey":
        return e.ctrlKey;
      case "metaKey":
        return e.metaKey;
      default:
        return !1;
    }
  }
  _hasNonMulticursorModifier(e) {
    switch (this.configuration.options.get(
      78
      /* EditorOption.multiCursorModifier */
    )) {
      case "altKey":
        return e.ctrlKey || e.metaKey;
      case "ctrlKey":
        return e.altKey || e.metaKey;
      case "metaKey":
        return e.ctrlKey || e.altKey;
      default:
        return !1;
    }
  }
  dispatchMouse(e) {
    const t = this.configuration.options, i = wn && t.get(
      108
      /* EditorOption.selectionClipboard */
    ), n = t.get(
      22
      /* EditorOption.columnSelection */
    );
    e.middleButton && !i ? this._columnSelect(e.position, e.mouseColumn, e.inSelectionMode) : e.startedOnLineNumbers ? this._hasMulticursorModifier(e) ? e.inSelectionMode ? this._lastCursorLineSelect(e.position, e.revealType) : this._createCursor(e.position, !0) : e.inSelectionMode ? this._lineSelectDrag(e.position, e.revealType) : this._lineSelect(e.position, e.revealType) : e.mouseDownCount >= 4 ? this._selectAll() : e.mouseDownCount === 3 ? this._hasMulticursorModifier(e) ? e.inSelectionMode ? this._lastCursorLineSelectDrag(e.position, e.revealType) : this._lastCursorLineSelect(e.position, e.revealType) : e.inSelectionMode ? this._lineSelectDrag(e.position, e.revealType) : this._lineSelect(e.position, e.revealType) : e.mouseDownCount === 2 ? e.onInjectedText || (this._hasMulticursorModifier(e) ? this._lastCursorWordSelect(e.position, e.revealType) : e.inSelectionMode ? this._wordSelectDrag(e.position, e.revealType) : this._wordSelect(e.position, e.revealType)) : this._hasMulticursorModifier(e) ? this._hasNonMulticursorModifier(e) || (e.shiftKey ? this._columnSelect(e.position, e.mouseColumn, !0) : e.inSelectionMode ? this._lastCursorMoveToSelect(e.position, e.revealType) : this._createCursor(e.position, !1)) : e.inSelectionMode ? e.altKey ? this._columnSelect(e.position, e.mouseColumn, !0) : n ? this._columnSelect(e.position, e.mouseColumn, !0) : this._moveToSelect(e.position, e.revealType) : this.moveTo(e.position, e.revealType);
  }
  _usualArgs(e, t) {
    return e = this._validateViewColumn(e), {
      source: "mouse",
      position: this._convertViewToModelPosition(e),
      viewPosition: e,
      revealType: t
    };
  }
  moveTo(e, t) {
    ai.MoveTo.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _moveToSelect(e, t) {
    ai.MoveToSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _columnSelect(e, t, i) {
    e = this._validateViewColumn(e), ai.ColumnSelect.runCoreEditorCommand(this.viewModel, {
      source: "mouse",
      position: this._convertViewToModelPosition(e),
      viewPosition: e,
      mouseColumn: t,
      doColumnSelect: i
    });
  }
  _createCursor(e, t) {
    e = this._validateViewColumn(e), ai.CreateCursor.runCoreEditorCommand(this.viewModel, {
      source: "mouse",
      position: this._convertViewToModelPosition(e),
      viewPosition: e,
      wholeLine: t
    });
  }
  _lastCursorMoveToSelect(e, t) {
    ai.LastCursorMoveToSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _wordSelect(e, t) {
    ai.WordSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _wordSelectDrag(e, t) {
    ai.WordSelectDrag.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _lastCursorWordSelect(e, t) {
    ai.LastCursorWordSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _lineSelect(e, t) {
    ai.LineSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _lineSelectDrag(e, t) {
    ai.LineSelectDrag.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _lastCursorLineSelect(e, t) {
    ai.LastCursorLineSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _lastCursorLineSelectDrag(e, t) {
    ai.LastCursorLineSelectDrag.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _selectAll() {
    ai.SelectAll.runCoreEditorCommand(this.viewModel, { source: "mouse" });
  }
  // ----------------------
  _convertViewToModelPosition(e) {
    return this.viewModel.coordinatesConverter.convertViewPositionToModelPosition(e);
  }
  emitKeyDown(e) {
    this.userInputEvents.emitKeyDown(e);
  }
  emitKeyUp(e) {
    this.userInputEvents.emitKeyUp(e);
  }
  emitContextMenu(e) {
    this.userInputEvents.emitContextMenu(e);
  }
  emitMouseMove(e) {
    this.userInputEvents.emitMouseMove(e);
  }
  emitMouseLeave(e) {
    this.userInputEvents.emitMouseLeave(e);
  }
  emitMouseUp(e) {
    this.userInputEvents.emitMouseUp(e);
  }
  emitMouseDown(e) {
    this.userInputEvents.emitMouseDown(e);
  }
  emitMouseDrag(e) {
    this.userInputEvents.emitMouseDrag(e);
  }
  emitMouseDrop(e) {
    this.userInputEvents.emitMouseDrop(e);
  }
  emitMouseDropCanceled() {
    this.userInputEvents.emitMouseDropCanceled();
  }
  emitMouseWheel(e) {
    this.userInputEvents.emitMouseWheel(e);
  }
}
class s5 {
  constructor(e) {
    this._lineFactory = e, this._set(1, []);
  }
  flush() {
    this._set(1, []);
  }
  _set(e, t) {
    this._lines = t, this._rendLineNumberStart = e;
  }
  _get() {
    return {
      rendLineNumberStart: this._rendLineNumberStart,
      lines: this._lines
    };
  }
  /**
   * @returns Inclusive line number that is inside this collection
   */
  getStartLineNumber() {
    return this._rendLineNumberStart;
  }
  /**
   * @returns Inclusive line number that is inside this collection
   */
  getEndLineNumber() {
    return this._rendLineNumberStart + this._lines.length - 1;
  }
  getCount() {
    return this._lines.length;
  }
  getLine(e) {
    const t = e - this._rendLineNumberStart;
    if (t < 0 || t >= this._lines.length)
      throw new it("Illegal value for lineNumber");
    return this._lines[t];
  }
  /**
   * @returns Lines that were removed from this collection
   */
  onLinesDeleted(e, t) {
    if (this.getCount() === 0)
      return null;
    const i = this.getStartLineNumber(), n = this.getEndLineNumber();
    if (t < i) {
      const l = t - e + 1;
      return this._rendLineNumberStart -= l, null;
    }
    if (e > n)
      return null;
    let o = 0, r = 0;
    for (let l = i; l <= n; l++) {
      const c = l - this._rendLineNumberStart;
      e <= l && l <= t && (r === 0 ? (o = c, r = 1) : r++);
    }
    if (e < i) {
      let l = 0;
      t < i ? l = t - e + 1 : l = i - e, this._rendLineNumberStart -= l;
    }
    return this._lines.splice(o, r);
  }
  onLinesChanged(e, t) {
    const i = e + t - 1;
    if (this.getCount() === 0)
      return !1;
    const n = this.getStartLineNumber(), o = this.getEndLineNumber();
    let r = !1;
    for (let a = e; a <= i; a++)
      a >= n && a <= o && (this._lines[a - this._rendLineNumberStart].onContentChanged(), r = !0);
    return r;
  }
  onLinesInserted(e, t) {
    if (this.getCount() === 0)
      return null;
    const i = t - e + 1, n = this.getStartLineNumber(), o = this.getEndLineNumber();
    if (e <= n)
      return this._rendLineNumberStart += i, null;
    if (e > o)
      return null;
    if (i + e > o)
      return this._lines.splice(e - this._rendLineNumberStart, o - e + 1);
    const r = [];
    for (let d = 0; d < i; d++)
      r[d] = this._lineFactory.createLine();
    const a = e - this._rendLineNumberStart, l = this._lines.slice(0, a), c = this._lines.slice(a, this._lines.length - i), h = this._lines.slice(this._lines.length - i, this._lines.length);
    return this._lines = l.concat(r).concat(c), h;
  }
  onTokensChanged(e) {
    if (this.getCount() === 0)
      return !1;
    const t = this.getStartLineNumber(), i = this.getEndLineNumber();
    let n = !1;
    for (let o = 0, r = e.length; o < r; o++) {
      const a = e[o];
      if (a.toLineNumber < t || a.fromLineNumber > i)
        continue;
      const l = Math.max(t, a.fromLineNumber), c = Math.min(i, a.toLineNumber);
      for (let h = l; h <= c; h++) {
        const d = h - this._rendLineNumberStart;
        this._lines[d].onTokensChanged(), n = !0;
      }
    }
    return n;
  }
}
class o5 {
  constructor(e) {
    this._lineFactory = e, this.domNode = this._createDomNode(), this._linesCollection = new s5(this._lineFactory);
  }
  _createDomNode() {
    const e = je(document.createElement("div"));
    return e.setClassName("view-layer"), e.setPosition("absolute"), e.domNode.setAttribute("role", "presentation"), e.domNode.setAttribute("aria-hidden", "true"), e;
  }
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    return !!e.hasChanged(
      146
      /* EditorOption.layoutInfo */
    );
  }
  onFlushed(e) {
    return this._linesCollection.flush(), !0;
  }
  onLinesChanged(e) {
    return this._linesCollection.onLinesChanged(e.fromLineNumber, e.count);
  }
  onLinesDeleted(e) {
    const t = this._linesCollection.onLinesDeleted(e.fromLineNumber, e.toLineNumber);
    if (t)
      for (let i = 0, n = t.length; i < n; i++) {
        const o = t[i].getDomNode();
        o == null || o.remove();
      }
    return !0;
  }
  onLinesInserted(e) {
    const t = this._linesCollection.onLinesInserted(e.fromLineNumber, e.toLineNumber);
    if (t)
      for (let i = 0, n = t.length; i < n; i++) {
        const o = t[i].getDomNode();
        o == null || o.remove();
      }
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onTokensChanged(e) {
    return this._linesCollection.onTokensChanged(e.ranges);
  }
  onZonesChanged(e) {
    return !0;
  }
  // ---- end view event handlers
  getStartLineNumber() {
    return this._linesCollection.getStartLineNumber();
  }
  getEndLineNumber() {
    return this._linesCollection.getEndLineNumber();
  }
  getVisibleLine(e) {
    return this._linesCollection.getLine(e);
  }
  renderLines(e) {
    const t = this._linesCollection._get(), i = new IS(this.domNode.domNode, this._lineFactory, e), n = {
      rendLineNumberStart: t.rendLineNumberStart,
      lines: t.lines,
      linesLength: t.lines.length
    }, o = i.render(n, e.startLineNumber, e.endLineNumber, e.relativeVerticalOffset);
    this._linesCollection._set(o.rendLineNumberStart, o.lines);
  }
}
const Cr = class Cr {
  constructor(e, t, i) {
    this._domNode = e, this._lineFactory = t, this._viewportData = i;
  }
  render(e, t, i, n) {
    const o = {
      rendLineNumberStart: e.rendLineNumberStart,
      lines: e.lines.slice(0),
      linesLength: e.linesLength
    };
    if (o.rendLineNumberStart + o.linesLength - 1 < t || i < o.rendLineNumberStart) {
      o.rendLineNumberStart = t, o.linesLength = i - t + 1, o.lines = [];
      for (let r = t; r <= i; r++)
        o.lines[r - t] = this._lineFactory.createLine();
      return this._finishRendering(o, !0, n), o;
    }
    if (this._renderUntouchedLines(o, Math.max(t - o.rendLineNumberStart, 0), Math.min(i - o.rendLineNumberStart, o.linesLength - 1), n, t), o.rendLineNumberStart > t) {
      const r = t, a = Math.min(i, o.rendLineNumberStart - 1);
      r <= a && (this._insertLinesBefore(o, r, a, n, t), o.linesLength += a - r + 1);
    } else if (o.rendLineNumberStart < t) {
      const r = Math.min(o.linesLength, t - o.rendLineNumberStart);
      r > 0 && (this._removeLinesBefore(o, r), o.linesLength -= r);
    }
    if (o.rendLineNumberStart = t, o.rendLineNumberStart + o.linesLength - 1 < i) {
      const r = o.rendLineNumberStart + o.linesLength, a = i;
      r <= a && (this._insertLinesAfter(o, r, a, n, t), o.linesLength += a - r + 1);
    } else if (o.rendLineNumberStart + o.linesLength - 1 > i) {
      const r = Math.max(0, i - o.rendLineNumberStart + 1), l = o.linesLength - 1 - r + 1;
      l > 0 && (this._removeLinesAfter(o, l), o.linesLength -= l);
    }
    return this._finishRendering(o, !1, n), o;
  }
  _renderUntouchedLines(e, t, i, n, o) {
    const r = e.rendLineNumberStart, a = e.lines;
    for (let l = t; l <= i; l++) {
      const c = r + l;
      a[l].layoutLine(c, n[c - o], this._viewportData.lineHeight);
    }
  }
  _insertLinesBefore(e, t, i, n, o) {
    const r = [];
    let a = 0;
    for (let l = t; l <= i; l++)
      r[a++] = this._lineFactory.createLine();
    e.lines = r.concat(e.lines);
  }
  _removeLinesBefore(e, t) {
    for (let i = 0; i < t; i++) {
      const n = e.lines[i].getDomNode();
      n == null || n.remove();
    }
    e.lines.splice(0, t);
  }
  _insertLinesAfter(e, t, i, n, o) {
    const r = [];
    let a = 0;
    for (let l = t; l <= i; l++)
      r[a++] = this._lineFactory.createLine();
    e.lines = e.lines.concat(r);
  }
  _removeLinesAfter(e, t) {
    const i = e.linesLength - t;
    for (let n = 0; n < t; n++) {
      const o = e.lines[i + n].getDomNode();
      o == null || o.remove();
    }
    e.lines.splice(i, t);
  }
  _finishRenderingNewLines(e, t, i, n) {
    Cr._ttPolicy && (i = Cr._ttPolicy.createHTML(i));
    const o = this._domNode.lastChild;
    t || !o ? this._domNode.innerHTML = i : o.insertAdjacentHTML("afterend", i);
    let r = this._domNode.lastChild;
    for (let a = e.linesLength - 1; a >= 0; a--) {
      const l = e.lines[a];
      n[a] && (l.setDomNode(r), r = r.previousSibling);
    }
  }
  _finishRenderingInvalidLines(e, t, i) {
    const n = document.createElement("div");
    Cr._ttPolicy && (t = Cr._ttPolicy.createHTML(t)), n.innerHTML = t;
    for (let o = 0; o < e.linesLength; o++) {
      const r = e.lines[o];
      if (i[o]) {
        const a = n.firstChild, l = r.getDomNode();
        l.parentNode.replaceChild(a, l), r.setDomNode(a);
      }
    }
  }
  _finishRendering(e, t, i) {
    const n = Cr._sb, o = e.linesLength, r = e.lines, a = e.rendLineNumberStart, l = [];
    {
      n.reset();
      let c = !1;
      for (let h = 0; h < o; h++) {
        const d = r[h];
        l[h] = !1, !(d.getDomNode() || !d.renderLine(h + a, i[h], this._viewportData.lineHeight, this._viewportData, n)) && (l[h] = !0, c = !0);
      }
      c && this._finishRenderingNewLines(e, t, n.build(), l);
    }
    {
      n.reset();
      let c = !1;
      const h = [];
      for (let d = 0; d < o; d++) {
        const u = r[d];
        h[d] = !1, !(l[d] || !u.renderLine(d + a, i[d], this._viewportData.lineHeight, this._viewportData, n)) && (h[d] = !0, c = !0);
      }
      c && this._finishRenderingInvalidLines(e, n.build(), h);
    }
  }
};
Cr._ttPolicy = Pc("editorViewLayer", { createHTML: (e) => e }), Cr._sb = new bb(1e5);
let IS = Cr;
class r5 extends Hn {
  constructor(e) {
    super(e), this._dynamicOverlays = [], this._isFocused = !1, this._visibleLines = new o5({
      createLine: () => new kZ(this._dynamicOverlays)
    }), this.domNode = this._visibleLines.domNode;
    const i = this._context.configuration.options.get(
      50
      /* EditorOption.fontInfo */
    );
    Fi(this.domNode, i), this.domNode.setClassName("view-overlays");
  }
  shouldRender() {
    if (super.shouldRender())
      return !0;
    for (let e = 0, t = this._dynamicOverlays.length; e < t; e++)
      if (this._dynamicOverlays[e].shouldRender())
        return !0;
    return !1;
  }
  dispose() {
    super.dispose();
    for (let e = 0, t = this._dynamicOverlays.length; e < t; e++)
      this._dynamicOverlays[e].dispose();
    this._dynamicOverlays = [];
  }
  getDomNode() {
    return this.domNode;
  }
  addDynamicOverlay(e) {
    this._dynamicOverlays.push(e);
  }
  // ----- event handlers
  onConfigurationChanged(e) {
    this._visibleLines.onConfigurationChanged(e);
    const i = this._context.configuration.options.get(
      50
      /* EditorOption.fontInfo */
    );
    return Fi(this.domNode, i), !0;
  }
  onFlushed(e) {
    return this._visibleLines.onFlushed(e);
  }
  onFocusChanged(e) {
    return this._isFocused = e.isFocused, !0;
  }
  onLinesChanged(e) {
    return this._visibleLines.onLinesChanged(e);
  }
  onLinesDeleted(e) {
    return this._visibleLines.onLinesDeleted(e);
  }
  onLinesInserted(e) {
    return this._visibleLines.onLinesInserted(e);
  }
  onScrollChanged(e) {
    return this._visibleLines.onScrollChanged(e) || !0;
  }
  onTokensChanged(e) {
    return this._visibleLines.onTokensChanged(e);
  }
  onZonesChanged(e) {
    return this._visibleLines.onZonesChanged(e);
  }
  // ----- end event handlers
  prepareRender(e) {
    const t = this._dynamicOverlays.filter((i) => i.shouldRender());
    for (let i = 0, n = t.length; i < n; i++) {
      const o = t[i];
      o.prepareRender(e), o.onDidRender();
    }
  }
  render(e) {
    this._viewOverlaysRender(e), this.domNode.toggleClassName("focused", this._isFocused);
  }
  _viewOverlaysRender(e) {
    this._visibleLines.renderLines(e.viewportData);
  }
}
class kZ {
  constructor(e) {
    this._dynamicOverlays = e, this._domNode = null, this._renderedContent = null;
  }
  getDomNode() {
    return this._domNode ? this._domNode.domNode : null;
  }
  setDomNode(e) {
    this._domNode = je(e);
  }
  onContentChanged() {
  }
  onTokensChanged() {
  }
  renderLine(e, t, i, n, o) {
    let r = "";
    for (let a = 0, l = this._dynamicOverlays.length; a < l; a++) {
      const c = this._dynamicOverlays[a];
      r += c.render(n.startLineNumber, e);
    }
    return this._renderedContent === r ? !1 : (this._renderedContent = r, o.appendString('<div style="top:'), o.appendString(String(t)), o.appendString("px;height:"), o.appendString(String(i)), o.appendString('px;">'), o.appendString(r), o.appendString("</div>"), !0);
  }
  layoutLine(e, t, i) {
    this._domNode && (this._domNode.setTop(t), this._domNode.setHeight(i));
  }
}
class xZ extends r5 {
  constructor(e) {
    super(e);
    const i = this._context.configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    );
    this._contentWidth = i.contentWidth, this.domNode.setHeight(0);
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const i = this._context.configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    );
    return this._contentWidth = i.contentWidth, super.onConfigurationChanged(e) || !0;
  }
  onScrollChanged(e) {
    return super.onScrollChanged(e) || e.scrollWidthChanged;
  }
  // --- end event handlers
  _viewOverlaysRender(e) {
    super._viewOverlaysRender(e), this.domNode.setWidth(Math.max(e.scrollWidth, this._contentWidth));
  }
}
class DZ extends r5 {
  constructor(e) {
    super(e);
    const t = this._context.configuration.options, i = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    this._contentLeft = i.contentLeft, this.domNode.setClassName("margin-view-overlays"), this.domNode.setWidth(1), Fi(this.domNode, t.get(
      50
      /* EditorOption.fontInfo */
    ));
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    Fi(this.domNode, t.get(
      50
      /* EditorOption.fontInfo */
    ));
    const i = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    return this._contentLeft = i.contentLeft, super.onConfigurationChanged(e) || !0;
  }
  onScrollChanged(e) {
    return super.onScrollChanged(e) || e.scrollHeightChanged;
  }
  _viewOverlaysRender(e) {
    super._viewOverlaysRender(e);
    const t = Math.min(e.scrollHeight, 1e6);
    this.domNode.setHeight(t), this.domNode.setWidth(this._contentLeft);
  }
}
class e0 {
  constructor(e) {
    this.onKeyDown = null, this.onKeyUp = null, this.onContextMenu = null, this.onMouseMove = null, this.onMouseLeave = null, this.onMouseDown = null, this.onMouseUp = null, this.onMouseDrag = null, this.onMouseDrop = null, this.onMouseDropCanceled = null, this.onMouseWheel = null, this._coordinatesConverter = e;
  }
  emitKeyDown(e) {
    var t;
    (t = this.onKeyDown) == null || t.call(this, e);
  }
  emitKeyUp(e) {
    var t;
    (t = this.onKeyUp) == null || t.call(this, e);
  }
  emitContextMenu(e) {
    var t;
    (t = this.onContextMenu) == null || t.call(this, this._convertViewToModelMouseEvent(e));
  }
  emitMouseMove(e) {
    var t;
    (t = this.onMouseMove) == null || t.call(this, this._convertViewToModelMouseEvent(e));
  }
  emitMouseLeave(e) {
    var t;
    (t = this.onMouseLeave) == null || t.call(this, this._convertViewToModelMouseEvent(e));
  }
  emitMouseDown(e) {
    var t;
    (t = this.onMouseDown) == null || t.call(this, this._convertViewToModelMouseEvent(e));
  }
  emitMouseUp(e) {
    var t;
    (t = this.onMouseUp) == null || t.call(this, this._convertViewToModelMouseEvent(e));
  }
  emitMouseDrag(e) {
    var t;
    (t = this.onMouseDrag) == null || t.call(this, this._convertViewToModelMouseEvent(e));
  }
  emitMouseDrop(e) {
    var t;
    (t = this.onMouseDrop) == null || t.call(this, this._convertViewToModelMouseEvent(e));
  }
  emitMouseDropCanceled() {
    var e;
    (e = this.onMouseDropCanceled) == null || e.call(this);
  }
  emitMouseWheel(e) {
    var t;
    (t = this.onMouseWheel) == null || t.call(this, e);
  }
  _convertViewToModelMouseEvent(e) {
    return e.target ? {
      event: e.event,
      target: this._convertViewToModelMouseTarget(e.target)
    } : e;
  }
  _convertViewToModelMouseTarget(e) {
    return e0.convertViewToModelMouseTarget(e, this._coordinatesConverter);
  }
  static convertViewToModelMouseTarget(e, t) {
    const i = { ...e };
    return i.position && (i.position = t.convertViewPositionToModelPosition(i.position)), i.range && (i.range = t.convertViewRangeToModelRange(i.range)), (i.type === 5 || i.type === 8) && (i.detail = this.convertViewToModelViewZoneData(i.detail, t)), i;
  }
  static convertViewToModelViewZoneData(e, t) {
    return {
      viewZoneId: e.viewZoneId,
      positionBefore: e.positionBefore ? t.convertViewPositionToModelPosition(e.positionBefore) : e.positionBefore,
      positionAfter: e.positionAfter ? t.convertViewPositionToModelPosition(e.positionAfter) : e.positionAfter,
      position: t.convertViewPositionToModelPosition(e.position),
      afterLineNumber: t.convertViewPositionToModelPosition(new V(e.afterLineNumber, 1)).lineNumber
    };
  }
}
class EZ extends Hn {
  constructor(e) {
    super(e), this.blocks = [], this.contentWidth = -1, this.contentLeft = 0, this.domNode = je(document.createElement("div")), this.domNode.setAttribute("role", "presentation"), this.domNode.setAttribute("aria-hidden", "true"), this.domNode.setClassName("blockDecorations-container"), this.update();
  }
  update() {
    let e = !1;
    const i = this._context.configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    ), n = i.contentWidth - i.verticalScrollbarWidth;
    this.contentWidth !== n && (this.contentWidth = n, e = !0);
    const o = i.contentLeft;
    return this.contentLeft !== o && (this.contentLeft = o, e = !0), e;
  }
  dispose() {
    super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    return this.update();
  }
  onScrollChanged(e) {
    return e.scrollTopChanged || e.scrollLeftChanged;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  prepareRender(e) {
  }
  render(e) {
    let t = 0;
    const i = e.getDecorationsInViewport();
    for (const n of i) {
      if (!n.options.blockClassName)
        continue;
      let o = this.blocks[t];
      o || (o = this.blocks[t] = je(document.createElement("div")), this.domNode.appendChild(o));
      let r, a;
      n.options.blockIsAfterEnd ? (r = e.getVerticalOffsetAfterLineNumber(n.range.endLineNumber, !1), a = e.getVerticalOffsetAfterLineNumber(n.range.endLineNumber, !0)) : (r = e.getVerticalOffsetForLineNumber(n.range.startLineNumber, !0), a = n.range.isEmpty() && !n.options.blockDoesNotCollapse ? e.getVerticalOffsetForLineNumber(n.range.startLineNumber, !1) : e.getVerticalOffsetAfterLineNumber(n.range.endLineNumber, !0));
      const [l, c, h, d] = n.options.blockPadding ?? [0, 0, 0, 0];
      o.setClassName("blockDecorations-block " + n.options.blockClassName), o.setLeft(this.contentLeft - d), o.setWidth(this.contentWidth + d + c), o.setTop(r - e.scrollTop - l), o.setHeight(a - r + l + h), t++;
    }
    for (let n = t; n < this.blocks.length; n++)
      this.blocks[n].domNode.remove();
    this.blocks.length = t;
  }
}
class IZ extends Hn {
  constructor(e, t) {
    super(e), this._viewDomNode = t, this._widgets = {}, this.domNode = je(document.createElement("div")), ho.write(
      this.domNode,
      1
      /* PartFingerprint.ContentWidgets */
    ), this.domNode.setClassName("contentWidgets"), this.domNode.setPosition("absolute"), this.domNode.setTop(0), this.overflowingContentWidgetsDomNode = je(document.createElement("div")), ho.write(
      this.overflowingContentWidgetsDomNode,
      2
      /* PartFingerprint.OverflowingContentWidgets */
    ), this.overflowingContentWidgetsDomNode.setClassName("overflowingContentWidgets");
  }
  dispose() {
    super.dispose(), this._widgets = {};
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = Object.keys(this._widgets);
    for (const i of t)
      this._widgets[i].onConfigurationChanged(e);
    return !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLineMappingChanged(e) {
    return this._updateAnchorsViewPositions(), !0;
  }
  onLinesChanged(e) {
    return this._updateAnchorsViewPositions(), !0;
  }
  onLinesDeleted(e) {
    return this._updateAnchorsViewPositions(), !0;
  }
  onLinesInserted(e) {
    return this._updateAnchorsViewPositions(), !0;
  }
  onScrollChanged(e) {
    return !0;
  }
  onZonesChanged(e) {
    return !0;
  }
  // ---- end view event handlers
  _updateAnchorsViewPositions() {
    const e = Object.keys(this._widgets);
    for (const t of e)
      this._widgets[t].updateAnchorViewPosition();
  }
  addWidget(e) {
    const t = new NZ(this._context, this._viewDomNode, e);
    this._widgets[t.id] = t, t.allowEditorOverflow ? this.overflowingContentWidgetsDomNode.appendChild(t.domNode) : this.domNode.appendChild(t.domNode), this.setShouldRender();
  }
  setWidgetPosition(e, t, i, n, o) {
    this._widgets[e.getId()].setPosition(t, i, n, o), this.setShouldRender();
  }
  removeWidget(e) {
    const t = e.getId();
    if (this._widgets.hasOwnProperty(t)) {
      const i = this._widgets[t];
      delete this._widgets[t];
      const n = i.domNode.domNode;
      n.remove(), n.removeAttribute("monaco-visible-content-widget"), this.setShouldRender();
    }
  }
  shouldSuppressMouseDownOnWidget(e) {
    return this._widgets.hasOwnProperty(e) ? this._widgets[e].suppressMouseDown : !1;
  }
  onBeforeRender(e) {
    const t = Object.keys(this._widgets);
    for (const i of t)
      this._widgets[i].onBeforeRender(e);
  }
  prepareRender(e) {
    const t = Object.keys(this._widgets);
    for (const i of t)
      this._widgets[i].prepareRender(e);
  }
  render(e) {
    const t = Object.keys(this._widgets);
    for (const i of t)
      this._widgets[i].render(e);
  }
}
class NZ {
  constructor(e, t, i) {
    this._primaryAnchor = new wu(null, null), this._secondaryAnchor = new wu(null, null), this._context = e, this._viewDomNode = t, this._actual = i, this.domNode = je(this._actual.getDomNode()), this.id = this._actual.getId(), this.allowEditorOverflow = this._actual.allowEditorOverflow || !1, this.suppressMouseDown = this._actual.suppressMouseDown || !1;
    const n = this._context.configuration.options, o = n.get(
      146
      /* EditorOption.layoutInfo */
    );
    this._fixedOverflowWidgets = n.get(
      42
      /* EditorOption.fixedOverflowWidgets */
    ), this._contentWidth = o.contentWidth, this._contentLeft = o.contentLeft, this._lineHeight = n.get(
      67
      /* EditorOption.lineHeight */
    ), this._affinity = null, this._preference = [], this._cachedDomNodeOffsetWidth = -1, this._cachedDomNodeOffsetHeight = -1, this._maxWidth = this._getMaxWidth(), this._isVisible = !1, this._renderData = null, this.domNode.setPosition(this._fixedOverflowWidgets && this.allowEditorOverflow ? "fixed" : "absolute"), this.domNode.setDisplay("none"), this.domNode.setVisibility("hidden"), this.domNode.setAttribute("widgetId", this.id), this.domNode.setMaxWidth(this._maxWidth);
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    if (this._lineHeight = t.get(
      67
      /* EditorOption.lineHeight */
    ), e.hasChanged(
      146
      /* EditorOption.layoutInfo */
    )) {
      const i = t.get(
        146
        /* EditorOption.layoutInfo */
      );
      this._contentLeft = i.contentLeft, this._contentWidth = i.contentWidth, this._maxWidth = this._getMaxWidth();
    }
  }
  updateAnchorViewPosition() {
    this._setPosition(this._affinity, this._primaryAnchor.modelPosition, this._secondaryAnchor.modelPosition);
  }
  _setPosition(e, t, i) {
    this._affinity = e, this._primaryAnchor = n(t, this._context.viewModel, this._affinity), this._secondaryAnchor = n(i, this._context.viewModel, this._affinity);
    function n(o, r, a) {
      if (!o)
        return new wu(null, null);
      const l = r.model.validatePosition(o);
      if (r.coordinatesConverter.modelPositionIsVisible(l)) {
        const c = r.coordinatesConverter.convertModelPositionToViewPosition(l, a ?? void 0);
        return new wu(o, c);
      }
      return new wu(o, null);
    }
  }
  _getMaxWidth() {
    const e = this.domNode.domNode.ownerDocument, t = e.defaultView;
    return this.allowEditorOverflow ? (t == null ? void 0 : t.innerWidth) || e.documentElement.offsetWidth || e.body.offsetWidth : this._contentWidth;
  }
  setPosition(e, t, i, n) {
    this._setPosition(n, e, t), this._preference = i, this._primaryAnchor.viewPosition && this._preference && this._preference.length > 0 ? this.domNode.setDisplay("block") : this.domNode.setDisplay("none"), this._cachedDomNodeOffsetWidth = -1, this._cachedDomNodeOffsetHeight = -1;
  }
  _layoutBoxInViewport(e, t, i, n) {
    const o = e.top, r = o, a = e.top + e.height, l = n.viewportHeight - a, c = o - i, h = r >= i, d = a, u = l >= i;
    let f = e.left;
    return f + t > n.scrollLeft + n.viewportWidth && (f = n.scrollLeft + n.viewportWidth - t), f < n.scrollLeft && (f = n.scrollLeft), { fitsAbove: h, aboveTop: c, fitsBelow: u, belowTop: d, left: f };
  }
  _layoutHorizontalSegmentInPage(e, t, i, n) {
    const a = Math.max(15, t.left - n), l = Math.min(t.left + t.width + n, e.width - 15), h = this._viewDomNode.domNode.ownerDocument.defaultView;
    let d = t.left + i - ((h == null ? void 0 : h.scrollX) ?? 0);
    if (d + n > l) {
      const u = d - (l - n);
      d -= u, i -= u;
    }
    if (d < a) {
      const u = d - a;
      d -= u, i -= u;
    }
    return [i, d];
  }
  _layoutBoxInPage(e, t, i, n) {
    const o = e.top - i, r = e.top + e.height, a = gs(this._viewDomNode.domNode), l = this._viewDomNode.domNode.ownerDocument, c = l.defaultView, h = a.top + o - ((c == null ? void 0 : c.scrollY) ?? 0), d = a.top + r - ((c == null ? void 0 : c.scrollY) ?? 0), u = Zw(l.body), [f, g] = this._layoutHorizontalSegmentInPage(u, a, e.left - n.scrollLeft + this._contentLeft, t), m = 22, _ = 22, b = h >= m, C = d + i <= u.height - _;
    return this._fixedOverflowWidgets ? {
      fitsAbove: b,
      aboveTop: Math.max(h, m),
      fitsBelow: C,
      belowTop: d,
      left: g
    } : { fitsAbove: b, aboveTop: o, fitsBelow: C, belowTop: r, left: f };
  }
  _prepareRenderWidgetAtExactPositionOverflowing(e) {
    return new vu(e.top, e.left + this._contentLeft);
  }
  /**
   * Compute the coordinates above and below the primary and secondary anchors.
   * The content widget *must* touch the primary anchor.
   * The content widget should touch if possible the secondary anchor.
   */
  _getAnchorsCoordinates(e) {
    var r, a;
    const t = o(this._primaryAnchor.viewPosition, this._affinity, this._lineHeight), i = ((r = this._secondaryAnchor.viewPosition) == null ? void 0 : r.lineNumber) === ((a = this._primaryAnchor.viewPosition) == null ? void 0 : a.lineNumber) ? this._secondaryAnchor.viewPosition : null, n = o(i, this._affinity, this._lineHeight);
    return { primary: t, secondary: n };
    function o(l, c, h) {
      if (!l)
        return null;
      const d = e.visibleRangeForPosition(l);
      if (!d)
        return null;
      const u = l.column === 1 && c === 3 ? 0 : d.left, f = e.getVerticalOffsetForLineNumber(l.lineNumber) - e.scrollTop;
      return new pT(f, u, h);
    }
  }
  _reduceAnchorCoordinates(e, t, i) {
    if (!t)
      return e;
    const n = this._context.configuration.options.get(
      50
      /* EditorOption.fontInfo */
    );
    let o = t.left;
    return o < e.left ? o = Math.max(o, e.left - i + n.typicalFullwidthCharacterWidth) : o = Math.min(o, e.left + i - n.typicalFullwidthCharacterWidth), new pT(e.top, o, e.height);
  }
  _prepareRenderWidget(e) {
    if (!this._preference || this._preference.length === 0)
      return null;
    const { primary: t, secondary: i } = this._getAnchorsCoordinates(e);
    if (!t)
      return {
        kind: "offViewport",
        preserveFocus: this.domNode.domNode.contains(this.domNode.domNode.ownerDocument.activeElement)
      };
    if (this._cachedDomNodeOffsetWidth === -1 || this._cachedDomNodeOffsetHeight === -1) {
      let r = null;
      if (typeof this._actual.beforeRender == "function" && (r = _C(this._actual.beforeRender, this._actual)), r)
        this._cachedDomNodeOffsetWidth = r.width, this._cachedDomNodeOffsetHeight = r.height;
      else {
        const l = this.domNode.domNode.getBoundingClientRect();
        this._cachedDomNodeOffsetWidth = Math.round(l.width), this._cachedDomNodeOffsetHeight = Math.round(l.height);
      }
    }
    const n = this._reduceAnchorCoordinates(t, i, this._cachedDomNodeOffsetWidth);
    let o;
    this.allowEditorOverflow ? o = this._layoutBoxInPage(n, this._cachedDomNodeOffsetWidth, this._cachedDomNodeOffsetHeight, e) : o = this._layoutBoxInViewport(n, this._cachedDomNodeOffsetWidth, this._cachedDomNodeOffsetHeight, e);
    for (let r = 1; r <= 2; r++)
      for (const a of this._preference)
        if (a === 1) {
          if (!o)
            return null;
          if (r === 2 || o.fitsAbove)
            return {
              kind: "inViewport",
              coordinate: new vu(o.aboveTop, o.left),
              position: 1
              /* ContentWidgetPositionPreference.ABOVE */
            };
        } else if (a === 2) {
          if (!o)
            return null;
          if (r === 2 || o.fitsBelow)
            return {
              kind: "inViewport",
              coordinate: new vu(o.belowTop, o.left),
              position: 2
              /* ContentWidgetPositionPreference.BELOW */
            };
        } else
          return this.allowEditorOverflow ? {
            kind: "inViewport",
            coordinate: this._prepareRenderWidgetAtExactPositionOverflowing(new vu(n.top, n.left)),
            position: 0
            /* ContentWidgetPositionPreference.EXACT */
          } : {
            kind: "inViewport",
            coordinate: new vu(n.top, n.left),
            position: 0
            /* ContentWidgetPositionPreference.EXACT */
          };
    return null;
  }
  /**
   * On this first pass, we ensure that the content widget (if it is in the viewport) has the max width set correctly.
   */
  onBeforeRender(e) {
    !this._primaryAnchor.viewPosition || !this._preference || this._primaryAnchor.viewPosition.lineNumber < e.startLineNumber || this._primaryAnchor.viewPosition.lineNumber > e.endLineNumber || this.domNode.setMaxWidth(this._maxWidth);
  }
  prepareRender(e) {
    this._renderData = this._prepareRenderWidget(e);
  }
  render(e) {
    var t;
    if (!this._renderData || this._renderData.kind === "offViewport") {
      this._isVisible && (this.domNode.removeAttribute("monaco-visible-content-widget"), this._isVisible = !1, ((t = this._renderData) == null ? void 0 : t.kind) === "offViewport" && this._renderData.preserveFocus ? this.domNode.setTop(-1e3) : this.domNode.setVisibility("hidden")), typeof this._actual.afterRender == "function" && _C(this._actual.afterRender, this._actual, null);
      return;
    }
    this.allowEditorOverflow ? (this.domNode.setTop(this._renderData.coordinate.top), this.domNode.setLeft(this._renderData.coordinate.left)) : (this.domNode.setTop(this._renderData.coordinate.top + e.scrollTop - e.bigNumbersDelta), this.domNode.setLeft(this._renderData.coordinate.left)), this._isVisible || (this.domNode.setVisibility("inherit"), this.domNode.setAttribute("monaco-visible-content-widget", "true"), this._isVisible = !0), typeof this._actual.afterRender == "function" && _C(this._actual.afterRender, this._actual, this._renderData.position);
  }
}
class wu {
  constructor(e, t) {
    this.modelPosition = e, this.viewPosition = t;
  }
}
class vu {
  constructor(e, t) {
    this.top = e, this.left = t, this._coordinateBrand = void 0;
  }
}
class pT {
  constructor(e, t, i) {
    this.top = e, this.left = t, this.height = i, this._anchorCoordinateBrand = void 0;
  }
}
function _C(s, e, ...t) {
  try {
    return s.call(e, ...t);
  } catch {
    return null;
  }
}
class a5 extends Hc {
  constructor(e) {
    super(), this._context = e;
    const t = this._context.configuration.options, i = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    this._renderLineHighlight = t.get(
      97
      /* EditorOption.renderLineHighlight */
    ), this._renderLineHighlightOnlyWhenFocus = t.get(
      98
      /* EditorOption.renderLineHighlightOnlyWhenFocus */
    ), this._wordWrap = i.isViewportWrapping, this._contentLeft = i.contentLeft, this._contentWidth = i.contentWidth, this._selectionIsEmpty = !0, this._focused = !1, this._cursorLineNumbers = [1], this._selections = [new ft(1, 1, 1, 1)], this._renderData = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), super.dispose();
  }
  _readFromSelections() {
    let e = !1;
    const t = /* @__PURE__ */ new Set();
    for (const o of this._selections)
      t.add(o.positionLineNumber);
    const i = Array.from(t);
    i.sort((o, r) => o - r), oi(this._cursorLineNumbers, i) || (this._cursorLineNumbers = i, e = !0);
    const n = this._selections.every((o) => o.isEmpty());
    return this._selectionIsEmpty !== n && (this._selectionIsEmpty = n, e = !0), e;
  }
  // --- begin event handlers
  onThemeChanged(e) {
    return this._readFromSelections();
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    return this._renderLineHighlight = t.get(
      97
      /* EditorOption.renderLineHighlight */
    ), this._renderLineHighlightOnlyWhenFocus = t.get(
      98
      /* EditorOption.renderLineHighlightOnlyWhenFocus */
    ), this._wordWrap = i.isViewportWrapping, this._contentLeft = i.contentLeft, this._contentWidth = i.contentWidth, !0;
  }
  onCursorStateChanged(e) {
    return this._selections = e.selections, this._readFromSelections();
  }
  onFlushed(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollWidthChanged || e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  onFocusChanged(e) {
    return this._renderLineHighlightOnlyWhenFocus ? (this._focused = e.isFocused, !0) : !1;
  }
  // --- end event handlers
  prepareRender(e) {
    if (!this._shouldRenderThis()) {
      this._renderData = null;
      return;
    }
    const t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber, n = [];
    for (let r = t; r <= i; r++) {
      const a = r - t;
      n[a] = "";
    }
    if (this._wordWrap) {
      const r = this._renderOne(e, !1);
      for (const a of this._cursorLineNumbers) {
        const l = this._context.viewModel.coordinatesConverter, c = l.convertViewPositionToModelPosition(new V(a, 1)).lineNumber, h = l.convertModelPositionToViewPosition(new V(c, 1)).lineNumber, d = l.convertModelPositionToViewPosition(new V(c, this._context.viewModel.model.getLineMaxColumn(c))).lineNumber, u = Math.max(h, t), f = Math.min(d, i);
        for (let g = u; g <= f; g++) {
          const m = g - t;
          n[m] = r;
        }
      }
    }
    const o = this._renderOne(e, !0);
    for (const r of this._cursorLineNumbers) {
      if (r < t || r > i)
        continue;
      const a = r - t;
      n[a] = o;
    }
    this._renderData = n;
  }
  render(e, t) {
    if (!this._renderData)
      return "";
    const i = t - e;
    return i >= this._renderData.length ? "" : this._renderData[i];
  }
  _shouldRenderInMargin() {
    return (this._renderLineHighlight === "gutter" || this._renderLineHighlight === "all") && (!this._renderLineHighlightOnlyWhenFocus || this._focused);
  }
  _shouldRenderInContent() {
    return (this._renderLineHighlight === "line" || this._renderLineHighlight === "all") && this._selectionIsEmpty && (!this._renderLineHighlightOnlyWhenFocus || this._focused);
  }
}
class TZ extends a5 {
  _renderOne(e, t) {
    return `<div class="${"current-line" + (this._shouldRenderInMargin() ? " current-line-both" : "") + (t ? " current-line-exact" : "")}" style="width:${Math.max(e.scrollWidth, this._contentWidth)}px;"></div>`;
  }
  _shouldRenderThis() {
    return this._shouldRenderInContent();
  }
  _shouldRenderOther() {
    return this._shouldRenderInMargin();
  }
}
class MZ extends a5 {
  _renderOne(e, t) {
    return `<div class="${"current-line" + (this._shouldRenderInMargin() ? " current-line-margin" : "") + (this._shouldRenderOther() ? " current-line-margin-both" : "") + (this._shouldRenderInMargin() && t ? " current-line-exact-margin" : "")}" style="width:${this._contentLeft}px"></div>`;
  }
  _shouldRenderThis() {
    return !0;
  }
  _shouldRenderOther() {
    return this._shouldRenderInContent();
  }
}
Jr((s, e) => {
  const t = s.getColor(MA);
  if (t && (e.addRule(`.monaco-editor .view-overlays .current-line { background-color: ${t}; }`), e.addRule(`.monaco-editor .margin-view-overlays .current-line-margin { background-color: ${t}; border: none; }`)), !t || t.isTransparent() || s.defines(ZI)) {
    const i = s.getColor(ZI);
    i && (e.addRule(`.monaco-editor .view-overlays .current-line-exact { border: 2px solid ${i}; }`), e.addRule(`.monaco-editor .margin-view-overlays .current-line-exact-margin { border: 2px solid ${i}; }`), Gh(s.type) && (e.addRule(".monaco-editor .view-overlays .current-line-exact { border-width: 1px; }"), e.addRule(".monaco-editor .margin-view-overlays .current-line-exact-margin { border-width: 1px; }")));
  }
});
class RZ extends Hc {
  constructor(e) {
    super(), this._context = e;
    const t = this._context.configuration.options;
    this._typicalHalfwidthCharacterWidth = t.get(
      50
      /* EditorOption.fontInfo */
    ).typicalHalfwidthCharacterWidth, this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    return this._typicalHalfwidthCharacterWidth = t.get(
      50
      /* EditorOption.fontInfo */
    ).typicalHalfwidthCharacterWidth, !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged || e.scrollWidthChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  prepareRender(e) {
    const t = e.getDecorationsInViewport();
    let i = [], n = 0;
    for (let l = 0, c = t.length; l < c; l++) {
      const h = t[l];
      h.options.className && (i[n++] = h);
    }
    i = i.sort((l, c) => {
      if (l.options.zIndex < c.options.zIndex)
        return -1;
      if (l.options.zIndex > c.options.zIndex)
        return 1;
      const h = l.options.className, d = c.options.className;
      return h < d ? -1 : h > d ? 1 : R.compareRangesUsingStarts(l.range, c.range);
    });
    const o = e.visibleRange.startLineNumber, r = e.visibleRange.endLineNumber, a = [];
    for (let l = o; l <= r; l++) {
      const c = l - o;
      a[c] = "";
    }
    this._renderWholeLineDecorations(e, i, a), this._renderNormalDecorations(e, i, a), this._renderResult = a;
  }
  _renderWholeLineDecorations(e, t, i) {
    const n = e.visibleRange.startLineNumber, o = e.visibleRange.endLineNumber;
    for (let r = 0, a = t.length; r < a; r++) {
      const l = t[r];
      if (!l.options.isWholeLine)
        continue;
      const c = '<div class="cdr ' + l.options.className + '" style="left:0;width:100%;"></div>', h = Math.max(l.range.startLineNumber, n), d = Math.min(l.range.endLineNumber, o);
      for (let u = h; u <= d; u++) {
        const f = u - n;
        i[f] += c;
      }
    }
  }
  _renderNormalDecorations(e, t, i) {
    const n = e.visibleRange.startLineNumber;
    let o = null, r = !1, a = null, l = !1;
    for (let c = 0, h = t.length; c < h; c++) {
      const d = t[c];
      if (d.options.isWholeLine)
        continue;
      const u = d.options.className, f = !!d.options.showIfCollapsed;
      let g = d.range;
      if (f && g.endColumn === 1 && g.endLineNumber !== g.startLineNumber && (g = new R(g.startLineNumber, g.startColumn, g.endLineNumber - 1, this._context.viewModel.getLineMaxColumn(g.endLineNumber - 1))), o === u && r === f && R.areIntersectingOrTouching(a, g)) {
        a = R.plusRange(a, g);
        continue;
      }
      o !== null && this._renderNormalDecoration(e, a, o, l, r, n, i), o = u, r = f, a = g, l = d.options.shouldFillLineOnLineBreak ?? !1;
    }
    o !== null && this._renderNormalDecoration(e, a, o, l, r, n, i);
  }
  _renderNormalDecoration(e, t, i, n, o, r, a) {
    const l = e.linesVisibleRangesForRange(
      t,
      /*TODO@Alex*/
      i === "findMatch"
    );
    if (l)
      for (let c = 0, h = l.length; c < h; c++) {
        const d = l[c];
        if (d.outsideRenderedLine)
          continue;
        const u = d.lineNumber - r;
        if (o && d.ranges.length === 1) {
          const f = d.ranges[0];
          if (f.width < this._typicalHalfwidthCharacterWidth) {
            const g = Math.round(f.left + f.width / 2), m = Math.max(0, Math.round(g - this._typicalHalfwidthCharacterWidth / 2));
            d.ranges[0] = new Xb(m, this._typicalHalfwidthCharacterWidth);
          }
        }
        for (let f = 0, g = d.ranges.length; f < g; f++) {
          const m = n && d.continuesOnNextLine && g === 1, _ = d.ranges[f], b = '<div class="cdr ' + i + '" style="left:' + String(_.left) + "px;width:" + (m ? "100%;" : String(_.width) + "px;") + '"></div>';
          a[u] += b;
        }
      }
  }
  render(e, t) {
    if (!this._renderResult)
      return "";
    const i = t - e;
    return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
  }
}
class AZ extends Hn {
  constructor(e, t, i, n) {
    super(e);
    const o = this._context.configuration.options, r = o.get(
      104
      /* EditorOption.scrollbar */
    ), a = o.get(
      75
      /* EditorOption.mouseWheelScrollSensitivity */
    ), l = o.get(
      40
      /* EditorOption.fastScrollSensitivity */
    ), c = o.get(
      107
      /* EditorOption.scrollPredominantAxis */
    ), h = {
      listenOnDomNode: i.domNode,
      className: "editor-scrollable " + wv(e.theme.type),
      useShadows: !1,
      lazyRender: !0,
      vertical: r.vertical,
      horizontal: r.horizontal,
      verticalHasArrows: r.verticalHasArrows,
      horizontalHasArrows: r.horizontalHasArrows,
      verticalScrollbarSize: r.verticalScrollbarSize,
      verticalSliderSize: r.verticalSliderSize,
      horizontalScrollbarSize: r.horizontalScrollbarSize,
      horizontalSliderSize: r.horizontalSliderSize,
      handleMouseWheel: r.handleMouseWheel,
      alwaysConsumeMouseWheel: r.alwaysConsumeMouseWheel,
      arrowSize: r.arrowSize,
      mouseWheelScrollSensitivity: a,
      fastScrollSensitivity: l,
      scrollPredominantAxis: c,
      scrollByPage: r.scrollByPage
    };
    this.scrollbar = this._register(new xb(t.domNode, h, this._context.viewLayout.getScrollable())), ho.write(
      this.scrollbar.getDomNode(),
      6
      /* PartFingerprint.ScrollableElement */
    ), this.scrollbarDomNode = je(this.scrollbar.getDomNode()), this.scrollbarDomNode.setPosition("absolute"), this._setLayout();
    const d = (u, f, g) => {
      const m = {};
      {
        const _ = u.scrollTop;
        _ && (m.scrollTop = this._context.viewLayout.getCurrentScrollTop() + _, u.scrollTop = 0);
      }
      if (g) {
        const _ = u.scrollLeft;
        _ && (m.scrollLeft = this._context.viewLayout.getCurrentScrollLeft() + _, u.scrollLeft = 0);
      }
      this._context.viewModel.viewLayout.setScrollPosition(
        m,
        1
        /* ScrollType.Immediate */
      );
    };
    this._register($(i.domNode, "scroll", (u) => d(i.domNode, !0, !0))), this._register($(t.domNode, "scroll", (u) => d(t.domNode, !0, !1))), this._register($(n.domNode, "scroll", (u) => d(n.domNode, !0, !1))), this._register($(this.scrollbarDomNode.domNode, "scroll", (u) => d(this.scrollbarDomNode.domNode, !0, !1)));
  }
  dispose() {
    super.dispose();
  }
  _setLayout() {
    const e = this._context.configuration.options, t = e.get(
      146
      /* EditorOption.layoutInfo */
    );
    this.scrollbarDomNode.setLeft(t.contentLeft), e.get(
      73
      /* EditorOption.minimap */
    ).side === "right" ? this.scrollbarDomNode.setWidth(t.contentWidth + t.minimap.minimapWidth) : this.scrollbarDomNode.setWidth(t.contentWidth), this.scrollbarDomNode.setHeight(t.height);
  }
  getOverviewRulerLayoutInfo() {
    return this.scrollbar.getOverviewRulerLayoutInfo();
  }
  getDomNode() {
    return this.scrollbarDomNode;
  }
  delegateVerticalScrollbarPointerDown(e) {
    this.scrollbar.delegateVerticalScrollbarPointerDown(e);
  }
  delegateScrollFromMouseWheelEvent(e) {
    this.scrollbar.delegateScrollFromMouseWheelEvent(e);
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    if (e.hasChanged(
      104
      /* EditorOption.scrollbar */
    ) || e.hasChanged(
      75
      /* EditorOption.mouseWheelScrollSensitivity */
    ) || e.hasChanged(
      40
      /* EditorOption.fastScrollSensitivity */
    )) {
      const t = this._context.configuration.options, i = t.get(
        104
        /* EditorOption.scrollbar */
      ), n = t.get(
        75
        /* EditorOption.mouseWheelScrollSensitivity */
      ), o = t.get(
        40
        /* EditorOption.fastScrollSensitivity */
      ), r = t.get(
        107
        /* EditorOption.scrollPredominantAxis */
      ), a = {
        vertical: i.vertical,
        horizontal: i.horizontal,
        verticalScrollbarSize: i.verticalScrollbarSize,
        horizontalScrollbarSize: i.horizontalScrollbarSize,
        scrollByPage: i.scrollByPage,
        handleMouseWheel: i.handleMouseWheel,
        mouseWheelScrollSensitivity: n,
        fastScrollSensitivity: o,
        scrollPredominantAxis: r
      };
      this.scrollbar.updateOptions(a);
    }
    return e.hasChanged(
      146
      /* EditorOption.layoutInfo */
    ) && this._setLayout(), !0;
  }
  onScrollChanged(e) {
    return !0;
  }
  onThemeChanged(e) {
    return this.scrollbar.updateClassName("editor-scrollable " + wv(this._context.theme.type)), !0;
  }
  // --- end event handlers
  prepareRender(e) {
  }
  render(e) {
    this.scrollbar.renderNow();
  }
}
class NS {
  constructor(e, t, i, n, o) {
    this.startLineNumber = e, this.endLineNumber = t, this.className = i, this.tooltip = n, this._decorationToRenderBrand = void 0, this.zIndex = o ?? 0;
  }
}
class PZ {
  constructor(e, t, i) {
    this.className = e, this.zIndex = t, this.tooltip = i;
  }
}
class OZ {
  constructor() {
    this.decorations = [];
  }
  add(e) {
    this.decorations.push(e);
  }
  getDecorations() {
    return this.decorations;
  }
}
class l5 extends Hc {
  /**
   * Returns an array with an element for each visible line number.
   */
  _render(e, t, i) {
    const n = [];
    for (let a = e; a <= t; a++) {
      const l = a - e;
      n[l] = new OZ();
    }
    if (i.length === 0)
      return n;
    i.sort((a, l) => a.className === l.className ? a.startLineNumber === l.startLineNumber ? a.endLineNumber - l.endLineNumber : a.startLineNumber - l.startLineNumber : a.className < l.className ? -1 : 1);
    let o = null, r = 0;
    for (let a = 0, l = i.length; a < l; a++) {
      const c = i[a], h = c.className, d = c.zIndex;
      let u = Math.max(c.startLineNumber, e) - e;
      const f = Math.min(c.endLineNumber, t) - e;
      o === h ? (u = Math.max(r + 1, u), r = Math.max(r, f)) : (o = h, r = f);
      for (let g = u; g <= r; g++)
        n[g].add(new PZ(h, d, c.tooltip));
    }
    return n;
  }
}
class FZ extends Hn {
  constructor(e) {
    super(e), this._widgets = {}, this._context = e;
    const t = this._context.configuration.options, i = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    this.domNode = je(document.createElement("div")), this.domNode.setClassName("glyph-margin-widgets"), this.domNode.setPosition("absolute"), this.domNode.setTop(0), this._lineHeight = t.get(
      67
      /* EditorOption.lineHeight */
    ), this._glyphMargin = t.get(
      57
      /* EditorOption.glyphMargin */
    ), this._glyphMarginLeft = i.glyphMarginLeft, this._glyphMarginWidth = i.glyphMarginWidth, this._glyphMarginDecorationLaneCount = i.glyphMarginDecorationLaneCount, this._managedDomNodes = [], this._decorationGlyphsToRender = [];
  }
  dispose() {
    this._managedDomNodes = [], this._decorationGlyphsToRender = [], this._widgets = {}, super.dispose();
  }
  getWidgets() {
    return Object.values(this._widgets);
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    return this._lineHeight = t.get(
      67
      /* EditorOption.lineHeight */
    ), this._glyphMargin = t.get(
      57
      /* EditorOption.glyphMargin */
    ), this._glyphMarginLeft = i.glyphMarginLeft, this._glyphMarginWidth = i.glyphMarginWidth, this._glyphMarginDecorationLaneCount = i.glyphMarginDecorationLaneCount, !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  // --- begin widget management
  addWidget(e) {
    const t = je(e.getDomNode());
    this._widgets[e.getId()] = {
      widget: e,
      preference: e.getPosition(),
      domNode: t,
      renderInfo: null
    }, t.setPosition("absolute"), t.setDisplay("none"), t.setAttribute("widgetId", e.getId()), this.domNode.appendChild(t), this.setShouldRender();
  }
  setWidgetPosition(e, t) {
    const i = this._widgets[e.getId()];
    return i.preference.lane === t.lane && i.preference.zIndex === t.zIndex && R.equalsRange(i.preference.range, t.range) ? !1 : (i.preference = t, this.setShouldRender(), !0);
  }
  removeWidget(e) {
    const t = e.getId();
    if (this._widgets[t]) {
      const n = this._widgets[t].domNode.domNode;
      delete this._widgets[t], n.remove(), this.setShouldRender();
    }
  }
  // --- end widget management
  _collectDecorationBasedGlyphRenderRequest(e, t) {
    var r;
    const i = e.visibleRange.startLineNumber, n = e.visibleRange.endLineNumber, o = e.getDecorationsInViewport();
    for (const a of o) {
      const l = a.options.glyphMarginClassName;
      if (!l)
        continue;
      const c = Math.max(a.range.startLineNumber, i), h = Math.min(a.range.endLineNumber, n), d = ((r = a.options.glyphMargin) == null ? void 0 : r.position) ?? Ka.Center, u = a.options.zIndex ?? 0;
      for (let f = c; f <= h; f++) {
        const g = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new V(f, 0)), m = this._context.viewModel.glyphLanes.getLanesAtLine(g.lineNumber).indexOf(d);
        t.push(new BZ(f, m, u, l));
      }
    }
  }
  _collectWidgetBasedGlyphRenderRequest(e, t) {
    const i = e.visibleRange.startLineNumber, n = e.visibleRange.endLineNumber;
    for (const o of Object.values(this._widgets)) {
      const r = o.preference.range, { startLineNumber: a, endLineNumber: l } = this._context.viewModel.coordinatesConverter.convertModelRangeToViewRange(R.lift(r));
      if (!a || !l || l < i || a > n)
        continue;
      const c = Math.max(a, i), h = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new V(c, 0)), d = this._context.viewModel.glyphLanes.getLanesAtLine(h.lineNumber).indexOf(o.preference.lane);
      t.push(new WZ(c, d, o.preference.zIndex, o));
    }
  }
  _collectSortedGlyphRenderRequests(e) {
    const t = [];
    return this._collectDecorationBasedGlyphRenderRequest(e, t), this._collectWidgetBasedGlyphRenderRequest(e, t), t.sort((i, n) => i.lineNumber === n.lineNumber ? i.laneIndex === n.laneIndex ? i.zIndex === n.zIndex ? n.type === i.type ? i.type === 0 && n.type === 0 ? i.className < n.className ? -1 : 1 : 0 : n.type - i.type : n.zIndex - i.zIndex : i.laneIndex - n.laneIndex : i.lineNumber - n.lineNumber), t;
  }
  /**
   * Will store render information in each widget's renderInfo and in `_decorationGlyphsToRender`.
   */
  prepareRender(e) {
    if (!this._glyphMargin) {
      this._decorationGlyphsToRender = [];
      return;
    }
    for (const n of Object.values(this._widgets))
      n.renderInfo = null;
    const t = new Gr(this._collectSortedGlyphRenderRequests(e)), i = [];
    for (; t.length > 0; ) {
      const n = t.peek();
      if (!n)
        break;
      const o = t.takeWhile((a) => a.lineNumber === n.lineNumber && a.laneIndex === n.laneIndex);
      if (!o || o.length === 0)
        break;
      const r = o[0];
      if (r.type === 0) {
        const a = [];
        for (const l of o) {
          if (l.zIndex !== r.zIndex || l.type !== r.type)
            break;
          (a.length === 0 || a[a.length - 1] !== l.className) && a.push(l.className);
        }
        i.push(r.accept(a.join(" ")));
      } else
        r.widget.renderInfo = {
          lineNumber: r.lineNumber,
          laneIndex: r.laneIndex
        };
    }
    this._decorationGlyphsToRender = i;
  }
  render(e) {
    if (!this._glyphMargin) {
      for (const i of Object.values(this._widgets))
        i.domNode.setDisplay("none");
      for (; this._managedDomNodes.length > 0; ) {
        const i = this._managedDomNodes.pop();
        i == null || i.domNode.remove();
      }
      return;
    }
    const t = Math.round(this._glyphMarginWidth / this._glyphMarginDecorationLaneCount);
    for (const i of Object.values(this._widgets))
      if (!i.renderInfo)
        i.domNode.setDisplay("none");
      else {
        const n = e.viewportData.relativeVerticalOffset[i.renderInfo.lineNumber - e.viewportData.startLineNumber], o = this._glyphMarginLeft + i.renderInfo.laneIndex * this._lineHeight;
        i.domNode.setDisplay("block"), i.domNode.setTop(n), i.domNode.setLeft(o), i.domNode.setWidth(t), i.domNode.setHeight(this._lineHeight);
      }
    for (let i = 0; i < this._decorationGlyphsToRender.length; i++) {
      const n = this._decorationGlyphsToRender[i], o = e.viewportData.relativeVerticalOffset[n.lineNumber - e.viewportData.startLineNumber], r = this._glyphMarginLeft + n.laneIndex * this._lineHeight;
      let a;
      i < this._managedDomNodes.length ? a = this._managedDomNodes[i] : (a = je(document.createElement("div")), this._managedDomNodes.push(a), this.domNode.appendChild(a)), a.setClassName("cgmr codicon " + n.combinedClassName), a.setPosition("absolute"), a.setTop(o), a.setLeft(r), a.setWidth(t), a.setHeight(this._lineHeight);
    }
    for (; this._managedDomNodes.length > this._decorationGlyphsToRender.length; ) {
      const i = this._managedDomNodes.pop();
      i == null || i.domNode.remove();
    }
  }
}
class BZ {
  constructor(e, t, i, n) {
    this.lineNumber = e, this.laneIndex = t, this.zIndex = i, this.className = n, this.type = 0;
  }
  accept(e) {
    return new VZ(this.lineNumber, this.laneIndex, e);
  }
}
class WZ {
  constructor(e, t, i, n) {
    this.lineNumber = e, this.laneIndex = t, this.zIndex = i, this.widget = n, this.type = 1;
  }
}
class VZ {
  constructor(e, t, i) {
    this.lineNumber = e, this.laneIndex = t, this.combinedClassName = i;
  }
}
class HZ extends Hc {
  constructor(e) {
    super(), this._context = e, this._primaryPosition = null;
    const t = this._context.configuration.options, i = t.get(
      147
      /* EditorOption.wrappingInfo */
    ), n = t.get(
      50
      /* EditorOption.fontInfo */
    );
    this._spaceWidth = n.spaceWidth, this._maxIndentLeft = i.wrappingColumn === -1 ? -1 : i.wrappingColumn * n.typicalHalfwidthCharacterWidth, this._bracketPairGuideOptions = t.get(
      16
      /* EditorOption.guides */
    ), this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      147
      /* EditorOption.wrappingInfo */
    ), n = t.get(
      50
      /* EditorOption.fontInfo */
    );
    return this._spaceWidth = n.spaceWidth, this._maxIndentLeft = i.wrappingColumn === -1 ? -1 : i.wrappingColumn * n.typicalHalfwidthCharacterWidth, this._bracketPairGuideOptions = t.get(
      16
      /* EditorOption.guides */
    ), !0;
  }
  onCursorStateChanged(e) {
    var n;
    const i = e.selections[0].getPosition();
    return (n = this._primaryPosition) != null && n.equals(i) ? !1 : (this._primaryPosition = i, !0);
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  onLanguageConfigurationChanged(e) {
    return !0;
  }
  // --- end event handlers
  prepareRender(e) {
    var l, c;
    if (!this._bracketPairGuideOptions.indentation && this._bracketPairGuideOptions.bracketPairs === !1) {
      this._renderResult = null;
      return;
    }
    const t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber, n = e.scrollWidth, o = this._primaryPosition, r = this.getGuidesByLine(t, Math.min(i + 1, this._context.viewModel.getLineCount()), o), a = [];
    for (let h = t; h <= i; h++) {
      const d = h - t, u = r[d];
      let f = "";
      const g = ((l = e.visibleRangeForPosition(new V(h, 1))) == null ? void 0 : l.left) ?? 0;
      for (const m of u) {
        const _ = m.column === -1 ? g + (m.visibleColumn - 1) * this._spaceWidth : e.visibleRangeForPosition(new V(h, m.column)).left;
        if (_ > n || this._maxIndentLeft > 0 && _ > this._maxIndentLeft)
          break;
        const b = m.horizontalLine ? m.horizontalLine.top ? "horizontal-top" : "horizontal-bottom" : "vertical", C = m.horizontalLine ? (((c = e.visibleRangeForPosition(new V(h, m.horizontalLine.endColumn))) == null ? void 0 : c.left) ?? _ + this._spaceWidth) - _ : this._spaceWidth;
        f += `<div class="core-guide ${m.className} ${b}" style="left:${_}px;width:${C}px"></div>`;
      }
      a[d] = f;
    }
    this._renderResult = a;
  }
  getGuidesByLine(e, t, i) {
    const n = this._bracketPairGuideOptions.bracketPairs !== !1 ? this._context.viewModel.getBracketGuidesInRangeByLine(e, t, i, {
      highlightActive: this._bracketPairGuideOptions.highlightActiveBracketPair,
      horizontalGuides: this._bracketPairGuideOptions.bracketPairsHorizontal === !0 ? Jl.Enabled : this._bracketPairGuideOptions.bracketPairsHorizontal === "active" ? Jl.EnabledForActive : Jl.Disabled,
      includeInactive: this._bracketPairGuideOptions.bracketPairs === !0
    }) : null, o = this._bracketPairGuideOptions.indentation ? this._context.viewModel.getLinesIndentGuides(e, t) : null;
    let r = 0, a = 0, l = 0;
    if (this._bracketPairGuideOptions.highlightActiveIndentation !== !1 && i) {
      const d = this._context.viewModel.getActiveIndentGuide(i.lineNumber, e, t);
      r = d.startLineNumber, a = d.endLineNumber, l = d.indent;
    }
    const { indentSize: c } = this._context.viewModel.model.getOptions(), h = [];
    for (let d = e; d <= t; d++) {
      const u = new Array();
      h.push(u);
      const f = n ? n[d - e] : [], g = new Gr(f), m = o ? o[d - e] : 0;
      for (let _ = 1; _ <= m; _++) {
        const b = (_ - 1) * c + 1, C = (
          // Disable active indent guide if there are bracket guides.
          (this._bracketPairGuideOptions.highlightActiveIndentation === "always" || f.length === 0) && r <= d && d <= a && _ === l
        );
        u.push(...g.takeWhile((w) => w.visibleColumn < b) || []);
        const v = g.peek();
        (!v || v.visibleColumn !== b || v.horizontalLine) && u.push(new Kl(b, -1, `core-guide-indent lvl-${(_ - 1) % 30}` + (C ? " indent-active" : ""), null, -1, -1));
      }
      u.push(...g.takeWhile((_) => !0) || []);
    }
    return h;
  }
  render(e, t) {
    if (!this._renderResult)
      return "";
    const i = t - e;
    return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
  }
}
function oh(s) {
  if (!(s && s.isTransparent()))
    return s;
}
Jr((s, e) => {
  const t = [
    { bracketColor: PA, guideColor: jz, guideColorActive: Jz },
    { bracketColor: OA, guideColor: Gz, guideColorActive: eU },
    { bracketColor: FA, guideColor: Zz, guideColorActive: tU },
    { bracketColor: BA, guideColor: Yz, guideColorActive: iU },
    { bracketColor: WA, guideColor: Qz, guideColorActive: nU },
    { bracketColor: VA, guideColor: Xz, guideColorActive: sU }
  ], i = new YA(), n = [
    { indentColor: zg, indentColorActive: Ug },
    { indentColor: Dz, indentColorActive: Mz },
    { indentColor: Ez, indentColorActive: Rz },
    { indentColor: Iz, indentColorActive: Az },
    { indentColor: Nz, indentColorActive: Pz },
    { indentColor: Tz, indentColorActive: Oz }
  ], o = t.map((a) => {
    const l = s.getColor(a.bracketColor), c = s.getColor(a.guideColor), h = s.getColor(a.guideColorActive), d = oh(oh(c) ?? (l == null ? void 0 : l.transparent(0.3))), u = oh(oh(h) ?? l);
    if (!(!d || !u))
      return {
        guideColor: d,
        guideColorActive: u
      };
  }).filter(gd), r = n.map((a) => {
    const l = s.getColor(a.indentColor), c = s.getColor(a.indentColorActive), h = oh(l), d = oh(c);
    if (!(!h || !d))
      return {
        indentColor: h,
        indentColorActive: d
      };
  }).filter(gd);
  if (o.length > 0) {
    for (let a = 0; a < 30; a++) {
      const l = o[a % o.length];
      e.addRule(`.monaco-editor .${i.getInlineClassNameOfLevel(a).replace(/ /g, ".")} { --guide-color: ${l.guideColor}; --guide-color-active: ${l.guideColorActive}; }`);
    }
    e.addRule(".monaco-editor .vertical { box-shadow: 1px 0 0 0 var(--guide-color) inset; }"), e.addRule(".monaco-editor .horizontal-top { border-top: 1px solid var(--guide-color); }"), e.addRule(".monaco-editor .horizontal-bottom { border-bottom: 1px solid var(--guide-color); }"), e.addRule(`.monaco-editor .vertical.${i.activeClassName} { box-shadow: 1px 0 0 0 var(--guide-color-active) inset; }`), e.addRule(`.monaco-editor .horizontal-top.${i.activeClassName} { border-top: 1px solid var(--guide-color-active); }`), e.addRule(`.monaco-editor .horizontal-bottom.${i.activeClassName} { border-bottom: 1px solid var(--guide-color-active); }`);
  }
  if (r.length > 0) {
    for (let a = 0; a < 30; a++) {
      const l = r[a % r.length];
      e.addRule(`.monaco-editor .lines-content .core-guide-indent.lvl-${a} { --indent-color: ${l.indentColor}; --indent-color-active: ${l.indentColorActive}; }`);
    }
    e.addRule(".monaco-editor .lines-content .core-guide-indent { box-shadow: 1px 0 0 0 var(--indent-color) inset; }"), e.addRule(".monaco-editor .lines-content .core-guide-indent.indent-active { box-shadow: 1px 0 0 0 var(--indent-color-active) inset; }");
  }
});
class bC {
  get didDomLayout() {
    return this._didDomLayout;
  }
  readClientRect() {
    if (!this._clientRectRead) {
      this._clientRectRead = !0;
      const e = this._domNode.getBoundingClientRect();
      this.markDidDomLayout(), this._clientRectDeltaLeft = e.left, this._clientRectScale = e.width / this._domNode.offsetWidth;
    }
  }
  get clientRectDeltaLeft() {
    return this._clientRectRead || this.readClientRect(), this._clientRectDeltaLeft;
  }
  get clientRectScale() {
    return this._clientRectRead || this.readClientRect(), this._clientRectScale;
  }
  constructor(e, t) {
    this._domNode = e, this.endNode = t, this._didDomLayout = !1, this._clientRectDeltaLeft = 0, this._clientRectScale = 1, this._clientRectRead = !1;
  }
  markDidDomLayout() {
    this._didDomLayout = !0;
  }
}
class zZ {
  constructor() {
    this._currentVisibleRange = new R(1, 1, 1, 1);
  }
  getCurrentVisibleRange() {
    return this._currentVisibleRange;
  }
  setCurrentVisibleRange(e) {
    this._currentVisibleRange = e;
  }
}
class UZ {
  constructor(e, t, i, n, o, r, a) {
    this.minimalReveal = e, this.lineNumber = t, this.startColumn = i, this.endColumn = n, this.startScrollTop = o, this.stopScrollTop = r, this.scrollType = a, this.type = "range", this.minLineNumber = t, this.maxLineNumber = t;
  }
}
class $Z {
  constructor(e, t, i, n, o) {
    this.minimalReveal = e, this.selections = t, this.startScrollTop = i, this.stopScrollTop = n, this.scrollType = o, this.type = "selections";
    let r = t[0].startLineNumber, a = t[0].endLineNumber;
    for (let l = 1, c = t.length; l < c; l++) {
      const h = t[l];
      r = Math.min(r, h.startLineNumber), a = Math.max(a, h.endLineNumber);
    }
    this.minLineNumber = r, this.maxLineNumber = a;
  }
}
const H1 = class H1 extends Hn {
  constructor(e, t) {
    super(e);
    const i = this._context.configuration, n = this._context.configuration.options, o = n.get(
      50
      /* EditorOption.fontInfo */
    ), r = n.get(
      147
      /* EditorOption.wrappingInfo */
    );
    this._lineHeight = n.get(
      67
      /* EditorOption.lineHeight */
    ), this._typicalHalfwidthCharacterWidth = o.typicalHalfwidthCharacterWidth, this._isViewportWrapping = r.isViewportWrapping, this._revealHorizontalRightPadding = n.get(
      101
      /* EditorOption.revealHorizontalRightPadding */
    ), this._cursorSurroundingLines = n.get(
      29
      /* EditorOption.cursorSurroundingLines */
    ), this._cursorSurroundingLinesStyle = n.get(
      30
      /* EditorOption.cursorSurroundingLinesStyle */
    ), this._canUseLayerHinting = !n.get(
      32
      /* EditorOption.disableLayerHinting */
    ), this._viewLineOptions = new rT(i, this._context.theme.type), this._linesContent = t, this._textRangeRestingSpot = document.createElement("div"), this._visibleLines = new o5({
      createLine: () => new Nr(this._viewLineOptions)
    }), this.domNode = this._visibleLines.domNode, ho.write(
      this.domNode,
      8
      /* PartFingerprint.ViewLines */
    ), this.domNode.setClassName(`view-lines ${ld}`), Fi(this.domNode, o), this._maxLineWidth = 0, this._asyncUpdateLineWidths = new sn(() => {
      this._updateLineWidthsSlow();
    }, 200), this._asyncCheckMonospaceFontAssumptions = new sn(() => {
      this._checkMonospaceFontAssumptions();
    }, 2e3), this._lastRenderedData = new zZ(), this._horizontalRevealRequest = null, this._stickyScrollEnabled = n.get(
      116
      /* EditorOption.stickyScroll */
    ).enabled, this._maxNumberStickyLines = n.get(
      116
      /* EditorOption.stickyScroll */
    ).maxLineCount;
  }
  dispose() {
    this._asyncUpdateLineWidths.dispose(), this._asyncCheckMonospaceFontAssumptions.dispose(), super.dispose();
  }
  getDomNode() {
    return this.domNode;
  }
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    this._visibleLines.onConfigurationChanged(e), e.hasChanged(
      147
      /* EditorOption.wrappingInfo */
    ) && (this._maxLineWidth = 0);
    const t = this._context.configuration.options, i = t.get(
      50
      /* EditorOption.fontInfo */
    ), n = t.get(
      147
      /* EditorOption.wrappingInfo */
    );
    return this._lineHeight = t.get(
      67
      /* EditorOption.lineHeight */
    ), this._typicalHalfwidthCharacterWidth = i.typicalHalfwidthCharacterWidth, this._isViewportWrapping = n.isViewportWrapping, this._revealHorizontalRightPadding = t.get(
      101
      /* EditorOption.revealHorizontalRightPadding */
    ), this._cursorSurroundingLines = t.get(
      29
      /* EditorOption.cursorSurroundingLines */
    ), this._cursorSurroundingLinesStyle = t.get(
      30
      /* EditorOption.cursorSurroundingLinesStyle */
    ), this._canUseLayerHinting = !t.get(
      32
      /* EditorOption.disableLayerHinting */
    ), this._stickyScrollEnabled = t.get(
      116
      /* EditorOption.stickyScroll */
    ).enabled, this._maxNumberStickyLines = t.get(
      116
      /* EditorOption.stickyScroll */
    ).maxLineCount, Fi(this.domNode, i), this._onOptionsMaybeChanged(), e.hasChanged(
      146
      /* EditorOption.layoutInfo */
    ) && (this._maxLineWidth = 0), !0;
  }
  _onOptionsMaybeChanged() {
    const e = this._context.configuration, t = new rT(e, this._context.theme.type);
    if (!this._viewLineOptions.equals(t)) {
      this._viewLineOptions = t;
      const i = this._visibleLines.getStartLineNumber(), n = this._visibleLines.getEndLineNumber();
      for (let o = i; o <= n; o++)
        this._visibleLines.getVisibleLine(o).onOptionsChanged(this._viewLineOptions);
      return !0;
    }
    return !1;
  }
  onCursorStateChanged(e) {
    const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
    let n = !1;
    for (let o = t; o <= i; o++)
      n = this._visibleLines.getVisibleLine(o).onSelectionChanged() || n;
    return n;
  }
  onDecorationsChanged(e) {
    {
      const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
      for (let n = t; n <= i; n++)
        this._visibleLines.getVisibleLine(n).onDecorationsChanged();
    }
    return !0;
  }
  onFlushed(e) {
    const t = this._visibleLines.onFlushed(e);
    return this._maxLineWidth = 0, t;
  }
  onLinesChanged(e) {
    return this._visibleLines.onLinesChanged(e);
  }
  onLinesDeleted(e) {
    return this._visibleLines.onLinesDeleted(e);
  }
  onLinesInserted(e) {
    return this._visibleLines.onLinesInserted(e);
  }
  onRevealRangeRequest(e) {
    const t = this._computeScrollTopToRevealRange(this._context.viewLayout.getFutureViewport(), e.source, e.minimalReveal, e.range, e.selections, e.verticalType);
    if (t === -1)
      return !1;
    let i = this._context.viewLayout.validateScrollPosition({ scrollTop: t });
    e.revealHorizontal ? e.range && e.range.startLineNumber !== e.range.endLineNumber ? i = {
      scrollTop: i.scrollTop,
      scrollLeft: 0
    } : e.range ? this._horizontalRevealRequest = new UZ(e.minimalReveal, e.range.startLineNumber, e.range.startColumn, e.range.endColumn, this._context.viewLayout.getCurrentScrollTop(), i.scrollTop, e.scrollType) : e.selections && e.selections.length > 0 && (this._horizontalRevealRequest = new $Z(e.minimalReveal, e.selections, this._context.viewLayout.getCurrentScrollTop(), i.scrollTop, e.scrollType)) : this._horizontalRevealRequest = null;
    const o = Math.abs(this._context.viewLayout.getCurrentScrollTop() - i.scrollTop) <= this._lineHeight ? 1 : e.scrollType;
    return this._context.viewModel.viewLayout.setScrollPosition(i, o), !0;
  }
  onScrollChanged(e) {
    if (this._horizontalRevealRequest && e.scrollLeftChanged && (this._horizontalRevealRequest = null), this._horizontalRevealRequest && e.scrollTopChanged) {
      const t = Math.min(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop), i = Math.max(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);
      (e.scrollTop < t || e.scrollTop > i) && (this._horizontalRevealRequest = null);
    }
    return this.domNode.setWidth(e.scrollWidth), this._visibleLines.onScrollChanged(e) || !0;
  }
  onTokensChanged(e) {
    return this._visibleLines.onTokensChanged(e);
  }
  onZonesChanged(e) {
    return this._context.viewModel.viewLayout.setMaxLineWidth(this._maxLineWidth), this._visibleLines.onZonesChanged(e);
  }
  onThemeChanged(e) {
    return this._onOptionsMaybeChanged();
  }
  // ---- end view event handlers
  // ----------- HELPERS FOR OTHERS
  getPositionFromDOMInfo(e, t) {
    const i = this._getViewLineDomNode(e);
    if (i === null)
      return null;
    const n = this._getLineNumberFor(i);
    if (n === -1 || n < 1 || n > this._context.viewModel.getLineCount())
      return null;
    if (this._context.viewModel.getLineMaxColumn(n) === 1)
      return new V(n, 1);
    const o = this._visibleLines.getStartLineNumber(), r = this._visibleLines.getEndLineNumber();
    if (n < o || n > r)
      return null;
    let a = this._visibleLines.getVisibleLine(n).getColumnOfNodeOffset(e, t);
    const l = this._context.viewModel.getLineMinColumn(n);
    return a < l && (a = l), new V(n, a);
  }
  _getViewLineDomNode(e) {
    for (; e && e.nodeType === 1; ) {
      if (e.className === Nr.CLASS_NAME)
        return e;
      e = e.parentElement;
    }
    return null;
  }
  /**
   * @returns the line number of this view line dom node.
   */
  _getLineNumberFor(e) {
    const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
    for (let n = t; n <= i; n++) {
      const o = this._visibleLines.getVisibleLine(n);
      if (e === o.getDomNode())
        return n;
    }
    return -1;
  }
  getLineWidth(e) {
    const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
    if (e < t || e > i)
      return -1;
    const n = new bC(this.domNode.domNode, this._textRangeRestingSpot), o = this._visibleLines.getVisibleLine(e).getWidth(n);
    return this._updateLineWidthsSlowIfDomDidLayout(n), o;
  }
  linesVisibleRangesForRange(e, t) {
    if (this.shouldRender())
      return null;
    const i = e.endLineNumber, n = R.intersectRanges(e, this._lastRenderedData.getCurrentVisibleRange());
    if (!n)
      return null;
    const o = [];
    let r = 0;
    const a = new bC(this.domNode.domNode, this._textRangeRestingSpot);
    let l = 0;
    t && (l = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new V(n.startLineNumber, 1)).lineNumber);
    const c = this._visibleLines.getStartLineNumber(), h = this._visibleLines.getEndLineNumber();
    for (let d = n.startLineNumber; d <= n.endLineNumber; d++) {
      if (d < c || d > h)
        continue;
      const u = d === n.startLineNumber ? n.startColumn : 1, f = d !== n.endLineNumber, g = f ? this._context.viewModel.getLineMaxColumn(d) : n.endColumn, m = this._visibleLines.getVisibleLine(d).getVisibleRangesForRange(d, u, g, a);
      if (m) {
        if (t && d < i) {
          const _ = l;
          l = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new V(d + 1, 1)).lineNumber, _ !== l && (m.ranges[m.ranges.length - 1].width += this._typicalHalfwidthCharacterWidth);
        }
        o[r++] = new DG(m.outsideRenderedLine, d, Xb.from(m.ranges), f);
      }
    }
    return this._updateLineWidthsSlowIfDomDidLayout(a), r === 0 ? null : o;
  }
  _visibleRangesForLineRange(e, t, i) {
    if (this.shouldRender() || e < this._visibleLines.getStartLineNumber() || e > this._visibleLines.getEndLineNumber())
      return null;
    const n = new bC(this.domNode.domNode, this._textRangeRestingSpot), o = this._visibleLines.getVisibleLine(e).getVisibleRangesForRange(e, t, i, n);
    return this._updateLineWidthsSlowIfDomDidLayout(n), o;
  }
  visibleRangeForPosition(e) {
    const t = this._visibleRangesForLineRange(e.lineNumber, e.column, e.column);
    return t ? new EG(t.outsideRenderedLine, t.ranges[0].left) : null;
  }
  /**
   * Updates the max line width if it is fast to compute.
   * Returns true if all lines were taken into account.
   * Returns false if some lines need to be reevaluated (in a slow fashion).
   */
  _updateLineWidthsFast() {
    return this._updateLineWidths(!0);
  }
  _updateLineWidthsSlow() {
    this._updateLineWidths(!1);
  }
  /**
   * Update the line widths using DOM layout information after someone else
   * has caused a synchronous layout.
   */
  _updateLineWidthsSlowIfDomDidLayout(e) {
    e.didDomLayout && (this._asyncUpdateLineWidths.isScheduled() || (this._asyncUpdateLineWidths.cancel(), this._updateLineWidthsSlow()));
  }
  _updateLineWidths(e) {
    const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
    let n = 1, o = !0;
    for (let r = t; r <= i; r++) {
      const a = this._visibleLines.getVisibleLine(r);
      if (e && !a.getWidthIsFast()) {
        o = !1;
        continue;
      }
      n = Math.max(n, a.getWidth(null));
    }
    return o && t === 1 && i === this._context.viewModel.getLineCount() && (this._maxLineWidth = 0), this._ensureMaxLineWidth(n), o;
  }
  _checkMonospaceFontAssumptions() {
    let e = -1, t = -1;
    const i = this._visibleLines.getStartLineNumber(), n = this._visibleLines.getEndLineNumber();
    for (let o = i; o <= n; o++) {
      const r = this._visibleLines.getVisibleLine(o);
      if (r.needsMonospaceFontCheck()) {
        const a = r.getWidth(null);
        a > t && (t = a, e = o);
      }
    }
    if (e !== -1 && !this._visibleLines.getVisibleLine(e).monospaceAssumptionsAreValid())
      for (let o = i; o <= n; o++)
        this._visibleLines.getVisibleLine(o).onMonospaceAssumptionsInvalidated();
  }
  prepareRender() {
    throw new Error("Not supported");
  }
  render() {
    throw new Error("Not supported");
  }
  renderText(e) {
    if (this._visibleLines.renderLines(e), this._lastRenderedData.setCurrentVisibleRange(e.visibleRange), this.domNode.setWidth(this._context.viewLayout.getScrollWidth()), this.domNode.setHeight(Math.min(this._context.viewLayout.getScrollHeight(), 1e6)), this._horizontalRevealRequest) {
      const i = this._horizontalRevealRequest;
      if (e.startLineNumber <= i.minLineNumber && i.maxLineNumber <= e.endLineNumber) {
        this._horizontalRevealRequest = null, this.onDidRender();
        const n = this._computeScrollLeftToReveal(i);
        n && (this._isViewportWrapping || this._ensureMaxLineWidth(n.maxHorizontalOffset), this._context.viewModel.viewLayout.setScrollPosition({
          scrollLeft: n.scrollLeft
        }, i.scrollType));
      }
    }
    if (this._updateLineWidthsFast() ? this._asyncUpdateLineWidths.cancel() : this._asyncUpdateLineWidths.schedule(), wn && !this._asyncCheckMonospaceFontAssumptions.isScheduled()) {
      const i = this._visibleLines.getStartLineNumber(), n = this._visibleLines.getEndLineNumber();
      for (let o = i; o <= n; o++)
        if (this._visibleLines.getVisibleLine(o).needsMonospaceFontCheck()) {
          this._asyncCheckMonospaceFontAssumptions.schedule();
          break;
        }
    }
    this._linesContent.setLayerHinting(this._canUseLayerHinting), this._linesContent.setContain("strict");
    const t = this._context.viewLayout.getCurrentScrollTop() - e.bigNumbersDelta;
    this._linesContent.setTop(-t), this._linesContent.setLeft(-this._context.viewLayout.getCurrentScrollLeft());
  }
  // --- width
  _ensureMaxLineWidth(e) {
    const t = Math.ceil(e);
    this._maxLineWidth < t && (this._maxLineWidth = t, this._context.viewModel.viewLayout.setMaxLineWidth(this._maxLineWidth));
  }
  _computeScrollTopToRevealRange(e, t, i, n, o, r) {
    const a = e.top, l = e.height, c = a + l;
    let h, d, u;
    if (o && o.length > 0) {
      let b = o[0].startLineNumber, C = o[0].endLineNumber;
      for (let v = 1, w = o.length; v < w; v++) {
        const S = o[v];
        b = Math.min(b, S.startLineNumber), C = Math.max(C, S.endLineNumber);
      }
      h = !1, d = this._context.viewLayout.getVerticalOffsetForLineNumber(b), u = this._context.viewLayout.getVerticalOffsetForLineNumber(C) + this._lineHeight;
    } else if (n)
      h = !0, d = this._context.viewLayout.getVerticalOffsetForLineNumber(n.startLineNumber), u = this._context.viewLayout.getVerticalOffsetForLineNumber(n.endLineNumber) + this._lineHeight;
    else
      return -1;
    const f = (t === "mouse" || i) && this._cursorSurroundingLinesStyle === "default";
    let g = 0, m = 0;
    if (f)
      i || (g = this._lineHeight);
    else {
      const b = l / this._lineHeight, C = Math.max(this._cursorSurroundingLines, this._stickyScrollEnabled ? this._maxNumberStickyLines : 0), v = Math.min(b / 2, C);
      g = v * this._lineHeight, m = Math.max(0, v - 1) * this._lineHeight;
    }
    i || (r === 0 || r === 4) && (m += this._lineHeight), d -= g, u += m;
    let _;
    if (u - d > l) {
      if (!h)
        return -1;
      _ = d;
    } else if (r === 5 || r === 6)
      if (r === 6 && a <= d && u <= c)
        _ = a;
      else {
        const b = Math.max(5 * this._lineHeight, l * 0.2), C = d - b, v = u - l;
        _ = Math.max(v, C);
      }
    else if (r === 1 || r === 2)
      if (r === 2 && a <= d && u <= c)
        _ = a;
      else {
        const b = (d + u) / 2;
        _ = Math.max(0, b - l / 2);
      }
    else
      _ = this._computeMinimumScrolling(
        a,
        c,
        d,
        u,
        r === 3,
        r === 4
        /* viewEvents.VerticalRevealType.Bottom */
      );
    return _;
  }
  _computeScrollLeftToReveal(e) {
    const t = this._context.viewLayout.getCurrentViewport(), i = this._context.configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    ), n = t.left, o = n + t.width - i.verticalScrollbarWidth;
    let r = 1073741824, a = 0;
    if (e.type === "range") {
      const c = this._visibleRangesForLineRange(e.lineNumber, e.startColumn, e.endColumn);
      if (!c)
        return null;
      for (const h of c.ranges)
        r = Math.min(r, Math.round(h.left)), a = Math.max(a, Math.round(h.left + h.width));
    } else
      for (const c of e.selections) {
        if (c.startLineNumber !== c.endLineNumber)
          return null;
        const h = this._visibleRangesForLineRange(c.startLineNumber, c.startColumn, c.endColumn);
        if (!h)
          return null;
        for (const d of h.ranges)
          r = Math.min(r, Math.round(d.left)), a = Math.max(a, Math.round(d.left + d.width));
      }
    return e.minimalReveal || (r = Math.max(0, r - H1.HORIZONTAL_EXTRA_PX), a += this._revealHorizontalRightPadding), e.type === "selections" && a - r > t.width ? null : {
      scrollLeft: this._computeMinimumScrolling(n, o, r, a),
      maxHorizontalOffset: a
    };
  }
  _computeMinimumScrolling(e, t, i, n, o, r) {
    e = e | 0, t = t | 0, i = i | 0, n = n | 0, o = !!o, r = !!r;
    const a = t - e;
    if (n - i < a) {
      if (o)
        return i;
      if (r)
        return Math.max(0, n - a);
      if (i < e)
        return i;
      if (n > t)
        return Math.max(0, n - a);
    } else
      return i;
    return e;
  }
};
H1.HORIZONTAL_EXTRA_PX = 30;
let TS = H1;
class KZ extends l5 {
  constructor(e) {
    super(), this._context = e;
    const i = this._context.configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    );
    this._decorationsLeft = i.decorationsLeft, this._decorationsWidth = i.decorationsWidth, this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const i = this._context.configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    );
    return this._decorationsLeft = i.decorationsLeft, this._decorationsWidth = i.decorationsWidth, !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  _getDecorations(e) {
    const t = e.getDecorationsInViewport(), i = [];
    let n = 0;
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o], l = a.options.linesDecorationsClassName, c = a.options.zIndex;
      l && (i[n++] = new NS(a.range.startLineNumber, a.range.endLineNumber, l, a.options.linesDecorationsTooltip ?? null, c));
      const h = a.options.firstLineDecorationClassName;
      h && (i[n++] = new NS(a.range.startLineNumber, a.range.startLineNumber, h, a.options.linesDecorationsTooltip ?? null, c));
    }
    return i;
  }
  prepareRender(e) {
    const t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber, n = this._render(t, i, this._getDecorations(e)), o = this._decorationsLeft.toString(), r = this._decorationsWidth.toString(), a = '" style="left:' + o + "px;width:" + r + 'px;"></div>', l = [];
    for (let c = t; c <= i; c++) {
      const h = c - t, d = n[h].getDecorations();
      let u = "";
      for (const f of d) {
        let g = '<div class="cldr ' + f.className;
        f.tooltip !== null && (g += '" title="' + f.tooltip), g += a, u += g;
      }
      l[h] = u;
    }
    this._renderResult = l;
  }
  render(e, t) {
    return this._renderResult ? this._renderResult[t - e] : "";
  }
}
class qZ extends l5 {
  constructor(e) {
    super(), this._context = e, this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    return !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  _getDecorations(e) {
    const t = e.getDecorationsInViewport(), i = [];
    let n = 0;
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o], l = a.options.marginClassName, c = a.options.zIndex;
      l && (i[n++] = new NS(a.range.startLineNumber, a.range.endLineNumber, l, null, c));
    }
    return i;
  }
  prepareRender(e) {
    const t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber, n = this._render(t, i, this._getDecorations(e)), o = [];
    for (let r = t; r <= i; r++) {
      const a = r - t, l = n[a].getDecorations();
      let c = "";
      for (const h of l)
        c += '<div class="cmdr ' + h.className + '" style=""></div>';
      o[a] = c;
    }
    this._renderResult = o;
  }
  render(e, t) {
    return this._renderResult ? this._renderResult[t - e] : "";
  }
}
const _a = class _a {
  constructor(e, t, i, n) {
    this._rgba8Brand = void 0, this.r = _a._clamp(e), this.g = _a._clamp(t), this.b = _a._clamp(i), this.a = _a._clamp(n);
  }
  equals(e) {
    return this.r === e.r && this.g === e.g && this.b === e.b && this.a === e.a;
  }
  static _clamp(e) {
    return e < 0 ? 0 : e > 255 ? 255 : e | 0;
  }
};
_a.Empty = new _a(0, 0, 0, 0);
let jr = _a;
const z1 = class z1 extends q {
  static getInstance() {
    return this._INSTANCE || (this._INSTANCE = new z1()), this._INSTANCE;
  }
  constructor() {
    super(), this._onDidChange = new O(), this.onDidChange = this._onDidChange.event, this._updateColorMap(), this._register(Yt.onDidChange((e) => {
      e.changedColorMap && this._updateColorMap();
    }));
  }
  _updateColorMap() {
    const e = Yt.getColorMap();
    if (!e) {
      this._colors = [jr.Empty], this._backgroundIsLight = !0;
      return;
    }
    this._colors = [jr.Empty];
    for (let i = 1; i < e.length; i++) {
      const n = e[i].rgba;
      this._colors[i] = new jr(n.r, n.g, n.b, Math.round(n.a * 255));
    }
    const t = e[
      2
      /* ColorId.DefaultBackground */
    ].getRelativeLuminance();
    this._backgroundIsLight = t >= 0.5, this._onDidChange.fire(void 0);
  }
  getColor(e) {
    return (e < 1 || e >= this._colors.length) && (e = 2), this._colors[e];
  }
  backgroundIsLight() {
    return this._backgroundIsLight;
  }
};
z1._INSTANCE = null;
let z_ = z1;
const jZ = (() => {
  const s = [];
  for (let e = 32; e <= 126; e++)
    s.push(e);
  return s.push(
    65533
    /* Constants.UNKNOWN_CODE */
  ), s;
})(), GZ = (s, e) => (s -= 32, s < 0 || s > 96 ? e <= 2 ? (s + 96) % 96 : 95 : s);
class fg {
  constructor(e, t) {
    this.scale = t, this._minimapCharRendererBrand = void 0, this.charDataNormal = fg.soften(e, 12 / 15), this.charDataLight = fg.soften(e, 50 / 60);
  }
  static soften(e, t) {
    const i = new Uint8ClampedArray(e.length);
    for (let n = 0, o = e.length; n < o; n++)
      i[n] = Rp(e[n] * t);
    return i;
  }
  renderChar(e, t, i, n, o, r, a, l, c, h, d) {
    const u = 1 * this.scale, f = 2 * this.scale, g = d ? 1 : f;
    if (t + u > e.width || i + g > e.height) {
      console.warn("bad render request outside image data");
      return;
    }
    const m = h ? this.charDataLight : this.charDataNormal, _ = GZ(n, c), b = e.width * 4, C = a.r, v = a.g, w = a.b, S = o.r - C, L = o.g - v, k = o.b - w, D = Math.max(r, l), E = e.data;
    let U = _ * u * f, P = i * b + t * 4;
    for (let B = 0; B < g; B++) {
      let W = P;
      for (let A = 0; A < u; A++) {
        const K = m[U++] / 255 * (r / 255);
        E[W++] = C + S * K, E[W++] = v + L * K, E[W++] = w + k * K, E[W++] = D;
      }
      P += b;
    }
  }
  blockRenderChar(e, t, i, n, o, r, a, l) {
    const c = 1 * this.scale, h = 2 * this.scale, d = l ? 1 : h;
    if (t + c > e.width || i + d > e.height) {
      console.warn("bad render request outside image data");
      return;
    }
    const u = e.width * 4, f = 0.5 * (o / 255), g = r.r, m = r.g, _ = r.b, b = n.r - g, C = n.g - m, v = n.b - _, w = g + b * f, S = m + C * f, L = _ + v * f, k = Math.max(o, a), D = e.data;
    let E = i * u + t * 4;
    for (let U = 0; U < d; U++) {
      let P = E;
      for (let B = 0; B < c; B++)
        D[P++] = w, D[P++] = S, D[P++] = L, D[P++] = k;
      E += u;
    }
  }
}
const _T = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  A: 10,
  B: 11,
  C: 12,
  D: 13,
  E: 14,
  F: 15
}, bT = (s) => {
  const e = new Uint8ClampedArray(s.length / 2);
  for (let t = 0; t < s.length; t += 2)
    e[t >> 1] = _T[s[t]] << 4 | _T[s[t + 1]] & 15;
  return e;
}, CT = {
  1: pd(() => bT("0000511D6300CF609C709645A78432005642574171487021003C451900274D35D762755E8B629C5BA856AF57BA649530C167D1512A272A3F6038604460398526BCA2A968DB6F8957C768BE5FBE2FB467CF5D8D5B795DC7625B5DFF50DE64C466DB2FC47CD860A65E9A2EB96CB54CE06DA763AB2EA26860524D3763536601005116008177A8705E53AB738E6A982F88BAA35B5F5B626D9C636B449B737E5B7B678598869A662F6B5B8542706C704C80736A607578685B70594A49715A4522E792")),
  2: pd(() => bT("000000000000000055394F383D2800008B8B1F210002000081B1CBCBCC820000847AAF6B9AAF2119BE08B8881AD60000A44FD07DCCF107015338130C00000000385972265F390B406E2437634B4B48031B12B8A0847000001E15B29A402F0000000000004B33460B00007A752C2A0000000000004D3900000084394B82013400ABA5CFC7AD9C0302A45A3E5A98AB000089A43382D97900008BA54AA087A70A0248A6A7AE6DBE0000BF6F94987EA40A01A06DCFA7A7A9030496C32F77891D0000A99FB1A0AFA80603B29AB9CA75930D010C0948354D3900000C0948354F37460D0028BE673D8400000000AF9D7B6E00002B007AA8933400007AA642675C2700007984CFB9C3985B768772A8A6B7B20000CAAECAAFC4B700009F94A6009F840009D09F9BA4CA9C0000CC8FC76DC87F0000C991C472A2000000A894A48CA7B501079BA2C9C69BA20000B19A5D3FA89000005CA6009DA2960901B0A7F0669FB200009D009E00B7890000DAD0F5D092820000D294D4C48BD10000B5A7A4A3B1A50402CAB6CBA6A2000000B5A7A4A3B1A8044FCDADD19D9CB00000B7778F7B8AAE0803C9AB5D3F5D3F00009EA09EA0BAB006039EA0989A8C7900009B9EF4D6B7C00000A9A7816CACA80000ABAC84705D3F000096DA635CDC8C00006F486F266F263D4784006124097B00374F6D2D6D2D6D4A3A95872322000000030000000000008D8939130000000000002E22A5C9CBC70600AB25C0B5C9B400061A2DB04CA67001082AA6BEBEBFC606002321DACBC19E03087AA08B6768380000282FBAC0B8CA7A88AD25BBA5A29900004C396C5894A6000040485A6E356E9442A32CD17EADA70000B4237923628600003E2DE9C1D7B500002F25BBA5A2990000231DB6AFB4A804023025C0B5CAB588062B2CBDBEC0C706882435A75CA20000002326BD6A82A908048B4B9A5A668000002423A09CB4BB060025259C9D8A7900001C1FCAB2C7C700002A2A9387ABA200002626A4A47D6E9D14333163A0C87500004B6F9C2D643A257049364936493647358A34438355497F1A0000A24C1D590000D38DFFBDD4CD3126"))
};
class lf {
  /**
   * Creates a new character renderer factory with the given scale.
   */
  static create(e, t) {
    if (this.lastCreated && e === this.lastCreated.scale && t === this.lastFontFamily)
      return this.lastCreated;
    let i;
    return CT[e] ? i = new fg(CT[e](), e) : i = lf.createFromSampleData(lf.createSampleData(t).data, e), this.lastFontFamily = t, this.lastCreated = i, i;
  }
  /**
   * Creates the font sample data, writing to a canvas.
   */
  static createSampleData(e) {
    const t = document.createElement("canvas"), i = t.getContext("2d");
    t.style.height = "16px", t.height = 16, t.width = 960, t.style.width = "960px", i.fillStyle = "#ffffff", i.font = `bold 16px ${e}`, i.textBaseline = "middle";
    let n = 0;
    for (const o of jZ)
      i.fillText(String.fromCharCode(o), n, 16 / 2), n += 10;
    return i.getImageData(
      0,
      0,
      960,
      16
      /* Constants.SAMPLED_CHAR_HEIGHT */
    );
  }
  /**
   * Creates a character renderer from the canvas sample data.
   */
  static createFromSampleData(e, t) {
    if (e.length !== 61440)
      throw new Error("Unexpected source in MinimapCharRenderer");
    const n = lf._downsample(e, t);
    return new fg(n, t);
  }
  static _downsampleChar(e, t, i, n, o) {
    const r = 1 * o, a = 2 * o;
    let l = n, c = 0;
    for (let h = 0; h < a; h++) {
      const d = h / a * 16, u = (h + 1) / a * 16;
      for (let f = 0; f < r; f++) {
        const g = f / r * 10, m = (f + 1) / r * 10;
        let _ = 0, b = 0;
        for (let v = d; v < u; v++) {
          const w = t + Math.floor(v) * 3840, S = 1 - (v - Math.floor(v));
          for (let L = g; L < m; L++) {
            const k = 1 - (L - Math.floor(L)), D = w + Math.floor(L) * 4, E = k * S;
            b += E, _ += e[D] * e[D + 3] / 255 * E;
          }
        }
        const C = _ / b;
        c = Math.max(c, C), i[l++] = Rp(C);
      }
    }
    return c;
  }
  static _downsample(e, t) {
    const i = 2 * t * 1 * t, n = i * 96, o = new Uint8ClampedArray(n);
    let r = 0, a = 0, l = 0;
    for (let c = 0; c < 96; c++)
      l = Math.max(l, this._downsampleChar(e, a, o, r, t)), r += i, a += 40;
    if (l > 0) {
      const c = 255 / l;
      for (let h = 0; h < n; h++)
        o[h] *= c;
    }
    return o;
  }
}
const ZZ = Fn ? '"Segoe WPC", "Segoe UI", sans-serif' : He ? "-apple-system, BlinkMacSystemFont, sans-serif" : 'system-ui, "Ubuntu", "Droid Sans", sans-serif', YZ = 140, QZ = 2;
class cd {
  constructor(e, t, i) {
    const n = e.options, o = n.get(
      144
      /* EditorOption.pixelRatio */
    ), r = n.get(
      146
      /* EditorOption.layoutInfo */
    ), a = r.minimap, l = n.get(
      50
      /* EditorOption.fontInfo */
    ), c = n.get(
      73
      /* EditorOption.minimap */
    );
    this.renderMinimap = a.renderMinimap, this.size = c.size, this.minimapHeightIsEditorHeight = a.minimapHeightIsEditorHeight, this.scrollBeyondLastLine = n.get(
      106
      /* EditorOption.scrollBeyondLastLine */
    ), this.paddingTop = n.get(
      84
      /* EditorOption.padding */
    ).top, this.paddingBottom = n.get(
      84
      /* EditorOption.padding */
    ).bottom, this.showSlider = c.showSlider, this.autohide = c.autohide, this.pixelRatio = o, this.typicalHalfwidthCharacterWidth = l.typicalHalfwidthCharacterWidth, this.lineHeight = n.get(
      67
      /* EditorOption.lineHeight */
    ), this.minimapLeft = a.minimapLeft, this.minimapWidth = a.minimapWidth, this.minimapHeight = r.height, this.canvasInnerWidth = a.minimapCanvasInnerWidth, this.canvasInnerHeight = a.minimapCanvasInnerHeight, this.canvasOuterWidth = a.minimapCanvasOuterWidth, this.canvasOuterHeight = a.minimapCanvasOuterHeight, this.isSampling = a.minimapIsSampling, this.editorHeight = r.height, this.fontScale = a.minimapScale, this.minimapLineHeight = a.minimapLineHeight, this.minimapCharWidth = 1 * this.fontScale, this.sectionHeaderFontFamily = ZZ, this.sectionHeaderFontSize = c.sectionHeaderFontSize * o, this.sectionHeaderLetterSpacing = c.sectionHeaderLetterSpacing, this.sectionHeaderFontColor = cd._getSectionHeaderColor(t, i.getColor(
      1
      /* ColorId.DefaultForeground */
    )), this.charRenderer = pd(() => lf.create(this.fontScale, l.fontFamily)), this.defaultBackgroundColor = i.getColor(
      2
      /* ColorId.DefaultBackground */
    ), this.backgroundColor = cd._getMinimapBackground(t, this.defaultBackgroundColor), this.foregroundAlpha = cd._getMinimapForegroundOpacity(t);
  }
  static _getMinimapBackground(e, t) {
    const i = e.getColor(v8);
    return i ? new jr(i.rgba.r, i.rgba.g, i.rgba.b, Math.round(255 * i.rgba.a)) : t;
  }
  static _getMinimapForegroundOpacity(e) {
    const t = e.getColor(y8);
    return t ? jr._clamp(Math.round(255 * t.rgba.a)) : 255;
  }
  static _getSectionHeaderColor(e, t) {
    const i = e.getColor(Mg);
    return i ? new jr(i.rgba.r, i.rgba.g, i.rgba.b, Math.round(255 * i.rgba.a)) : t;
  }
  equals(e) {
    return this.renderMinimap === e.renderMinimap && this.size === e.size && this.minimapHeightIsEditorHeight === e.minimapHeightIsEditorHeight && this.scrollBeyondLastLine === e.scrollBeyondLastLine && this.paddingTop === e.paddingTop && this.paddingBottom === e.paddingBottom && this.showSlider === e.showSlider && this.autohide === e.autohide && this.pixelRatio === e.pixelRatio && this.typicalHalfwidthCharacterWidth === e.typicalHalfwidthCharacterWidth && this.lineHeight === e.lineHeight && this.minimapLeft === e.minimapLeft && this.minimapWidth === e.minimapWidth && this.minimapHeight === e.minimapHeight && this.canvasInnerWidth === e.canvasInnerWidth && this.canvasInnerHeight === e.canvasInnerHeight && this.canvasOuterWidth === e.canvasOuterWidth && this.canvasOuterHeight === e.canvasOuterHeight && this.isSampling === e.isSampling && this.editorHeight === e.editorHeight && this.fontScale === e.fontScale && this.minimapLineHeight === e.minimapLineHeight && this.minimapCharWidth === e.minimapCharWidth && this.sectionHeaderFontSize === e.sectionHeaderFontSize && this.sectionHeaderLetterSpacing === e.sectionHeaderLetterSpacing && this.defaultBackgroundColor && this.defaultBackgroundColor.equals(e.defaultBackgroundColor) && this.backgroundColor && this.backgroundColor.equals(e.backgroundColor) && this.foregroundAlpha === e.foregroundAlpha;
  }
}
class cf {
  constructor(e, t, i, n, o, r, a, l, c) {
    this.scrollTop = e, this.scrollHeight = t, this.sliderNeeded = i, this._computedSliderRatio = n, this.sliderTop = o, this.sliderHeight = r, this.topPaddingLineCount = a, this.startLineNumber = l, this.endLineNumber = c;
  }
  /**
   * Compute a desired `scrollPosition` such that the slider moves by `delta`.
   */
  getDesiredScrollTopFromDelta(e) {
    return Math.round(this.scrollTop + e / this._computedSliderRatio);
  }
  getDesiredScrollTopFromTouchLocation(e) {
    return Math.round((e - this.sliderHeight / 2) / this._computedSliderRatio);
  }
  /**
   * Intersect a line range with `this.startLineNumber` and `this.endLineNumber`.
   */
  intersectWithViewport(e) {
    const t = Math.max(this.startLineNumber, e.startLineNumber), i = Math.min(this.endLineNumber, e.endLineNumber);
    return t > i ? null : [t, i];
  }
  /**
   * Get the inner minimap y coordinate for a line number.
   */
  getYForLineNumber(e, t) {
    return +(e - this.startLineNumber + this.topPaddingLineCount) * t;
  }
  static create(e, t, i, n, o, r, a, l, c, h, d) {
    const u = e.pixelRatio, f = e.minimapLineHeight, g = Math.floor(e.canvasInnerHeight / f), m = e.lineHeight;
    if (e.minimapHeightIsEditorHeight) {
      let L = l * e.lineHeight + e.paddingTop + e.paddingBottom;
      e.scrollBeyondLastLine && (L += Math.max(0, o - e.lineHeight - e.paddingBottom));
      const k = Math.max(1, Math.floor(o * o / L)), D = Math.max(0, e.minimapHeight - k), E = D / (h - o), U = c * E, P = D > 0, B = Math.floor(e.canvasInnerHeight / e.minimapLineHeight), W = Math.floor(e.paddingTop / e.lineHeight);
      return new cf(c, h, P, E, U, k, W, 1, Math.min(a, B));
    }
    let _;
    if (r && i !== a) {
      const L = i - t + 1;
      _ = Math.floor(L * f / u);
    } else {
      const L = o / m;
      _ = Math.floor(L * f / u);
    }
    const b = Math.floor(e.paddingTop / m);
    let C = Math.floor(e.paddingBottom / m);
    if (e.scrollBeyondLastLine) {
      const L = o / m;
      C = Math.max(C, L - 1);
    }
    let v;
    if (C > 0) {
      const L = o / m;
      v = (b + a + C - L - 1) * f / u;
    } else
      v = Math.max(0, (b + a) * f / u - _);
    v = Math.min(e.minimapHeight - _, v);
    const w = v / (h - o), S = c * w;
    if (g >= b + a + C) {
      const L = v > 0;
      return new cf(c, h, L, w, S, _, b, 1, a);
    } else {
      let L;
      t > 1 ? L = t + b : L = Math.max(1, c / m);
      let k, D = Math.max(1, Math.floor(L - S * u / f));
      D < b ? (k = b - D + 1, D = 1) : (k = 0, D = Math.max(1, D - b)), d && d.scrollHeight === h && (d.scrollTop > c && (D = Math.min(D, d.startLineNumber), k = Math.max(k, d.topPaddingLineCount)), d.scrollTop < c && (D = Math.max(D, d.startLineNumber), k = Math.min(k, d.topPaddingLineCount)));
      const E = Math.min(a, D - k + g - 1), U = (c - n) / m;
      let P;
      return c >= e.paddingTop ? P = (t - D + k + U) * f / u : P = c / e.paddingTop * (k + U) * f / u, new cf(c, h, !0, w, P, _, k, D, E);
    }
  }
}
const U1 = class U1 {
  constructor(e) {
    this.dy = e;
  }
  onContentChanged() {
    this.dy = -1;
  }
  onTokensChanged() {
    this.dy = -1;
  }
};
U1.INVALID = new U1(-1);
let U_ = U1;
class wT {
  constructor(e, t, i) {
    this.renderedLayout = e, this._imageData = t, this._renderedLines = new s5({
      createLine: () => U_.INVALID
    }), this._renderedLines._set(e.startLineNumber, i);
  }
  /**
   * Check if the current RenderData matches accurately the new desired layout and no painting is needed.
   */
  linesEquals(e) {
    if (!this.scrollEquals(e))
      return !1;
    const i = this._renderedLines._get().lines;
    for (let n = 0, o = i.length; n < o; n++)
      if (i[n].dy === -1)
        return !1;
    return !0;
  }
  /**
   * Check if the current RenderData matches the new layout's scroll position
   */
  scrollEquals(e) {
    return this.renderedLayout.startLineNumber === e.startLineNumber && this.renderedLayout.endLineNumber === e.endLineNumber;
  }
  _get() {
    const e = this._renderedLines._get();
    return {
      imageData: this._imageData,
      rendLineNumberStart: e.rendLineNumberStart,
      lines: e.lines
    };
  }
  onLinesChanged(e, t) {
    return this._renderedLines.onLinesChanged(e, t);
  }
  onLinesDeleted(e, t) {
    this._renderedLines.onLinesDeleted(e, t);
  }
  onLinesInserted(e, t) {
    this._renderedLines.onLinesInserted(e, t);
  }
  onTokensChanged(e) {
    return this._renderedLines.onTokensChanged(e);
  }
}
class Ex {
  constructor(e, t, i, n) {
    this._backgroundFillData = Ex._createBackgroundFillData(t, i, n), this._buffers = [
      e.createImageData(t, i),
      e.createImageData(t, i)
    ], this._lastUsedBuffer = 0;
  }
  getBuffer() {
    this._lastUsedBuffer = 1 - this._lastUsedBuffer;
    const e = this._buffers[this._lastUsedBuffer];
    return e.data.set(this._backgroundFillData), e;
  }
  static _createBackgroundFillData(e, t, i) {
    const n = i.r, o = i.g, r = i.b, a = i.a, l = new Uint8ClampedArray(e * t * 4);
    let c = 0;
    for (let h = 0; h < t; h++)
      for (let d = 0; d < e; d++)
        l[c] = n, l[c + 1] = o, l[c + 2] = r, l[c + 3] = a, c += 4;
    return l;
  }
}
class gg {
  static compute(e, t, i) {
    if (e.renderMinimap === 0 || !e.isSampling)
      return [null, []];
    const { minimapLineCount: n } = Hh.computeContainedMinimapLineCount({
      viewLineCount: t,
      scrollBeyondLastLine: e.scrollBeyondLastLine,
      paddingTop: e.paddingTop,
      paddingBottom: e.paddingBottom,
      height: e.editorHeight,
      lineHeight: e.lineHeight,
      pixelRatio: e.pixelRatio
    }), o = t / n, r = o / 2;
    if (!i || i.minimapLines.length === 0) {
      const _ = [];
      if (_[0] = 1, n > 1) {
        for (let b = 0, C = n - 1; b < C; b++)
          _[b] = Math.round(b * o + r);
        _[n - 1] = t;
      }
      return [new gg(o, _), []];
    }
    const a = i.minimapLines, l = a.length, c = [];
    let h = 0, d = 0, u = 1;
    const f = 10;
    let g = [], m = null;
    for (let _ = 0; _ < n; _++) {
      const b = Math.max(u, Math.round(_ * o)), C = Math.max(b, Math.round((_ + 1) * o));
      for (; h < l && a[h] < b; ) {
        if (g.length < f) {
          const w = h + 1 + d;
          m && m.type === "deleted" && m._oldIndex === h - 1 ? m.deleteToLineNumber++ : (m = { type: "deleted", _oldIndex: h, deleteFromLineNumber: w, deleteToLineNumber: w }, g.push(m)), d--;
        }
        h++;
      }
      let v;
      if (h < l && a[h] <= C)
        v = a[h], h++;
      else if (_ === 0 ? v = 1 : _ + 1 === n ? v = t : v = Math.round(_ * o + r), g.length < f) {
        const w = h + 1 + d;
        m && m.type === "inserted" && m._i === _ - 1 ? m.insertToLineNumber++ : (m = { type: "inserted", _i: _, insertFromLineNumber: w, insertToLineNumber: w }, g.push(m)), d++;
      }
      c[_] = v, u = v;
    }
    if (g.length < f)
      for (; h < l; ) {
        const _ = h + 1 + d;
        m && m.type === "deleted" && m._oldIndex === h - 1 ? m.deleteToLineNumber++ : (m = { type: "deleted", _oldIndex: h, deleteFromLineNumber: _, deleteToLineNumber: _ }, g.push(m)), d--, h++;
      }
    else
      g = [{ type: "flush" }];
    return [new gg(o, c), g];
  }
  constructor(e, t) {
    this.samplingRatio = e, this.minimapLines = t;
  }
  modelLineToMinimapLine(e) {
    return Math.min(this.minimapLines.length, Math.max(1, Math.round(e / this.samplingRatio)));
  }
  /**
   * Will return null if the model line ranges are not intersecting with a sampled model line.
   */
  modelLineRangeToMinimapLineRange(e, t) {
    let i = this.modelLineToMinimapLine(e) - 1;
    for (; i > 0 && this.minimapLines[i - 1] >= e; )
      i--;
    let n = this.modelLineToMinimapLine(t) - 1;
    for (; n + 1 < this.minimapLines.length && this.minimapLines[n + 1] <= t; )
      n++;
    if (i === n) {
      const o = this.minimapLines[i];
      if (o < e || o > t)
        return null;
    }
    return [i + 1, n + 1];
  }
  /**
   * Will always return a range, even if it is not intersecting with a sampled model line.
   */
  decorationLineRangeToMinimapLineRange(e, t) {
    let i = this.modelLineToMinimapLine(e), n = this.modelLineToMinimapLine(t);
    return e !== t && n === i && (n === this.minimapLines.length ? i > 1 && i-- : n++), [i, n];
  }
  onLinesDeleted(e) {
    const t = e.toLineNumber - e.fromLineNumber + 1;
    let i = this.minimapLines.length, n = 0;
    for (let o = this.minimapLines.length - 1; o >= 0 && !(this.minimapLines[o] < e.fromLineNumber); o--)
      this.minimapLines[o] <= e.toLineNumber ? (this.minimapLines[o] = Math.max(1, e.fromLineNumber - 1), i = Math.min(i, o), n = Math.max(n, o)) : this.minimapLines[o] -= t;
    return [i, n];
  }
  onLinesInserted(e) {
    const t = e.toLineNumber - e.fromLineNumber + 1;
    for (let i = this.minimapLines.length - 1; i >= 0 && !(this.minimapLines[i] < e.fromLineNumber); i--)
      this.minimapLines[i] += t;
  }
}
class XZ extends Hn {
  constructor(e) {
    super(e), this._sectionHeaderCache = new Tg(10, 1.5), this.tokensColorTracker = z_.getInstance(), this._selections = [], this._minimapSelections = null, this.options = new cd(this._context.configuration, this._context.theme, this.tokensColorTracker);
    const [t] = gg.compute(this.options, this._context.viewModel.getLineCount(), null);
    this._samplingState = t, this._shouldCheckSampling = !1, this._actual = new Dh(e.theme, this);
  }
  dispose() {
    this._actual.dispose(), super.dispose();
  }
  getDomNode() {
    return this._actual.getDomNode();
  }
  _onOptionsMaybeChanged() {
    const e = new cd(this._context.configuration, this._context.theme, this.tokensColorTracker);
    return this.options.equals(e) ? !1 : (this.options = e, this._recreateLineSampling(), this._actual.onDidChangeOptions(), !0);
  }
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    return this._onOptionsMaybeChanged();
  }
  onCursorStateChanged(e) {
    return this._selections = e.selections, this._minimapSelections = null, this._actual.onSelectionChanged();
  }
  onDecorationsChanged(e) {
    return e.affectsMinimap ? this._actual.onDecorationsChanged() : !1;
  }
  onFlushed(e) {
    return this._samplingState && (this._shouldCheckSampling = !0), this._actual.onFlushed();
  }
  onLinesChanged(e) {
    if (this._samplingState) {
      const t = this._samplingState.modelLineRangeToMinimapLineRange(e.fromLineNumber, e.fromLineNumber + e.count - 1);
      return t ? this._actual.onLinesChanged(t[0], t[1] - t[0] + 1) : !1;
    } else
      return this._actual.onLinesChanged(e.fromLineNumber, e.count);
  }
  onLinesDeleted(e) {
    if (this._samplingState) {
      const [t, i] = this._samplingState.onLinesDeleted(e);
      return t <= i && this._actual.onLinesChanged(t + 1, i - t + 1), this._shouldCheckSampling = !0, !0;
    } else
      return this._actual.onLinesDeleted(e.fromLineNumber, e.toLineNumber);
  }
  onLinesInserted(e) {
    return this._samplingState ? (this._samplingState.onLinesInserted(e), this._shouldCheckSampling = !0, !0) : this._actual.onLinesInserted(e.fromLineNumber, e.toLineNumber);
  }
  onScrollChanged(e) {
    return this._actual.onScrollChanged();
  }
  onThemeChanged(e) {
    return this._actual.onThemeChanged(), this._onOptionsMaybeChanged(), !0;
  }
  onTokensChanged(e) {
    if (this._samplingState) {
      const t = [];
      for (const i of e.ranges) {
        const n = this._samplingState.modelLineRangeToMinimapLineRange(i.fromLineNumber, i.toLineNumber);
        n && t.push({ fromLineNumber: n[0], toLineNumber: n[1] });
      }
      return t.length ? this._actual.onTokensChanged(t) : !1;
    } else
      return this._actual.onTokensChanged(e.ranges);
  }
  onTokensColorsChanged(e) {
    return this._onOptionsMaybeChanged(), this._actual.onTokensColorsChanged();
  }
  onZonesChanged(e) {
    return this._actual.onZonesChanged();
  }
  // --- end event handlers
  prepareRender(e) {
    this._shouldCheckSampling && (this._shouldCheckSampling = !1, this._recreateLineSampling());
  }
  render(e) {
    let t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber;
    this._samplingState && (t = this._samplingState.modelLineToMinimapLine(t), i = this._samplingState.modelLineToMinimapLine(i));
    const n = {
      viewportContainsWhitespaceGaps: e.viewportData.whitespaceViewportData.length > 0,
      scrollWidth: e.scrollWidth,
      scrollHeight: e.scrollHeight,
      viewportStartLineNumber: t,
      viewportEndLineNumber: i,
      viewportStartLineNumberVerticalOffset: e.getVerticalOffsetForLineNumber(t),
      scrollTop: e.scrollTop,
      scrollLeft: e.scrollLeft,
      viewportWidth: e.viewportWidth,
      viewportHeight: e.viewportHeight
    };
    this._actual.render(n);
  }
  //#region IMinimapModel
  _recreateLineSampling() {
    this._minimapSelections = null;
    const e = !!this._samplingState, [t, i] = gg.compute(this.options, this._context.viewModel.getLineCount(), this._samplingState);
    if (this._samplingState = t, e && this._samplingState)
      for (const n of i)
        switch (n.type) {
          case "deleted":
            this._actual.onLinesDeleted(n.deleteFromLineNumber, n.deleteToLineNumber);
            break;
          case "inserted":
            this._actual.onLinesInserted(n.insertFromLineNumber, n.insertToLineNumber);
            break;
          case "flush":
            this._actual.onFlushed();
            break;
        }
  }
  getLineCount() {
    return this._samplingState ? this._samplingState.minimapLines.length : this._context.viewModel.getLineCount();
  }
  getRealLineCount() {
    return this._context.viewModel.getLineCount();
  }
  getLineContent(e) {
    return this._samplingState ? this._context.viewModel.getLineContent(this._samplingState.minimapLines[e - 1]) : this._context.viewModel.getLineContent(e);
  }
  getLineMaxColumn(e) {
    return this._samplingState ? this._context.viewModel.getLineMaxColumn(this._samplingState.minimapLines[e - 1]) : this._context.viewModel.getLineMaxColumn(e);
  }
  getMinimapLinesRenderingData(e, t, i) {
    if (this._samplingState) {
      const n = [];
      for (let o = 0, r = t - e + 1; o < r; o++)
        i[o] ? n[o] = this._context.viewModel.getViewLineData(this._samplingState.minimapLines[e + o - 1]) : n[o] = null;
      return n;
    }
    return this._context.viewModel.getMinimapLinesRenderingData(e, t, i).data;
  }
  getSelections() {
    if (this._minimapSelections === null)
      if (this._samplingState) {
        this._minimapSelections = [];
        for (const e of this._selections) {
          const [t, i] = this._samplingState.decorationLineRangeToMinimapLineRange(e.startLineNumber, e.endLineNumber);
          this._minimapSelections.push(new ft(t, e.startColumn, i, e.endColumn));
        }
      } else
        this._minimapSelections = this._selections;
    return this._minimapSelections;
  }
  getMinimapDecorationsInViewport(e, t) {
    const i = this._getMinimapDecorationsInViewport(e, t).filter((n) => {
      var o;
      return !((o = n.options.minimap) != null && o.sectionHeaderStyle);
    });
    if (this._samplingState) {
      const n = [];
      for (const o of i) {
        if (!o.options.minimap)
          continue;
        const r = o.range, a = this._samplingState.modelLineToMinimapLine(r.startLineNumber), l = this._samplingState.modelLineToMinimapLine(r.endLineNumber);
        n.push(new K4(new R(a, r.startColumn, l, r.endColumn), o.options));
      }
      return n;
    }
    return i;
  }
  getSectionHeaderDecorationsInViewport(e, t) {
    const i = this.options.minimapLineHeight, o = this.options.sectionHeaderFontSize / i;
    return e = Math.floor(Math.max(1, e - o)), this._getMinimapDecorationsInViewport(e, t).filter((r) => {
      var a;
      return !!((a = r.options.minimap) != null && a.sectionHeaderStyle);
    });
  }
  _getMinimapDecorationsInViewport(e, t) {
    let i;
    if (this._samplingState) {
      const n = this._samplingState.minimapLines[e - 1], o = this._samplingState.minimapLines[t - 1];
      i = new R(n, 1, o, this._context.viewModel.getLineMaxColumn(o));
    } else
      i = new R(e, 1, t, this._context.viewModel.getLineMaxColumn(t));
    return this._context.viewModel.getMinimapDecorationsInRange(i);
  }
  getSectionHeaderText(e, t) {
    var r;
    const i = (r = e.options.minimap) == null ? void 0 : r.sectionHeaderText;
    if (!i)
      return null;
    const n = this._sectionHeaderCache.get(i);
    if (n)
      return n;
    const o = t(i);
    return this._sectionHeaderCache.set(i, o), o;
  }
  getOptions() {
    return this._context.viewModel.model.getOptions();
  }
  revealLineNumber(e) {
    this._samplingState && (e = this._samplingState.minimapLines[e - 1]), this._context.viewModel.revealRange(
      "mouse",
      !1,
      new R(e, 1, e, 1),
      1,
      0
      /* ScrollType.Smooth */
    );
  }
  setScrollTop(e) {
    this._context.viewModel.viewLayout.setScrollPosition(
      {
        scrollTop: e
      },
      1
      /* ScrollType.Immediate */
    );
  }
}
class Dh extends q {
  constructor(e, t) {
    super(), this._renderDecorations = !1, this._gestureInProgress = !1, this._theme = e, this._model = t, this._lastRenderData = null, this._buffers = null, this._selectionColor = this._theme.getColor(iI), this._domNode = je(document.createElement("div")), ho.write(
      this._domNode,
      9
      /* PartFingerprint.Minimap */
    ), this._domNode.setClassName(this._getMinimapDomNodeClassName()), this._domNode.setPosition("absolute"), this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true"), this._shadow = je(document.createElement("div")), this._shadow.setClassName("minimap-shadow-hidden"), this._domNode.appendChild(this._shadow), this._canvas = je(document.createElement("canvas")), this._canvas.setPosition("absolute"), this._canvas.setLeft(0), this._domNode.appendChild(this._canvas), this._decorationsCanvas = je(document.createElement("canvas")), this._decorationsCanvas.setPosition("absolute"), this._decorationsCanvas.setClassName("minimap-decorations-layer"), this._decorationsCanvas.setLeft(0), this._domNode.appendChild(this._decorationsCanvas), this._slider = je(document.createElement("div")), this._slider.setPosition("absolute"), this._slider.setClassName("minimap-slider"), this._slider.setLayerHinting(!0), this._slider.setContain("strict"), this._domNode.appendChild(this._slider), this._sliderHorizontal = je(document.createElement("div")), this._sliderHorizontal.setPosition("absolute"), this._sliderHorizontal.setClassName("minimap-slider-horizontal"), this._slider.appendChild(this._sliderHorizontal), this._applyLayout(), this._pointerDownListener = fi(this._domNode.domNode, ee.POINTER_DOWN, (i) => {
      if (i.preventDefault(), this._model.options.renderMinimap === 0 || !this._lastRenderData)
        return;
      if (this._model.options.size !== "proportional") {
        if (i.button === 0 && this._lastRenderData) {
          const c = gs(this._slider.domNode), h = c.top + c.height / 2;
          this._startSliderDragging(i, h, this._lastRenderData.renderedLayout);
        }
        return;
      }
      const o = this._model.options.minimapLineHeight, r = this._model.options.canvasInnerHeight / this._model.options.canvasOuterHeight * i.offsetY;
      let l = Math.floor(r / o) + this._lastRenderData.renderedLayout.startLineNumber - this._lastRenderData.renderedLayout.topPaddingLineCount;
      l = Math.min(l, this._model.getLineCount()), this._model.revealLineNumber(l);
    }), this._sliderPointerMoveMonitor = new kb(), this._sliderPointerDownListener = fi(this._slider.domNode, ee.POINTER_DOWN, (i) => {
      i.preventDefault(), i.stopPropagation(), i.button === 0 && this._lastRenderData && this._startSliderDragging(i, i.pageY, this._lastRenderData.renderedLayout);
    }), this._gestureDisposable = an.addTarget(this._domNode.domNode), this._sliderTouchStartListener = $(this._domNode.domNode, bt.Start, (i) => {
      i.preventDefault(), i.stopPropagation(), this._lastRenderData && (this._slider.toggleClassName("active", !0), this._gestureInProgress = !0, this.scrollDueToTouchEvent(i));
    }, { passive: !1 }), this._sliderTouchMoveListener = $(this._domNode.domNode, bt.Change, (i) => {
      i.preventDefault(), i.stopPropagation(), this._lastRenderData && this._gestureInProgress && this.scrollDueToTouchEvent(i);
    }, { passive: !1 }), this._sliderTouchEndListener = fi(this._domNode.domNode, bt.End, (i) => {
      i.preventDefault(), i.stopPropagation(), this._gestureInProgress = !1, this._slider.toggleClassName("active", !1);
    });
  }
  _startSliderDragging(e, t, i) {
    if (!e.target || !(e.target instanceof Element))
      return;
    const n = e.pageX;
    this._slider.toggleClassName("active", !0);
    const o = (r, a) => {
      const l = gs(this._domNode.domNode), c = Math.min(Math.abs(a - n), Math.abs(a - l.left), Math.abs(a - l.left - l.width));
      if (Fn && c > YZ) {
        this._model.setScrollTop(i.scrollTop);
        return;
      }
      const h = r - t;
      this._model.setScrollTop(i.getDesiredScrollTopFromDelta(h));
    };
    e.pageY !== t && o(e.pageY, n), this._sliderPointerMoveMonitor.startMonitoring(e.target, e.pointerId, e.buttons, (r) => o(r.pageY, r.pageX), () => {
      this._slider.toggleClassName("active", !1);
    });
  }
  scrollDueToTouchEvent(e) {
    const t = this._domNode.domNode.getBoundingClientRect().top, i = this._lastRenderData.renderedLayout.getDesiredScrollTopFromTouchLocation(e.pageY - t);
    this._model.setScrollTop(i);
  }
  dispose() {
    this._pointerDownListener.dispose(), this._sliderPointerMoveMonitor.dispose(), this._sliderPointerDownListener.dispose(), this._gestureDisposable.dispose(), this._sliderTouchStartListener.dispose(), this._sliderTouchMoveListener.dispose(), this._sliderTouchEndListener.dispose(), super.dispose();
  }
  _getMinimapDomNodeClassName() {
    const e = ["minimap"];
    return this._model.options.showSlider === "always" ? e.push("slider-always") : e.push("slider-mouseover"), this._model.options.autohide && e.push("autohide"), e.join(" ");
  }
  getDomNode() {
    return this._domNode;
  }
  _applyLayout() {
    this._domNode.setLeft(this._model.options.minimapLeft), this._domNode.setWidth(this._model.options.minimapWidth), this._domNode.setHeight(this._model.options.minimapHeight), this._shadow.setHeight(this._model.options.minimapHeight), this._canvas.setWidth(this._model.options.canvasOuterWidth), this._canvas.setHeight(this._model.options.canvasOuterHeight), this._canvas.domNode.width = this._model.options.canvasInnerWidth, this._canvas.domNode.height = this._model.options.canvasInnerHeight, this._decorationsCanvas.setWidth(this._model.options.canvasOuterWidth), this._decorationsCanvas.setHeight(this._model.options.canvasOuterHeight), this._decorationsCanvas.domNode.width = this._model.options.canvasInnerWidth, this._decorationsCanvas.domNode.height = this._model.options.canvasInnerHeight, this._slider.setWidth(this._model.options.minimapWidth);
  }
  _getBuffer() {
    return this._buffers || this._model.options.canvasInnerWidth > 0 && this._model.options.canvasInnerHeight > 0 && (this._buffers = new Ex(this._canvas.domNode.getContext("2d"), this._model.options.canvasInnerWidth, this._model.options.canvasInnerHeight, this._model.options.backgroundColor)), this._buffers ? this._buffers.getBuffer() : null;
  }
  // ---- begin view event handlers
  onDidChangeOptions() {
    this._lastRenderData = null, this._buffers = null, this._applyLayout(), this._domNode.setClassName(this._getMinimapDomNodeClassName());
  }
  onSelectionChanged() {
    return this._renderDecorations = !0, !0;
  }
  onDecorationsChanged() {
    return this._renderDecorations = !0, !0;
  }
  onFlushed() {
    return this._lastRenderData = null, !0;
  }
  onLinesChanged(e, t) {
    return this._lastRenderData ? this._lastRenderData.onLinesChanged(e, t) : !1;
  }
  onLinesDeleted(e, t) {
    var i;
    return (i = this._lastRenderData) == null || i.onLinesDeleted(e, t), !0;
  }
  onLinesInserted(e, t) {
    var i;
    return (i = this._lastRenderData) == null || i.onLinesInserted(e, t), !0;
  }
  onScrollChanged() {
    return this._renderDecorations = !0, !0;
  }
  onThemeChanged() {
    return this._selectionColor = this._theme.getColor(iI), this._renderDecorations = !0, !0;
  }
  onTokensChanged(e) {
    return this._lastRenderData ? this._lastRenderData.onTokensChanged(e) : !1;
  }
  onTokensColorsChanged() {
    return this._lastRenderData = null, this._buffers = null, !0;
  }
  onZonesChanged() {
    return this._lastRenderData = null, !0;
  }
  // --- end event handlers
  render(e) {
    if (this._model.options.renderMinimap === 0) {
      this._shadow.setClassName("minimap-shadow-hidden"), this._sliderHorizontal.setWidth(0), this._sliderHorizontal.setHeight(0);
      return;
    }
    e.scrollLeft + e.viewportWidth >= e.scrollWidth ? this._shadow.setClassName("minimap-shadow-hidden") : this._shadow.setClassName("minimap-shadow-visible");
    const i = cf.create(this._model.options, e.viewportStartLineNumber, e.viewportEndLineNumber, e.viewportStartLineNumberVerticalOffset, e.viewportHeight, e.viewportContainsWhitespaceGaps, this._model.getLineCount(), this._model.getRealLineCount(), e.scrollTop, e.scrollHeight, this._lastRenderData ? this._lastRenderData.renderedLayout : null);
    this._slider.setDisplay(i.sliderNeeded ? "block" : "none"), this._slider.setTop(i.sliderTop), this._slider.setHeight(i.sliderHeight), this._sliderHorizontal.setLeft(0), this._sliderHorizontal.setWidth(this._model.options.minimapWidth), this._sliderHorizontal.setTop(0), this._sliderHorizontal.setHeight(i.sliderHeight), this.renderDecorations(i), this._lastRenderData = this.renderLines(i);
  }
  renderDecorations(e) {
    if (this._renderDecorations) {
      this._renderDecorations = !1;
      const t = this._model.getSelections();
      t.sort(R.compareRangesUsingStarts);
      const i = this._model.getMinimapDecorationsInViewport(e.startLineNumber, e.endLineNumber);
      i.sort((u, f) => (u.options.zIndex || 0) - (f.options.zIndex || 0));
      const { canvasInnerWidth: n, canvasInnerHeight: o } = this._model.options, r = this._model.options.minimapLineHeight, a = this._model.options.minimapCharWidth, l = this._model.getOptions().tabSize, c = this._decorationsCanvas.domNode.getContext("2d");
      c.clearRect(0, 0, n, o);
      const h = new vT(e.startLineNumber, e.endLineNumber, !1);
      this._renderSelectionLineHighlights(c, t, h, e, r), this._renderDecorationsLineHighlights(c, i, h, e, r);
      const d = new vT(e.startLineNumber, e.endLineNumber, null);
      this._renderSelectionsHighlights(c, t, d, e, r, l, a, n), this._renderDecorationsHighlights(c, i, d, e, r, l, a, n), this._renderSectionHeaders(e);
    }
  }
  _renderSelectionLineHighlights(e, t, i, n, o) {
    if (!this._selectionColor || this._selectionColor.isTransparent())
      return;
    e.fillStyle = this._selectionColor.transparent(0.5).toString();
    let r = 0, a = 0;
    for (const l of t) {
      const c = n.intersectWithViewport(l);
      if (!c)
        continue;
      const [h, d] = c;
      for (let g = h; g <= d; g++)
        i.set(g, !0);
      const u = n.getYForLineNumber(h, o), f = n.getYForLineNumber(d, o);
      a >= u || (a > r && e.fillRect(So, r, e.canvas.width, a - r), r = u), a = f;
    }
    a > r && e.fillRect(So, r, e.canvas.width, a - r);
  }
  _renderDecorationsLineHighlights(e, t, i, n, o) {
    const r = /* @__PURE__ */ new Map();
    for (let a = t.length - 1; a >= 0; a--) {
      const l = t[a], c = l.options.minimap;
      if (!c || c.position !== 1)
        continue;
      const h = n.intersectWithViewport(l.range);
      if (!h)
        continue;
      const [d, u] = h, f = c.getColor(this._theme.value);
      if (!f || f.isTransparent())
        continue;
      let g = r.get(f.toString());
      g || (g = f.transparent(0.5).toString(), r.set(f.toString(), g)), e.fillStyle = g;
      for (let m = d; m <= u; m++) {
        if (i.has(m))
          continue;
        i.set(m, !0);
        const _ = n.getYForLineNumber(d, o);
        e.fillRect(So, _, e.canvas.width, o);
      }
    }
  }
  _renderSelectionsHighlights(e, t, i, n, o, r, a, l) {
    if (!(!this._selectionColor || this._selectionColor.isTransparent()))
      for (const c of t) {
        const h = n.intersectWithViewport(c);
        if (!h)
          continue;
        const [d, u] = h;
        for (let f = d; f <= u; f++)
          this.renderDecorationOnLine(e, i, c, this._selectionColor, n, f, o, o, r, a, l);
      }
  }
  _renderDecorationsHighlights(e, t, i, n, o, r, a, l) {
    for (const c of t) {
      const h = c.options.minimap;
      if (!h)
        continue;
      const d = n.intersectWithViewport(c.range);
      if (!d)
        continue;
      const [u, f] = d, g = h.getColor(this._theme.value);
      if (!(!g || g.isTransparent()))
        for (let m = u; m <= f; m++)
          switch (h.position) {
            case 1:
              this.renderDecorationOnLine(e, i, c.range, g, n, m, o, o, r, a, l);
              continue;
            case 2: {
              const _ = n.getYForLineNumber(m, o);
              this.renderDecoration(e, g, 2, _, QZ, o);
              continue;
            }
          }
    }
  }
  renderDecorationOnLine(e, t, i, n, o, r, a, l, c, h, d) {
    const u = o.getYForLineNumber(r, l);
    if (u + a < 0 || u > this._model.options.canvasInnerHeight)
      return;
    const { startLineNumber: f, endLineNumber: g } = i, m = f === r ? i.startColumn : 1, _ = g === r ? i.endColumn : this._model.getLineMaxColumn(r), b = this.getXOffsetForPosition(t, r, m, c, h, d), C = this.getXOffsetForPosition(t, r, _, c, h, d);
    this.renderDecoration(e, n, b, u, C - b, a);
  }
  getXOffsetForPosition(e, t, i, n, o, r) {
    if (i === 1)
      return So;
    if ((i - 1) * o >= r)
      return r;
    let l = e.get(t);
    if (!l) {
      const c = this._model.getLineContent(t);
      l = [So];
      let h = So;
      for (let d = 1; d < c.length + 1; d++) {
        const u = c.charCodeAt(d - 1), f = u === 9 ? n * o : za(u) ? 2 * o : o, g = h + f;
        if (g >= r) {
          l[d] = r;
          break;
        }
        l[d] = g, h = g;
      }
      e.set(t, l);
    }
    return i - 1 < l.length ? l[i - 1] : r;
  }
  renderDecoration(e, t, i, n, o, r) {
    e.fillStyle = t && t.toString() || "", e.fillRect(i, n, o, r);
  }
  _renderSectionHeaders(e) {
    var m;
    const t = this._model.options.minimapLineHeight, i = this._model.options.sectionHeaderFontSize, n = this._model.options.sectionHeaderLetterSpacing, o = i * 1.5, { canvasInnerWidth: r } = this._model.options, a = this._model.options.backgroundColor, l = `rgb(${a.r} ${a.g} ${a.b} / .7)`, c = this._model.options.sectionHeaderFontColor, h = `rgb(${c.r} ${c.g} ${c.b})`, d = h, u = this._decorationsCanvas.domNode.getContext("2d");
    u.letterSpacing = n + "px", u.font = "500 " + i + "px " + this._model.options.sectionHeaderFontFamily, u.strokeStyle = d, u.lineWidth = 0.2;
    const f = this._model.getSectionHeaderDecorationsInViewport(e.startLineNumber, e.endLineNumber);
    f.sort((_, b) => _.range.startLineNumber - b.range.startLineNumber);
    const g = Dh._fitSectionHeader.bind(null, u, r - So);
    for (const _ of f) {
      const b = e.getYForLineNumber(_.range.startLineNumber, t) + i, C = b - i, v = C + 2, w = this._model.getSectionHeaderText(_, g);
      Dh._renderSectionLabel(u, w, ((m = _.options.minimap) == null ? void 0 : m.sectionHeaderStyle) === 2, l, h, r, C, o, b, v);
    }
  }
  static _fitSectionHeader(e, t, i) {
    if (!i)
      return i;
    const n = "…", o = e.measureText(i).width, r = e.measureText(n).width;
    if (o <= t || o <= r)
      return i;
    const a = i.length, l = o / i.length, c = Math.floor((t - r) / l) - 1;
    let h = Math.ceil(c / 2);
    for (; h > 0 && /\s/.test(i[h - 1]); )
      --h;
    return i.substring(0, h) + n + i.substring(a - (c - h));
  }
  static _renderSectionLabel(e, t, i, n, o, r, a, l, c, h) {
    t && (e.fillStyle = n, e.fillRect(0, a, r, l), e.fillStyle = o, e.fillText(t, So, c)), i && (e.beginPath(), e.moveTo(0, h), e.lineTo(r, h), e.closePath(), e.stroke());
  }
  renderLines(e) {
    const t = e.startLineNumber, i = e.endLineNumber, n = this._model.options.minimapLineHeight;
    if (this._lastRenderData && this._lastRenderData.linesEquals(e)) {
      const K = this._lastRenderData._get();
      return new wT(e, K.imageData, K.lines);
    }
    const o = this._getBuffer();
    if (!o)
      return null;
    const [r, a, l] = Dh._renderUntouchedLines(o, e.topPaddingLineCount, t, i, n, this._lastRenderData), c = this._model.getMinimapLinesRenderingData(t, i, l), h = this._model.getOptions().tabSize, d = this._model.options.defaultBackgroundColor, u = this._model.options.backgroundColor, f = this._model.options.foregroundAlpha, g = this._model.tokensColorTracker, m = g.backgroundIsLight(), _ = this._model.options.renderMinimap, b = this._model.options.charRenderer(), C = this._model.options.fontScale, v = this._model.options.minimapCharWidth, S = (_ === 1 ? 2 : 3) * C, L = n > S ? Math.floor((n - S) / 2) : 0, k = u.a / 255, D = new jr(Math.round((u.r - d.r) * k + d.r), Math.round((u.g - d.g) * k + d.g), Math.round((u.b - d.b) * k + d.b), 255);
    let E = e.topPaddingLineCount * n;
    const U = [];
    for (let K = 0, Y = i - t + 1; K < Y; K++)
      l[K] && Dh._renderLine(o, D, u.a, m, _, v, g, f, b, E, L, h, c[K], C, n), U[K] = new U_(E), E += n;
    const P = r === -1 ? 0 : r, W = (a === -1 ? o.height : a) - P;
    return this._canvas.domNode.getContext("2d").putImageData(o, 0, 0, 0, P, o.width, W), new wT(e, o, U);
  }
  static _renderUntouchedLines(e, t, i, n, o, r) {
    const a = [];
    if (!r) {
      for (let E = 0, U = n - i + 1; E < U; E++)
        a[E] = !0;
      return [-1, -1, a];
    }
    const l = r._get(), c = l.imageData.data, h = l.rendLineNumberStart, d = l.lines, u = d.length, f = e.width, g = e.data, m = (n - i + 1) * o * f * 4;
    let _ = -1, b = -1, C = -1, v = -1, w = -1, S = -1, L = t * o;
    for (let E = i; E <= n; E++) {
      const U = E - i, P = E - h, B = P >= 0 && P < u ? d[P].dy : -1;
      if (B === -1) {
        a[U] = !0, L += o;
        continue;
      }
      const W = B * f * 4, A = (B + o) * f * 4, K = L * f * 4, Y = (L + o) * f * 4;
      v === W && S === K ? (v = A, S = Y) : (C !== -1 && (g.set(c.subarray(C, v), w), _ === -1 && C === 0 && C === w && (_ = v), b === -1 && v === m && C === w && (b = C)), C = W, v = A, w = K, S = Y), a[U] = !1, L += o;
    }
    C !== -1 && (g.set(c.subarray(C, v), w), _ === -1 && C === 0 && C === w && (_ = v), b === -1 && v === m && C === w && (b = C));
    const k = _ === -1 ? -1 : _ / (f * 4), D = b === -1 ? -1 : b / (f * 4);
    return [k, D, a];
  }
  static _renderLine(e, t, i, n, o, r, a, l, c, h, d, u, f, g, m) {
    const _ = f.content, b = f.tokens, C = e.width - r, v = m === 1;
    let w = So, S = 0, L = 0;
    for (let k = 0, D = b.getCount(); k < D; k++) {
      const E = b.getEndOffset(k), U = b.getForeground(k), P = a.getColor(U);
      for (; S < E; S++) {
        if (w > C)
          return;
        const B = _.charCodeAt(S);
        if (B === 9) {
          const W = u - (S + L) % u;
          L += W - 1, w += W * r;
        } else if (B === 32)
          w += r;
        else {
          const W = za(B) ? 2 : 1;
          for (let A = 0; A < W; A++)
            if (o === 2 ? c.blockRenderChar(e, w, h + d, P, l, t, i, v) : c.renderChar(e, w, h + d, B, P, l, t, i, g, n, v), w += r, w > C)
              return;
        }
      }
    }
  }
}
class vT {
  constructor(e, t, i) {
    this._startLineNumber = e, this._endLineNumber = t, this._defaultValue = i, this._values = [];
    for (let n = 0, o = this._endLineNumber - this._startLineNumber + 1; n < o; n++)
      this._values[n] = i;
  }
  has(e) {
    return this.get(e) !== this._defaultValue;
  }
  set(e, t) {
    e < this._startLineNumber || e > this._endLineNumber || (this._values[e - this._startLineNumber] = t);
  }
  get(e) {
    return e < this._startLineNumber || e > this._endLineNumber ? this._defaultValue : this._values[e - this._startLineNumber];
  }
}
class JZ extends Hn {
  constructor(e, t) {
    super(e), this._viewDomNode = t;
    const n = this._context.configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    );
    this._widgets = {}, this._verticalScrollbarWidth = n.verticalScrollbarWidth, this._minimapWidth = n.minimap.minimapWidth, this._horizontalScrollbarHeight = n.horizontalScrollbarHeight, this._editorHeight = n.height, this._editorWidth = n.width, this._viewDomNodeRect = { top: 0, left: 0, width: 0, height: 0 }, this._domNode = je(document.createElement("div")), ho.write(
      this._domNode,
      4
      /* PartFingerprint.OverlayWidgets */
    ), this._domNode.setClassName("overlayWidgets"), this.overflowingOverlayWidgetsDomNode = je(document.createElement("div")), ho.write(
      this.overflowingOverlayWidgetsDomNode,
      5
      /* PartFingerprint.OverflowingOverlayWidgets */
    ), this.overflowingOverlayWidgetsDomNode.setClassName("overflowingOverlayWidgets");
  }
  dispose() {
    super.dispose(), this._widgets = {};
  }
  getDomNode() {
    return this._domNode;
  }
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    const i = this._context.configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    );
    return this._verticalScrollbarWidth = i.verticalScrollbarWidth, this._minimapWidth = i.minimap.minimapWidth, this._horizontalScrollbarHeight = i.horizontalScrollbarHeight, this._editorHeight = i.height, this._editorWidth = i.width, !0;
  }
  // ---- end view event handlers
  addWidget(e) {
    const t = je(e.getDomNode());
    this._widgets[e.getId()] = {
      widget: e,
      preference: null,
      domNode: t
    }, t.setPosition("absolute"), t.setAttribute("widgetId", e.getId()), e.allowEditorOverflow ? this.overflowingOverlayWidgetsDomNode.appendChild(t) : this._domNode.appendChild(t), this.setShouldRender(), this._updateMaxMinWidth();
  }
  setWidgetPosition(e, t) {
    const i = this._widgets[e.getId()], n = t ? t.preference : null, o = t == null ? void 0 : t.stackOridinal;
    return i.preference === n && i.stack === o ? (this._updateMaxMinWidth(), !1) : (i.preference = n, i.stack = o, this.setShouldRender(), this._updateMaxMinWidth(), !0);
  }
  removeWidget(e) {
    const t = e.getId();
    if (this._widgets.hasOwnProperty(t)) {
      const n = this._widgets[t].domNode.domNode;
      delete this._widgets[t], n.remove(), this.setShouldRender(), this._updateMaxMinWidth();
    }
  }
  _updateMaxMinWidth() {
    var i, n;
    let e = 0;
    const t = Object.keys(this._widgets);
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o], c = (n = (i = this._widgets[a].widget).getMinContentWidthInPx) == null ? void 0 : n.call(i);
      typeof c < "u" && (e = Math.max(e, c));
    }
    this._context.viewLayout.setOverlayWidgetsMinWidth(e);
  }
  _renderWidget(e, t) {
    const i = e.domNode;
    if (e.preference === null) {
      i.setTop("");
      return;
    }
    const n = 2 * this._verticalScrollbarWidth + this._minimapWidth;
    if (e.preference === 0 || e.preference === 1) {
      if (e.preference === 1) {
        const o = i.domNode.clientHeight;
        i.setTop(this._editorHeight - o - 2 * this._horizontalScrollbarHeight);
      } else
        i.setTop(0);
      e.stack !== void 0 ? (i.setTop(t[e.preference]), t[e.preference] += i.domNode.clientWidth) : i.setRight(n);
    } else if (e.preference === 2)
      i.domNode.style.right = "50%", e.stack !== void 0 ? (i.setTop(t[
        2
        /* OverlayWidgetPositionPreference.TOP_CENTER */
      ]), t[
        2
        /* OverlayWidgetPositionPreference.TOP_CENTER */
      ] += i.domNode.clientHeight) : i.setTop(0);
    else {
      const { top: o, left: r } = e.preference;
      if (this._context.configuration.options.get(
        42
        /* EditorOption.fixedOverflowWidgets */
      ) && e.widget.allowEditorOverflow) {
        const l = this._viewDomNodeRect;
        i.setTop(o + l.top), i.setLeft(r + l.left), i.setPosition("fixed");
      } else
        i.setTop(o), i.setLeft(r), i.setPosition("absolute");
    }
  }
  prepareRender(e) {
    this._viewDomNodeRect = gs(this._viewDomNode.domNode);
  }
  render(e) {
    this._domNode.setWidth(this._editorWidth);
    const t = Object.keys(this._widgets), i = Array.from({ length: 3 }, () => 0);
    t.sort((n, o) => (this._widgets[n].stack || 0) - (this._widgets[o].stack || 0));
    for (let n = 0, o = t.length; n < o; n++) {
      const r = t[n];
      this._renderWidget(this._widgets[r], i);
    }
  }
}
class eY {
  constructor(e, t) {
    const i = e.options;
    this.lineHeight = i.get(
      67
      /* EditorOption.lineHeight */
    ), this.pixelRatio = i.get(
      144
      /* EditorOption.pixelRatio */
    ), this.overviewRulerLanes = i.get(
      83
      /* EditorOption.overviewRulerLanes */
    ), this.renderBorder = i.get(
      82
      /* EditorOption.overviewRulerBorder */
    );
    const n = t.getColor(Wz);
    this.borderColor = n ? n.toString() : null, this.hideCursor = i.get(
      59
      /* EditorOption.hideCursorInOverviewRuler */
    );
    const o = t.getColor(Wb);
    this.cursorColorSingle = o ? o.transparent(0.7).toString() : null;
    const r = t.getColor(RA);
    this.cursorColorPrimary = r ? r.transparent(0.7).toString() : null;
    const a = t.getColor(AA);
    this.cursorColorSecondary = a ? a.transparent(0.7).toString() : null, this.themeType = t.type;
    const l = i.get(
      73
      /* EditorOption.minimap */
    ), c = l.enabled, h = l.side, d = t.getColor(Vz), u = Yt.getDefaultBackground();
    d ? this.backgroundColor = d : c && h === "right" ? this.backgroundColor = u : this.backgroundColor = null;
    const g = i.get(
      146
      /* EditorOption.layoutInfo */
    ).overviewRuler;
    this.top = g.top, this.right = g.right, this.domWidth = g.width, this.domHeight = g.height, this.overviewRulerLanes === 0 ? (this.canvasWidth = 0, this.canvasHeight = 0) : (this.canvasWidth = this.domWidth * this.pixelRatio | 0, this.canvasHeight = this.domHeight * this.pixelRatio | 0);
    const [m, _] = this._initLanes(1, this.canvasWidth, this.overviewRulerLanes);
    this.x = m, this.w = _;
  }
  _initLanes(e, t, i) {
    const n = t - e;
    if (i >= 3) {
      const o = Math.floor(n / 3), r = Math.floor(n / 3), a = n - o - r, l = e, c = l + o, h = l + o + a;
      return [
        [
          0,
          l,
          // Left
          c,
          // Center
          l,
          // Left | Center
          h,
          // Right
          l,
          // Left | Right
          c,
          // Center | Right
          l
          // Left | Center | Right
        ],
        [
          0,
          o,
          // Left
          a,
          // Center
          o + a,
          // Left | Center
          r,
          // Right
          o + a + r,
          // Left | Right
          a + r,
          // Center | Right
          o + a + r
          // Left | Center | Right
        ]
      ];
    } else if (i === 2) {
      const o = Math.floor(n / 2), r = n - o, a = e, l = a + o;
      return [
        [
          0,
          a,
          // Left
          a,
          // Center
          a,
          // Left | Center
          l,
          // Right
          a,
          // Left | Right
          a,
          // Center | Right
          a
          // Left | Center | Right
        ],
        [
          0,
          o,
          // Left
          o,
          // Center
          o,
          // Left | Center
          r,
          // Right
          o + r,
          // Left | Right
          o + r,
          // Center | Right
          o + r
          // Left | Center | Right
        ]
      ];
    } else {
      const o = e, r = n;
      return [
        [
          0,
          o,
          // Left
          o,
          // Center
          o,
          // Left | Center
          o,
          // Right
          o,
          // Left | Right
          o,
          // Center | Right
          o
          // Left | Center | Right
        ],
        [
          0,
          r,
          // Left
          r,
          // Center
          r,
          // Left | Center
          r,
          // Right
          r,
          // Left | Right
          r,
          // Center | Right
          r
          // Left | Center | Right
        ]
      ];
    }
  }
  equals(e) {
    return this.lineHeight === e.lineHeight && this.pixelRatio === e.pixelRatio && this.overviewRulerLanes === e.overviewRulerLanes && this.renderBorder === e.renderBorder && this.borderColor === e.borderColor && this.hideCursor === e.hideCursor && this.cursorColorSingle === e.cursorColorSingle && this.cursorColorPrimary === e.cursorColorPrimary && this.cursorColorSecondary === e.cursorColorSecondary && this.themeType === e.themeType && Z.equals(this.backgroundColor, e.backgroundColor) && this.top === e.top && this.right === e.right && this.domWidth === e.domWidth && this.domHeight === e.domHeight && this.canvasWidth === e.canvasWidth && this.canvasHeight === e.canvasHeight;
  }
}
class tY extends Hn {
  constructor(e) {
    super(e), this._actualShouldRender = 0, this._renderedDecorations = [], this._renderedCursorPositions = [], this._domNode = je(document.createElement("canvas")), this._domNode.setClassName("decorationsOverviewRuler"), this._domNode.setPosition("absolute"), this._domNode.setLayerHinting(!0), this._domNode.setContain("strict"), this._domNode.setAttribute("aria-hidden", "true"), this._updateSettings(!1), this._tokensColorTrackerListener = Yt.onDidChange((t) => {
      t.changedColorMap && this._updateSettings(!0);
    }), this._cursorPositions = [{ position: new V(1, 1), color: this._settings.cursorColorSingle }];
  }
  dispose() {
    super.dispose(), this._tokensColorTrackerListener.dispose();
  }
  _updateSettings(e) {
    const t = new eY(this._context.configuration, this._context.theme);
    return this._settings && this._settings.equals(t) ? !1 : (this._settings = t, this._domNode.setTop(this._settings.top), this._domNode.setRight(this._settings.right), this._domNode.setWidth(this._settings.domWidth), this._domNode.setHeight(this._settings.domHeight), this._domNode.domNode.width = this._settings.canvasWidth, this._domNode.domNode.height = this._settings.canvasHeight, e && this._render(), !0);
  }
  // ---- begin view event handlers
  _markRenderingIsNeeded() {
    return this._actualShouldRender = 2, !0;
  }
  _markRenderingIsMaybeNeeded() {
    return this._actualShouldRender = 1, !0;
  }
  onConfigurationChanged(e) {
    return this._updateSettings(!1) ? this._markRenderingIsNeeded() : !1;
  }
  onCursorStateChanged(e) {
    this._cursorPositions = [];
    for (let t = 0, i = e.selections.length; t < i; t++) {
      let n = this._settings.cursorColorSingle;
      i > 1 && (n = t === 0 ? this._settings.cursorColorPrimary : this._settings.cursorColorSecondary), this._cursorPositions.push({ position: e.selections[t].getPosition(), color: n });
    }
    return this._cursorPositions.sort((t, i) => V.compare(t.position, i.position)), this._markRenderingIsMaybeNeeded();
  }
  onDecorationsChanged(e) {
    return e.affectsOverviewRuler ? this._markRenderingIsMaybeNeeded() : !1;
  }
  onFlushed(e) {
    return this._markRenderingIsNeeded();
  }
  onScrollChanged(e) {
    return e.scrollHeightChanged ? this._markRenderingIsNeeded() : !1;
  }
  onZonesChanged(e) {
    return this._markRenderingIsNeeded();
  }
  onThemeChanged(e) {
    return this._updateSettings(!1) ? this._markRenderingIsNeeded() : !1;
  }
  // ---- end view event handlers
  getDomNode() {
    return this._domNode.domNode;
  }
  prepareRender(e) {
  }
  render(e) {
    this._render(), this._actualShouldRender = 0;
  }
  _render() {
    const e = this._settings.backgroundColor;
    if (this._settings.overviewRulerLanes === 0) {
      this._domNode.setBackgroundColor(e ? Z.Format.CSS.formatHexA(e) : ""), this._domNode.setDisplay("none");
      return;
    }
    const t = this._context.viewModel.getAllOverviewRulerDecorations(this._context.theme);
    if (t.sort(lg.compareByRenderingProps), this._actualShouldRender === 1 && !lg.equalsArr(this._renderedDecorations, t) && (this._actualShouldRender = 2), this._actualShouldRender === 1 && !oi(this._renderedCursorPositions, this._cursorPositions, (g, m) => g.position.lineNumber === m.position.lineNumber && g.color === m.color) && (this._actualShouldRender = 2), this._actualShouldRender === 1)
      return;
    this._renderedDecorations = t, this._renderedCursorPositions = this._cursorPositions, this._domNode.setDisplay("block");
    const i = this._settings.canvasWidth, n = this._settings.canvasHeight, o = this._settings.lineHeight, r = this._context.viewLayout, a = this._context.viewLayout.getScrollHeight(), l = n / a, c = 6 * this._settings.pixelRatio | 0, h = c / 2 | 0, d = this._domNode.domNode.getContext("2d");
    e ? e.isOpaque() ? (d.fillStyle = Z.Format.CSS.formatHexA(e), d.fillRect(0, 0, i, n)) : (d.clearRect(0, 0, i, n), d.fillStyle = Z.Format.CSS.formatHexA(e), d.fillRect(0, 0, i, n)) : d.clearRect(0, 0, i, n);
    const u = this._settings.x, f = this._settings.w;
    for (const g of t) {
      const m = g.color, _ = g.data;
      d.fillStyle = m;
      let b = 0, C = 0, v = 0;
      for (let w = 0, S = _.length / 3; w < S; w++) {
        const L = _[3 * w], k = _[3 * w + 1], D = _[3 * w + 2];
        let E = r.getVerticalOffsetForLineNumber(k) * l | 0, U = (r.getVerticalOffsetForLineNumber(D) + o) * l | 0;
        if (U - E < c) {
          let B = (E + U) / 2 | 0;
          B < h ? B = h : B + h > n && (B = n - h), E = B - h, U = B + h;
        }
        E > v + 1 || L !== b ? (w !== 0 && d.fillRect(u[b], C, f[b], v - C), b = L, C = E, v = U) : U > v && (v = U);
      }
      d.fillRect(u[b], C, f[b], v - C);
    }
    if (!this._settings.hideCursor) {
      const g = 2 * this._settings.pixelRatio | 0, m = g / 2 | 0, _ = this._settings.x[
        7
        /* OverviewRulerLane.Full */
      ], b = this._settings.w[
        7
        /* OverviewRulerLane.Full */
      ];
      let C = -100, v = -100, w = null;
      for (let S = 0, L = this._cursorPositions.length; S < L; S++) {
        const k = this._cursorPositions[S].color;
        if (!k)
          continue;
        const D = this._cursorPositions[S].position;
        let E = r.getVerticalOffsetForLineNumber(D.lineNumber) * l | 0;
        E < m ? E = m : E + m > n && (E = n - m);
        const U = E - m, P = U + g;
        U > v + 1 || k !== w ? (S !== 0 && w && d.fillRect(_, C, b, v - C), C = U, v = P) : P > v && (v = P), w = k, d.fillStyle = k;
      }
      w && d.fillRect(_, C, b, v - C);
    }
    this._settings.renderBorder && this._settings.borderColor && this._settings.overviewRulerLanes > 0 && (d.beginPath(), d.lineWidth = 1, d.strokeStyle = this._settings.borderColor, d.moveTo(0, 0), d.lineTo(0, n), d.moveTo(1, 0), d.lineTo(i, 0), d.stroke());
  }
}
class yT {
  constructor(e, t, i) {
    this._colorZoneBrand = void 0, this.from = e | 0, this.to = t | 0, this.colorId = i | 0;
  }
  static compare(e, t) {
    return e.colorId === t.colorId ? e.from === t.from ? e.to - t.to : e.from - t.from : e.colorId - t.colorId;
  }
}
class c5 {
  constructor(e, t, i, n) {
    this._overviewRulerZoneBrand = void 0, this.startLineNumber = e, this.endLineNumber = t, this.heightInLines = i, this.color = n, this._colorZone = null;
  }
  static compare(e, t) {
    return e.color === t.color ? e.startLineNumber === t.startLineNumber ? e.heightInLines === t.heightInLines ? e.endLineNumber - t.endLineNumber : e.heightInLines - t.heightInLines : e.startLineNumber - t.startLineNumber : e.color < t.color ? -1 : 1;
  }
  setColorZone(e) {
    this._colorZone = e;
  }
  getColorZones() {
    return this._colorZone;
  }
}
class iY {
  constructor(e) {
    this._getVerticalOffsetForLine = e, this._zones = [], this._colorZonesInvalid = !1, this._lineHeight = 0, this._domWidth = 0, this._domHeight = 0, this._outerHeight = 0, this._pixelRatio = 1, this._lastAssignedId = 0, this._color2Id = /* @__PURE__ */ Object.create(null), this._id2Color = [];
  }
  getId2Color() {
    return this._id2Color;
  }
  setZones(e) {
    this._zones = e, this._zones.sort(c5.compare);
  }
  setLineHeight(e) {
    return this._lineHeight === e ? !1 : (this._lineHeight = e, this._colorZonesInvalid = !0, !0);
  }
  setPixelRatio(e) {
    this._pixelRatio = e, this._colorZonesInvalid = !0;
  }
  getDOMWidth() {
    return this._domWidth;
  }
  getCanvasWidth() {
    return this._domWidth * this._pixelRatio;
  }
  setDOMWidth(e) {
    return this._domWidth === e ? !1 : (this._domWidth = e, this._colorZonesInvalid = !0, !0);
  }
  getDOMHeight() {
    return this._domHeight;
  }
  getCanvasHeight() {
    return this._domHeight * this._pixelRatio;
  }
  setDOMHeight(e) {
    return this._domHeight === e ? !1 : (this._domHeight = e, this._colorZonesInvalid = !0, !0);
  }
  getOuterHeight() {
    return this._outerHeight;
  }
  setOuterHeight(e) {
    return this._outerHeight === e ? !1 : (this._outerHeight = e, this._colorZonesInvalid = !0, !0);
  }
  resolveColorZones() {
    const e = this._colorZonesInvalid, t = Math.floor(this._lineHeight), i = Math.floor(this.getCanvasHeight()), n = Math.floor(this._outerHeight), o = i / n, r = Math.floor(4 * this._pixelRatio / 2), a = [];
    for (let l = 0, c = this._zones.length; l < c; l++) {
      const h = this._zones[l];
      if (!e) {
        const w = h.getColorZones();
        if (w) {
          a.push(w);
          continue;
        }
      }
      const d = this._getVerticalOffsetForLine(h.startLineNumber), u = h.heightInLines === 0 ? this._getVerticalOffsetForLine(h.endLineNumber) + t : d + h.heightInLines * t, f = Math.floor(o * d), g = Math.floor(o * u);
      let m = Math.floor((f + g) / 2), _ = g - m;
      _ < r && (_ = r), m - _ < 0 && (m = _), m + _ > i && (m = i - _);
      const b = h.color;
      let C = this._color2Id[b];
      C || (C = ++this._lastAssignedId, this._color2Id[b] = C, this._id2Color[C] = b);
      const v = new yT(m - _, m + _, C);
      h.setColorZone(v), a.push(v);
    }
    return this._colorZonesInvalid = !1, a.sort(yT.compare), a;
  }
}
class nY extends Kg {
  constructor(e, t) {
    super(), this._context = e;
    const i = this._context.configuration.options;
    this._domNode = je(document.createElement("canvas")), this._domNode.setClassName(t), this._domNode.setPosition("absolute"), this._domNode.setLayerHinting(!0), this._domNode.setContain("strict"), this._zoneManager = new iY((n) => this._context.viewLayout.getVerticalOffsetForLineNumber(n)), this._zoneManager.setDOMWidth(0), this._zoneManager.setDOMHeight(0), this._zoneManager.setOuterHeight(this._context.viewLayout.getScrollHeight()), this._zoneManager.setLineHeight(i.get(
      67
      /* EditorOption.lineHeight */
    )), this._zoneManager.setPixelRatio(i.get(
      144
      /* EditorOption.pixelRatio */
    )), this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), super.dispose();
  }
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    return e.hasChanged(
      67
      /* EditorOption.lineHeight */
    ) && (this._zoneManager.setLineHeight(t.get(
      67
      /* EditorOption.lineHeight */
    )), this._render()), e.hasChanged(
      144
      /* EditorOption.pixelRatio */
    ) && (this._zoneManager.setPixelRatio(t.get(
      144
      /* EditorOption.pixelRatio */
    )), this._domNode.setWidth(this._zoneManager.getDOMWidth()), this._domNode.setHeight(this._zoneManager.getDOMHeight()), this._domNode.domNode.width = this._zoneManager.getCanvasWidth(), this._domNode.domNode.height = this._zoneManager.getCanvasHeight(), this._render()), !0;
  }
  onFlushed(e) {
    return this._render(), !0;
  }
  onScrollChanged(e) {
    return e.scrollHeightChanged && (this._zoneManager.setOuterHeight(e.scrollHeight), this._render()), !0;
  }
  onZonesChanged(e) {
    return this._render(), !0;
  }
  // ---- end view event handlers
  getDomNode() {
    return this._domNode.domNode;
  }
  setLayout(e) {
    this._domNode.setTop(e.top), this._domNode.setRight(e.right);
    let t = !1;
    t = this._zoneManager.setDOMWidth(e.width) || t, t = this._zoneManager.setDOMHeight(e.height) || t, t && (this._domNode.setWidth(this._zoneManager.getDOMWidth()), this._domNode.setHeight(this._zoneManager.getDOMHeight()), this._domNode.domNode.width = this._zoneManager.getCanvasWidth(), this._domNode.domNode.height = this._zoneManager.getCanvasHeight(), this._render());
  }
  setZones(e) {
    this._zoneManager.setZones(e), this._render();
  }
  _render() {
    if (this._zoneManager.getOuterHeight() === 0)
      return !1;
    const e = this._zoneManager.getCanvasWidth(), t = this._zoneManager.getCanvasHeight(), i = this._zoneManager.resolveColorZones(), n = this._zoneManager.getId2Color(), o = this._domNode.domNode.getContext("2d");
    return o.clearRect(0, 0, e, t), i.length > 0 && this._renderOneLane(o, i, n, e), !0;
  }
  _renderOneLane(e, t, i, n) {
    let o = 0, r = 0, a = 0;
    for (const l of t) {
      const c = l.colorId, h = l.from, d = l.to;
      c !== o ? (e.fillRect(0, r, n, a - r), o = c, e.fillStyle = i[o], r = h, a = d) : a >= h ? a = Math.max(a, d) : (e.fillRect(0, r, n, a - r), r = h, a = d);
    }
    e.fillRect(0, r, n, a - r);
  }
}
class sY extends Hn {
  constructor(e) {
    super(e), this.domNode = je(document.createElement("div")), this.domNode.setAttribute("role", "presentation"), this.domNode.setAttribute("aria-hidden", "true"), this.domNode.setClassName("view-rulers"), this._renderedRulers = [];
    const t = this._context.configuration.options;
    this._rulers = t.get(
      103
      /* EditorOption.rulers */
    ), this._typicalHalfwidthCharacterWidth = t.get(
      50
      /* EditorOption.fontInfo */
    ).typicalHalfwidthCharacterWidth;
  }
  dispose() {
    super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    return this._rulers = t.get(
      103
      /* EditorOption.rulers */
    ), this._typicalHalfwidthCharacterWidth = t.get(
      50
      /* EditorOption.fontInfo */
    ).typicalHalfwidthCharacterWidth, !0;
  }
  onScrollChanged(e) {
    return e.scrollHeightChanged;
  }
  // --- end event handlers
  prepareRender(e) {
  }
  _ensureRulersCount() {
    const e = this._renderedRulers.length, t = this._rulers.length;
    if (e === t)
      return;
    if (e < t) {
      const { tabSize: n } = this._context.viewModel.model.getOptions(), o = n;
      let r = t - e;
      for (; r > 0; ) {
        const a = je(document.createElement("div"));
        a.setClassName("view-ruler"), a.setWidth(o), this.domNode.appendChild(a), this._renderedRulers.push(a), r--;
      }
      return;
    }
    let i = e - t;
    for (; i > 0; ) {
      const n = this._renderedRulers.pop();
      this.domNode.removeChild(n), i--;
    }
  }
  render(e) {
    this._ensureRulersCount();
    for (let t = 0, i = this._rulers.length; t < i; t++) {
      const n = this._renderedRulers[t], o = this._rulers[t];
      n.setBoxShadow(o.color ? `1px 0 0 0 ${o.color} inset` : ""), n.setHeight(Math.min(e.scrollHeight, 1e6)), n.setLeft(o.column * this._typicalHalfwidthCharacterWidth);
    }
  }
}
class oY extends Hn {
  constructor(e) {
    super(e), this._scrollTop = 0, this._width = 0, this._updateWidth(), this._shouldShow = !1;
    const i = this._context.configuration.options.get(
      104
      /* EditorOption.scrollbar */
    );
    this._useShadows = i.useShadows, this._domNode = je(document.createElement("div")), this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true");
  }
  dispose() {
    super.dispose();
  }
  _updateShouldShow() {
    const e = this._useShadows && this._scrollTop > 0;
    return this._shouldShow !== e ? (this._shouldShow = e, !0) : !1;
  }
  getDomNode() {
    return this._domNode;
  }
  _updateWidth() {
    const t = this._context.configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    );
    t.minimap.renderMinimap === 0 || t.minimap.minimapWidth > 0 && t.minimap.minimapLeft === 0 ? this._width = t.width : this._width = t.width - t.verticalScrollbarWidth;
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const i = this._context.configuration.options.get(
      104
      /* EditorOption.scrollbar */
    );
    return this._useShadows = i.useShadows, this._updateWidth(), this._updateShouldShow(), !0;
  }
  onScrollChanged(e) {
    return this._scrollTop = e.scrollTop, this._updateShouldShow();
  }
  // --- end event handlers
  prepareRender(e) {
  }
  render(e) {
    this._domNode.setWidth(this._width), this._domNode.setClassName(this._shouldShow ? "scroll-decoration" : "");
  }
}
class rY {
  constructor(e) {
    this.left = e.left, this.width = e.width, this.startStyle = null, this.endStyle = null;
  }
}
class aY {
  constructor(e, t) {
    this.lineNumber = e, this.ranges = t;
  }
}
function lY(s) {
  return new rY(s);
}
function cY(s) {
  return new aY(s.lineNumber, s.ranges.map(lY));
}
const Ft = class Ft extends Hc {
  constructor(e) {
    super(), this._previousFrameVisibleRangesWithStyle = [], this._context = e;
    const t = this._context.configuration.options;
    this._roundedSelection = t.get(
      102
      /* EditorOption.roundedSelection */
    ), this._typicalHalfwidthCharacterWidth = t.get(
      50
      /* EditorOption.fontInfo */
    ).typicalHalfwidthCharacterWidth, this._selections = [], this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    return this._roundedSelection = t.get(
      102
      /* EditorOption.roundedSelection */
    ), this._typicalHalfwidthCharacterWidth = t.get(
      50
      /* EditorOption.fontInfo */
    ).typicalHalfwidthCharacterWidth, !0;
  }
  onCursorStateChanged(e) {
    return this._selections = e.selections.slice(0), !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  _visibleRangesHaveGaps(e) {
    for (let t = 0, i = e.length; t < i; t++)
      if (e[t].ranges.length > 1)
        return !0;
    return !1;
  }
  _enrichVisibleRangesWithStyle(e, t, i) {
    const n = this._typicalHalfwidthCharacterWidth / 4;
    let o = null, r = null;
    if (i && i.length > 0 && t.length > 0) {
      const a = t[0].lineNumber;
      if (a === e.startLineNumber)
        for (let c = 0; !o && c < i.length; c++)
          i[c].lineNumber === a && (o = i[c].ranges[0]);
      const l = t[t.length - 1].lineNumber;
      if (l === e.endLineNumber)
        for (let c = i.length - 1; !r && c >= 0; c--)
          i[c].lineNumber === l && (r = i[c].ranges[0]);
      o && !o.startStyle && (o = null), r && !r.startStyle && (r = null);
    }
    for (let a = 0, l = t.length; a < l; a++) {
      const c = t[a].ranges[0], h = c.left, d = c.left + c.width, u = {
        top: 0,
        bottom: 0
        /* CornerStyle.EXTERN */
      }, f = {
        top: 0,
        bottom: 0
        /* CornerStyle.EXTERN */
      };
      if (a > 0) {
        const g = t[a - 1].ranges[0].left, m = t[a - 1].ranges[0].left + t[a - 1].ranges[0].width;
        Pm(h - g) < n ? u.top = 2 : h > g && (u.top = 1), Pm(d - m) < n ? f.top = 2 : g < d && d < m && (f.top = 1);
      } else o && (u.top = o.startStyle.top, f.top = o.endStyle.top);
      if (a + 1 < l) {
        const g = t[a + 1].ranges[0].left, m = t[a + 1].ranges[0].left + t[a + 1].ranges[0].width;
        Pm(h - g) < n ? u.bottom = 2 : g < h && h < m && (u.bottom = 1), Pm(d - m) < n ? f.bottom = 2 : d < m && (f.bottom = 1);
      } else r && (u.bottom = r.startStyle.bottom, f.bottom = r.endStyle.bottom);
      c.startStyle = u, c.endStyle = f;
    }
  }
  _getVisibleRangesWithStyle(e, t, i) {
    const o = (t.linesVisibleRangesForRange(e, !0) || []).map(cY);
    return !this._visibleRangesHaveGaps(o) && this._roundedSelection && this._enrichVisibleRangesWithStyle(t.visibleRange, o, i), o;
  }
  _createSelectionPiece(e, t, i, n, o) {
    return '<div class="cslr ' + i + '" style="top:' + e.toString() + "px;bottom:" + t.toString() + "px;left:" + n.toString() + "px;width:" + o.toString() + 'px;"></div>';
  }
  _actualRenderOneSelection(e, t, i, n) {
    if (n.length === 0)
      return;
    const o = !!n[0].ranges[0].startStyle, r = n[0].lineNumber, a = n[n.length - 1].lineNumber;
    for (let l = 0, c = n.length; l < c; l++) {
      const h = n[l], d = h.lineNumber, u = d - t, f = i && d === r ? 1 : 0, g = i && d !== r && d === a ? 1 : 0;
      let m = "", _ = "";
      for (let b = 0, C = h.ranges.length; b < C; b++) {
        const v = h.ranges[b];
        if (o) {
          const S = v.startStyle, L = v.endStyle;
          if (S.top === 1 || S.bottom === 1) {
            m += this._createSelectionPiece(f, g, Ft.SELECTION_CLASS_NAME, v.left - Ft.ROUNDED_PIECE_WIDTH, Ft.ROUNDED_PIECE_WIDTH);
            let k = Ft.EDITOR_BACKGROUND_CLASS_NAME;
            S.top === 1 && (k += " " + Ft.SELECTION_TOP_RIGHT), S.bottom === 1 && (k += " " + Ft.SELECTION_BOTTOM_RIGHT), m += this._createSelectionPiece(f, g, k, v.left - Ft.ROUNDED_PIECE_WIDTH, Ft.ROUNDED_PIECE_WIDTH);
          }
          if (L.top === 1 || L.bottom === 1) {
            m += this._createSelectionPiece(f, g, Ft.SELECTION_CLASS_NAME, v.left + v.width, Ft.ROUNDED_PIECE_WIDTH);
            let k = Ft.EDITOR_BACKGROUND_CLASS_NAME;
            L.top === 1 && (k += " " + Ft.SELECTION_TOP_LEFT), L.bottom === 1 && (k += " " + Ft.SELECTION_BOTTOM_LEFT), m += this._createSelectionPiece(f, g, k, v.left + v.width, Ft.ROUNDED_PIECE_WIDTH);
          }
        }
        let w = Ft.SELECTION_CLASS_NAME;
        if (o) {
          const S = v.startStyle, L = v.endStyle;
          S.top === 0 && (w += " " + Ft.SELECTION_TOP_LEFT), S.bottom === 0 && (w += " " + Ft.SELECTION_BOTTOM_LEFT), L.top === 0 && (w += " " + Ft.SELECTION_TOP_RIGHT), L.bottom === 0 && (w += " " + Ft.SELECTION_BOTTOM_RIGHT);
        }
        _ += this._createSelectionPiece(f, g, w, v.left, v.width);
      }
      e[u][0] += m, e[u][1] += _;
    }
  }
  prepareRender(e) {
    const t = [], i = e.visibleRange.startLineNumber, n = e.visibleRange.endLineNumber;
    for (let r = i; r <= n; r++) {
      const a = r - i;
      t[a] = ["", ""];
    }
    const o = [];
    for (let r = 0, a = this._selections.length; r < a; r++) {
      const l = this._selections[r];
      if (l.isEmpty()) {
        o[r] = null;
        continue;
      }
      const c = this._getVisibleRangesWithStyle(l, e, this._previousFrameVisibleRangesWithStyle[r]);
      o[r] = c, this._actualRenderOneSelection(t, i, this._selections.length > 1, c);
    }
    this._previousFrameVisibleRangesWithStyle = o, this._renderResult = t.map(([r, a]) => r + a);
  }
  render(e, t) {
    if (!this._renderResult)
      return "";
    const i = t - e;
    return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
  }
};
Ft.SELECTION_CLASS_NAME = "selected-text", Ft.SELECTION_TOP_LEFT = "top-left-radius", Ft.SELECTION_BOTTOM_LEFT = "bottom-left-radius", Ft.SELECTION_TOP_RIGHT = "top-right-radius", Ft.SELECTION_BOTTOM_RIGHT = "bottom-right-radius", Ft.EDITOR_BACKGROUND_CLASS_NAME = "monaco-editor-background", Ft.ROUNDED_PIECE_WIDTH = 10;
let MS = Ft;
Jr((s, e) => {
  const t = s.getColor(n8);
  t && !t.isTransparent() && e.addRule(`.monaco-editor .view-line span.inline-selected-text { color: ${t}; }`);
});
function Pm(s) {
  return s < 0 ? -s : s;
}
class ST {
  constructor(e, t, i, n, o, r, a) {
    this.top = e, this.left = t, this.paddingLeft = i, this.width = n, this.height = o, this.textContent = r, this.textContentClassName = a;
  }
}
var Or;
(function(s) {
  s[s.Single = 0] = "Single", s[s.MultiPrimary = 1] = "MultiPrimary", s[s.MultiSecondary = 2] = "MultiSecondary";
})(Or || (Or = {}));
class LT {
  constructor(e, t) {
    this._context = e;
    const i = this._context.configuration.options, n = i.get(
      50
      /* EditorOption.fontInfo */
    );
    this._cursorStyle = i.get(
      28
      /* EditorOption.cursorStyle */
    ), this._lineHeight = i.get(
      67
      /* EditorOption.lineHeight */
    ), this._typicalHalfwidthCharacterWidth = n.typicalHalfwidthCharacterWidth, this._lineCursorWidth = Math.min(i.get(
      31
      /* EditorOption.cursorWidth */
    ), this._typicalHalfwidthCharacterWidth), this._isVisible = !0, this._domNode = je(document.createElement("div")), this._domNode.setClassName(`cursor ${ld}`), this._domNode.setHeight(this._lineHeight), this._domNode.setTop(0), this._domNode.setLeft(0), Fi(this._domNode, n), this._domNode.setDisplay("none"), this._position = new V(1, 1), this._pluralityClass = "", this.setPlurality(t), this._lastRenderedContent = "", this._renderData = null;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return this._position;
  }
  setPlurality(e) {
    switch (e) {
      default:
      case Or.Single:
        this._pluralityClass = "";
        break;
      case Or.MultiPrimary:
        this._pluralityClass = "cursor-primary";
        break;
      case Or.MultiSecondary:
        this._pluralityClass = "cursor-secondary";
        break;
    }
  }
  show() {
    this._isVisible || (this._domNode.setVisibility("inherit"), this._isVisible = !0);
  }
  hide() {
    this._isVisible && (this._domNode.setVisibility("hidden"), this._isVisible = !1);
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      50
      /* EditorOption.fontInfo */
    );
    return this._cursorStyle = t.get(
      28
      /* EditorOption.cursorStyle */
    ), this._lineHeight = t.get(
      67
      /* EditorOption.lineHeight */
    ), this._typicalHalfwidthCharacterWidth = i.typicalHalfwidthCharacterWidth, this._lineCursorWidth = Math.min(t.get(
      31
      /* EditorOption.cursorWidth */
    ), this._typicalHalfwidthCharacterWidth), Fi(this._domNode, i), !0;
  }
  onCursorPositionChanged(e, t) {
    return t ? this._domNode.domNode.style.transitionProperty = "none" : this._domNode.domNode.style.transitionProperty = "", this._position = e, !0;
  }
  /**
   * If `this._position` is inside a grapheme, returns the position where the grapheme starts.
   * Also returns the next grapheme.
   */
  _getGraphemeAwarePosition() {
    const { lineNumber: e, column: t } = this._position, i = this._context.viewModel.getLineContent(e), [n, o] = JO(i, t - 1);
    return [new V(e, n + 1), i.substring(n, o)];
  }
  _prepareRender(e) {
    let t = "", i = "";
    const [n, o] = this._getGraphemeAwarePosition();
    if (this._cursorStyle === wi.Line || this._cursorStyle === wi.LineThin) {
      const u = e.visibleRangeForPosition(n);
      if (!u || u.outsideRenderedLine)
        return null;
      const f = ue(this._domNode.domNode);
      let g;
      this._cursorStyle === wi.Line ? (g = BD(f, this._lineCursorWidth > 0 ? this._lineCursorWidth : 2), g > 2 && (t = o, i = this._getTokenClassName(n))) : g = BD(f, 1);
      let m = u.left, _ = 0;
      g >= 2 && m >= 1 && (_ = 1, m -= _);
      const b = e.getVerticalOffsetForLineNumber(n.lineNumber) - e.bigNumbersDelta;
      return new ST(b, m, _, g, this._lineHeight, t, i);
    }
    const r = e.linesVisibleRangesForRange(new R(n.lineNumber, n.column, n.lineNumber, n.column + o.length), !1);
    if (!r || r.length === 0)
      return null;
    const a = r[0];
    if (a.outsideRenderedLine || a.ranges.length === 0)
      return null;
    const l = a.ranges[0], c = o === "	" ? this._typicalHalfwidthCharacterWidth : l.width < 1 ? this._typicalHalfwidthCharacterWidth : l.width;
    this._cursorStyle === wi.Block && (t = o, i = this._getTokenClassName(n));
    let h = e.getVerticalOffsetForLineNumber(n.lineNumber) - e.bigNumbersDelta, d = this._lineHeight;
    return (this._cursorStyle === wi.Underline || this._cursorStyle === wi.UnderlineThin) && (h += this._lineHeight - 2, d = 2), new ST(h, l.left, 0, c, d, t, i);
  }
  _getTokenClassName(e) {
    const t = this._context.viewModel.getViewLineData(e.lineNumber), i = t.tokens.findTokenIndexAtOffset(e.column - 1);
    return t.tokens.getClassName(i);
  }
  prepareRender(e) {
    this._renderData = this._prepareRender(e);
  }
  render(e) {
    return this._renderData ? (this._lastRenderedContent !== this._renderData.textContent && (this._lastRenderedContent = this._renderData.textContent, this._domNode.domNode.textContent = this._lastRenderedContent), this._domNode.setClassName(`cursor ${this._pluralityClass} ${ld} ${this._renderData.textContentClassName}`), this._domNode.setDisplay("block"), this._domNode.setTop(this._renderData.top), this._domNode.setLeft(this._renderData.left), this._domNode.setPaddingLeft(this._renderData.paddingLeft), this._domNode.setWidth(this._renderData.width), this._domNode.setLineHeight(this._renderData.height), this._domNode.setHeight(this._renderData.height), {
      domNode: this._domNode.domNode,
      position: this._position,
      contentLeft: this._renderData.left,
      height: this._renderData.height,
      width: 2
    }) : (this._domNode.setDisplay("none"), null);
  }
}
const xf = class xf extends Hn {
  constructor(e) {
    super(e);
    const t = this._context.configuration.options;
    this._readOnly = t.get(
      92
      /* EditorOption.readOnly */
    ), this._cursorBlinking = t.get(
      26
      /* EditorOption.cursorBlinking */
    ), this._cursorStyle = t.get(
      28
      /* EditorOption.cursorStyle */
    ), this._cursorSmoothCaretAnimation = t.get(
      27
      /* EditorOption.cursorSmoothCaretAnimation */
    ), this._selectionIsEmpty = !0, this._isComposingInput = !1, this._isVisible = !1, this._primaryCursor = new LT(this._context, Or.Single), this._secondaryCursors = [], this._renderData = [], this._domNode = je(document.createElement("div")), this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true"), this._updateDomClassName(), this._domNode.appendChild(this._primaryCursor.getDomNode()), this._startCursorBlinkAnimation = new Ic(), this._cursorFlatBlinkInterval = new BL(), this._blinkingEnabled = !1, this._editorHasFocus = !1, this._updateBlinking();
  }
  dispose() {
    super.dispose(), this._startCursorBlinkAnimation.dispose(), this._cursorFlatBlinkInterval.dispose();
  }
  getDomNode() {
    return this._domNode;
  }
  // --- begin event handlers
  onCompositionStart(e) {
    return this._isComposingInput = !0, this._updateBlinking(), !0;
  }
  onCompositionEnd(e) {
    return this._isComposingInput = !1, this._updateBlinking(), !0;
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    this._readOnly = t.get(
      92
      /* EditorOption.readOnly */
    ), this._cursorBlinking = t.get(
      26
      /* EditorOption.cursorBlinking */
    ), this._cursorStyle = t.get(
      28
      /* EditorOption.cursorStyle */
    ), this._cursorSmoothCaretAnimation = t.get(
      27
      /* EditorOption.cursorSmoothCaretAnimation */
    ), this._updateBlinking(), this._updateDomClassName(), this._primaryCursor.onConfigurationChanged(e);
    for (let i = 0, n = this._secondaryCursors.length; i < n; i++)
      this._secondaryCursors[i].onConfigurationChanged(e);
    return !0;
  }
  _onCursorPositionChanged(e, t, i) {
    const n = this._secondaryCursors.length !== t.length || this._cursorSmoothCaretAnimation === "explicit" && i !== 3;
    if (this._primaryCursor.setPlurality(t.length ? Or.MultiPrimary : Or.Single), this._primaryCursor.onCursorPositionChanged(e, n), this._updateBlinking(), this._secondaryCursors.length < t.length) {
      const o = t.length - this._secondaryCursors.length;
      for (let r = 0; r < o; r++) {
        const a = new LT(this._context, Or.MultiSecondary);
        this._domNode.domNode.insertBefore(a.getDomNode().domNode, this._primaryCursor.getDomNode().domNode.nextSibling), this._secondaryCursors.push(a);
      }
    } else if (this._secondaryCursors.length > t.length) {
      const o = this._secondaryCursors.length - t.length;
      for (let r = 0; r < o; r++)
        this._domNode.removeChild(this._secondaryCursors[0].getDomNode()), this._secondaryCursors.splice(0, 1);
    }
    for (let o = 0; o < t.length; o++)
      this._secondaryCursors[o].onCursorPositionChanged(t[o], n);
  }
  onCursorStateChanged(e) {
    const t = [];
    for (let n = 0, o = e.selections.length; n < o; n++)
      t[n] = e.selections[n].getPosition();
    this._onCursorPositionChanged(t[0], t.slice(1), e.reason);
    const i = e.selections[0].isEmpty();
    return this._selectionIsEmpty !== i && (this._selectionIsEmpty = i, this._updateDomClassName()), !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onFocusChanged(e) {
    return this._editorHasFocus = e.isFocused, this._updateBlinking(), !1;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return !0;
  }
  onTokensChanged(e) {
    const t = (i) => {
      for (let n = 0, o = e.ranges.length; n < o; n++)
        if (e.ranges[n].fromLineNumber <= i.lineNumber && i.lineNumber <= e.ranges[n].toLineNumber)
          return !0;
      return !1;
    };
    if (t(this._primaryCursor.getPosition()))
      return !0;
    for (const i of this._secondaryCursors)
      if (t(i.getPosition()))
        return !0;
    return !1;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  // ---- blinking logic
  _getCursorBlinking() {
    return this._isComposingInput || !this._editorHasFocus ? 0 : this._readOnly ? 5 : this._cursorBlinking;
  }
  _updateBlinking() {
    this._startCursorBlinkAnimation.cancel(), this._cursorFlatBlinkInterval.cancel();
    const e = this._getCursorBlinking(), t = e === 0, i = e === 5;
    t ? this._hide() : this._show(), this._blinkingEnabled = !1, this._updateDomClassName(), !t && !i && (e === 1 ? this._cursorFlatBlinkInterval.cancelAndSet(() => {
      this._isVisible ? this._hide() : this._show();
    }, xf.BLINK_INTERVAL, ue(this._domNode.domNode)) : this._startCursorBlinkAnimation.setIfNotSet(() => {
      this._blinkingEnabled = !0, this._updateDomClassName();
    }, xf.BLINK_INTERVAL));
  }
  // --- end blinking logic
  _updateDomClassName() {
    this._domNode.setClassName(this._getClassName());
  }
  _getClassName() {
    let e = "cursors-layer";
    switch (this._selectionIsEmpty || (e += " has-selection"), this._cursorStyle) {
      case wi.Line:
        e += " cursor-line-style";
        break;
      case wi.Block:
        e += " cursor-block-style";
        break;
      case wi.Underline:
        e += " cursor-underline-style";
        break;
      case wi.LineThin:
        e += " cursor-line-thin-style";
        break;
      case wi.BlockOutline:
        e += " cursor-block-outline-style";
        break;
      case wi.UnderlineThin:
        e += " cursor-underline-thin-style";
        break;
      default:
        e += " cursor-line-style";
    }
    if (this._blinkingEnabled)
      switch (this._getCursorBlinking()) {
        case 1:
          e += " cursor-blink";
          break;
        case 2:
          e += " cursor-smooth";
          break;
        case 3:
          e += " cursor-phase";
          break;
        case 4:
          e += " cursor-expand";
          break;
        case 5:
          e += " cursor-solid";
          break;
        default:
          e += " cursor-solid";
      }
    else
      e += " cursor-solid";
    return (this._cursorSmoothCaretAnimation === "on" || this._cursorSmoothCaretAnimation === "explicit") && (e += " cursor-smooth-caret-animation"), e;
  }
  _show() {
    this._primaryCursor.show();
    for (let e = 0, t = this._secondaryCursors.length; e < t; e++)
      this._secondaryCursors[e].show();
    this._isVisible = !0;
  }
  _hide() {
    this._primaryCursor.hide();
    for (let e = 0, t = this._secondaryCursors.length; e < t; e++)
      this._secondaryCursors[e].hide();
    this._isVisible = !1;
  }
  // ---- IViewPart implementation
  prepareRender(e) {
    this._primaryCursor.prepareRender(e);
    for (let t = 0, i = this._secondaryCursors.length; t < i; t++)
      this._secondaryCursors[t].prepareRender(e);
  }
  render(e) {
    const t = [];
    let i = 0;
    const n = this._primaryCursor.render(e);
    n && (t[i++] = n);
    for (let o = 0, r = this._secondaryCursors.length; o < r; o++) {
      const a = this._secondaryCursors[o].render(e);
      a && (t[i++] = a);
    }
    this._renderData = t;
  }
  getLastRenderData() {
    return this._renderData;
  }
};
xf.BLINK_INTERVAL = 500;
let RS = xf;
Jr((s, e) => {
  const t = [
    { class: ".cursor", foreground: Wb, background: Ok },
    { class: ".cursor-primary", foreground: RA, background: yz },
    { class: ".cursor-secondary", foreground: AA, background: Sz }
  ];
  for (const i of t) {
    const n = s.getColor(i.foreground);
    if (n) {
      let o = s.getColor(i.background);
      o || (o = n.opposite()), e.addRule(`.monaco-editor .cursors-layer ${i.class} { background-color: ${n}; border-color: ${n}; color: ${o}; }`), Gh(s.type) && e.addRule(`.monaco-editor .cursors-layer.has-selection ${i.class} { border-left: 1px solid ${o}; border-right: 1px solid ${o}; }`);
    }
  }
});
const CC = () => {
  throw new Error("Invalid change accessor");
};
class hY extends Hn {
  constructor(e) {
    super(e);
    const t = this._context.configuration.options, i = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    this._lineHeight = t.get(
      67
      /* EditorOption.lineHeight */
    ), this._contentWidth = i.contentWidth, this._contentLeft = i.contentLeft, this.domNode = je(document.createElement("div")), this.domNode.setClassName("view-zones"), this.domNode.setPosition("absolute"), this.domNode.setAttribute("role", "presentation"), this.domNode.setAttribute("aria-hidden", "true"), this.marginDomNode = je(document.createElement("div")), this.marginDomNode.setClassName("margin-view-zones"), this.marginDomNode.setPosition("absolute"), this.marginDomNode.setAttribute("role", "presentation"), this.marginDomNode.setAttribute("aria-hidden", "true"), this._zones = {};
  }
  dispose() {
    super.dispose(), this._zones = {};
  }
  // ---- begin view event handlers
  _recomputeWhitespacesProps() {
    const e = this._context.viewLayout.getWhitespaces(), t = /* @__PURE__ */ new Map();
    for (const n of e)
      t.set(n.id, n);
    let i = !1;
    return this._context.viewModel.changeWhitespace((n) => {
      const o = Object.keys(this._zones);
      for (let r = 0, a = o.length; r < a; r++) {
        const l = o[r], c = this._zones[l], h = this._computeWhitespaceProps(c.delegate);
        c.isInHiddenArea = h.isInHiddenArea;
        const d = t.get(l);
        d && (d.afterLineNumber !== h.afterViewLineNumber || d.height !== h.heightInPx) && (n.changeOneWhitespace(l, h.afterViewLineNumber, h.heightInPx), this._safeCallOnComputedHeight(c.delegate, h.heightInPx), i = !0);
      }
    }), i;
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    return this._lineHeight = t.get(
      67
      /* EditorOption.lineHeight */
    ), this._contentWidth = i.contentWidth, this._contentLeft = i.contentLeft, e.hasChanged(
      67
      /* EditorOption.lineHeight */
    ) && this._recomputeWhitespacesProps(), !0;
  }
  onLineMappingChanged(e) {
    return this._recomputeWhitespacesProps();
  }
  onLinesDeleted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged || e.scrollWidthChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  // ---- end view event handlers
  _getZoneOrdinal(e) {
    return e.ordinal ?? e.afterColumn ?? 1e4;
  }
  _computeWhitespaceProps(e) {
    if (e.afterLineNumber === 0)
      return {
        isInHiddenArea: !1,
        afterViewLineNumber: 0,
        heightInPx: this._heightInPixels(e),
        minWidthInPx: this._minWidthInPixels(e)
      };
    let t;
    if (typeof e.afterColumn < "u")
      t = this._context.viewModel.model.validatePosition({
        lineNumber: e.afterLineNumber,
        column: e.afterColumn
      });
    else {
      const r = this._context.viewModel.model.validatePosition({
        lineNumber: e.afterLineNumber,
        column: 1
      }).lineNumber;
      t = new V(r, this._context.viewModel.model.getLineMaxColumn(r));
    }
    let i;
    t.column === this._context.viewModel.model.getLineMaxColumn(t.lineNumber) ? i = this._context.viewModel.model.validatePosition({
      lineNumber: t.lineNumber + 1,
      column: 1
    }) : i = this._context.viewModel.model.validatePosition({
      lineNumber: t.lineNumber,
      column: t.column + 1
    });
    const n = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(t, e.afterColumnAffinity, !0), o = e.showInHiddenAreas || this._context.viewModel.coordinatesConverter.modelPositionIsVisible(i);
    return {
      isInHiddenArea: !o,
      afterViewLineNumber: n.lineNumber,
      heightInPx: o ? this._heightInPixels(e) : 0,
      minWidthInPx: this._minWidthInPixels(e)
    };
  }
  changeViewZones(e) {
    let t = !1;
    return this._context.viewModel.changeWhitespace((i) => {
      const n = {
        addZone: (o) => (t = !0, this._addZone(i, o)),
        removeZone: (o) => {
          o && (t = this._removeZone(i, o) || t);
        },
        layoutZone: (o) => {
          o && (t = this._layoutZone(i, o) || t);
        }
      };
      dY(e, n), n.addZone = CC, n.removeZone = CC, n.layoutZone = CC;
    }), t;
  }
  _addZone(e, t) {
    const i = this._computeWhitespaceProps(t), o = {
      whitespaceId: e.insertWhitespace(i.afterViewLineNumber, this._getZoneOrdinal(t), i.heightInPx, i.minWidthInPx),
      delegate: t,
      isInHiddenArea: i.isInHiddenArea,
      isVisible: !1,
      domNode: je(t.domNode),
      marginDomNode: t.marginDomNode ? je(t.marginDomNode) : null
    };
    return this._safeCallOnComputedHeight(o.delegate, i.heightInPx), o.domNode.setPosition("absolute"), o.domNode.domNode.style.width = "100%", o.domNode.setDisplay("none"), o.domNode.setAttribute("monaco-view-zone", o.whitespaceId), this.domNode.appendChild(o.domNode), o.marginDomNode && (o.marginDomNode.setPosition("absolute"), o.marginDomNode.domNode.style.width = "100%", o.marginDomNode.setDisplay("none"), o.marginDomNode.setAttribute("monaco-view-zone", o.whitespaceId), this.marginDomNode.appendChild(o.marginDomNode)), this._zones[o.whitespaceId] = o, this.setShouldRender(), o.whitespaceId;
  }
  _removeZone(e, t) {
    if (this._zones.hasOwnProperty(t)) {
      const i = this._zones[t];
      return delete this._zones[t], e.removeWhitespace(i.whitespaceId), i.domNode.removeAttribute("monaco-visible-view-zone"), i.domNode.removeAttribute("monaco-view-zone"), i.domNode.domNode.remove(), i.marginDomNode && (i.marginDomNode.removeAttribute("monaco-visible-view-zone"), i.marginDomNode.removeAttribute("monaco-view-zone"), i.marginDomNode.domNode.remove()), this.setShouldRender(), !0;
    }
    return !1;
  }
  _layoutZone(e, t) {
    if (this._zones.hasOwnProperty(t)) {
      const i = this._zones[t], n = this._computeWhitespaceProps(i.delegate);
      return i.isInHiddenArea = n.isInHiddenArea, e.changeOneWhitespace(i.whitespaceId, n.afterViewLineNumber, n.heightInPx), this._safeCallOnComputedHeight(i.delegate, n.heightInPx), this.setShouldRender(), !0;
    }
    return !1;
  }
  shouldSuppressMouseDownOnViewZone(e) {
    return this._zones.hasOwnProperty(e) ? !!this._zones[e].delegate.suppressMouseDown : !1;
  }
  _heightInPixels(e) {
    return typeof e.heightInPx == "number" ? e.heightInPx : typeof e.heightInLines == "number" ? this._lineHeight * e.heightInLines : this._lineHeight;
  }
  _minWidthInPixels(e) {
    return typeof e.minWidthInPx == "number" ? e.minWidthInPx : 0;
  }
  _safeCallOnComputedHeight(e, t) {
    if (typeof e.onComputedHeight == "function")
      try {
        e.onComputedHeight(t);
      } catch (i) {
        ht(i);
      }
  }
  _safeCallOnDomNodeTop(e, t) {
    if (typeof e.onDomNodeTop == "function")
      try {
        e.onDomNodeTop(t);
      } catch (i) {
        ht(i);
      }
  }
  prepareRender(e) {
  }
  render(e) {
    const t = e.viewportData.whitespaceViewportData, i = {};
    let n = !1;
    for (const r of t)
      this._zones[r.id].isInHiddenArea || (i[r.id] = r, n = !0);
    const o = Object.keys(this._zones);
    for (let r = 0, a = o.length; r < a; r++) {
      const l = o[r], c = this._zones[l];
      let h = 0, d = 0, u = "none";
      i.hasOwnProperty(l) ? (h = i[l].verticalOffset - e.bigNumbersDelta, d = i[l].height, u = "block", c.isVisible || (c.domNode.setAttribute("monaco-visible-view-zone", "true"), c.isVisible = !0), this._safeCallOnDomNodeTop(c.delegate, e.getScrolledTopFromAbsoluteTop(i[l].verticalOffset))) : (c.isVisible && (c.domNode.removeAttribute("monaco-visible-view-zone"), c.isVisible = !1), this._safeCallOnDomNodeTop(c.delegate, e.getScrolledTopFromAbsoluteTop(-1e6))), c.domNode.setTop(h), c.domNode.setHeight(d), c.domNode.setDisplay(u), c.marginDomNode && (c.marginDomNode.setTop(h), c.marginDomNode.setHeight(d), c.marginDomNode.setDisplay(u));
    }
    n && (this.domNode.setWidth(Math.max(e.scrollWidth, this._contentWidth)), this.marginDomNode.setWidth(this._contentLeft));
  }
}
function dY(s, e) {
  try {
    return s(e);
  } catch (t) {
    ht(t);
  }
}
class uY extends Hc {
  constructor(e) {
    super(), this._context = e, this._options = new kT(this._context.configuration), this._selection = [], this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = new kT(this._context.configuration);
    return this._options.equals(t) ? e.hasChanged(
      146
      /* EditorOption.layoutInfo */
    ) : (this._options = t, !0);
  }
  onCursorStateChanged(e) {
    return this._selection = e.selections, this._options.renderWhitespace === "selection";
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  prepareRender(e) {
    if (this._options.renderWhitespace === "none") {
      this._renderResult = null;
      return;
    }
    const t = e.visibleRange.startLineNumber, n = e.visibleRange.endLineNumber - t + 1, o = new Array(n);
    for (let a = 0; a < n; a++)
      o[a] = !0;
    const r = this._context.viewModel.getMinimapLinesRenderingData(e.viewportData.startLineNumber, e.viewportData.endLineNumber, o);
    this._renderResult = [];
    for (let a = e.viewportData.startLineNumber; a <= e.viewportData.endLineNumber; a++) {
      const l = a - e.viewportData.startLineNumber, c = r.data[l];
      let h = null;
      if (this._options.renderWhitespace === "selection") {
        const d = this._selection;
        for (const u of d) {
          if (u.endLineNumber < a || u.startLineNumber > a)
            continue;
          const f = u.startLineNumber === a ? u.startColumn : c.minColumn, g = u.endLineNumber === a ? u.endColumn : c.maxColumn;
          f < g && (h || (h = []), h.push(new z4(f - 1, g - 1)));
        }
      }
      this._renderResult[l] = this._applyRenderWhitespace(e, a, h, c);
    }
  }
  _applyRenderWhitespace(e, t, i, n) {
    if (this._options.renderWhitespace === "selection" && !i || this._options.renderWhitespace === "trailing" && n.continuesWithWrappedLine)
      return "";
    const o = this._context.theme.getColor(Fk), r = this._options.renderWithSVG, a = n.content, l = this._options.stopRenderingLineAfter === -1 ? a.length : Math.min(this._options.stopRenderingLineAfter, a.length), c = n.continuesWithWrappedLine, h = n.minColumn - 1, d = this._options.renderWhitespace === "boundary", u = this._options.renderWhitespace === "trailing", f = this._options.lineHeight, g = this._options.middotWidth, m = this._options.wsmiddotWidth, _ = this._options.spaceWidth, b = Math.abs(m - _), C = Math.abs(g - _), v = b < C ? 11825 : 183, w = this._options.canUseHalfwidthRightwardsArrow;
    let S = "", L = !1, k = On(a), D;
    k === -1 ? (L = !0, k = l, D = l) : D = Ec(a);
    let E = 0, U = i && i[E], P = 0;
    for (let B = h; B < l; B++) {
      const W = a.charCodeAt(B);
      if (U && B >= U.endOffset && (E++, U = i && i[E]), W !== 9 && W !== 32 || u && !L && B <= D)
        continue;
      if (d && B >= k && B <= D && W === 32) {
        const K = B - 1 >= 0 ? a.charCodeAt(B - 1) : 0, Y = B + 1 < l ? a.charCodeAt(B + 1) : 0;
        if (K !== 32 && Y !== 32)
          continue;
      }
      if (d && c && B === l - 1) {
        const K = B - 1 >= 0 ? a.charCodeAt(B - 1) : 0;
        if (W === 32 && K !== 32 && K !== 9)
          continue;
      }
      if (i && (!U || U.startOffset > B || U.endOffset <= B))
        continue;
      const A = e.visibleRangeForPosition(new V(t, B + 1));
      A && (r ? (P = Math.max(P, A.left), W === 9 ? S += this._renderArrow(f, _, A.left) : S += `<circle cx="${(A.left + _ / 2).toFixed(2)}" cy="${(f / 2).toFixed(2)}" r="${(_ / 7).toFixed(2)}" />`) : W === 9 ? S += `<div class="mwh" style="left:${A.left}px;height:${f}px;">${w ? "￫" : "→"}</div>` : S += `<div class="mwh" style="left:${A.left}px;height:${f}px;">${String.fromCharCode(v)}</div>`);
    }
    return r ? (P = Math.round(P + _), `<svg style="bottom:0;position:absolute;width:${P}px;height:${f}px" viewBox="0 0 ${P} ${f}" xmlns="http://www.w3.org/2000/svg" fill="${o}">` + S + "</svg>") : S;
  }
  _renderArrow(e, t, i) {
    const n = t / 7, o = t, r = e / 2, a = i, l = { x: 0, y: n / 2 }, c = { x: 100 / 125 * o, y: l.y }, h = { x: c.x - 0.2 * c.x, y: c.y + 0.2 * c.x }, d = { x: h.x + 0.1 * c.x, y: h.y + 0.1 * c.x }, u = { x: d.x + 0.35 * c.x, y: d.y - 0.35 * c.x }, f = { x: u.x, y: -u.y }, g = { x: d.x, y: -d.y }, m = { x: h.x, y: -h.y }, _ = { x: c.x, y: -c.y }, b = { x: l.x, y: -l.y };
    return `<path d="M ${[l, c, h, d, u, f, g, m, _, b].map((w) => `${(a + w.x).toFixed(2)} ${(r + w.y).toFixed(2)}`).join(" L ")}" />`;
  }
  render(e, t) {
    if (!this._renderResult)
      return "";
    const i = t - e;
    return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
  }
}
class kT {
  constructor(e) {
    const t = e.options, i = t.get(
      50
      /* EditorOption.fontInfo */
    ), n = t.get(
      38
      /* EditorOption.experimentalWhitespaceRendering */
    );
    n === "off" ? (this.renderWhitespace = "none", this.renderWithSVG = !1) : n === "svg" ? (this.renderWhitespace = t.get(
      100
      /* EditorOption.renderWhitespace */
    ), this.renderWithSVG = !0) : (this.renderWhitespace = t.get(
      100
      /* EditorOption.renderWhitespace */
    ), this.renderWithSVG = !1), this.spaceWidth = i.spaceWidth, this.middotWidth = i.middotWidth, this.wsmiddotWidth = i.wsmiddotWidth, this.canUseHalfwidthRightwardsArrow = i.canUseHalfwidthRightwardsArrow, this.lineHeight = t.get(
      67
      /* EditorOption.lineHeight */
    ), this.stopRenderingLineAfter = t.get(
      118
      /* EditorOption.stopRenderingLineAfter */
    );
  }
  equals(e) {
    return this.renderWhitespace === e.renderWhitespace && this.renderWithSVG === e.renderWithSVG && this.spaceWidth === e.spaceWidth && this.middotWidth === e.middotWidth && this.wsmiddotWidth === e.wsmiddotWidth && this.canUseHalfwidthRightwardsArrow === e.canUseHalfwidthRightwardsArrow && this.lineHeight === e.lineHeight && this.stopRenderingLineAfter === e.stopRenderingLineAfter;
  }
}
class fY {
  constructor(e, t, i, n) {
    this.selections = e, this.startLineNumber = t.startLineNumber | 0, this.endLineNumber = t.endLineNumber | 0, this.relativeVerticalOffset = t.relativeVerticalOffset, this.bigNumbersDelta = t.bigNumbersDelta | 0, this.lineHeight = t.lineHeight | 0, this.whitespaceViewportData = i, this._model = n, this.visibleRange = new R(t.startLineNumber, this._model.getLineMinColumn(t.startLineNumber), t.endLineNumber, this._model.getLineMaxColumn(t.endLineNumber));
  }
  getViewLineRenderingData(e) {
    return this._model.getViewportViewLineRenderingData(this.visibleRange, e);
  }
  getDecorationsInViewport() {
    return this._model.getDecorationsInViewport(this.visibleRange);
  }
}
class gY {
  get type() {
    return this._theme.type;
  }
  get value() {
    return this._theme;
  }
  constructor(e) {
    this._theme = e;
  }
  update(e) {
    this._theme = e;
  }
  getColor(e) {
    return this._theme.getColor(e);
  }
}
class mY {
  constructor(e, t, i) {
    this.configuration = e, this.theme = new gY(t), this.viewModel = i, this.viewLayout = i.viewLayout;
  }
  addEventHandler(e) {
    this.viewModel.addViewEventHandler(e);
  }
  removeEventHandler(e) {
    this.viewModel.removeViewEventHandler(e);
  }
}
var pY = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, _Y = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let AS = class extends Kg {
  constructor(e, t, i, n, o, r, a) {
    super(), this._instantiationService = a, this._shouldRecomputeGlyphMarginLanes = !1, this._selections = [new ft(1, 1, 1, 1)], this._renderAnimationFrame = null;
    const l = new LZ(t, n, o, e);
    this._context = new mY(t, i, n), this._context.addEventHandler(this), this._viewParts = [], this._textAreaHandler = this._instantiationService.createInstance(xS, this._context, l, this._createTextAreaHandlerHelper()), this._viewParts.push(this._textAreaHandler), this._linesContent = je(document.createElement("div")), this._linesContent.setClassName("lines-content monaco-editor-background"), this._linesContent.setPosition("absolute"), this.domNode = je(document.createElement("div")), this.domNode.setClassName(this._getEditorClassName()), this.domNode.setAttribute("role", "code"), this._overflowGuardContainer = je(document.createElement("div")), ho.write(
      this._overflowGuardContainer,
      3
      /* PartFingerprint.OverflowGuard */
    ), this._overflowGuardContainer.setClassName("overflow-guard"), this._scrollbar = new AZ(this._context, this._linesContent, this.domNode, this._overflowGuardContainer), this._viewParts.push(this._scrollbar), this._viewLines = new TS(this._context, this._linesContent), this._viewZones = new hY(this._context), this._viewParts.push(this._viewZones);
    const c = new tY(this._context);
    this._viewParts.push(c);
    const h = new oY(this._context);
    this._viewParts.push(h);
    const d = new xZ(this._context);
    this._viewParts.push(d), d.addDynamicOverlay(new TZ(this._context)), d.addDynamicOverlay(new MS(this._context)), d.addDynamicOverlay(new HZ(this._context)), d.addDynamicOverlay(new RZ(this._context)), d.addDynamicOverlay(new uY(this._context));
    const u = new DZ(this._context);
    this._viewParts.push(u), u.addDynamicOverlay(new MZ(this._context)), u.addDynamicOverlay(new qZ(this._context)), u.addDynamicOverlay(new KZ(this._context)), u.addDynamicOverlay(new O_(this._context)), this._glyphMarginWidgets = new FZ(this._context), this._viewParts.push(this._glyphMarginWidgets);
    const f = new F_(this._context);
    f.getDomNode().appendChild(this._viewZones.marginDomNode), f.getDomNode().appendChild(u.getDomNode()), f.getDomNode().appendChild(this._glyphMarginWidgets.domNode), this._viewParts.push(f), this._contentWidgets = new IZ(this._context, this.domNode), this._viewParts.push(this._contentWidgets), this._viewCursors = new RS(this._context), this._viewParts.push(this._viewCursors), this._overlayWidgets = new JZ(this._context, this.domNode), this._viewParts.push(this._overlayWidgets);
    const g = new sY(this._context);
    this._viewParts.push(g);
    const m = new EZ(this._context);
    this._viewParts.push(m);
    const _ = new XZ(this._context);
    if (this._viewParts.push(_), c) {
      const b = this._scrollbar.getOverviewRulerLayoutInfo();
      b.parent.insertBefore(c.getDomNode(), b.insertBefore);
    }
    this._linesContent.appendChild(d.getDomNode()), this._linesContent.appendChild(g.domNode), this._linesContent.appendChild(this._viewZones.domNode), this._linesContent.appendChild(this._viewLines.getDomNode()), this._linesContent.appendChild(this._contentWidgets.domNode), this._linesContent.appendChild(this._viewCursors.getDomNode()), this._overflowGuardContainer.appendChild(f.getDomNode()), this._overflowGuardContainer.appendChild(this._scrollbar.getDomNode()), this._overflowGuardContainer.appendChild(h.getDomNode()), this._overflowGuardContainer.appendChild(this._textAreaHandler.textArea), this._overflowGuardContainer.appendChild(this._textAreaHandler.textAreaCover), this._overflowGuardContainer.appendChild(this._overlayWidgets.getDomNode()), this._overflowGuardContainer.appendChild(_.getDomNode()), this._overflowGuardContainer.appendChild(m.domNode), this.domNode.appendChild(this._overflowGuardContainer), r ? (r.appendChild(this._contentWidgets.overflowingContentWidgetsDomNode.domNode), r.appendChild(this._overlayWidgets.overflowingOverlayWidgetsDomNode.domNode)) : (this.domNode.appendChild(this._contentWidgets.overflowingContentWidgetsDomNode), this.domNode.appendChild(this._overlayWidgets.overflowingOverlayWidgetsDomNode)), this._applyLayout(), this._pointerHandler = this._register(new KG(this._context, l, this._createPointerHandlerHelper()));
  }
  _computeGlyphMarginLanes() {
    const e = this._context.viewModel.model, t = this._context.viewModel.glyphLanes;
    let i = [], n = 0;
    i = i.concat(e.getAllMarginDecorations().map((o) => {
      var a, l;
      const r = ((a = o.options.glyphMargin) == null ? void 0 : a.position) ?? Ka.Center;
      return n = Math.max(n, o.range.endLineNumber), { range: o.range, lane: r, persist: (l = o.options.glyphMargin) == null ? void 0 : l.persistLane };
    })), i = i.concat(this._glyphMarginWidgets.getWidgets().map((o) => {
      const r = e.validateRange(o.preference.range);
      return n = Math.max(n, r.endLineNumber), { range: r, lane: o.preference.lane };
    })), i.sort((o, r) => R.compareRangesUsingStarts(o.range, r.range)), t.reset(n);
    for (const o of i)
      t.push(o.lane, o.range, o.persist);
    return t;
  }
  _createPointerHandlerHelper() {
    return {
      viewDomNode: this.domNode.domNode,
      linesContentDomNode: this._linesContent.domNode,
      viewLinesDomNode: this._viewLines.getDomNode().domNode,
      focusTextArea: () => {
        this.focus();
      },
      dispatchTextAreaEvent: (e) => {
        this._textAreaHandler.textArea.domNode.dispatchEvent(e);
      },
      getLastRenderData: () => {
        const e = this._viewCursors.getLastRenderData() || [], t = this._textAreaHandler.getLastRenderData();
        return new RG(e, t);
      },
      renderNow: () => {
        this.render(!0, !1);
      },
      shouldSuppressMouseDownOnViewZone: (e) => this._viewZones.shouldSuppressMouseDownOnViewZone(e),
      shouldSuppressMouseDownOnWidget: (e) => this._contentWidgets.shouldSuppressMouseDownOnWidget(e),
      getPositionFromDOMInfo: (e, t) => (this._flushAccumulatedAndRenderNow(), this._viewLines.getPositionFromDOMInfo(e, t)),
      visibleRangeForPosition: (e, t) => (this._flushAccumulatedAndRenderNow(), this._viewLines.visibleRangeForPosition(new V(e, t))),
      getLineWidth: (e) => (this._flushAccumulatedAndRenderNow(), this._viewLines.getLineWidth(e))
    };
  }
  _createTextAreaHandlerHelper() {
    return {
      visibleRangeForPosition: (e) => (this._flushAccumulatedAndRenderNow(), this._viewLines.visibleRangeForPosition(e))
    };
  }
  _applyLayout() {
    const t = this._context.configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    );
    this.domNode.setWidth(t.width), this.domNode.setHeight(t.height), this._overflowGuardContainer.setWidth(t.width), this._overflowGuardContainer.setHeight(t.height), this._linesContent.setWidth(16777216), this._linesContent.setHeight(16777216);
  }
  _getEditorClassName() {
    const e = this._textAreaHandler.isFocused() ? " focused" : "";
    return this._context.configuration.options.get(
      143
      /* EditorOption.editorClassName */
    ) + " " + wv(this._context.theme.type) + e;
  }
  // --- begin event handlers
  handleEvents(e) {
    super.handleEvents(e), this._scheduleRender();
  }
  onConfigurationChanged(e) {
    return this.domNode.setClassName(this._getEditorClassName()), this._applyLayout(), !1;
  }
  onCursorStateChanged(e) {
    return this._selections = e.selections, !1;
  }
  onDecorationsChanged(e) {
    return e.affectsGlyphMargin && (this._shouldRecomputeGlyphMarginLanes = !0), !1;
  }
  onFocusChanged(e) {
    return this.domNode.setClassName(this._getEditorClassName()), !1;
  }
  onThemeChanged(e) {
    return this._context.theme.update(e.theme), this.domNode.setClassName(this._getEditorClassName()), !1;
  }
  // --- end event handlers
  dispose() {
    this._renderAnimationFrame !== null && (this._renderAnimationFrame.dispose(), this._renderAnimationFrame = null), this._contentWidgets.overflowingContentWidgetsDomNode.domNode.remove(), this._context.removeEventHandler(this), this._viewLines.dispose();
    for (const e of this._viewParts)
      e.dispose();
    super.dispose();
  }
  _scheduleRender() {
    var e;
    if (this._store.isDisposed)
      throw new it();
    if (this._renderAnimationFrame === null) {
      const t = this._createCoordinatedRendering();
      this._renderAnimationFrame = PS.INSTANCE.scheduleCoordinatedRendering({
        window: ue((e = this.domNode) == null ? void 0 : e.domNode),
        prepareRenderText: () => {
          if (this._store.isDisposed)
            throw new it();
          try {
            return t.prepareRenderText();
          } finally {
            this._renderAnimationFrame = null;
          }
        },
        renderText: () => {
          if (this._store.isDisposed)
            throw new it();
          return t.renderText();
        },
        prepareRender: (i, n) => {
          if (this._store.isDisposed)
            throw new it();
          return t.prepareRender(i, n);
        },
        render: (i, n) => {
          if (this._store.isDisposed)
            throw new it();
          return t.render(i, n);
        }
      });
    }
  }
  _flushAccumulatedAndRenderNow() {
    const e = this._createCoordinatedRendering();
    Ta(() => e.prepareRenderText());
    const t = Ta(() => e.renderText());
    if (t) {
      const [i, n] = t;
      Ta(() => e.prepareRender(i, n)), Ta(() => e.render(i, n));
    }
  }
  _getViewPartsToRender() {
    const e = [];
    let t = 0;
    for (const i of this._viewParts)
      i.shouldRender() && (e[t++] = i);
    return e;
  }
  _createCoordinatedRendering() {
    return {
      prepareRenderText: () => {
        if (this._shouldRecomputeGlyphMarginLanes) {
          this._shouldRecomputeGlyphMarginLanes = !1;
          const e = this._computeGlyphMarginLanes();
          this._context.configuration.setGlyphMarginDecorationLaneCount(e.requiredLanes);
        }
        Na.onRenderStart();
      },
      renderText: () => {
        if (!this.domNode.domNode.isConnected)
          return null;
        let e = this._getViewPartsToRender();
        if (!this._viewLines.shouldRender() && e.length === 0)
          return null;
        const t = this._context.viewLayout.getLinesViewportData();
        this._context.viewModel.setViewport(t.startLineNumber, t.endLineNumber, t.centeredLineNumber);
        const i = new fY(this._selections, t, this._context.viewLayout.getWhitespaceViewportData(), this._context.viewModel);
        return this._contentWidgets.shouldRender() && this._contentWidgets.onBeforeRender(i), this._viewLines.shouldRender() && (this._viewLines.renderText(i), this._viewLines.onDidRender(), e = this._getViewPartsToRender()), [e, new xG(this._context.viewLayout, i, this._viewLines)];
      },
      prepareRender: (e, t) => {
        for (const i of e)
          i.prepareRender(t);
      },
      render: (e, t) => {
        for (const i of e)
          i.render(t), i.onDidRender();
      }
    };
  }
  // --- BEGIN CodeEditor helpers
  delegateVerticalScrollbarPointerDown(e) {
    this._scrollbar.delegateVerticalScrollbarPointerDown(e);
  }
  delegateScrollFromMouseWheelEvent(e) {
    this._scrollbar.delegateScrollFromMouseWheelEvent(e);
  }
  restoreState(e) {
    this._context.viewModel.viewLayout.setScrollPosition(
      {
        scrollTop: e.scrollTop,
        scrollLeft: e.scrollLeft
      },
      1
      /* ScrollType.Immediate */
    ), this._context.viewModel.visibleLinesStabilized();
  }
  getOffsetForColumn(e, t) {
    const i = this._context.viewModel.model.validatePosition({
      lineNumber: e,
      column: t
    }), n = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(i);
    this._flushAccumulatedAndRenderNow();
    const o = this._viewLines.visibleRangeForPosition(new V(n.lineNumber, n.column));
    return o ? o.left : -1;
  }
  getTargetAtClientPoint(e, t) {
    const i = this._pointerHandler.getTargetAtClientPoint(e, t);
    return i ? e0.convertViewToModelMouseTarget(i, this._context.viewModel.coordinatesConverter) : null;
  }
  createOverviewRuler(e) {
    return new nY(this._context, e);
  }
  change(e) {
    this._viewZones.changeViewZones(e), this._scheduleRender();
  }
  render(e, t) {
    if (t) {
      this._viewLines.forceShouldRender();
      for (const i of this._viewParts)
        i.forceShouldRender();
    }
    e ? this._flushAccumulatedAndRenderNow() : this._scheduleRender();
  }
  writeScreenReaderContent(e) {
    this._textAreaHandler.writeScreenReaderContent(e);
  }
  focus() {
    this._textAreaHandler.focusTextArea();
  }
  isFocused() {
    return this._textAreaHandler.isFocused();
  }
  setAriaOptions(e) {
    this._textAreaHandler.setAriaOptions(e);
  }
  addContentWidget(e) {
    this._contentWidgets.addWidget(e.widget), this.layoutContentWidget(e), this._scheduleRender();
  }
  layoutContentWidget(e) {
    var t, i, n, o;
    this._contentWidgets.setWidgetPosition(e.widget, ((t = e.position) == null ? void 0 : t.position) ?? null, ((i = e.position) == null ? void 0 : i.secondaryPosition) ?? null, ((n = e.position) == null ? void 0 : n.preference) ?? null, ((o = e.position) == null ? void 0 : o.positionAffinity) ?? null), this._scheduleRender();
  }
  removeContentWidget(e) {
    this._contentWidgets.removeWidget(e.widget), this._scheduleRender();
  }
  addOverlayWidget(e) {
    this._overlayWidgets.addWidget(e.widget), this.layoutOverlayWidget(e), this._scheduleRender();
  }
  layoutOverlayWidget(e) {
    this._overlayWidgets.setWidgetPosition(e.widget, e.position) && this._scheduleRender();
  }
  removeOverlayWidget(e) {
    this._overlayWidgets.removeWidget(e.widget), this._scheduleRender();
  }
  addGlyphMarginWidget(e) {
    this._glyphMarginWidgets.addWidget(e.widget), this._shouldRecomputeGlyphMarginLanes = !0, this._scheduleRender();
  }
  layoutGlyphMarginWidget(e) {
    const t = e.position;
    this._glyphMarginWidgets.setWidgetPosition(e.widget, t) && (this._shouldRecomputeGlyphMarginLanes = !0, this._scheduleRender());
  }
  removeGlyphMarginWidget(e) {
    this._glyphMarginWidgets.removeWidget(e.widget), this._shouldRecomputeGlyphMarginLanes = !0, this._scheduleRender();
  }
};
AS = pY([
  _Y(6, ot)
], AS);
function Ta(s) {
  try {
    return s();
  } catch (e) {
    return ht(e), null;
  }
}
const $1 = class $1 {
  constructor() {
    this._coordinatedRenderings = [], this._animationFrameRunners = /* @__PURE__ */ new Map();
  }
  scheduleCoordinatedRendering(e) {
    return this._coordinatedRenderings.push(e), this._scheduleRender(e.window), {
      dispose: () => {
        const t = this._coordinatedRenderings.indexOf(e);
        if (t !== -1 && (this._coordinatedRenderings.splice(t, 1), this._coordinatedRenderings.length === 0)) {
          for (const [i, n] of this._animationFrameRunners)
            n.dispose();
          this._animationFrameRunners.clear();
        }
      }
    };
  }
  _scheduleRender(e) {
    if (!this._animationFrameRunners.has(e)) {
      const t = () => {
        this._animationFrameRunners.delete(e), this._onRenderScheduled();
      };
      this._animationFrameRunners.set(e, wM(e, t, 100));
    }
  }
  _onRenderScheduled() {
    const e = this._coordinatedRenderings.slice(0);
    this._coordinatedRenderings = [];
    for (const i of e)
      Ta(() => i.prepareRenderText());
    const t = [];
    for (let i = 0, n = e.length; i < n; i++) {
      const o = e[i];
      t[i] = Ta(() => o.renderText());
    }
    for (let i = 0, n = e.length; i < n; i++) {
      const o = e[i], r = t[i];
      if (!r)
        continue;
      const [a, l] = r;
      Ta(() => o.prepareRender(a, l));
    }
    for (let i = 0, n = e.length; i < n; i++) {
      const o = e[i], r = t[i];
      if (!r)
        continue;
      const [a, l] = r;
      Ta(() => o.render(a, l));
    }
  }
};
$1.INSTANCE = new $1();
let PS = $1;
class hf {
  constructor(e, t, i, n, o) {
    this.injectionOffsets = e, this.injectionOptions = t, this.breakOffsets = i, this.breakOffsetsVisibleColumn = n, this.wrappedTextIndentLength = o;
  }
  getOutputLineCount() {
    return this.breakOffsets.length;
  }
  getMinOutputOffset(e) {
    return e > 0 ? this.wrappedTextIndentLength : 0;
  }
  getLineLength(e) {
    const t = e > 0 ? this.breakOffsets[e - 1] : 0;
    let n = this.breakOffsets[e] - t;
    return e > 0 && (n += this.wrappedTextIndentLength), n;
  }
  getMaxOutputOffset(e) {
    return this.getLineLength(e);
  }
  translateToInputOffset(e, t) {
    e > 0 && (t = Math.max(0, t - this.wrappedTextIndentLength));
    let n = e === 0 ? t : this.breakOffsets[e - 1] + t;
    if (this.injectionOffsets !== null)
      for (let o = 0; o < this.injectionOffsets.length && n > this.injectionOffsets[o]; o++)
        n < this.injectionOffsets[o] + this.injectionOptions[o].content.length ? n = this.injectionOffsets[o] : n -= this.injectionOptions[o].content.length;
    return n;
  }
  translateToOutputPosition(e, t = 2) {
    let i = e;
    if (this.injectionOffsets !== null)
      for (let n = 0; n < this.injectionOffsets.length && !(e < this.injectionOffsets[n] || t !== 1 && e === this.injectionOffsets[n]); n++)
        i += this.injectionOptions[n].content.length;
    return this.offsetInInputWithInjectionsToOutputPosition(i, t);
  }
  offsetInInputWithInjectionsToOutputPosition(e, t = 2) {
    let i = 0, n = this.breakOffsets.length - 1, o = 0, r = 0;
    for (; i <= n; ) {
      o = i + (n - i) / 2 | 0;
      const l = this.breakOffsets[o];
      if (r = o > 0 ? this.breakOffsets[o - 1] : 0, t === 0)
        if (e <= r)
          n = o - 1;
        else if (e > l)
          i = o + 1;
        else
          break;
      else if (e < r)
        n = o - 1;
      else if (e >= l)
        i = o + 1;
      else
        break;
    }
    let a = e - r;
    return o > 0 && (a += this.wrappedTextIndentLength), new Om(o, a);
  }
  normalizeOutputPosition(e, t, i) {
    if (this.injectionOffsets !== null) {
      const n = this.outputPositionToOffsetInInputWithInjections(e, t), o = this.normalizeOffsetInInputWithInjectionsAroundInjections(n, i);
      if (o !== n)
        return this.offsetInInputWithInjectionsToOutputPosition(o, i);
    }
    if (i === 0) {
      if (e > 0 && t === this.getMinOutputOffset(e))
        return new Om(e - 1, this.getMaxOutputOffset(e - 1));
    } else if (i === 1) {
      const n = this.getOutputLineCount() - 1;
      if (e < n && t === this.getMaxOutputOffset(e))
        return new Om(e + 1, this.getMinOutputOffset(e + 1));
    }
    return new Om(e, t);
  }
  outputPositionToOffsetInInputWithInjections(e, t) {
    return e > 0 && (t = Math.max(0, t - this.wrappedTextIndentLength)), (e > 0 ? this.breakOffsets[e - 1] : 0) + t;
  }
  normalizeOffsetInInputWithInjectionsAroundInjections(e, t) {
    const i = this.getInjectedTextAtOffset(e);
    if (!i)
      return e;
    if (t === 2) {
      if (e === i.offsetInInputWithInjections + i.length && xT(this.injectionOptions[i.injectedTextIndex].cursorStops))
        return i.offsetInInputWithInjections + i.length;
      {
        let n = i.offsetInInputWithInjections;
        if (DT(this.injectionOptions[i.injectedTextIndex].cursorStops))
          return n;
        let o = i.injectedTextIndex - 1;
        for (; o >= 0 && this.injectionOffsets[o] === this.injectionOffsets[i.injectedTextIndex] && !(xT(this.injectionOptions[o].cursorStops) || (n -= this.injectionOptions[o].content.length, DT(this.injectionOptions[o].cursorStops))); )
          o--;
        return n;
      }
    } else if (t === 1 || t === 4) {
      let n = i.offsetInInputWithInjections + i.length, o = i.injectedTextIndex;
      for (; o + 1 < this.injectionOffsets.length && this.injectionOffsets[o + 1] === this.injectionOffsets[o]; )
        n += this.injectionOptions[o + 1].content.length, o++;
      return n;
    } else if (t === 0 || t === 3) {
      let n = i.offsetInInputWithInjections, o = i.injectedTextIndex;
      for (; o - 1 >= 0 && this.injectionOffsets[o - 1] === this.injectionOffsets[o]; )
        n -= this.injectionOptions[o - 1].content.length, o--;
      return n;
    }
    jL();
  }
  getInjectedText(e, t) {
    const i = this.outputPositionToOffsetInInputWithInjections(e, t), n = this.getInjectedTextAtOffset(i);
    return n ? {
      options: this.injectionOptions[n.injectedTextIndex]
    } : null;
  }
  getInjectedTextAtOffset(e) {
    const t = this.injectionOffsets, i = this.injectionOptions;
    if (t !== null) {
      let n = 0;
      for (let o = 0; o < t.length; o++) {
        const r = i[o].content.length, a = t[o] + n, l = t[o] + n + r;
        if (a > e)
          break;
        if (e <= l)
          return {
            injectedTextIndex: o,
            offsetInInputWithInjections: a,
            length: r
          };
        n += r;
      }
    }
  }
}
function xT(s) {
  return s == null ? !0 : s === yd.Right || s === yd.Both;
}
function DT(s) {
  return s == null ? !0 : s === yd.Left || s === yd.Both;
}
class Om {
  constructor(e, t) {
    this.outputLineIndex = e, this.outputOffset = t;
  }
  toString() {
    return `${this.outputLineIndex}:${this.outputOffset}`;
  }
  toPosition(e) {
    return new V(e + this.outputLineIndex, this.outputOffset + 1);
  }
}
const wC = Pc("domLineBreaksComputer", { createHTML: (s) => s });
class Ix {
  static create(e) {
    return new Ix(new WeakRef(e));
  }
  constructor(e) {
    this.targetWindow = e;
  }
  createLineBreaksComputer(e, t, i, n, o) {
    const r = [], a = [];
    return {
      addRequest: (l, c, h) => {
        r.push(l), a.push(c);
      },
      finalize: () => bY(w2(this.targetWindow.deref()), r, e, t, i, n, o, a)
    };
  }
}
function bY(s, e, t, i, n, o, r, a) {
  function l(E) {
    const U = a[E];
    if (U) {
      const P = ao.applyInjectedText(e[E], U), B = U.map((A) => A.options), W = U.map((A) => A.column - 1);
      return new hf(W, B, [P.length], [], 0);
    } else
      return null;
  }
  if (n === -1) {
    const E = [];
    for (let U = 0, P = e.length; U < P; U++)
      E[U] = l(U);
    return E;
  }
  const c = Math.round(n * t.typicalHalfwidthCharacterWidth), d = Math.round(i * (o === 3 ? 2 : o === 2 ? 1 : 0)), u = Math.ceil(t.spaceWidth * d), f = document.createElement("div");
  Fi(f, t);
  const g = new bb(1e4), m = [], _ = [], b = [], C = [], v = [];
  for (let E = 0; E < e.length; E++) {
    const U = ao.applyInjectedText(e[E], a[E]);
    let P = 0, B = 0, W = c;
    if (o !== 0)
      if (P = On(U), P === -1)
        P = 0;
      else {
        for (let Q = 0; Q < P; Q++) {
          const ne = U.charCodeAt(Q) === 9 ? i - B % i : 1;
          B += ne;
        }
        const Y = Math.ceil(t.spaceWidth * B);
        Y + t.typicalFullwidthCharacterWidth > c ? (P = 0, B = 0) : W = c - Y;
      }
    const A = U.substr(P), K = CY(A, B, i, W, g, u);
    m[E] = P, _[E] = B, b[E] = A, C[E] = K[0], v[E] = K[1];
  }
  const w = g.build(), S = (wC == null ? void 0 : wC.createHTML(w)) ?? w;
  f.innerHTML = S, f.style.position = "absolute", f.style.top = "10000", r === "keepAll" ? (f.style.wordBreak = "keep-all", f.style.overflowWrap = "anywhere") : (f.style.wordBreak = "inherit", f.style.overflowWrap = "break-word"), s.document.body.appendChild(f);
  const L = document.createRange(), k = Array.prototype.slice.call(f.children, 0), D = [];
  for (let E = 0; E < e.length; E++) {
    const U = k[E], P = wY(L, U, b[E], C[E]);
    if (P === null) {
      D[E] = l(E);
      continue;
    }
    const B = m[E], W = _[E] + d, A = v[E], K = [];
    for (let ie = 0, me = P.length; ie < me; ie++)
      K[ie] = A[P[ie]];
    if (B !== 0)
      for (let ie = 0, me = P.length; ie < me; ie++)
        P[ie] += B;
    let Y, Q;
    const ne = a[E];
    ne ? (Y = ne.map((ie) => ie.options), Q = ne.map((ie) => ie.column - 1)) : (Y = null, Q = null), D[E] = new hf(Q, Y, P, K, W);
  }
  return f.remove(), D;
}
function CY(s, e, t, i, n, o) {
  if (o !== 0) {
    const u = String(o);
    n.appendString('<div style="text-indent: -'), n.appendString(u), n.appendString("px; padding-left: "), n.appendString(u), n.appendString("px; box-sizing: border-box; width:");
  } else
    n.appendString('<div style="width:');
  n.appendString(String(i)), n.appendString('px;">');
  const r = s.length;
  let a = e, l = 0;
  const c = [], h = [];
  let d = 0 < r ? s.charCodeAt(0) : 0;
  n.appendString("<span>");
  for (let u = 0; u < r; u++) {
    u !== 0 && u % 16384 === 0 && n.appendString("</span><span>"), c[u] = l, h[u] = a;
    const f = d;
    d = u + 1 < r ? s.charCodeAt(u + 1) : 0;
    let g = 1, m = 1;
    switch (f) {
      case 9:
        g = t - a % t, m = g;
        for (let _ = 1; _ <= g; _++)
          _ < g ? n.appendCharCode(160) : n.appendASCIICharCode(
            32
            /* CharCode.Space */
          );
        break;
      case 32:
        d === 32 ? n.appendCharCode(160) : n.appendASCIICharCode(
          32
          /* CharCode.Space */
        );
        break;
      case 60:
        n.appendString("&lt;");
        break;
      case 62:
        n.appendString("&gt;");
        break;
      case 38:
        n.appendString("&amp;");
        break;
      case 0:
        n.appendString("&#00;");
        break;
      case 65279:
      case 8232:
      case 8233:
      case 133:
        n.appendCharCode(65533);
        break;
      default:
        za(f) && m++, f < 32 ? n.appendCharCode(9216 + f) : n.appendCharCode(f);
    }
    l += g, a += m;
  }
  return n.appendString("</span>"), c[s.length] = l, h[s.length] = a, n.appendString("</div>"), [c, h];
}
function wY(s, e, t, i) {
  if (t.length <= 1)
    return null;
  const n = Array.prototype.slice.call(e.children, 0), o = [];
  try {
    OS(s, n, i, 0, null, t.length - 1, null, o);
  } catch (r) {
    return console.log(r), null;
  }
  return o.length === 0 ? null : (o.push(t.length), o);
}
function OS(s, e, t, i, n, o, r, a) {
  if (i === o || (n = n || vC(s, e, t[i], t[i + 1]), r = r || vC(s, e, t[o], t[o + 1]), Math.abs(n[0].top - r[0].top) <= 0.1))
    return;
  if (i + 1 === o) {
    a.push(o);
    return;
  }
  const l = i + (o - i) / 2 | 0, c = vC(s, e, t[l], t[l + 1]);
  OS(s, e, t, i, n, l, c, a), OS(s, e, t, l, c, o, r, a);
}
function vC(s, e, t, i) {
  return s.setStart(
    e[t / 16384 | 0].firstChild,
    t % 16384
    /* Constants.SPAN_MODULO_LIMIT */
  ), s.setEnd(
    e[i / 16384 | 0].firstChild,
    i % 16384
    /* Constants.SPAN_MODULO_LIMIT */
  ), s.getClientRects();
}
class vY extends q {
  constructor() {
    super(), this._editor = null, this._instantiationService = null, this._instances = this._register(new yL()), this._pending = /* @__PURE__ */ new Map(), this._finishedInstantiation = [], this._finishedInstantiation[
      0
      /* EditorContributionInstantiation.Eager */
    ] = !1, this._finishedInstantiation[
      1
      /* EditorContributionInstantiation.AfterFirstRender */
    ] = !1, this._finishedInstantiation[
      2
      /* EditorContributionInstantiation.BeforeFirstInteraction */
    ] = !1, this._finishedInstantiation[
      3
      /* EditorContributionInstantiation.Eventually */
    ] = !1;
  }
  initialize(e, t, i) {
    this._editor = e, this._instantiationService = i;
    for (const n of t) {
      if (this._pending.has(n.id)) {
        ht(new Error(`Cannot have two contributions with the same id ${n.id}`));
        continue;
      }
      this._pending.set(n.id, n);
    }
    this._instantiateSome(
      0
      /* EditorContributionInstantiation.Eager */
    ), this._register(sm(ue(this._editor.getDomNode()), () => {
      this._instantiateSome(
        1
        /* EditorContributionInstantiation.AfterFirstRender */
      );
    })), this._register(sm(ue(this._editor.getDomNode()), () => {
      this._instantiateSome(
        2
        /* EditorContributionInstantiation.BeforeFirstInteraction */
      );
    })), this._register(sm(ue(this._editor.getDomNode()), () => {
      this._instantiateSome(
        3
        /* EditorContributionInstantiation.Eventually */
      );
    }, 5e3));
  }
  saveViewState() {
    const e = {};
    for (const [t, i] of this._instances)
      typeof i.saveViewState == "function" && (e[t] = i.saveViewState());
    return e;
  }
  restoreViewState(e) {
    for (const [t, i] of this._instances)
      typeof i.restoreViewState == "function" && i.restoreViewState(e[t]);
  }
  get(e) {
    return this._instantiateById(e), this._instances.get(e) || null;
  }
  onBeforeInteractionEvent() {
    this._instantiateSome(
      2
      /* EditorContributionInstantiation.BeforeFirstInteraction */
    );
  }
  onAfterModelAttached() {
    var e;
    return sm(ue((e = this._editor) == null ? void 0 : e.getDomNode()), () => {
      this._instantiateSome(
        1
        /* EditorContributionInstantiation.AfterFirstRender */
      );
    }, 50);
  }
  _instantiateSome(e) {
    if (this._finishedInstantiation[e])
      return;
    this._finishedInstantiation[e] = !0;
    const t = this._findPendingContributionsByInstantiation(e);
    for (const i of t)
      this._instantiateById(i.id);
  }
  _findPendingContributionsByInstantiation(e) {
    const t = [];
    for (const [, i] of this._pending)
      i.instantiation === e && t.push(i);
    return t;
  }
  _instantiateById(e) {
    const t = this._pending.get(e);
    if (t) {
      if (this._pending.delete(e), !this._instantiationService || !this._editor)
        throw new Error("Cannot instantiate contributions before being initialized!");
      try {
        const i = this._instantiationService.createInstance(t.ctor, this._editor);
        this._instances.set(t.id, i), typeof i.restoreViewState == "function" && t.instantiation !== 0 && console.warn(`Editor contribution '${t.id}' should be eager instantiated because it uses saveViewState / restoreViewState.`);
      } catch (i) {
        ht(i);
      }
    }
  }
}
class h5 {
  constructor(e, t, i, n, o, r, a) {
    this.id = e, this.label = t, this.alias = i, this.metadata = n, this._precondition = o, this._run = r, this._contextKeyService = a;
  }
  isSupported() {
    return this._contextKeyService.contextMatchesRules(this._precondition);
  }
  run(e) {
    return this.isSupported() ? this._run(e) : Promise.resolve(void 0);
  }
}
class Nx {
  static create(e) {
    return new Nx(e.get(
      135
      /* EditorOption.wordWrapBreakBeforeCharacters */
    ), e.get(
      134
      /* EditorOption.wordWrapBreakAfterCharacters */
    ));
  }
  constructor(e, t) {
    this.classifier = new yY(e, t);
  }
  createLineBreaksComputer(e, t, i, n, o) {
    const r = [], a = [], l = [];
    return {
      addRequest: (c, h, d) => {
        r.push(c), a.push(h), l.push(d);
      },
      finalize: () => {
        const c = e.typicalFullwidthCharacterWidth / e.typicalHalfwidthCharacterWidth, h = [];
        for (let d = 0, u = r.length; d < u; d++) {
          const f = a[d], g = l[d];
          g && !g.injectionOptions && !f ? h[d] = SY(this.classifier, g, r[d], t, i, c, n, o) : h[d] = LY(this.classifier, r[d], f, t, i, c, n, o);
        }
        return FS.length = 0, BS.length = 0, h;
      }
    };
  }
}
class yY extends Ng {
  constructor(e, t) {
    super(
      0
      /* CharacterClass.NONE */
    );
    for (let i = 0; i < e.length; i++)
      this.set(
        e.charCodeAt(i),
        1
        /* CharacterClass.BREAK_BEFORE */
      );
    for (let i = 0; i < t.length; i++)
      this.set(
        t.charCodeAt(i),
        2
        /* CharacterClass.BREAK_AFTER */
      );
  }
  get(e) {
    return e >= 0 && e < 256 ? this._asciiMap[e] : e >= 12352 && e <= 12543 || e >= 13312 && e <= 19903 || e >= 19968 && e <= 40959 ? 3 : this._map.get(e) || this._defaultValue;
  }
}
let FS = [], BS = [];
function SY(s, e, t, i, n, o, r, a) {
  if (n === -1)
    return null;
  const l = t.length;
  if (l <= 1)
    return null;
  const c = a === "keepAll", h = e.breakOffsets, d = e.breakOffsetsVisibleColumn, u = d5(t, i, n, o, r), f = n - u, g = FS, m = BS;
  let _ = 0, b = 0, C = 0, v = n;
  const w = h.length;
  let S = 0;
  if (S >= 0) {
    let L = Math.abs(d[S] - v);
    for (; S + 1 < w; ) {
      const k = Math.abs(d[S + 1] - v);
      if (k >= L)
        break;
      L = k, S++;
    }
  }
  for (; S < w; ) {
    let L = S < 0 ? 0 : h[S], k = S < 0 ? 0 : d[S];
    b > L && (L = b, k = C);
    let D = 0, E = 0, U = 0, P = 0;
    if (k <= v) {
      let W = k, A = L === 0 ? 0 : t.charCodeAt(L - 1), K = L === 0 ? 0 : s.get(A), Y = !0;
      for (let Q = L; Q < l; Q++) {
        const ne = Q, ie = t.charCodeAt(Q);
        let me, _e;
        if (hi(ie) ? (Q++, me = 0, _e = 2) : (me = s.get(ie), _e = df(ie, W, i, o)), ne > b && WS(A, K, ie, me, c) && (D = ne, E = W), W += _e, W > v) {
          ne > b ? (U = ne, P = W - _e) : (U = Q + 1, P = W), W - E > f && (D = 0), Y = !1;
          break;
        }
        A = ie, K = me;
      }
      if (Y) {
        _ > 0 && (g[_] = h[h.length - 1], m[_] = d[h.length - 1], _++);
        break;
      }
    }
    if (D === 0) {
      let W = k, A = t.charCodeAt(L), K = s.get(A), Y = !1;
      for (let Q = L - 1; Q >= b; Q--) {
        const ne = Q + 1, ie = t.charCodeAt(Q);
        if (ie === 9) {
          Y = !0;
          break;
        }
        let me, _e;
        if (_d(ie) ? (Q--, me = 0, _e = 2) : (me = s.get(ie), _e = za(ie) ? o : 1), W <= v) {
          if (U === 0 && (U = ne, P = W), W <= v - f)
            break;
          if (WS(ie, me, A, K, c)) {
            D = ne, E = W;
            break;
          }
        }
        W -= _e, A = ie, K = me;
      }
      if (D !== 0) {
        const Q = f - (P - E);
        if (Q <= i) {
          const ne = t.charCodeAt(U);
          let ie;
          hi(ne) ? ie = 2 : ie = df(ne, P, i, o), Q - ie < 0 && (D = 0);
        }
      }
      if (Y) {
        S--;
        continue;
      }
    }
    if (D === 0 && (D = U, E = P), D <= b) {
      const W = t.charCodeAt(b);
      hi(W) ? (D = b + 2, E = C + 2) : (D = b + 1, E = C + df(W, C, i, o));
    }
    for (b = D, g[_] = D, C = E, m[_] = E, _++, v = E + f; S < 0 || S < w && d[S] < E; )
      S++;
    let B = Math.abs(d[S] - v);
    for (; S + 1 < w; ) {
      const W = Math.abs(d[S + 1] - v);
      if (W >= B)
        break;
      B = W, S++;
    }
  }
  return _ === 0 ? null : (g.length = _, m.length = _, FS = e.breakOffsets, BS = e.breakOffsetsVisibleColumn, e.breakOffsets = g, e.breakOffsetsVisibleColumn = m, e.wrappedTextIndentLength = u, e);
}
function LY(s, e, t, i, n, o, r, a) {
  const l = ao.applyInjectedText(e, t);
  let c, h;
  if (t && t.length > 0 ? (c = t.map((E) => E.options), h = t.map((E) => E.column - 1)) : (c = null, h = null), n === -1)
    return c ? new hf(h, c, [l.length], [], 0) : null;
  const d = l.length;
  if (d <= 1)
    return c ? new hf(h, c, [l.length], [], 0) : null;
  const u = a === "keepAll", f = d5(l, i, n, o, r), g = n - f, m = [], _ = [];
  let b = 0, C = 0, v = 0, w = n, S = l.charCodeAt(0), L = s.get(S), k = df(S, 0, i, o), D = 1;
  hi(S) && (k += 1, S = l.charCodeAt(1), L = s.get(S), D++);
  for (let E = D; E < d; E++) {
    const U = E, P = l.charCodeAt(E);
    let B, W;
    hi(P) ? (E++, B = 0, W = 2) : (B = s.get(P), W = df(P, k, i, o)), WS(S, L, P, B, u) && (C = U, v = k), k += W, k > w && ((C === 0 || k - v > g) && (C = U, v = k - W), m[b] = C, _[b] = v, b++, w = v + g, C = 0), S = P, L = B;
  }
  return b === 0 && (!t || t.length === 0) ? null : (m[b] = d, _[b] = k, new hf(h, c, m, _, f));
}
function df(s, e, t, i) {
  return s === 9 ? t - e % t : za(s) || s < 32 ? i : 1;
}
function ET(s, e) {
  return e - s % e;
}
function WS(s, e, t, i, n) {
  return t !== 32 && (e === 2 && i !== 2 || e !== 1 && i === 1 || !n && e === 3 && i !== 2 || !n && i === 3 && e !== 1);
}
function d5(s, e, t, i, n) {
  let o = 0;
  if (n !== 0) {
    const r = On(s);
    if (r !== -1) {
      for (let l = 0; l < r; l++) {
        const c = s.charCodeAt(l) === 9 ? ET(o, e) : 1;
        o += c;
      }
      const a = n === 3 ? 2 : n === 2 ? 1 : 0;
      for (let l = 0; l < a; l++) {
        const c = ET(o, e);
        o += c;
      }
      o + i > t && (o = 0);
    }
  }
  return o;
}
class $_ {
  constructor(e) {
    this._selTrackedRange = null, this._trackSelection = !0, this._setState(e, new Ci(new R(1, 1, 1, 1), 0, 0, new V(1, 1), 0), new Ci(new R(1, 1, 1, 1), 0, 0, new V(1, 1), 0));
  }
  dispose(e) {
    this._removeTrackedRange(e);
  }
  startTrackingSelection(e) {
    this._trackSelection = !0, this._updateTrackedRange(e);
  }
  stopTrackingSelection(e) {
    this._trackSelection = !1, this._removeTrackedRange(e);
  }
  _updateTrackedRange(e) {
    this._trackSelection && (this._selTrackedRange = e.model._setTrackedRange(
      this._selTrackedRange,
      this.modelState.selection,
      0
      /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */
    ));
  }
  _removeTrackedRange(e) {
    this._selTrackedRange = e.model._setTrackedRange(
      this._selTrackedRange,
      null,
      0
      /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */
    );
  }
  asCursorState() {
    return new Pe(this.modelState, this.viewState);
  }
  readSelectionFromMarkers(e) {
    const t = e.model._getTrackedRange(this._selTrackedRange);
    return this.modelState.selection.isEmpty() && !t.isEmpty() ? ft.fromRange(t.collapseToEnd(), this.modelState.selection.getDirection()) : ft.fromRange(t, this.modelState.selection.getDirection());
  }
  ensureValidState(e) {
    this._setState(e, this.modelState, this.viewState);
  }
  setState(e, t, i) {
    this._setState(e, t, i);
  }
  static _validatePositionWithCache(e, t, i, n) {
    return t.equals(i) ? n : e.normalizePosition(
      t,
      2
      /* PositionAffinity.None */
    );
  }
  static _validateViewState(e, t) {
    const i = t.position, n = t.selectionStart.getStartPosition(), o = t.selectionStart.getEndPosition(), r = e.normalizePosition(
      i,
      2
      /* PositionAffinity.None */
    ), a = this._validatePositionWithCache(e, n, i, r), l = this._validatePositionWithCache(e, o, n, a);
    return i.equals(r) && n.equals(a) && o.equals(l) ? t : new Ci(R.fromPositions(a, l), t.selectionStartKind, t.selectionStartLeftoverVisibleColumns + n.column - a.column, r, t.leftoverVisibleColumns + i.column - r.column);
  }
  _setState(e, t, i) {
    if (i && (i = $_._validateViewState(e.viewModel, i)), t) {
      const n = e.model.validateRange(t.selectionStart), o = t.selectionStart.equalsRange(n) ? t.selectionStartLeftoverVisibleColumns : 0, r = e.model.validatePosition(t.position), a = t.position.equals(r) ? t.leftoverVisibleColumns : 0;
      t = new Ci(n, t.selectionStartKind, o, r, a);
    } else {
      if (!i)
        return;
      const n = e.model.validateRange(e.coordinatesConverter.convertViewRangeToModelRange(i.selectionStart)), o = e.model.validatePosition(e.coordinatesConverter.convertViewPositionToModelPosition(i.position));
      t = new Ci(n, i.selectionStartKind, i.selectionStartLeftoverVisibleColumns, o, i.leftoverVisibleColumns);
    }
    if (i) {
      const n = e.coordinatesConverter.validateViewRange(i.selectionStart, t.selectionStart), o = e.coordinatesConverter.validateViewPosition(i.position, t.position);
      i = new Ci(n, t.selectionStartKind, t.selectionStartLeftoverVisibleColumns, o, t.leftoverVisibleColumns);
    } else {
      const n = e.coordinatesConverter.convertModelPositionToViewPosition(new V(t.selectionStart.startLineNumber, t.selectionStart.startColumn)), o = e.coordinatesConverter.convertModelPositionToViewPosition(new V(t.selectionStart.endLineNumber, t.selectionStart.endColumn)), r = new R(n.lineNumber, n.column, o.lineNumber, o.column), a = e.coordinatesConverter.convertModelPositionToViewPosition(t.position);
      i = new Ci(r, t.selectionStartKind, t.selectionStartLeftoverVisibleColumns, a, t.leftoverVisibleColumns);
    }
    this.modelState = t, this.viewState = i, this._updateTrackedRange(e);
  }
}
class IT {
  constructor(e) {
    this.context = e, this.cursors = [new $_(e)], this.lastAddedCursorIndex = 0;
  }
  dispose() {
    for (const e of this.cursors)
      e.dispose(this.context);
  }
  startTrackingSelections() {
    for (const e of this.cursors)
      e.startTrackingSelection(this.context);
  }
  stopTrackingSelections() {
    for (const e of this.cursors)
      e.stopTrackingSelection(this.context);
  }
  updateContext(e) {
    this.context = e;
  }
  ensureValidState() {
    for (const e of this.cursors)
      e.ensureValidState(this.context);
  }
  readSelectionFromMarkers() {
    return this.cursors.map((e) => e.readSelectionFromMarkers(this.context));
  }
  getAll() {
    return this.cursors.map((e) => e.asCursorState());
  }
  getViewPositions() {
    return this.cursors.map((e) => e.viewState.position);
  }
  getTopMostViewPosition() {
    return b9(this.cursors, Ts((e) => e.viewState.position, V.compare)).viewState.position;
  }
  getBottomMostViewPosition() {
    return _9(this.cursors, Ts((e) => e.viewState.position, V.compare)).viewState.position;
  }
  getSelections() {
    return this.cursors.map((e) => e.modelState.selection);
  }
  getViewSelections() {
    return this.cursors.map((e) => e.viewState.selection);
  }
  setSelections(e) {
    this.setStates(Pe.fromModelSelections(e));
  }
  getPrimaryCursor() {
    return this.cursors[0].asCursorState();
  }
  setStates(e) {
    e !== null && (this.cursors[0].setState(this.context, e[0].modelState, e[0].viewState), this._setSecondaryStates(e.slice(1)));
  }
  /**
   * Creates or disposes secondary cursors as necessary to match the number of `secondarySelections`.
   */
  _setSecondaryStates(e) {
    const t = this.cursors.length - 1, i = e.length;
    if (t < i) {
      const n = i - t;
      for (let o = 0; o < n; o++)
        this._addSecondaryCursor();
    } else if (t > i) {
      const n = t - i;
      for (let o = 0; o < n; o++)
        this._removeSecondaryCursor(this.cursors.length - 2);
    }
    for (let n = 0; n < i; n++)
      this.cursors[n + 1].setState(this.context, e[n].modelState, e[n].viewState);
  }
  killSecondaryCursors() {
    this._setSecondaryStates([]);
  }
  _addSecondaryCursor() {
    this.cursors.push(new $_(this.context)), this.lastAddedCursorIndex = this.cursors.length - 1;
  }
  getLastAddedCursorIndex() {
    return this.cursors.length === 1 || this.lastAddedCursorIndex === 0 ? 0 : this.lastAddedCursorIndex;
  }
  _removeSecondaryCursor(e) {
    this.lastAddedCursorIndex >= e + 1 && this.lastAddedCursorIndex--, this.cursors[e + 1].dispose(this.context), this.cursors.splice(e + 1, 1);
  }
  normalize() {
    if (this.cursors.length === 1)
      return;
    const e = this.cursors.slice(0), t = [];
    for (let i = 0, n = e.length; i < n; i++)
      t.push({
        index: i,
        selection: e[i].modelState.selection
      });
    t.sort(Ts((i) => i.selection, R.compareRangesUsingStarts));
    for (let i = 0; i < t.length - 1; i++) {
      const n = t[i], o = t[i + 1], r = n.selection, a = o.selection;
      if (!this.context.cursorConfig.multiCursorMergeOverlapping)
        continue;
      let l;
      if (a.isEmpty() || r.isEmpty() ? l = a.getStartPosition().isBeforeOrEqual(r.getEndPosition()) : l = a.getStartPosition().isBefore(r.getEndPosition()), l) {
        const c = n.index < o.index ? i : i + 1, h = n.index < o.index ? i + 1 : i, d = t[h].index, u = t[c].index, f = t[h].selection, g = t[c].selection;
        if (!f.equalsSelection(g)) {
          const m = f.plusRange(g), _ = f.selectionStartLineNumber === f.startLineNumber && f.selectionStartColumn === f.startColumn, b = g.selectionStartLineNumber === g.startLineNumber && g.selectionStartColumn === g.startColumn;
          let C;
          d === this.lastAddedCursorIndex ? (C = _, this.lastAddedCursorIndex = u) : C = b;
          let v;
          C ? v = new ft(m.startLineNumber, m.startColumn, m.endLineNumber, m.endColumn) : v = new ft(m.endLineNumber, m.endColumn, m.startLineNumber, m.startColumn), t[c].selection = v;
          const w = Pe.fromModelSelection(v);
          e[u].setState(this.context, w.modelState, w.viewState);
        }
        for (const m of t)
          m.index > d && m.index--;
        e.splice(d, 1), t.splice(h, 1), this._removeSecondaryCursor(d - 1), i--;
      }
    }
  }
}
class NT {
  constructor(e, t, i, n) {
    this._cursorContextBrand = void 0, this.model = e, this.viewModel = t, this.coordinatesConverter = i, this.cursorConfig = n;
  }
}
class kY {
  constructor() {
    this.type = 0;
  }
}
class xY {
  constructor() {
    this.type = 1;
  }
}
class DY {
  constructor(e) {
    this.type = 2, this._source = e;
  }
  hasChanged(e) {
    return this._source.hasChanged(e);
  }
}
class EY {
  constructor(e, t, i) {
    this.selections = e, this.modelSelections = t, this.reason = i, this.type = 3;
  }
}
class ul {
  constructor(e) {
    this.type = 4, e ? (this.affectsMinimap = e.affectsMinimap, this.affectsOverviewRuler = e.affectsOverviewRuler, this.affectsGlyphMargin = e.affectsGlyphMargin, this.affectsLineNumber = e.affectsLineNumber) : (this.affectsMinimap = !0, this.affectsOverviewRuler = !0, this.affectsGlyphMargin = !0, this.affectsLineNumber = !0);
  }
}
class Fm {
  constructor() {
    this.type = 5;
  }
}
class IY {
  constructor(e) {
    this.type = 6, this.isFocused = e;
  }
}
class NY {
  constructor() {
    this.type = 7;
  }
}
class Bm {
  constructor() {
    this.type = 8;
  }
}
class u5 {
  constructor(e, t) {
    this.fromLineNumber = e, this.count = t, this.type = 9;
  }
}
class VS {
  constructor(e, t) {
    this.type = 10, this.fromLineNumber = e, this.toLineNumber = t;
  }
}
class HS {
  constructor(e, t) {
    this.type = 11, this.fromLineNumber = e, this.toLineNumber = t;
  }
}
class uf {
  constructor(e, t, i, n, o, r, a) {
    this.source = e, this.minimalReveal = t, this.range = i, this.selections = n, this.verticalType = o, this.revealHorizontal = r, this.scrollType = a, this.type = 12;
  }
}
class TY {
  constructor(e) {
    this.type = 13, this.scrollWidth = e.scrollWidth, this.scrollLeft = e.scrollLeft, this.scrollHeight = e.scrollHeight, this.scrollTop = e.scrollTop, this.scrollWidthChanged = e.scrollWidthChanged, this.scrollLeftChanged = e.scrollLeftChanged, this.scrollHeightChanged = e.scrollHeightChanged, this.scrollTopChanged = e.scrollTopChanged;
  }
}
class MY {
  constructor(e) {
    this.theme = e, this.type = 14;
  }
}
class RY {
  constructor(e) {
    this.type = 15, this.ranges = e;
  }
}
class AY {
  constructor() {
    this.type = 16;
  }
}
let PY = class {
  constructor() {
    this.type = 17;
  }
};
class OY extends q {
  constructor() {
    super(), this._onEvent = this._register(new O()), this.onEvent = this._onEvent.event, this._eventHandlers = [], this._viewEventQueue = null, this._isConsumingViewEventQueue = !1, this._collector = null, this._collectorCnt = 0, this._outgoingEvents = [];
  }
  emitOutgoingEvent(e) {
    this._addOutgoingEvent(e), this._emitOutgoingEvents();
  }
  _addOutgoingEvent(e) {
    for (let t = 0, i = this._outgoingEvents.length; t < i; t++) {
      const n = this._outgoingEvents[t].kind === e.kind ? this._outgoingEvents[t].attemptToMerge(e) : null;
      if (n) {
        this._outgoingEvents[t] = n;
        return;
      }
    }
    this._outgoingEvents.push(e);
  }
  _emitOutgoingEvents() {
    for (; this._outgoingEvents.length > 0; ) {
      if (this._collector || this._isConsumingViewEventQueue)
        return;
      const e = this._outgoingEvents.shift();
      e.isNoOp() || this._onEvent.fire(e);
    }
  }
  addViewEventHandler(e) {
    for (let t = 0, i = this._eventHandlers.length; t < i; t++)
      this._eventHandlers[t] === e && console.warn("Detected duplicate listener in ViewEventDispatcher", e);
    this._eventHandlers.push(e);
  }
  removeViewEventHandler(e) {
    for (let t = 0; t < this._eventHandlers.length; t++)
      if (this._eventHandlers[t] === e) {
        this._eventHandlers.splice(t, 1);
        break;
      }
  }
  beginEmitViewEvents() {
    return this._collectorCnt++, this._collectorCnt === 1 && (this._collector = new FY()), this._collector;
  }
  endEmitViewEvents() {
    if (this._collectorCnt--, this._collectorCnt === 0) {
      const e = this._collector.outgoingEvents, t = this._collector.viewEvents;
      this._collector = null;
      for (const i of e)
        this._addOutgoingEvent(i);
      t.length > 0 && this._emitMany(t);
    }
    this._emitOutgoingEvents();
  }
  emitSingleViewEvent(e) {
    try {
      this.beginEmitViewEvents().emitViewEvent(e);
    } finally {
      this.endEmitViewEvents();
    }
  }
  _emitMany(e) {
    this._viewEventQueue ? this._viewEventQueue = this._viewEventQueue.concat(e) : this._viewEventQueue = e, this._isConsumingViewEventQueue || this._consumeViewEventQueue();
  }
  _consumeViewEventQueue() {
    try {
      this._isConsumingViewEventQueue = !0, this._doConsumeQueue();
    } finally {
      this._isConsumingViewEventQueue = !1;
    }
  }
  _doConsumeQueue() {
    for (; this._viewEventQueue; ) {
      const e = this._viewEventQueue;
      this._viewEventQueue = null;
      const t = this._eventHandlers.slice(0);
      for (const i of t)
        i.handleEvents(e);
    }
  }
}
class FY {
  constructor() {
    this.viewEvents = [], this.outgoingEvents = [];
  }
  emitViewEvent(e) {
    this.viewEvents.push(e);
  }
  emitOutgoingEvent(e) {
    this.outgoingEvents.push(e);
  }
}
class Tx {
  constructor(e, t, i, n) {
    this.kind = 0, this._oldContentWidth = e, this._oldContentHeight = t, this.contentWidth = i, this.contentHeight = n, this.contentWidthChanged = this._oldContentWidth !== this.contentWidth, this.contentHeightChanged = this._oldContentHeight !== this.contentHeight;
  }
  isNoOp() {
    return !this.contentWidthChanged && !this.contentHeightChanged;
  }
  attemptToMerge(e) {
    return e.kind !== this.kind ? null : new Tx(this._oldContentWidth, this._oldContentHeight, e.contentWidth, e.contentHeight);
  }
}
class Mx {
  constructor(e, t) {
    this.kind = 1, this.oldHasFocus = e, this.hasFocus = t;
  }
  isNoOp() {
    return this.oldHasFocus === this.hasFocus;
  }
  attemptToMerge(e) {
    return e.kind !== this.kind ? null : new Mx(this.oldHasFocus, e.hasFocus);
  }
}
class Rx {
  constructor(e, t, i, n, o, r, a, l) {
    this.kind = 2, this._oldScrollWidth = e, this._oldScrollLeft = t, this._oldScrollHeight = i, this._oldScrollTop = n, this.scrollWidth = o, this.scrollLeft = r, this.scrollHeight = a, this.scrollTop = l, this.scrollWidthChanged = this._oldScrollWidth !== this.scrollWidth, this.scrollLeftChanged = this._oldScrollLeft !== this.scrollLeft, this.scrollHeightChanged = this._oldScrollHeight !== this.scrollHeight, this.scrollTopChanged = this._oldScrollTop !== this.scrollTop;
  }
  isNoOp() {
    return !this.scrollWidthChanged && !this.scrollLeftChanged && !this.scrollHeightChanged && !this.scrollTopChanged;
  }
  attemptToMerge(e) {
    return e.kind !== this.kind ? null : new Rx(this._oldScrollWidth, this._oldScrollLeft, this._oldScrollHeight, this._oldScrollTop, e.scrollWidth, e.scrollLeft, e.scrollHeight, e.scrollTop);
  }
}
class BY {
  constructor() {
    this.kind = 3;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return e.kind !== this.kind ? null : this;
  }
}
class WY {
  constructor() {
    this.kind = 4;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return e.kind !== this.kind ? null : this;
  }
}
class K_ {
  constructor(e, t, i, n, o, r, a) {
    this.kind = 6, this.oldSelections = e, this.selections = t, this.oldModelVersionId = i, this.modelVersionId = n, this.source = o, this.reason = r, this.reachedMaxCursorCount = a;
  }
  static _selectionsAreEqual(e, t) {
    if (!e && !t)
      return !0;
    if (!e || !t)
      return !1;
    const i = e.length, n = t.length;
    if (i !== n)
      return !1;
    for (let o = 0; o < i; o++)
      if (!e[o].equalsSelection(t[o]))
        return !1;
    return !0;
  }
  isNoOp() {
    return K_._selectionsAreEqual(this.oldSelections, this.selections) && this.oldModelVersionId === this.modelVersionId;
  }
  attemptToMerge(e) {
    return e.kind !== this.kind ? null : new K_(this.oldSelections, e.selections, this.oldModelVersionId, e.modelVersionId, e.source, e.reason, this.reachedMaxCursorCount || e.reachedMaxCursorCount);
  }
}
class VY {
  constructor() {
    this.kind = 5;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return e.kind !== this.kind ? null : this;
  }
}
class HY {
  constructor(e) {
    this.event = e, this.kind = 7;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return null;
  }
}
class zY {
  constructor(e) {
    this.event = e, this.kind = 8;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return null;
  }
}
class UY {
  constructor(e) {
    this.event = e, this.kind = 9;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return null;
  }
}
class $Y {
  constructor(e) {
    this.event = e, this.kind = 10;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return null;
  }
}
class KY {
  constructor(e) {
    this.event = e, this.kind = 11;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return null;
  }
}
class qY {
  constructor(e) {
    this.event = e, this.kind = 12;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return null;
  }
}
class jY extends q {
  constructor(e, t, i, n) {
    super(), this._model = e, this._knownModelVersionId = this._model.getVersionId(), this._viewModel = t, this._coordinatesConverter = i, this.context = new NT(this._model, this._viewModel, this._coordinatesConverter, n), this._cursors = new IT(this.context), this._hasFocus = !1, this._isHandling = !1, this._compositionState = null, this._columnSelectData = null, this._autoClosedActions = [], this._prevEditOperationType = 0;
  }
  dispose() {
    this._cursors.dispose(), this._autoClosedActions = Ri(this._autoClosedActions), super.dispose();
  }
  updateConfiguration(e) {
    this.context = new NT(this._model, this._viewModel, this._coordinatesConverter, e), this._cursors.updateContext(this.context);
  }
  onLineMappingChanged(e) {
    this._knownModelVersionId === this._model.getVersionId() && this.setStates(e, "viewModel", 0, this.getCursorStates());
  }
  setHasFocus(e) {
    this._hasFocus = e;
  }
  _validateAutoClosedActions() {
    if (this._autoClosedActions.length > 0) {
      const e = this._cursors.getSelections();
      for (let t = 0; t < this._autoClosedActions.length; t++) {
        const i = this._autoClosedActions[t];
        i.isValid(e) || (i.dispose(), this._autoClosedActions.splice(t, 1), t--);
      }
    }
  }
  // ------ some getters/setters
  getPrimaryCursorState() {
    return this._cursors.getPrimaryCursor();
  }
  getLastAddedCursorIndex() {
    return this._cursors.getLastAddedCursorIndex();
  }
  getCursorStates() {
    return this._cursors.getAll();
  }
  setStates(e, t, i, n) {
    let o = !1;
    const r = this.context.cursorConfig.multiCursorLimit;
    n !== null && n.length > r && (n = n.slice(0, r), o = !0);
    const a = ff.from(this._model, this);
    return this._cursors.setStates(n), this._cursors.normalize(), this._columnSelectData = null, this._validateAutoClosedActions(), this._emitStateChangedIfNecessary(e, t, i, a, o);
  }
  setCursorColumnSelectData(e) {
    this._columnSelectData = e;
  }
  revealAll(e, t, i, n, o, r) {
    const a = this._cursors.getViewPositions();
    let l = null, c = null;
    a.length > 1 ? c = this._cursors.getViewSelections() : l = R.fromPositions(a[0], a[0]), e.emitViewEvent(new uf(t, i, l, c, n, o, r));
  }
  revealPrimary(e, t, i, n, o, r) {
    const l = [this._cursors.getPrimaryCursor().viewState.selection];
    e.emitViewEvent(new uf(t, i, null, l, n, o, r));
  }
  saveState() {
    const e = [], t = this._cursors.getSelections();
    for (let i = 0, n = t.length; i < n; i++) {
      const o = t[i];
      e.push({
        inSelectionMode: !o.isEmpty(),
        selectionStart: {
          lineNumber: o.selectionStartLineNumber,
          column: o.selectionStartColumn
        },
        position: {
          lineNumber: o.positionLineNumber,
          column: o.positionColumn
        }
      });
    }
    return e;
  }
  restoreState(e, t) {
    const i = [];
    for (let n = 0, o = t.length; n < o; n++) {
      const r = t[n];
      let a = 1, l = 1;
      r.position && r.position.lineNumber && (a = r.position.lineNumber), r.position && r.position.column && (l = r.position.column);
      let c = a, h = l;
      r.selectionStart && r.selectionStart.lineNumber && (c = r.selectionStart.lineNumber), r.selectionStart && r.selectionStart.column && (h = r.selectionStart.column), i.push({
        selectionStartLineNumber: c,
        selectionStartColumn: h,
        positionLineNumber: a,
        positionColumn: l
      });
    }
    this.setStates(e, "restoreState", 0, Pe.fromModelSelections(i)), this.revealAll(
      e,
      "restoreState",
      !1,
      0,
      !0,
      1
      /* editorCommon.ScrollType.Immediate */
    );
  }
  onModelContentChanged(e, t) {
    if (t instanceof r4) {
      if (this._isHandling)
        return;
      this._isHandling = !0;
      try {
        this.setStates(e, "modelChange", 0, this.getCursorStates());
      } finally {
        this._isHandling = !1;
      }
    } else {
      const i = t.rawContentChangedEvent;
      if (this._knownModelVersionId = i.versionId, this._isHandling)
        return;
      const n = i.containsEvent(
        1
        /* RawContentChangedType.Flush */
      );
      if (this._prevEditOperationType = 0, n)
        this._cursors.dispose(), this._cursors = new IT(this.context), this._validateAutoClosedActions(), this._emitStateChangedIfNecessary(e, "model", 1, null, !1);
      else if (this._hasFocus && i.resultingSelection && i.resultingSelection.length > 0) {
        const o = Pe.fromModelSelections(i.resultingSelection);
        this.setStates(e, "modelChange", i.isUndoing ? 5 : i.isRedoing ? 6 : 2, o) && this.revealAll(
          e,
          "modelChange",
          !1,
          0,
          !0,
          0
          /* editorCommon.ScrollType.Smooth */
        );
      } else {
        const o = this._cursors.readSelectionFromMarkers();
        this.setStates(e, "modelChange", 2, Pe.fromModelSelections(o));
      }
    }
  }
  getSelection() {
    return this._cursors.getPrimaryCursor().modelState.selection;
  }
  getTopMostViewPosition() {
    return this._cursors.getTopMostViewPosition();
  }
  getBottomMostViewPosition() {
    return this._cursors.getBottomMostViewPosition();
  }
  getCursorColumnSelectData() {
    if (this._columnSelectData)
      return this._columnSelectData;
    const e = this._cursors.getPrimaryCursor(), t = e.viewState.selectionStart.getStartPosition(), i = e.viewState.position;
    return {
      isReal: !1,
      fromViewLineNumber: t.lineNumber,
      fromViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, t),
      toViewLineNumber: i.lineNumber,
      toViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, i)
    };
  }
  getSelections() {
    return this._cursors.getSelections();
  }
  setSelections(e, t, i, n) {
    this.setStates(e, t, n, Pe.fromModelSelections(i));
  }
  getPrevEditOperationType() {
    return this._prevEditOperationType;
  }
  setPrevEditOperationType(e) {
    this._prevEditOperationType = e;
  }
  // ------ auxiliary handling logic
  _pushAutoClosedAction(e, t) {
    const i = [], n = [];
    for (let a = 0, l = e.length; a < l; a++)
      i.push({
        range: e[a],
        options: {
          description: "auto-closed-character",
          inlineClassName: "auto-closed-character",
          stickiness: 1
          /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
        }
      }), n.push({
        range: t[a],
        options: {
          description: "auto-closed-enclosing",
          stickiness: 1
          /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
        }
      });
    const o = this._model.deltaDecorations([], i), r = this._model.deltaDecorations([], n);
    this._autoClosedActions.push(new TT(this._model, o, r));
  }
  _executeEditOperation(e) {
    if (!e)
      return;
    e.shouldPushStackElementBefore && this._model.pushStackElement();
    const t = GY.executeCommands(this._model, this._cursors.getSelections(), e.commands);
    if (t) {
      this._interpretCommandResult(t);
      const i = [], n = [];
      for (let o = 0; o < e.commands.length; o++) {
        const r = e.commands[o];
        r instanceof kx && r.enclosingRange && r.closeCharacterRange && (i.push(r.closeCharacterRange), n.push(r.enclosingRange));
      }
      i.length > 0 && this._pushAutoClosedAction(i, n), this._prevEditOperationType = e.type;
    }
    e.shouldPushStackElementAfter && this._model.pushStackElement();
  }
  _interpretCommandResult(e) {
    (!e || e.length === 0) && (e = this._cursors.readSelectionFromMarkers()), this._columnSelectData = null, this._cursors.setSelections(e), this._cursors.normalize();
  }
  // -----------------------------------------------------------------------------------------------------------
  // ----- emitting events
  _emitStateChangedIfNecessary(e, t, i, n, o) {
    const r = ff.from(this._model, this);
    if (r.equals(n))
      return !1;
    const a = this._cursors.getSelections(), l = this._cursors.getViewSelections();
    if (e.emitViewEvent(new EY(l, a, i)), !n || n.cursorState.length !== r.cursorState.length || r.cursorState.some((c, h) => !c.modelState.equals(n.cursorState[h].modelState))) {
      const c = n ? n.cursorState.map((d) => d.modelState.selection) : null, h = n ? n.modelVersionId : 0;
      e.emitOutgoingEvent(new K_(c, a, h, r.modelVersionId, t || "keyboard", i, o));
    }
    return !0;
  }
  // -----------------------------------------------------------------------------------------------------------
  // ----- handlers beyond this point
  _findAutoClosingPairs(e) {
    if (!e.length)
      return null;
    const t = [];
    for (let i = 0, n = e.length; i < n; i++) {
      const o = e[i];
      if (!o.text || o.text.indexOf(`
`) >= 0)
        return null;
      const r = o.text.match(/([)\]}>'"`])([^)\]}>'"`]*)$/);
      if (!r)
        return null;
      const a = r[1], l = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(a);
      if (!l || l.length !== 1)
        return null;
      const c = l[0].open, h = o.text.length - r[2].length - 1, d = o.text.lastIndexOf(c, h - 1);
      if (d === -1)
        return null;
      t.push([d, h]);
    }
    return t;
  }
  executeEdits(e, t, i, n) {
    let o = null;
    t === "snippet" && (o = this._findAutoClosingPairs(i)), o && (i[0]._isTracked = !0);
    const r = [], a = [], l = this._model.pushEditOperations(this.getSelections(), i, (c) => {
      if (o)
        for (let d = 0, u = o.length; d < u; d++) {
          const [f, g] = o[d], m = c[d], _ = m.range.startLineNumber, b = m.range.startColumn - 1 + f, C = m.range.startColumn - 1 + g;
          r.push(new R(_, C + 1, _, C + 2)), a.push(new R(_, b + 1, _, C + 2));
        }
      const h = n(c);
      return h && (this._isHandling = !0), h;
    });
    l && (this._isHandling = !1, this.setSelections(
      e,
      t,
      l,
      0
      /* CursorChangeReason.NotSet */
    )), r.length > 0 && this._pushAutoClosedAction(r, a);
  }
  _executeEdit(e, t, i, n = 0) {
    if (this.context.cursorConfig.readOnly)
      return;
    const o = ff.from(this._model, this);
    this._cursors.stopTrackingSelections(), this._isHandling = !0;
    try {
      this._cursors.ensureValidState(), e();
    } catch (r) {
      ht(r);
    }
    this._isHandling = !1, this._cursors.startTrackingSelections(), this._validateAutoClosedActions(), this._emitStateChangedIfNecessary(t, i, n, o, !1) && this.revealAll(
      t,
      i,
      !1,
      0,
      !0,
      0
      /* editorCommon.ScrollType.Smooth */
    );
  }
  getAutoClosedCharacters() {
    return TT.getAllAutoClosedCharacters(this._autoClosedActions);
  }
  startComposition(e) {
    this._compositionState = new gf(this._model, this.getSelections());
  }
  endComposition(e, t) {
    const i = this._compositionState ? this._compositionState.deduceOutcome(this._model, this.getSelections()) : null;
    this._compositionState = null, this._executeEdit(() => {
      t === "keyboard" && this._executeEditOperation(Pl.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, i, this.getSelections(), this.getAutoClosedCharacters()));
    }, e, t);
  }
  type(e, t, i) {
    this._executeEdit(() => {
      if (i === "keyboard") {
        const n = t.length;
        let o = 0;
        for (; o < n; ) {
          const r = TL(t, o), a = t.substr(o, r);
          this._executeEditOperation(Pl.typeWithInterceptors(!!this._compositionState, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), this.getAutoClosedCharacters(), a)), o += r;
        }
      } else
        this._executeEditOperation(Pl.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), t));
    }, e, i);
  }
  compositionType(e, t, i, n, o, r) {
    if (t.length === 0 && i === 0 && n === 0) {
      if (o !== 0) {
        const a = this.getSelections().map((l) => {
          const c = l.getPosition();
          return new ft(c.lineNumber, c.column + o, c.lineNumber, c.column + o);
        });
        this.setSelections(
          e,
          r,
          a,
          0
          /* CursorChangeReason.NotSet */
        );
      }
      return;
    }
    this._executeEdit(() => {
      this._executeEditOperation(Pl.compositionType(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), t, i, n, o));
    }, e, r);
  }
  paste(e, t, i, n, o) {
    this._executeEdit(
      () => {
        this._executeEditOperation(Pl.paste(this.context.cursorConfig, this._model, this.getSelections(), t, i, n || []));
      },
      e,
      o,
      4
      /* CursorChangeReason.Paste */
    );
  }
  cut(e, t) {
    this._executeEdit(() => {
      this._executeEditOperation(Lc.cut(this.context.cursorConfig, this._model, this.getSelections()));
    }, e, t);
  }
  executeCommand(e, t, i) {
    this._executeEdit(() => {
      this._cursors.killSecondaryCursors(), this._executeEditOperation(new yn(0, [t], {
        shouldPushStackElementBefore: !1,
        shouldPushStackElementAfter: !1
      }));
    }, e, i);
  }
  executeCommands(e, t, i) {
    this._executeEdit(() => {
      this._executeEditOperation(new yn(0, t, {
        shouldPushStackElementBefore: !1,
        shouldPushStackElementAfter: !1
      }));
    }, e, i);
  }
}
class ff {
  static from(e, t) {
    return new ff(e.getVersionId(), t.getCursorStates());
  }
  constructor(e, t) {
    this.modelVersionId = e, this.cursorState = t;
  }
  equals(e) {
    if (!e || this.modelVersionId !== e.modelVersionId || this.cursorState.length !== e.cursorState.length)
      return !1;
    for (let t = 0, i = this.cursorState.length; t < i; t++)
      if (!this.cursorState[t].equals(e.cursorState[t]))
        return !1;
    return !0;
  }
}
class TT {
  static getAllAutoClosedCharacters(e) {
    let t = [];
    for (const i of e)
      t = t.concat(i.getAutoClosedCharactersRanges());
    return t;
  }
  constructor(e, t, i) {
    this._model = e, this._autoClosedCharactersDecorations = t, this._autoClosedEnclosingDecorations = i;
  }
  dispose() {
    this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []), this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);
  }
  getAutoClosedCharactersRanges() {
    const e = [];
    for (let t = 0; t < this._autoClosedCharactersDecorations.length; t++) {
      const i = this._model.getDecorationRange(this._autoClosedCharactersDecorations[t]);
      i && e.push(i);
    }
    return e;
  }
  isValid(e) {
    const t = [];
    for (let i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {
      const n = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);
      if (n && (t.push(n), n.startLineNumber !== n.endLineNumber))
        return !1;
    }
    t.sort(R.compareRangesUsingStarts), e.sort(R.compareRangesUsingStarts);
    for (let i = 0; i < e.length; i++)
      if (i >= t.length || !t[i].strictContainsRange(e[i]))
        return !1;
    return !0;
  }
}
class GY {
  static executeCommands(e, t, i) {
    const n = {
      model: e,
      selectionsBefore: t,
      trackedRanges: [],
      trackedRangesDirection: []
    }, o = this._innerExecuteCommands(n, i);
    for (let r = 0, a = n.trackedRanges.length; r < a; r++)
      n.model._setTrackedRange(
        n.trackedRanges[r],
        null,
        0
        /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */
      );
    return o;
  }
  static _innerExecuteCommands(e, t) {
    if (this._arrayIsEmpty(t))
      return null;
    const i = this._getEditOperations(e, t);
    if (i.operations.length === 0)
      return null;
    const n = i.operations, o = this._getLoserCursorMap(n);
    if (o.hasOwnProperty("0"))
      return console.warn("Ignoring commands"), null;
    const r = [];
    for (let c = 0, h = n.length; c < h; c++)
      o.hasOwnProperty(n[c].identifier.major.toString()) || r.push(n[c]);
    i.hadTrackedEditOperation && r.length > 0 && (r[0]._isTracked = !0);
    let a = e.model.pushEditOperations(e.selectionsBefore, r, (c) => {
      const h = [];
      for (let f = 0; f < e.selectionsBefore.length; f++)
        h[f] = [];
      for (const f of c)
        f.identifier && h[f.identifier.major].push(f);
      const d = (f, g) => f.identifier.minor - g.identifier.minor, u = [];
      for (let f = 0; f < e.selectionsBefore.length; f++)
        h[f].length > 0 ? (h[f].sort(d), u[f] = t[f].computeCursorState(e.model, {
          getInverseEditOperations: () => h[f],
          getTrackedSelection: (g) => {
            const m = parseInt(g, 10), _ = e.model._getTrackedRange(e.trackedRanges[m]);
            return e.trackedRangesDirection[m] === 0 ? new ft(_.startLineNumber, _.startColumn, _.endLineNumber, _.endColumn) : new ft(_.endLineNumber, _.endColumn, _.startLineNumber, _.startColumn);
          }
        })) : u[f] = e.selectionsBefore[f];
      return u;
    });
    a || (a = e.selectionsBefore);
    const l = [];
    for (const c in o)
      o.hasOwnProperty(c) && l.push(parseInt(c, 10));
    l.sort((c, h) => h - c);
    for (const c of l)
      a.splice(c, 1);
    return a;
  }
  static _arrayIsEmpty(e) {
    for (let t = 0, i = e.length; t < i; t++)
      if (e[t])
        return !1;
    return !0;
  }
  static _getEditOperations(e, t) {
    let i = [], n = !1;
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o];
      if (a) {
        const l = this._getEditOperationsFromCommand(e, o, a);
        i = i.concat(l.operations), n = n || l.hadTrackedEditOperation;
      }
    }
    return {
      operations: i,
      hadTrackedEditOperation: n
    };
  }
  static _getEditOperationsFromCommand(e, t, i) {
    const n = [];
    let o = 0;
    const r = (d, u, f = !1) => {
      R.isEmpty(d) && u === "" || n.push({
        identifier: {
          major: t,
          minor: o++
        },
        range: d,
        text: u,
        forceMoveMarkers: f,
        isAutoWhitespaceEdit: i.insertsAutoWhitespace
      });
    };
    let a = !1;
    const h = {
      addEditOperation: r,
      addTrackedEditOperation: (d, u, f) => {
        a = !0, r(d, u, f);
      },
      trackSelection: (d, u) => {
        const f = ft.liftSelection(d);
        let g;
        if (f.isEmpty())
          if (typeof u == "boolean")
            u ? g = 2 : g = 3;
          else {
            const b = e.model.getLineMaxColumn(f.startLineNumber);
            f.startColumn === b ? g = 2 : g = 3;
          }
        else
          g = 1;
        const m = e.trackedRanges.length, _ = e.model._setTrackedRange(null, f, g);
        return e.trackedRanges[m] = _, e.trackedRangesDirection[m] = f.getDirection(), m.toString();
      }
    };
    try {
      i.getEditOperations(e.model, h);
    } catch (d) {
      return ht(d), {
        operations: [],
        hadTrackedEditOperation: !1
      };
    }
    return {
      operations: n,
      hadTrackedEditOperation: a
    };
  }
  static _getLoserCursorMap(e) {
    e = e.slice(0), e.sort((i, n) => -R.compareRangesUsingEnds(i.range, n.range));
    const t = {};
    for (let i = 1; i < e.length; i++) {
      const n = e[i - 1], o = e[i];
      if (R.getStartPosition(n.range).isBefore(R.getEndPosition(o.range))) {
        let r;
        n.identifier.major > o.identifier.major ? r = n.identifier.major : r = o.identifier.major, t[r.toString()] = !0;
        for (let a = 0; a < e.length; a++)
          e[a].identifier.major === r && (e.splice(a, 1), a < i && i--, a--);
        i > 0 && i--;
      }
    }
    return t;
  }
}
class ZY {
  constructor(e, t, i) {
    this.text = e, this.startSelection = t, this.endSelection = i;
  }
}
class gf {
  static _capture(e, t) {
    const i = [];
    for (const n of t) {
      if (n.startLineNumber !== n.endLineNumber)
        return null;
      i.push(new ZY(e.getLineContent(n.startLineNumber), n.startColumn - 1, n.endColumn - 1));
    }
    return i;
  }
  constructor(e, t) {
    this._original = gf._capture(e, t);
  }
  /**
   * Returns the inserted text during this composition.
   * If the composition resulted in existing text being changed (i.e. not a pure insertion) it returns null.
   */
  deduceOutcome(e, t) {
    if (!this._original)
      return null;
    const i = gf._capture(e, t);
    if (!i || this._original.length !== i.length)
      return null;
    const n = [];
    for (let o = 0, r = this._original.length; o < r; o++)
      n.push(gf._deduceOutcome(this._original[o], i[o]));
    return n;
  }
  static _deduceOutcome(e, t) {
    const i = Math.min(e.startSelection, t.startSelection, Fw(e.text, t.text)), n = Math.min(e.text.length - e.endSelection, t.text.length - t.endSelection, Bw(e.text, t.text)), o = e.text.substring(i, e.text.length - n), r = t.text.substring(i, t.text.length - n);
    return new yZ(o, e.startSelection - i, e.endSelection - i, r, t.startSelection - i, t.endSelection - i);
  }
}
class YY {
  constructor() {
    this._hasPending = !1, this._inserts = [], this._changes = [], this._removes = [];
  }
  insert(e) {
    this._hasPending = !0, this._inserts.push(e);
  }
  change(e) {
    this._hasPending = !0, this._changes.push(e);
  }
  remove(e) {
    this._hasPending = !0, this._removes.push(e);
  }
  mustCommit() {
    return this._hasPending;
  }
  commit(e) {
    if (!this._hasPending)
      return;
    const t = this._inserts, i = this._changes, n = this._removes;
    this._hasPending = !1, this._inserts = [], this._changes = [], this._removes = [], e._commitPendingChanges(t, i, n);
  }
}
class QY {
  constructor(e, t, i, n, o) {
    this.id = e, this.afterLineNumber = t, this.ordinal = i, this.height = n, this.minWidth = o, this.prefixSum = 0;
  }
}
var Va;
let XY = (Va = class {
  constructor(e, t, i, n) {
    this._instanceId = eM(++Va.INSTANCE_COUNT), this._pendingChanges = new YY(), this._lastWhitespaceId = 0, this._arr = [], this._prefixSumValidIndex = -1, this._minWidth = -1, this._lineCount = e, this._lineHeight = t, this._paddingTop = i, this._paddingBottom = n;
  }
  /**
   * Find the insertion index for a new value inside a sorted array of values.
   * If the value is already present in the sorted array, the insertion index will be after the already existing value.
   */
  static findInsertionIndex(e, t, i) {
    let n = 0, o = e.length;
    for (; n < o; ) {
      const r = n + o >>> 1;
      t === e[r].afterLineNumber ? i < e[r].ordinal ? o = r : n = r + 1 : t < e[r].afterLineNumber ? o = r : n = r + 1;
    }
    return n;
  }
  /**
   * Change the height of a line in pixels.
   */
  setLineHeight(e) {
    this._checkPendingChanges(), this._lineHeight = e;
  }
  /**
   * Changes the padding used to calculate vertical offsets.
   */
  setPadding(e, t) {
    this._paddingTop = e, this._paddingBottom = t;
  }
  /**
   * Set the number of lines.
   *
   * @param lineCount New number of lines.
   */
  onFlushed(e) {
    this._checkPendingChanges(), this._lineCount = e;
  }
  changeWhitespace(e) {
    let t = !1;
    try {
      e({
        insertWhitespace: (n, o, r, a) => {
          t = !0, n = n | 0, o = o | 0, r = r | 0, a = a | 0;
          const l = this._instanceId + ++this._lastWhitespaceId;
          return this._pendingChanges.insert(new QY(l, n, o, r, a)), l;
        },
        changeOneWhitespace: (n, o, r) => {
          t = !0, o = o | 0, r = r | 0, this._pendingChanges.change({ id: n, newAfterLineNumber: o, newHeight: r });
        },
        removeWhitespace: (n) => {
          t = !0, this._pendingChanges.remove({ id: n });
        }
      });
    } finally {
      this._pendingChanges.commit(this);
    }
    return t;
  }
  _commitPendingChanges(e, t, i) {
    if ((e.length > 0 || i.length > 0) && (this._minWidth = -1), e.length + t.length + i.length <= 1) {
      for (const l of e)
        this._insertWhitespace(l);
      for (const l of t)
        this._changeOneWhitespace(l.id, l.newAfterLineNumber, l.newHeight);
      for (const l of i) {
        const c = this._findWhitespaceIndex(l.id);
        c !== -1 && this._removeWhitespace(c);
      }
      return;
    }
    const n = /* @__PURE__ */ new Set();
    for (const l of i)
      n.add(l.id);
    const o = /* @__PURE__ */ new Map();
    for (const l of t)
      o.set(l.id, l);
    const r = (l) => {
      const c = [];
      for (const h of l)
        if (!n.has(h.id)) {
          if (o.has(h.id)) {
            const d = o.get(h.id);
            h.afterLineNumber = d.newAfterLineNumber, h.height = d.newHeight;
          }
          c.push(h);
        }
      return c;
    }, a = r(this._arr).concat(r(e));
    a.sort((l, c) => l.afterLineNumber === c.afterLineNumber ? l.ordinal - c.ordinal : l.afterLineNumber - c.afterLineNumber), this._arr = a, this._prefixSumValidIndex = -1;
  }
  _checkPendingChanges() {
    this._pendingChanges.mustCommit() && this._pendingChanges.commit(this);
  }
  _insertWhitespace(e) {
    const t = Va.findInsertionIndex(this._arr, e.afterLineNumber, e.ordinal);
    this._arr.splice(t, 0, e), this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, t - 1);
  }
  _findWhitespaceIndex(e) {
    const t = this._arr;
    for (let i = 0, n = t.length; i < n; i++)
      if (t[i].id === e)
        return i;
    return -1;
  }
  _changeOneWhitespace(e, t, i) {
    const n = this._findWhitespaceIndex(e);
    if (n !== -1 && (this._arr[n].height !== i && (this._arr[n].height = i, this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, n - 1)), this._arr[n].afterLineNumber !== t)) {
      const o = this._arr[n];
      this._removeWhitespace(n), o.afterLineNumber = t, this._insertWhitespace(o);
    }
  }
  _removeWhitespace(e) {
    this._arr.splice(e, 1), this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, e - 1);
  }
  /**
   * Notify the layouter that lines have been deleted (a continuous zone of lines).
   *
   * @param fromLineNumber The line number at which the deletion started, inclusive
   * @param toLineNumber The line number at which the deletion ended, inclusive
   */
  onLinesDeleted(e, t) {
    this._checkPendingChanges(), e = e | 0, t = t | 0, this._lineCount -= t - e + 1;
    for (let i = 0, n = this._arr.length; i < n; i++) {
      const o = this._arr[i].afterLineNumber;
      e <= o && o <= t ? this._arr[i].afterLineNumber = e - 1 : o > t && (this._arr[i].afterLineNumber -= t - e + 1);
    }
  }
  /**
   * Notify the layouter that lines have been inserted (a continuous zone of lines).
   *
   * @param fromLineNumber The line number at which the insertion started, inclusive
   * @param toLineNumber The line number at which the insertion ended, inclusive.
   */
  onLinesInserted(e, t) {
    this._checkPendingChanges(), e = e | 0, t = t | 0, this._lineCount += t - e + 1;
    for (let i = 0, n = this._arr.length; i < n; i++) {
      const o = this._arr[i].afterLineNumber;
      e <= o && (this._arr[i].afterLineNumber += t - e + 1);
    }
  }
  /**
   * Get the sum of all the whitespaces.
   */
  getWhitespacesTotalHeight() {
    return this._checkPendingChanges(), this._arr.length === 0 ? 0 : this.getWhitespacesAccumulatedHeight(this._arr.length - 1);
  }
  /**
   * Return the sum of the heights of the whitespaces at [0..index].
   * This includes the whitespace at `index`.
   *
   * @param index The index of the whitespace.
   * @return The sum of the heights of all whitespaces before the one at `index`, including the one at `index`.
   */
  getWhitespacesAccumulatedHeight(e) {
    this._checkPendingChanges(), e = e | 0;
    let t = Math.max(0, this._prefixSumValidIndex + 1);
    t === 0 && (this._arr[0].prefixSum = this._arr[0].height, t++);
    for (let i = t; i <= e; i++)
      this._arr[i].prefixSum = this._arr[i - 1].prefixSum + this._arr[i].height;
    return this._prefixSumValidIndex = Math.max(this._prefixSumValidIndex, e), this._arr[e].prefixSum;
  }
  /**
   * Get the sum of heights for all objects.
   *
   * @return The sum of heights for all objects.
   */
  getLinesTotalHeight() {
    this._checkPendingChanges();
    const e = this._lineHeight * this._lineCount, t = this.getWhitespacesTotalHeight();
    return e + t + this._paddingTop + this._paddingBottom;
  }
  /**
   * Returns the accumulated height of whitespaces before the given line number.
   *
   * @param lineNumber The line number
   */
  getWhitespaceAccumulatedHeightBeforeLineNumber(e) {
    this._checkPendingChanges(), e = e | 0;
    const t = this._findLastWhitespaceBeforeLineNumber(e);
    return t === -1 ? 0 : this.getWhitespacesAccumulatedHeight(t);
  }
  _findLastWhitespaceBeforeLineNumber(e) {
    e = e | 0;
    const t = this._arr;
    let i = 0, n = t.length - 1;
    for (; i <= n; ) {
      const r = (n - i | 0) / 2 | 0, a = i + r | 0;
      if (t[a].afterLineNumber < e) {
        if (a + 1 >= t.length || t[a + 1].afterLineNumber >= e)
          return a;
        i = a + 1 | 0;
      } else
        n = a - 1 | 0;
    }
    return -1;
  }
  _findFirstWhitespaceAfterLineNumber(e) {
    e = e | 0;
    const i = this._findLastWhitespaceBeforeLineNumber(e) + 1;
    return i < this._arr.length ? i : -1;
  }
  /**
   * Find the index of the first whitespace which has `afterLineNumber` >= `lineNumber`.
   * @return The index of the first whitespace with `afterLineNumber` >= `lineNumber` or -1 if no whitespace is found.
   */
  getFirstWhitespaceIndexAfterLineNumber(e) {
    return this._checkPendingChanges(), e = e | 0, this._findFirstWhitespaceAfterLineNumber(e);
  }
  /**
   * Get the vertical offset (the sum of heights for all objects above) a certain line number.
   *
   * @param lineNumber The line number
   * @return The sum of heights for all objects above `lineNumber`.
   */
  getVerticalOffsetForLineNumber(e, t = !1) {
    this._checkPendingChanges(), e = e | 0;
    let i;
    e > 1 ? i = this._lineHeight * (e - 1) : i = 0;
    const n = this.getWhitespaceAccumulatedHeightBeforeLineNumber(e - (t ? 1 : 0));
    return i + n + this._paddingTop;
  }
  /**
   * Get the vertical offset (the sum of heights for all objects above) a certain line number.
   *
   * @param lineNumber The line number
   * @return The sum of heights for all objects above `lineNumber`.
   */
  getVerticalOffsetAfterLineNumber(e, t = !1) {
    this._checkPendingChanges(), e = e | 0;
    const i = this._lineHeight * e, n = this.getWhitespaceAccumulatedHeightBeforeLineNumber(e + (t ? 1 : 0));
    return i + n + this._paddingTop;
  }
  /**
   * The maximum min width for all whitespaces.
   */
  getWhitespaceMinWidth() {
    if (this._checkPendingChanges(), this._minWidth === -1) {
      let e = 0;
      for (let t = 0, i = this._arr.length; t < i; t++)
        e = Math.max(e, this._arr[t].minWidth);
      this._minWidth = e;
    }
    return this._minWidth;
  }
  /**
   * Check if `verticalOffset` is below all lines.
   */
  isAfterLines(e) {
    this._checkPendingChanges();
    const t = this.getLinesTotalHeight();
    return e > t;
  }
  isInTopPadding(e) {
    return this._paddingTop === 0 ? !1 : (this._checkPendingChanges(), e < this._paddingTop);
  }
  isInBottomPadding(e) {
    if (this._paddingBottom === 0)
      return !1;
    this._checkPendingChanges();
    const t = this.getLinesTotalHeight();
    return e >= t - this._paddingBottom;
  }
  /**
   * Find the first line number that is at or after vertical offset `verticalOffset`.
   * i.e. if getVerticalOffsetForLine(line) is x and getVerticalOffsetForLine(line + 1) is y, then
   * getLineNumberAtOrAfterVerticalOffset(i) = line, x <= i < y.
   *
   * @param verticalOffset The vertical offset to search at.
   * @return The line number at or after vertical offset `verticalOffset`.
   */
  getLineNumberAtOrAfterVerticalOffset(e) {
    if (this._checkPendingChanges(), e = e | 0, e < 0)
      return 1;
    const t = this._lineCount | 0, i = this._lineHeight;
    let n = 1, o = t;
    for (; n < o; ) {
      const r = (n + o) / 2 | 0, a = this.getVerticalOffsetForLineNumber(r) | 0;
      if (e >= a + i)
        n = r + 1;
      else {
        if (e >= a)
          return r;
        o = r;
      }
    }
    return n > t ? t : n;
  }
  /**
   * Get all the lines and their relative vertical offsets that are positioned between `verticalOffset1` and `verticalOffset2`.
   *
   * @param verticalOffset1 The beginning of the viewport.
   * @param verticalOffset2 The end of the viewport.
   * @return A structure describing the lines positioned between `verticalOffset1` and `verticalOffset2`.
   */
  getLinesViewportData(e, t) {
    this._checkPendingChanges(), e = e | 0, t = t | 0;
    const i = this._lineHeight, n = this.getLineNumberAtOrAfterVerticalOffset(e) | 0, o = this.getVerticalOffsetForLineNumber(n) | 0;
    let r = this._lineCount | 0, a = this.getFirstWhitespaceIndexAfterLineNumber(n) | 0;
    const l = this.getWhitespacesCount() | 0;
    let c, h;
    a === -1 ? (a = l, h = r + 1, c = 0) : (h = this.getAfterLineNumberForWhitespaceIndex(a) | 0, c = this.getHeightForWhitespaceIndex(a) | 0);
    let d = o, u = d;
    const f = 5e5;
    let g = 0;
    o >= f && (g = Math.floor(o / f) * f, g = Math.floor(g / i) * i, u -= g);
    const m = [], _ = e + (t - e) / 2;
    let b = -1;
    for (let S = n; S <= r; S++) {
      if (b === -1) {
        const L = d, k = d + i;
        (L <= _ && _ < k || L > _) && (b = S);
      }
      for (d += i, m[S - n] = u, u += i; h === S; )
        u += c, d += c, a++, a >= l ? h = r + 1 : (h = this.getAfterLineNumberForWhitespaceIndex(a) | 0, c = this.getHeightForWhitespaceIndex(a) | 0);
      if (d >= t) {
        r = S;
        break;
      }
    }
    b === -1 && (b = r);
    const C = this.getVerticalOffsetForLineNumber(r) | 0;
    let v = n, w = r;
    return v < w && o < e && v++, v < w && C + i > t && w--, {
      bigNumbersDelta: g,
      startLineNumber: n,
      endLineNumber: r,
      relativeVerticalOffset: m,
      centeredLineNumber: b,
      completelyVisibleStartLineNumber: v,
      completelyVisibleEndLineNumber: w,
      lineHeight: this._lineHeight
    };
  }
  getVerticalOffsetForWhitespaceIndex(e) {
    this._checkPendingChanges(), e = e | 0;
    const t = this.getAfterLineNumberForWhitespaceIndex(e);
    let i;
    t >= 1 ? i = this._lineHeight * t : i = 0;
    let n;
    return e > 0 ? n = this.getWhitespacesAccumulatedHeight(e - 1) : n = 0, i + n + this._paddingTop;
  }
  getWhitespaceIndexAtOrAfterVerticallOffset(e) {
    this._checkPendingChanges(), e = e | 0;
    let t = 0, i = this.getWhitespacesCount() - 1;
    if (i < 0)
      return -1;
    const n = this.getVerticalOffsetForWhitespaceIndex(i), o = this.getHeightForWhitespaceIndex(i);
    if (e >= n + o)
      return -1;
    for (; t < i; ) {
      const r = Math.floor((t + i) / 2), a = this.getVerticalOffsetForWhitespaceIndex(r), l = this.getHeightForWhitespaceIndex(r);
      if (e >= a + l)
        t = r + 1;
      else {
        if (e >= a)
          return r;
        i = r;
      }
    }
    return t;
  }
  /**
   * Get exactly the whitespace that is layouted at `verticalOffset`.
   *
   * @param verticalOffset The vertical offset.
   * @return Precisely the whitespace that is layouted at `verticaloffset` or null.
   */
  getWhitespaceAtVerticalOffset(e) {
    this._checkPendingChanges(), e = e | 0;
    const t = this.getWhitespaceIndexAtOrAfterVerticallOffset(e);
    if (t < 0 || t >= this.getWhitespacesCount())
      return null;
    const i = this.getVerticalOffsetForWhitespaceIndex(t);
    if (i > e)
      return null;
    const n = this.getHeightForWhitespaceIndex(t), o = this.getIdForWhitespaceIndex(t), r = this.getAfterLineNumberForWhitespaceIndex(t);
    return {
      id: o,
      afterLineNumber: r,
      verticalOffset: i,
      height: n
    };
  }
  /**
   * Get a list of whitespaces that are positioned between `verticalOffset1` and `verticalOffset2`.
   *
   * @param verticalOffset1 The beginning of the viewport.
   * @param verticalOffset2 The end of the viewport.
   * @return An array with all the whitespaces in the viewport. If no whitespace is in viewport, the array is empty.
   */
  getWhitespaceViewportData(e, t) {
    this._checkPendingChanges(), e = e | 0, t = t | 0;
    const i = this.getWhitespaceIndexAtOrAfterVerticallOffset(e), n = this.getWhitespacesCount() - 1;
    if (i < 0)
      return [];
    const o = [];
    for (let r = i; r <= n; r++) {
      const a = this.getVerticalOffsetForWhitespaceIndex(r), l = this.getHeightForWhitespaceIndex(r);
      if (a >= t)
        break;
      o.push({
        id: this.getIdForWhitespaceIndex(r),
        afterLineNumber: this.getAfterLineNumberForWhitespaceIndex(r),
        verticalOffset: a,
        height: l
      });
    }
    return o;
  }
  /**
   * Get all whitespaces.
   */
  getWhitespaces() {
    return this._checkPendingChanges(), this._arr.slice(0);
  }
  /**
   * The number of whitespaces.
   */
  getWhitespacesCount() {
    return this._checkPendingChanges(), this._arr.length;
  }
  /**
   * Get the `id` for whitespace at index `index`.
   *
   * @param index The index of the whitespace.
   * @return `id` of whitespace at `index`.
   */
  getIdForWhitespaceIndex(e) {
    return this._checkPendingChanges(), e = e | 0, this._arr[e].id;
  }
  /**
   * Get the `afterLineNumber` for whitespace at index `index`.
   *
   * @param index The index of the whitespace.
   * @return `afterLineNumber` of whitespace at `index`.
   */
  getAfterLineNumberForWhitespaceIndex(e) {
    return this._checkPendingChanges(), e = e | 0, this._arr[e].afterLineNumber;
  }
  /**
   * Get the `height` for whitespace at index `index`.
   *
   * @param index The index of the whitespace.
   * @return `height` of whitespace at `index`.
   */
  getHeightForWhitespaceIndex(e) {
    return this._checkPendingChanges(), e = e | 0, this._arr[e].height;
  }
}, Va.INSTANCE_COUNT = 0, Va);
const JY = 125;
class Au {
  constructor(e, t, i, n) {
    e = e | 0, t = t | 0, i = i | 0, n = n | 0, e < 0 && (e = 0), t < 0 && (t = 0), i < 0 && (i = 0), n < 0 && (n = 0), this.width = e, this.contentWidth = t, this.scrollWidth = Math.max(e, t), this.height = i, this.contentHeight = n, this.scrollHeight = Math.max(i, n);
  }
  equals(e) {
    return this.width === e.width && this.contentWidth === e.contentWidth && this.height === e.height && this.contentHeight === e.contentHeight;
  }
}
class eQ extends q {
  constructor(e, t) {
    super(), this._onDidContentSizeChange = this._register(new O()), this.onDidContentSizeChange = this._onDidContentSizeChange.event, this._dimensions = new Au(0, 0, 0, 0), this._scrollable = this._register(new zd({
      forceIntegerValues: !0,
      smoothScrollDuration: e,
      scheduleAtNextAnimationFrame: t
    })), this.onDidScroll = this._scrollable.onScroll;
  }
  getScrollable() {
    return this._scrollable;
  }
  setSmoothScrollDuration(e) {
    this._scrollable.setSmoothScrollDuration(e);
  }
  validateScrollPosition(e) {
    return this._scrollable.validateScrollPosition(e);
  }
  getScrollDimensions() {
    return this._dimensions;
  }
  setScrollDimensions(e) {
    if (this._dimensions.equals(e))
      return;
    const t = this._dimensions;
    this._dimensions = e, this._scrollable.setScrollDimensions({
      width: e.width,
      scrollWidth: e.scrollWidth,
      height: e.height,
      scrollHeight: e.scrollHeight
    }, !0);
    const i = t.contentWidth !== e.contentWidth, n = t.contentHeight !== e.contentHeight;
    (i || n) && this._onDidContentSizeChange.fire(new Tx(t.contentWidth, t.contentHeight, e.contentWidth, e.contentHeight));
  }
  getFutureScrollPosition() {
    return this._scrollable.getFutureScrollPosition();
  }
  getCurrentScrollPosition() {
    return this._scrollable.getCurrentScrollPosition();
  }
  setScrollPositionNow(e) {
    this._scrollable.setScrollPositionNow(e);
  }
  setScrollPositionSmooth(e) {
    this._scrollable.setScrollPositionSmooth(e);
  }
  hasPendingScrollAnimation() {
    return this._scrollable.hasPendingScrollAnimation();
  }
}
class tQ extends q {
  constructor(e, t, i) {
    super(), this._configuration = e;
    const n = this._configuration.options, o = n.get(
      146
      /* EditorOption.layoutInfo */
    ), r = n.get(
      84
      /* EditorOption.padding */
    );
    this._linesLayout = new XY(t, n.get(
      67
      /* EditorOption.lineHeight */
    ), r.top, r.bottom), this._maxLineWidth = 0, this._overlayWidgetsMinWidth = 0, this._scrollable = this._register(new eQ(0, i)), this._configureSmoothScrollDuration(), this._scrollable.setScrollDimensions(new Au(o.contentWidth, 0, o.height, 0)), this.onDidScroll = this._scrollable.onDidScroll, this.onDidContentSizeChange = this._scrollable.onDidContentSizeChange, this._updateHeight();
  }
  dispose() {
    super.dispose();
  }
  getScrollable() {
    return this._scrollable.getScrollable();
  }
  onHeightMaybeChanged() {
    this._updateHeight();
  }
  _configureSmoothScrollDuration() {
    this._scrollable.setSmoothScrollDuration(this._configuration.options.get(
      115
      /* EditorOption.smoothScrolling */
    ) ? JY : 0);
  }
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    const t = this._configuration.options;
    if (e.hasChanged(
      67
      /* EditorOption.lineHeight */
    ) && this._linesLayout.setLineHeight(t.get(
      67
      /* EditorOption.lineHeight */
    )), e.hasChanged(
      84
      /* EditorOption.padding */
    )) {
      const i = t.get(
        84
        /* EditorOption.padding */
      );
      this._linesLayout.setPadding(i.top, i.bottom);
    }
    if (e.hasChanged(
      146
      /* EditorOption.layoutInfo */
    )) {
      const i = t.get(
        146
        /* EditorOption.layoutInfo */
      ), n = i.contentWidth, o = i.height, r = this._scrollable.getScrollDimensions(), a = r.contentWidth;
      this._scrollable.setScrollDimensions(new Au(n, r.contentWidth, o, this._getContentHeight(n, o, a)));
    } else
      this._updateHeight();
    e.hasChanged(
      115
      /* EditorOption.smoothScrolling */
    ) && this._configureSmoothScrollDuration();
  }
  onFlushed(e) {
    this._linesLayout.onFlushed(e);
  }
  onLinesDeleted(e, t) {
    this._linesLayout.onLinesDeleted(e, t);
  }
  onLinesInserted(e, t) {
    this._linesLayout.onLinesInserted(e, t);
  }
  // ---- end view event handlers
  _getHorizontalScrollbarHeight(e, t) {
    const n = this._configuration.options.get(
      104
      /* EditorOption.scrollbar */
    );
    return n.horizontal === 2 || e >= t ? 0 : n.horizontalScrollbarSize;
  }
  _getContentHeight(e, t, i) {
    const n = this._configuration.options;
    let o = this._linesLayout.getLinesTotalHeight();
    return n.get(
      106
      /* EditorOption.scrollBeyondLastLine */
    ) ? o += Math.max(0, t - n.get(
      67
      /* EditorOption.lineHeight */
    ) - n.get(
      84
      /* EditorOption.padding */
    ).bottom) : n.get(
      104
      /* EditorOption.scrollbar */
    ).ignoreHorizontalScrollbarInContentHeight || (o += this._getHorizontalScrollbarHeight(e, i)), o;
  }
  _updateHeight() {
    const e = this._scrollable.getScrollDimensions(), t = e.width, i = e.height, n = e.contentWidth;
    this._scrollable.setScrollDimensions(new Au(t, e.contentWidth, i, this._getContentHeight(t, i, n)));
  }
  // ---- Layouting logic
  getCurrentViewport() {
    const e = this._scrollable.getScrollDimensions(), t = this._scrollable.getCurrentScrollPosition();
    return new eT(t.scrollTop, t.scrollLeft, e.width, e.height);
  }
  getFutureViewport() {
    const e = this._scrollable.getScrollDimensions(), t = this._scrollable.getFutureScrollPosition();
    return new eT(t.scrollTop, t.scrollLeft, e.width, e.height);
  }
  _computeContentWidth() {
    const e = this._configuration.options, t = this._maxLineWidth, i = e.get(
      147
      /* EditorOption.wrappingInfo */
    ), n = e.get(
      50
      /* EditorOption.fontInfo */
    ), o = e.get(
      146
      /* EditorOption.layoutInfo */
    );
    if (i.isViewportWrapping) {
      const r = e.get(
        73
        /* EditorOption.minimap */
      );
      return t > o.contentWidth + n.typicalHalfwidthCharacterWidth && r.enabled && r.side === "right" ? t + o.verticalScrollbarWidth : t;
    } else {
      const r = e.get(
        105
        /* EditorOption.scrollBeyondLastColumn */
      ) * n.typicalHalfwidthCharacterWidth, a = this._linesLayout.getWhitespaceMinWidth();
      return Math.max(t + r + o.verticalScrollbarWidth, a, this._overlayWidgetsMinWidth);
    }
  }
  setMaxLineWidth(e) {
    this._maxLineWidth = e, this._updateContentWidth();
  }
  setOverlayWidgetsMinWidth(e) {
    this._overlayWidgetsMinWidth = e, this._updateContentWidth();
  }
  _updateContentWidth() {
    const e = this._scrollable.getScrollDimensions();
    this._scrollable.setScrollDimensions(new Au(e.width, this._computeContentWidth(), e.height, e.contentHeight)), this._updateHeight();
  }
  // ---- view state
  saveState() {
    const e = this._scrollable.getFutureScrollPosition(), t = e.scrollTop, i = this._linesLayout.getLineNumberAtOrAfterVerticalOffset(t), n = this._linesLayout.getWhitespaceAccumulatedHeightBeforeLineNumber(i);
    return {
      scrollTop: t,
      scrollTopWithoutViewZones: t - n,
      scrollLeft: e.scrollLeft
    };
  }
  // ----
  changeWhitespace(e) {
    const t = this._linesLayout.changeWhitespace(e);
    return t && this.onHeightMaybeChanged(), t;
  }
  getVerticalOffsetForLineNumber(e, t = !1) {
    return this._linesLayout.getVerticalOffsetForLineNumber(e, t);
  }
  getVerticalOffsetAfterLineNumber(e, t = !1) {
    return this._linesLayout.getVerticalOffsetAfterLineNumber(e, t);
  }
  isAfterLines(e) {
    return this._linesLayout.isAfterLines(e);
  }
  isInTopPadding(e) {
    return this._linesLayout.isInTopPadding(e);
  }
  isInBottomPadding(e) {
    return this._linesLayout.isInBottomPadding(e);
  }
  getLineNumberAtVerticalOffset(e) {
    return this._linesLayout.getLineNumberAtOrAfterVerticalOffset(e);
  }
  getWhitespaceAtVerticalOffset(e) {
    return this._linesLayout.getWhitespaceAtVerticalOffset(e);
  }
  getLinesViewportData() {
    const e = this.getCurrentViewport();
    return this._linesLayout.getLinesViewportData(e.top, e.top + e.height);
  }
  getLinesViewportDataAtScrollTop(e) {
    const t = this._scrollable.getScrollDimensions();
    return e + t.height > t.scrollHeight && (e = t.scrollHeight - t.height), e < 0 && (e = 0), this._linesLayout.getLinesViewportData(e, e + t.height);
  }
  getWhitespaceViewportData() {
    const e = this.getCurrentViewport();
    return this._linesLayout.getWhitespaceViewportData(e.top, e.top + e.height);
  }
  getWhitespaces() {
    return this._linesLayout.getWhitespaces();
  }
  // ----
  getContentWidth() {
    return this._scrollable.getScrollDimensions().contentWidth;
  }
  getScrollWidth() {
    return this._scrollable.getScrollDimensions().scrollWidth;
  }
  getContentHeight() {
    return this._scrollable.getScrollDimensions().contentHeight;
  }
  getScrollHeight() {
    return this._scrollable.getScrollDimensions().scrollHeight;
  }
  getCurrentScrollLeft() {
    return this._scrollable.getCurrentScrollPosition().scrollLeft;
  }
  getCurrentScrollTop() {
    return this._scrollable.getCurrentScrollPosition().scrollTop;
  }
  validateScrollPosition(e) {
    return this._scrollable.validateScrollPosition(e);
  }
  setScrollPosition(e, t) {
    t === 1 ? this._scrollable.setScrollPositionNow(e) : this._scrollable.setScrollPositionSmooth(e);
  }
  hasPendingScrollAnimation() {
    return this._scrollable.hasPendingScrollAnimation();
  }
  deltaScrollNow(e, t) {
    const i = this._scrollable.getCurrentScrollPosition();
    this._scrollable.setScrollPositionNow({
      scrollLeft: i.scrollLeft + e,
      scrollTop: i.scrollTop + t
    });
  }
}
class iQ {
  constructor(e, t, i, n, o) {
    this.editorId = e, this.model = t, this.configuration = i, this._linesCollection = n, this._coordinatesConverter = o, this._decorationsCache = /* @__PURE__ */ Object.create(null), this._cachedModelDecorationsResolver = null, this._cachedModelDecorationsResolverViewRange = null;
  }
  _clearCachedModelDecorationsResolver() {
    this._cachedModelDecorationsResolver = null, this._cachedModelDecorationsResolverViewRange = null;
  }
  dispose() {
    this._decorationsCache = /* @__PURE__ */ Object.create(null), this._clearCachedModelDecorationsResolver();
  }
  reset() {
    this._decorationsCache = /* @__PURE__ */ Object.create(null), this._clearCachedModelDecorationsResolver();
  }
  onModelDecorationsChanged() {
    this._decorationsCache = /* @__PURE__ */ Object.create(null), this._clearCachedModelDecorationsResolver();
  }
  onLineMappingChanged() {
    this._decorationsCache = /* @__PURE__ */ Object.create(null), this._clearCachedModelDecorationsResolver();
  }
  _getOrCreateViewModelDecoration(e) {
    const t = e.id;
    let i = this._decorationsCache[t];
    if (!i) {
      const n = e.range, o = e.options;
      let r;
      if (o.isWholeLine) {
        const a = this._coordinatesConverter.convertModelPositionToViewPosition(new V(n.startLineNumber, 1), 0, !1, !0), l = this._coordinatesConverter.convertModelPositionToViewPosition(
          new V(n.endLineNumber, this.model.getLineMaxColumn(n.endLineNumber)),
          1
          /* PositionAffinity.Right */
        );
        r = new R(a.lineNumber, a.column, l.lineNumber, l.column);
      } else
        r = this._coordinatesConverter.convertModelRangeToViewRange(
          n,
          1
          /* PositionAffinity.Right */
        );
      i = new K4(r, o), this._decorationsCache[t] = i;
    }
    return i;
  }
  getMinimapDecorationsInRange(e) {
    return this._getDecorationsInRange(e, !0, !1).decorations;
  }
  getDecorationsViewportData(e) {
    let t = this._cachedModelDecorationsResolver !== null;
    return t = t && e.equalsRange(this._cachedModelDecorationsResolverViewRange), t || (this._cachedModelDecorationsResolver = this._getDecorationsInRange(e, !1, !1), this._cachedModelDecorationsResolverViewRange = e), this._cachedModelDecorationsResolver;
  }
  getInlineDecorationsOnLine(e, t = !1, i = !1) {
    const n = new R(e, this._linesCollection.getViewLineMinColumn(e), e, this._linesCollection.getViewLineMaxColumn(e));
    return this._getDecorationsInRange(n, t, i).inlineDecorations[0];
  }
  _getDecorationsInRange(e, t, i) {
    const n = this._linesCollection.getDecorationsInRange(e, this.editorId, wp(this.configuration.options), t, i), o = e.startLineNumber, r = e.endLineNumber, a = [];
    let l = 0;
    const c = [];
    for (let h = o; h <= r; h++)
      c[h - o] = [];
    for (let h = 0, d = n.length; h < d; h++) {
      const u = n[h], f = u.options;
      if (!nQ(this.model, u))
        continue;
      const g = this._getOrCreateViewModelDecoration(u), m = g.range;
      if (a[l++] = g, f.inlineClassName) {
        const _ = new rf(
          m,
          f.inlineClassName,
          f.inlineClassNameAffectsLetterSpacing ? 3 : 0
          /* InlineDecorationType.Regular */
        ), b = Math.max(o, m.startLineNumber), C = Math.min(r, m.endLineNumber);
        for (let v = b; v <= C; v++)
          c[v - o].push(_);
      }
      if (f.beforeContentClassName && o <= m.startLineNumber && m.startLineNumber <= r) {
        const _ = new rf(
          new R(m.startLineNumber, m.startColumn, m.startLineNumber, m.startColumn),
          f.beforeContentClassName,
          1
          /* InlineDecorationType.Before */
        );
        c[m.startLineNumber - o].push(_);
      }
      if (f.afterContentClassName && o <= m.endLineNumber && m.endLineNumber <= r) {
        const _ = new rf(
          new R(m.endLineNumber, m.endColumn, m.endLineNumber, m.endColumn),
          f.afterContentClassName,
          2
          /* InlineDecorationType.After */
        );
        c[m.endLineNumber - o].push(_);
      }
    }
    return {
      decorations: a,
      inlineDecorations: c
    };
  }
}
function nQ(s, e) {
  return !(e.options.hideInCommentTokens && sQ(s, e) || e.options.hideInStringTokens && oQ(s, e));
}
function sQ(s, e) {
  return f5(
    s,
    e.range,
    (t) => t === 1
    /* StandardTokenType.Comment */
  );
}
function oQ(s, e) {
  return f5(
    s,
    e.range,
    (t) => t === 2
    /* StandardTokenType.String */
  );
}
function f5(s, e, t) {
  for (let i = e.startLineNumber; i <= e.endLineNumber; i++) {
    const n = s.tokenization.getLineTokens(i), o = i === e.startLineNumber, r = i === e.endLineNumber;
    let a = o ? n.findTokenIndexAtOffset(e.startColumn - 1) : 0;
    for (; a < n.getCount() && !(r && n.getStartOffset(a) > e.endColumn - 1); ) {
      if (!t(n.getStandardTokenType(a)))
        return !1;
      a++;
    }
  }
  return !0;
}
function yC(s, e) {
  return s === null ? e ? q_.INSTANCE : j_.INSTANCE : new rQ(s, e);
}
class rQ {
  constructor(e, t) {
    this._projectionData = e, this._isVisible = t;
  }
  isVisible() {
    return this._isVisible;
  }
  setVisible(e) {
    return this._isVisible = e, this;
  }
  getProjectionData() {
    return this._projectionData;
  }
  getViewLineCount() {
    return this._isVisible ? this._projectionData.getOutputLineCount() : 0;
  }
  getViewLineContent(e, t, i) {
    this._assertVisible();
    const n = i > 0 ? this._projectionData.breakOffsets[i - 1] : 0, o = this._projectionData.breakOffsets[i];
    let r;
    if (this._projectionData.injectionOffsets !== null) {
      const a = this._projectionData.injectionOffsets.map((c, h) => new ao(0, 0, c + 1, this._projectionData.injectionOptions[h], 0));
      r = ao.applyInjectedText(e.getLineContent(t), a).substring(n, o);
    } else
      r = e.getValueInRange({
        startLineNumber: t,
        startColumn: n + 1,
        endLineNumber: t,
        endColumn: o + 1
      });
    return i > 0 && (r = MT(this._projectionData.wrappedTextIndentLength) + r), r;
  }
  getViewLineLength(e, t, i) {
    return this._assertVisible(), this._projectionData.getLineLength(i);
  }
  getViewLineMinColumn(e, t, i) {
    return this._assertVisible(), this._projectionData.getMinOutputOffset(i) + 1;
  }
  getViewLineMaxColumn(e, t, i) {
    return this._assertVisible(), this._projectionData.getMaxOutputOffset(i) + 1;
  }
  /**
   * Try using {@link getViewLinesData} instead.
  */
  getViewLineData(e, t, i) {
    const n = new Array();
    return this.getViewLinesData(e, t, i, 1, 0, [!0], n), n[0];
  }
  getViewLinesData(e, t, i, n, o, r, a) {
    this._assertVisible();
    const l = this._projectionData, c = l.injectionOffsets, h = l.injectionOptions;
    let d = null;
    if (c) {
      d = [];
      let f = 0, g = 0;
      for (let m = 0; m < l.getOutputLineCount(); m++) {
        const _ = new Array();
        d[m] = _;
        const b = m > 0 ? l.breakOffsets[m - 1] : 0, C = l.breakOffsets[m];
        for (; g < c.length; ) {
          const v = h[g].content.length, w = c[g] + f, S = w + v;
          if (w > C)
            break;
          if (b < S) {
            const L = h[g];
            if (L.inlineClassName) {
              const k = m > 0 ? l.wrappedTextIndentLength : 0, D = k + Math.max(w - b, 0), E = k + Math.min(S - b, C - b);
              D !== E && _.push(new Qj(D, E, L.inlineClassName, L.inlineClassNameAffectsLetterSpacing));
            }
          }
          if (S <= C)
            f += v, g++;
          else
            break;
        }
      }
    }
    let u;
    c ? u = e.tokenization.getLineTokens(t).withInserted(c.map((f, g) => ({
      offset: f,
      text: h[g].content,
      tokenMetadata: Si.defaultTokenMetadata
    }))) : u = e.tokenization.getLineTokens(t);
    for (let f = i; f < i + n; f++) {
      const g = o + f - i;
      if (!r[g]) {
        a[g] = null;
        continue;
      }
      a[g] = this._getViewLineData(u, d ? d[f] : null, f);
    }
  }
  _getViewLineData(e, t, i) {
    this._assertVisible();
    const n = this._projectionData, o = i > 0 ? n.wrappedTextIndentLength : 0, r = i > 0 ? n.breakOffsets[i - 1] : 0, a = n.breakOffsets[i], l = e.sliceAndInflate(r, a, o);
    let c = l.getLineContent();
    i > 0 && (c = MT(n.wrappedTextIndentLength) + c);
    const h = this._projectionData.getMinOutputOffset(i) + 1, d = c.length + 1, u = i + 1 < this.getViewLineCount(), f = i === 0 ? 0 : n.breakOffsetsVisibleColumn[i - 1];
    return new _x(c, u, h, d, f, l, t);
  }
  getModelColumnOfViewPosition(e, t) {
    return this._assertVisible(), this._projectionData.translateToInputOffset(e, t - 1) + 1;
  }
  getViewPositionOfModelPosition(e, t, i = 2) {
    return this._assertVisible(), this._projectionData.translateToOutputPosition(t - 1, i).toPosition(e);
  }
  getViewLineNumberOfModelPosition(e, t) {
    this._assertVisible();
    const i = this._projectionData.translateToOutputPosition(t - 1);
    return e + i.outputLineIndex;
  }
  normalizePosition(e, t, i) {
    const n = t.lineNumber - e;
    return this._projectionData.normalizeOutputPosition(e, t.column - 1, i).toPosition(n);
  }
  getInjectedTextAt(e, t) {
    return this._projectionData.getInjectedText(e, t - 1);
  }
  _assertVisible() {
    if (!this._isVisible)
      throw new Error("Not supported");
  }
}
const K1 = class K1 {
  constructor() {
  }
  isVisible() {
    return !0;
  }
  setVisible(e) {
    return e ? this : j_.INSTANCE;
  }
  getProjectionData() {
    return null;
  }
  getViewLineCount() {
    return 1;
  }
  getViewLineContent(e, t, i) {
    return e.getLineContent(t);
  }
  getViewLineLength(e, t, i) {
    return e.getLineLength(t);
  }
  getViewLineMinColumn(e, t, i) {
    return e.getLineMinColumn(t);
  }
  getViewLineMaxColumn(e, t, i) {
    return e.getLineMaxColumn(t);
  }
  getViewLineData(e, t, i) {
    const n = e.tokenization.getLineTokens(t), o = n.getLineContent();
    return new _x(o, !1, 1, o.length + 1, 0, n.inflate(), null);
  }
  getViewLinesData(e, t, i, n, o, r, a) {
    if (!r[o]) {
      a[o] = null;
      return;
    }
    a[o] = this.getViewLineData(e, t, 0);
  }
  getModelColumnOfViewPosition(e, t) {
    return t;
  }
  getViewPositionOfModelPosition(e, t) {
    return new V(e, t);
  }
  getViewLineNumberOfModelPosition(e, t) {
    return e;
  }
  normalizePosition(e, t, i) {
    return t;
  }
  getInjectedTextAt(e, t) {
    return null;
  }
};
K1.INSTANCE = new K1();
let q_ = K1;
const q1 = class q1 {
  constructor() {
  }
  isVisible() {
    return !1;
  }
  setVisible(e) {
    return e ? q_.INSTANCE : this;
  }
  getProjectionData() {
    return null;
  }
  getViewLineCount() {
    return 0;
  }
  getViewLineContent(e, t, i) {
    throw new Error("Not supported");
  }
  getViewLineLength(e, t, i) {
    throw new Error("Not supported");
  }
  getViewLineMinColumn(e, t, i) {
    throw new Error("Not supported");
  }
  getViewLineMaxColumn(e, t, i) {
    throw new Error("Not supported");
  }
  getViewLineData(e, t, i) {
    throw new Error("Not supported");
  }
  getViewLinesData(e, t, i, n, o, r, a) {
    throw new Error("Not supported");
  }
  getModelColumnOfViewPosition(e, t) {
    throw new Error("Not supported");
  }
  getViewPositionOfModelPosition(e, t) {
    throw new Error("Not supported");
  }
  getViewLineNumberOfModelPosition(e, t) {
    throw new Error("Not supported");
  }
  normalizePosition(e, t, i) {
    throw new Error("Not supported");
  }
  getInjectedTextAt(e, t) {
    throw new Error("Not supported");
  }
};
q1.INSTANCE = new q1();
let j_ = q1;
const SC = [""];
function MT(s) {
  if (s >= SC.length)
    for (let e = 1; e <= s; e++)
      SC[e] = aQ(e);
  return SC[s];
}
function aQ(s) {
  return new Array(s + 1).join(" ");
}
class lQ {
  constructor(e, t, i, n, o, r, a, l, c, h) {
    this._editorId = e, this.model = t, this._validModelVersionId = -1, this._domLineBreaksComputerFactory = i, this._monospaceLineBreaksComputerFactory = n, this.fontInfo = o, this.tabSize = r, this.wrappingStrategy = a, this.wrappingColumn = l, this.wrappingIndent = c, this.wordBreak = h, this._constructLines(
      /*resetHiddenAreas*/
      !0,
      null
    );
  }
  dispose() {
    this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);
  }
  createCoordinatesConverter() {
    return new hQ(this);
  }
  _constructLines(e, t) {
    this.modelLineProjections = [], e && (this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []));
    const i = this.model.getLinesContent(), n = this.model.getInjectedTextDecorations(this._editorId), o = i.length, r = this.createLineBreaksComputer(), a = new Gr(ao.fromDecorations(n));
    for (let m = 0; m < o; m++) {
      const _ = a.takeWhile((b) => b.lineNumber === m + 1);
      r.addRequest(i[m], _, t ? t[m] : null);
    }
    const l = r.finalize(), c = [], h = this.hiddenAreasDecorationIds.map((m) => this.model.getDecorationRange(m)).sort(R.compareRangesUsingStarts);
    let d = 1, u = 0, f = -1, g = f + 1 < h.length ? u + 1 : o + 2;
    for (let m = 0; m < o; m++) {
      const _ = m + 1;
      _ === g && (f++, d = h[f].startLineNumber, u = h[f].endLineNumber, g = f + 1 < h.length ? u + 1 : o + 2);
      const b = _ >= d && _ <= u, C = yC(l[m], !b);
      c[m] = C.getViewLineCount(), this.modelLineProjections[m] = C;
    }
    this._validModelVersionId = this.model.getVersionId(), this.projectedModelLineLineCounts = new nF(c);
  }
  getHiddenAreas() {
    return this.hiddenAreasDecorationIds.map((e) => this.model.getDecorationRange(e));
  }
  setHiddenAreas(e) {
    const t = e.map((u) => this.model.validateRange(u)), i = cQ(t), n = this.hiddenAreasDecorationIds.map((u) => this.model.getDecorationRange(u)).sort(R.compareRangesUsingStarts);
    if (i.length === n.length) {
      let u = !1;
      for (let f = 0; f < i.length; f++)
        if (!i[f].equalsRange(n[f])) {
          u = !0;
          break;
        }
      if (!u)
        return !1;
    }
    const o = i.map((u) => ({
      range: u,
      options: si.EMPTY
    }));
    this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, o);
    const r = i;
    let a = 1, l = 0, c = -1, h = c + 1 < r.length ? l + 1 : this.modelLineProjections.length + 2, d = !1;
    for (let u = 0; u < this.modelLineProjections.length; u++) {
      const f = u + 1;
      f === h && (c++, a = r[c].startLineNumber, l = r[c].endLineNumber, h = c + 1 < r.length ? l + 1 : this.modelLineProjections.length + 2);
      let g = !1;
      if (f >= a && f <= l ? this.modelLineProjections[u].isVisible() && (this.modelLineProjections[u] = this.modelLineProjections[u].setVisible(!1), g = !0) : (d = !0, this.modelLineProjections[u].isVisible() || (this.modelLineProjections[u] = this.modelLineProjections[u].setVisible(!0), g = !0)), g) {
        const m = this.modelLineProjections[u].getViewLineCount();
        this.projectedModelLineLineCounts.setValue(u, m);
      }
    }
    return d || this.setHiddenAreas([]), !0;
  }
  modelPositionIsVisible(e, t) {
    return e < 1 || e > this.modelLineProjections.length ? !1 : this.modelLineProjections[e - 1].isVisible();
  }
  getModelLineViewLineCount(e) {
    return e < 1 || e > this.modelLineProjections.length ? 1 : this.modelLineProjections[e - 1].getViewLineCount();
  }
  setTabSize(e) {
    return this.tabSize === e ? !1 : (this.tabSize = e, this._constructLines(
      /*resetHiddenAreas*/
      !1,
      null
    ), !0);
  }
  setWrappingSettings(e, t, i, n, o) {
    const r = this.fontInfo.equals(e), a = this.wrappingStrategy === t, l = this.wrappingColumn === i, c = this.wrappingIndent === n, h = this.wordBreak === o;
    if (r && a && l && c && h)
      return !1;
    const d = r && a && !l && c && h;
    this.fontInfo = e, this.wrappingStrategy = t, this.wrappingColumn = i, this.wrappingIndent = n, this.wordBreak = o;
    let u = null;
    if (d) {
      u = [];
      for (let f = 0, g = this.modelLineProjections.length; f < g; f++)
        u[f] = this.modelLineProjections[f].getProjectionData();
    }
    return this._constructLines(
      /*resetHiddenAreas*/
      !1,
      u
    ), !0;
  }
  createLineBreaksComputer() {
    return (this.wrappingStrategy === "advanced" ? this._domLineBreaksComputerFactory : this._monospaceLineBreaksComputerFactory).createLineBreaksComputer(this.fontInfo, this.tabSize, this.wrappingColumn, this.wrappingIndent, this.wordBreak);
  }
  onModelFlushed() {
    this._constructLines(
      /*resetHiddenAreas*/
      !0,
      null
    );
  }
  onModelLinesDeleted(e, t, i) {
    if (!e || e <= this._validModelVersionId)
      return null;
    const n = t === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(t - 1) + 1, o = this.projectedModelLineLineCounts.getPrefixSum(i);
    return this.modelLineProjections.splice(t - 1, i - t + 1), this.projectedModelLineLineCounts.removeValues(t - 1, i - t + 1), new VS(n, o);
  }
  onModelLinesInserted(e, t, i, n) {
    if (!e || e <= this._validModelVersionId)
      return null;
    const o = t > 2 && !this.modelLineProjections[t - 2].isVisible(), r = t === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(t - 1) + 1;
    let a = 0;
    const l = [], c = [];
    for (let h = 0, d = n.length; h < d; h++) {
      const u = yC(n[h], !o);
      l.push(u);
      const f = u.getViewLineCount();
      a += f, c[h] = f;
    }
    return this.modelLineProjections = this.modelLineProjections.slice(0, t - 1).concat(l).concat(this.modelLineProjections.slice(t - 1)), this.projectedModelLineLineCounts.insertValues(t - 1, c), new HS(r, r + a - 1);
  }
  onModelLineChanged(e, t, i) {
    if (e !== null && e <= this._validModelVersionId)
      return [!1, null, null, null];
    const n = t - 1, o = this.modelLineProjections[n].getViewLineCount(), r = this.modelLineProjections[n].isVisible(), a = yC(i, r);
    this.modelLineProjections[n] = a;
    const l = this.modelLineProjections[n].getViewLineCount();
    let c = !1, h = 0, d = -1, u = 0, f = -1, g = 0, m = -1;
    o > l ? (h = this.projectedModelLineLineCounts.getPrefixSum(t - 1) + 1, d = h + l - 1, g = d + 1, m = g + (o - l) - 1, c = !0) : o < l ? (h = this.projectedModelLineLineCounts.getPrefixSum(t - 1) + 1, d = h + o - 1, u = d + 1, f = u + (l - o) - 1, c = !0) : (h = this.projectedModelLineLineCounts.getPrefixSum(t - 1) + 1, d = h + l - 1), this.projectedModelLineLineCounts.setValue(n, l);
    const _ = h <= d ? new u5(h, d - h + 1) : null, b = u <= f ? new HS(u, f) : null, C = g <= m ? new VS(g, m) : null;
    return [c, _, b, C];
  }
  acceptVersionId(e) {
    this._validModelVersionId = e, this.modelLineProjections.length === 1 && !this.modelLineProjections[0].isVisible() && this.setHiddenAreas([]);
  }
  getViewLineCount() {
    return this.projectedModelLineLineCounts.getTotalSum();
  }
  _toValidViewLineNumber(e) {
    if (e < 1)
      return 1;
    const t = this.getViewLineCount();
    return e > t ? t : e | 0;
  }
  getActiveIndentGuide(e, t, i) {
    e = this._toValidViewLineNumber(e), t = this._toValidViewLineNumber(t), i = this._toValidViewLineNumber(i);
    const n = this.convertViewPositionToModelPosition(e, this.getViewLineMinColumn(e)), o = this.convertViewPositionToModelPosition(t, this.getViewLineMinColumn(t)), r = this.convertViewPositionToModelPosition(i, this.getViewLineMinColumn(i)), a = this.model.guides.getActiveIndentGuide(n.lineNumber, o.lineNumber, r.lineNumber), l = this.convertModelPositionToViewPosition(a.startLineNumber, 1), c = this.convertModelPositionToViewPosition(a.endLineNumber, this.model.getLineMaxColumn(a.endLineNumber));
    return {
      startLineNumber: l.lineNumber,
      endLineNumber: c.lineNumber,
      indent: a.indent
    };
  }
  // #region ViewLineInfo
  getViewLineInfo(e) {
    e = this._toValidViewLineNumber(e);
    const t = this.projectedModelLineLineCounts.getIndexOf(e - 1), i = t.index, n = t.remainder;
    return new RT(i + 1, n);
  }
  getMinColumnOfViewLine(e) {
    return this.modelLineProjections[e.modelLineNumber - 1].getViewLineMinColumn(this.model, e.modelLineNumber, e.modelLineWrappedLineIdx);
  }
  getMaxColumnOfViewLine(e) {
    return this.modelLineProjections[e.modelLineNumber - 1].getViewLineMaxColumn(this.model, e.modelLineNumber, e.modelLineWrappedLineIdx);
  }
  getModelStartPositionOfViewLine(e) {
    const t = this.modelLineProjections[e.modelLineNumber - 1], i = t.getViewLineMinColumn(this.model, e.modelLineNumber, e.modelLineWrappedLineIdx), n = t.getModelColumnOfViewPosition(e.modelLineWrappedLineIdx, i);
    return new V(e.modelLineNumber, n);
  }
  getModelEndPositionOfViewLine(e) {
    const t = this.modelLineProjections[e.modelLineNumber - 1], i = t.getViewLineMaxColumn(this.model, e.modelLineNumber, e.modelLineWrappedLineIdx), n = t.getModelColumnOfViewPosition(e.modelLineWrappedLineIdx, i);
    return new V(e.modelLineNumber, n);
  }
  getViewLineInfosGroupedByModelRanges(e, t) {
    const i = this.getViewLineInfo(e), n = this.getViewLineInfo(t), o = new Array();
    let r = this.getModelStartPositionOfViewLine(i), a = new Array();
    for (let l = i.modelLineNumber; l <= n.modelLineNumber; l++) {
      const c = this.modelLineProjections[l - 1];
      if (c.isVisible()) {
        const h = l === i.modelLineNumber ? i.modelLineWrappedLineIdx : 0, d = l === n.modelLineNumber ? n.modelLineWrappedLineIdx + 1 : c.getViewLineCount();
        for (let u = h; u < d; u++)
          a.push(new RT(l, u));
      }
      if (!c.isVisible() && r) {
        const h = new V(l - 1, this.model.getLineMaxColumn(l - 1) + 1), d = R.fromPositions(r, h);
        o.push(new AT(d, a)), a = [], r = null;
      } else c.isVisible() && !r && (r = new V(l, 1));
    }
    if (r) {
      const l = R.fromPositions(r, this.getModelEndPositionOfViewLine(n));
      o.push(new AT(l, a));
    }
    return o;
  }
  // #endregion
  getViewLinesBracketGuides(e, t, i, n) {
    const o = i ? this.convertViewPositionToModelPosition(i.lineNumber, i.column) : null, r = [];
    for (const a of this.getViewLineInfosGroupedByModelRanges(e, t)) {
      const l = a.modelRange.startLineNumber, c = this.model.guides.getLinesBracketGuides(l, a.modelRange.endLineNumber, o, n);
      for (const h of a.viewLines) {
        const u = c[h.modelLineNumber - l].map((f) => {
          if (f.forWrappedLinesAfterColumn !== -1 && this.modelLineProjections[h.modelLineNumber - 1].getViewPositionOfModelPosition(0, f.forWrappedLinesAfterColumn).lineNumber >= h.modelLineWrappedLineIdx || f.forWrappedLinesBeforeOrAtColumn !== -1 && this.modelLineProjections[h.modelLineNumber - 1].getViewPositionOfModelPosition(0, f.forWrappedLinesBeforeOrAtColumn).lineNumber < h.modelLineWrappedLineIdx)
            return;
          if (!f.horizontalLine)
            return f;
          let g = -1;
          if (f.column !== -1) {
            const b = this.modelLineProjections[h.modelLineNumber - 1].getViewPositionOfModelPosition(0, f.column);
            if (b.lineNumber === h.modelLineWrappedLineIdx)
              g = b.column;
            else if (b.lineNumber < h.modelLineWrappedLineIdx)
              g = this.getMinColumnOfViewLine(h);
            else if (b.lineNumber > h.modelLineWrappedLineIdx)
              return;
          }
          const m = this.convertModelPositionToViewPosition(h.modelLineNumber, f.horizontalLine.endColumn), _ = this.modelLineProjections[h.modelLineNumber - 1].getViewPositionOfModelPosition(0, f.horizontalLine.endColumn);
          return _.lineNumber === h.modelLineWrappedLineIdx ? new Kl(f.visibleColumn, g, f.className, new Zu(f.horizontalLine.top, m.column), -1, -1) : _.lineNumber < h.modelLineWrappedLineIdx || f.visibleColumn !== -1 ? void 0 : new Kl(f.visibleColumn, g, f.className, new Zu(f.horizontalLine.top, this.getMaxColumnOfViewLine(h)), -1, -1);
        });
        r.push(u.filter((f) => !!f));
      }
    }
    return r;
  }
  getViewLinesIndentGuides(e, t) {
    e = this._toValidViewLineNumber(e), t = this._toValidViewLineNumber(t);
    const i = this.convertViewPositionToModelPosition(e, this.getViewLineMinColumn(e)), n = this.convertViewPositionToModelPosition(t, this.getViewLineMaxColumn(t));
    let o = [];
    const r = [], a = [], l = i.lineNumber - 1, c = n.lineNumber - 1;
    let h = null;
    for (let g = l; g <= c; g++) {
      const m = this.modelLineProjections[g];
      if (m.isVisible()) {
        const _ = m.getViewLineNumberOfModelPosition(0, g === l ? i.column : 1), b = m.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(g + 1)), C = b - _ + 1;
        let v = 0;
        C > 1 && m.getViewLineMinColumn(this.model, g + 1, b) === 1 && (v = _ === 0 ? 1 : 2), r.push(C), a.push(v), h === null && (h = new V(g + 1, 0));
      } else
        h !== null && (o = o.concat(this.model.guides.getLinesIndentGuides(h.lineNumber, g)), h = null);
    }
    h !== null && (o = o.concat(this.model.guides.getLinesIndentGuides(h.lineNumber, n.lineNumber)), h = null);
    const d = t - e + 1, u = new Array(d);
    let f = 0;
    for (let g = 0, m = o.length; g < m; g++) {
      let _ = o[g];
      const b = Math.min(d - f, r[g]), C = a[g];
      let v;
      C === 2 ? v = 0 : C === 1 ? v = 1 : v = b;
      for (let w = 0; w < b; w++)
        w === v && (_ = 0), u[f++] = _;
    }
    return u;
  }
  getViewLineContent(e) {
    const t = this.getViewLineInfo(e);
    return this.modelLineProjections[t.modelLineNumber - 1].getViewLineContent(this.model, t.modelLineNumber, t.modelLineWrappedLineIdx);
  }
  getViewLineLength(e) {
    const t = this.getViewLineInfo(e);
    return this.modelLineProjections[t.modelLineNumber - 1].getViewLineLength(this.model, t.modelLineNumber, t.modelLineWrappedLineIdx);
  }
  getViewLineMinColumn(e) {
    const t = this.getViewLineInfo(e);
    return this.modelLineProjections[t.modelLineNumber - 1].getViewLineMinColumn(this.model, t.modelLineNumber, t.modelLineWrappedLineIdx);
  }
  getViewLineMaxColumn(e) {
    const t = this.getViewLineInfo(e);
    return this.modelLineProjections[t.modelLineNumber - 1].getViewLineMaxColumn(this.model, t.modelLineNumber, t.modelLineWrappedLineIdx);
  }
  getViewLineData(e) {
    const t = this.getViewLineInfo(e);
    return this.modelLineProjections[t.modelLineNumber - 1].getViewLineData(this.model, t.modelLineNumber, t.modelLineWrappedLineIdx);
  }
  getViewLinesData(e, t, i) {
    e = this._toValidViewLineNumber(e), t = this._toValidViewLineNumber(t);
    const n = this.projectedModelLineLineCounts.getIndexOf(e - 1);
    let o = e;
    const r = n.index, a = n.remainder, l = [];
    for (let c = r, h = this.model.getLineCount(); c < h; c++) {
      const d = this.modelLineProjections[c];
      if (!d.isVisible())
        continue;
      const u = c === r ? a : 0;
      let f = d.getViewLineCount() - u, g = !1;
      if (o + f > t && (g = !0, f = t - o + 1), d.getViewLinesData(this.model, c + 1, u, f, o - e, i, l), o += f, g)
        break;
    }
    return l;
  }
  validateViewPosition(e, t, i) {
    e = this._toValidViewLineNumber(e);
    const n = this.projectedModelLineLineCounts.getIndexOf(e - 1), o = n.index, r = n.remainder, a = this.modelLineProjections[o], l = a.getViewLineMinColumn(this.model, o + 1, r), c = a.getViewLineMaxColumn(this.model, o + 1, r);
    t < l && (t = l), t > c && (t = c);
    const h = a.getModelColumnOfViewPosition(r, t);
    return this.model.validatePosition(new V(o + 1, h)).equals(i) ? new V(e, t) : this.convertModelPositionToViewPosition(i.lineNumber, i.column);
  }
  validateViewRange(e, t) {
    const i = this.validateViewPosition(e.startLineNumber, e.startColumn, t.getStartPosition()), n = this.validateViewPosition(e.endLineNumber, e.endColumn, t.getEndPosition());
    return new R(i.lineNumber, i.column, n.lineNumber, n.column);
  }
  convertViewPositionToModelPosition(e, t) {
    const i = this.getViewLineInfo(e), n = this.modelLineProjections[i.modelLineNumber - 1].getModelColumnOfViewPosition(i.modelLineWrappedLineIdx, t);
    return this.model.validatePosition(new V(i.modelLineNumber, n));
  }
  convertViewRangeToModelRange(e) {
    const t = this.convertViewPositionToModelPosition(e.startLineNumber, e.startColumn), i = this.convertViewPositionToModelPosition(e.endLineNumber, e.endColumn);
    return new R(t.lineNumber, t.column, i.lineNumber, i.column);
  }
  convertModelPositionToViewPosition(e, t, i = 2, n = !1, o = !1) {
    const r = this.model.validatePosition(new V(e, t)), a = r.lineNumber, l = r.column;
    let c = a - 1, h = !1;
    if (o)
      for (; c < this.modelLineProjections.length && !this.modelLineProjections[c].isVisible(); )
        c++, h = !0;
    else
      for (; c > 0 && !this.modelLineProjections[c].isVisible(); )
        c--, h = !0;
    if (c === 0 && !this.modelLineProjections[c].isVisible())
      return new V(n ? 0 : 1, 1);
    const d = 1 + this.projectedModelLineLineCounts.getPrefixSum(c);
    let u;
    return h ? o ? u = this.modelLineProjections[c].getViewPositionOfModelPosition(d, 1, i) : u = this.modelLineProjections[c].getViewPositionOfModelPosition(d, this.model.getLineMaxColumn(c + 1), i) : u = this.modelLineProjections[a - 1].getViewPositionOfModelPosition(d, l, i), u;
  }
  /**
   * @param affinity The affinity in case of an empty range. Has no effect for non-empty ranges.
  */
  convertModelRangeToViewRange(e, t = 0) {
    if (e.isEmpty()) {
      const i = this.convertModelPositionToViewPosition(e.startLineNumber, e.startColumn, t);
      return R.fromPositions(i);
    } else {
      const i = this.convertModelPositionToViewPosition(
        e.startLineNumber,
        e.startColumn,
        1
        /* PositionAffinity.Right */
      ), n = this.convertModelPositionToViewPosition(
        e.endLineNumber,
        e.endColumn,
        0
        /* PositionAffinity.Left */
      );
      return new R(i.lineNumber, i.column, n.lineNumber, n.column);
    }
  }
  getViewLineNumberOfModelPosition(e, t) {
    let i = e - 1;
    if (this.modelLineProjections[i].isVisible()) {
      const o = 1 + this.projectedModelLineLineCounts.getPrefixSum(i);
      return this.modelLineProjections[i].getViewLineNumberOfModelPosition(o, t);
    }
    for (; i > 0 && !this.modelLineProjections[i].isVisible(); )
      i--;
    if (i === 0 && !this.modelLineProjections[i].isVisible())
      return 1;
    const n = 1 + this.projectedModelLineLineCounts.getPrefixSum(i);
    return this.modelLineProjections[i].getViewLineNumberOfModelPosition(n, this.model.getLineMaxColumn(i + 1));
  }
  getDecorationsInRange(e, t, i, n, o) {
    const r = this.convertViewPositionToModelPosition(e.startLineNumber, e.startColumn), a = this.convertViewPositionToModelPosition(e.endLineNumber, e.endColumn);
    if (a.lineNumber - r.lineNumber <= e.endLineNumber - e.startLineNumber)
      return this.model.getDecorationsInRange(new R(r.lineNumber, 1, a.lineNumber, a.column), t, i, n, o);
    let l = [];
    const c = r.lineNumber - 1, h = a.lineNumber - 1;
    let d = null;
    for (let m = c; m <= h; m++)
      if (this.modelLineProjections[m].isVisible())
        d === null && (d = new V(m + 1, m === c ? r.column : 1));
      else if (d !== null) {
        const b = this.model.getLineMaxColumn(m);
        l = l.concat(this.model.getDecorationsInRange(new R(d.lineNumber, d.column, m, b), t, i, n)), d = null;
      }
    d !== null && (l = l.concat(this.model.getDecorationsInRange(new R(d.lineNumber, d.column, a.lineNumber, a.column), t, i, n)), d = null), l.sort((m, _) => {
      const b = R.compareRangesUsingStarts(m.range, _.range);
      return b === 0 ? m.id < _.id ? -1 : m.id > _.id ? 1 : 0 : b;
    });
    const u = [];
    let f = 0, g = null;
    for (const m of l) {
      const _ = m.id;
      g !== _ && (g = _, u[f++] = m);
    }
    return u;
  }
  getInjectedTextAt(e) {
    const t = this.getViewLineInfo(e.lineNumber);
    return this.modelLineProjections[t.modelLineNumber - 1].getInjectedTextAt(t.modelLineWrappedLineIdx, e.column);
  }
  normalizePosition(e, t) {
    const i = this.getViewLineInfo(e.lineNumber);
    return this.modelLineProjections[i.modelLineNumber - 1].normalizePosition(i.modelLineWrappedLineIdx, e, t);
  }
  getLineIndentColumn(e) {
    const t = this.getViewLineInfo(e);
    return t.modelLineWrappedLineIdx === 0 ? this.model.getLineIndentColumn(t.modelLineNumber) : 0;
  }
}
function cQ(s) {
  if (s.length === 0)
    return [];
  const e = s.slice();
  e.sort(R.compareRangesUsingStarts);
  const t = [];
  let i = e[0].startLineNumber, n = e[0].endLineNumber;
  for (let o = 1, r = e.length; o < r; o++) {
    const a = e[o];
    a.startLineNumber > n + 1 ? (t.push(new R(i, 1, n, 1)), i = a.startLineNumber, n = a.endLineNumber) : a.endLineNumber > n && (n = a.endLineNumber);
  }
  return t.push(new R(i, 1, n, 1)), t;
}
class RT {
  constructor(e, t) {
    this.modelLineNumber = e, this.modelLineWrappedLineIdx = t;
  }
}
class AT {
  constructor(e, t) {
    this.modelRange = e, this.viewLines = t;
  }
}
class hQ {
  constructor(e) {
    this._lines = e;
  }
  // View -> Model conversion and related methods
  convertViewPositionToModelPosition(e) {
    return this._lines.convertViewPositionToModelPosition(e.lineNumber, e.column);
  }
  convertViewRangeToModelRange(e) {
    return this._lines.convertViewRangeToModelRange(e);
  }
  validateViewPosition(e, t) {
    return this._lines.validateViewPosition(e.lineNumber, e.column, t);
  }
  validateViewRange(e, t) {
    return this._lines.validateViewRange(e, t);
  }
  // Model -> View conversion and related methods
  convertModelPositionToViewPosition(e, t, i, n) {
    return this._lines.convertModelPositionToViewPosition(e.lineNumber, e.column, t, i, n);
  }
  convertModelRangeToViewRange(e, t) {
    return this._lines.convertModelRangeToViewRange(e, t);
  }
  modelPositionIsVisible(e) {
    return this._lines.modelPositionIsVisible(e.lineNumber, e.column);
  }
  getModelLineViewLineCount(e) {
    return this._lines.getModelLineViewLineCount(e);
  }
  getViewLineNumberOfModelPosition(e, t) {
    return this._lines.getViewLineNumberOfModelPosition(e, t);
  }
}
class dQ {
  constructor(e) {
    this.model = e;
  }
  dispose() {
  }
  createCoordinatesConverter() {
    return new uQ(this);
  }
  getHiddenAreas() {
    return [];
  }
  setHiddenAreas(e) {
    return !1;
  }
  setTabSize(e) {
    return !1;
  }
  setWrappingSettings(e, t, i, n) {
    return !1;
  }
  createLineBreaksComputer() {
    const e = [];
    return {
      addRequest: (t, i, n) => {
        e.push(null);
      },
      finalize: () => e
    };
  }
  onModelFlushed() {
  }
  onModelLinesDeleted(e, t, i) {
    return new VS(t, i);
  }
  onModelLinesInserted(e, t, i, n) {
    return new HS(t, i);
  }
  onModelLineChanged(e, t, i) {
    return [!1, new u5(t, 1), null, null];
  }
  acceptVersionId(e) {
  }
  getViewLineCount() {
    return this.model.getLineCount();
  }
  getActiveIndentGuide(e, t, i) {
    return {
      startLineNumber: e,
      endLineNumber: e,
      indent: 0
    };
  }
  getViewLinesBracketGuides(e, t, i) {
    return new Array(t - e + 1).fill([]);
  }
  getViewLinesIndentGuides(e, t) {
    const i = t - e + 1, n = new Array(i);
    for (let o = 0; o < i; o++)
      n[o] = 0;
    return n;
  }
  getViewLineContent(e) {
    return this.model.getLineContent(e);
  }
  getViewLineLength(e) {
    return this.model.getLineLength(e);
  }
  getViewLineMinColumn(e) {
    return this.model.getLineMinColumn(e);
  }
  getViewLineMaxColumn(e) {
    return this.model.getLineMaxColumn(e);
  }
  getViewLineData(e) {
    const t = this.model.tokenization.getLineTokens(e), i = t.getLineContent();
    return new _x(i, !1, 1, i.length + 1, 0, t.inflate(), null);
  }
  getViewLinesData(e, t, i) {
    const n = this.model.getLineCount();
    e = Math.min(Math.max(1, e), n), t = Math.min(Math.max(1, t), n);
    const o = [];
    for (let r = e; r <= t; r++) {
      const a = r - e;
      o[a] = i[a] ? this.getViewLineData(r) : null;
    }
    return o;
  }
  getDecorationsInRange(e, t, i, n, o) {
    return this.model.getDecorationsInRange(e, t, i, n, o);
  }
  normalizePosition(e, t) {
    return this.model.normalizePosition(e, t);
  }
  getLineIndentColumn(e) {
    return this.model.getLineIndentColumn(e);
  }
  getInjectedTextAt(e) {
    return null;
  }
}
class uQ {
  constructor(e) {
    this._lines = e;
  }
  _validPosition(e) {
    return this._lines.model.validatePosition(e);
  }
  _validRange(e) {
    return this._lines.model.validateRange(e);
  }
  // View -> Model conversion and related methods
  convertViewPositionToModelPosition(e) {
    return this._validPosition(e);
  }
  convertViewRangeToModelRange(e) {
    return this._validRange(e);
  }
  validateViewPosition(e, t) {
    return this._validPosition(t);
  }
  validateViewRange(e, t) {
    return this._validRange(t);
  }
  // Model -> View conversion and related methods
  convertModelPositionToViewPosition(e) {
    return this._validPosition(e);
  }
  convertModelRangeToViewRange(e) {
    return this._validRange(e);
  }
  modelPositionIsVisible(e) {
    const t = this._lines.model.getLineCount();
    return !(e.lineNumber < 1 || e.lineNumber > t);
  }
  getModelLineViewLineCount(e) {
    return 1;
  }
  getViewLineNumberOfModelPosition(e, t) {
    return e;
  }
}
const fl = Ka.Right;
class fQ {
  constructor(e) {
    this.persist = 0, this._requiredLanes = 1, this.lanes = new Uint8Array(Math.ceil((e + 1) * fl / 8));
  }
  reset(e) {
    const t = Math.ceil((e + 1) * fl / 8);
    this.lanes.length < t ? this.lanes = new Uint8Array(t) : this.lanes.fill(0), this._requiredLanes = 1;
  }
  get requiredLanes() {
    return this._requiredLanes;
  }
  push(e, t, i) {
    i && (this.persist |= 1 << e - 1);
    for (let n = t.startLineNumber; n <= t.endLineNumber; n++) {
      const o = fl * n + (e - 1);
      this.lanes[o >>> 3] |= 1 << o % 8, this._requiredLanes = Math.max(this._requiredLanes, this.countAtLine(n));
    }
  }
  getLanesAtLine(e) {
    const t = [];
    let i = fl * e;
    for (let n = 0; n < fl; n++)
      (this.persist & 1 << n || this.lanes[i >>> 3] & 1 << i % 8) && t.push(n + 1), i++;
    return t.length ? t : [Ka.Center];
  }
  countAtLine(e) {
    let t = fl * e, i = 0;
    for (let n = 0; n < fl; n++)
      (this.persist & 1 << n || this.lanes[t >>> 3] & 1 << t % 8) && i++, t++;
    return i;
  }
}
let gQ = class extends q {
  constructor(e, t, i, n, o, r, a, l, c, h) {
    if (super(), this.languageConfigurationService = a, this._themeService = l, this._attachedView = c, this._transactionalTarget = h, this.hiddenAreasModel = new pQ(), this.previousHiddenAreas = [], this._editorId = e, this._configuration = t, this.model = i, this._eventDispatcher = new OY(), this.onEvent = this._eventDispatcher.onEvent, this.cursorConfig = new sh(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService), this._updateConfigurationViewLineCount = this._register(new sn(() => this._updateConfigurationViewLineCountNow(), 0)), this._hasFocus = !1, this._viewportStart = Ax.create(this.model), this.glyphLanes = new fQ(0), this.model.isTooLargeForTokenization())
      this._lines = new dQ(this.model);
    else {
      const d = this._configuration.options, u = d.get(
        50
        /* EditorOption.fontInfo */
      ), f = d.get(
        140
        /* EditorOption.wrappingStrategy */
      ), g = d.get(
        147
        /* EditorOption.wrappingInfo */
      ), m = d.get(
        139
        /* EditorOption.wrappingIndent */
      ), _ = d.get(
        130
        /* EditorOption.wordBreak */
      );
      this._lines = new lQ(this._editorId, this.model, n, o, u, this.model.getOptions().tabSize, f, g.wrappingColumn, m, _);
    }
    this.coordinatesConverter = this._lines.createCoordinatesConverter(), this._cursor = this._register(new jY(i, this, this.coordinatesConverter, this.cursorConfig)), this.viewLayout = this._register(new tQ(this._configuration, this.getLineCount(), r)), this._register(this.viewLayout.onDidScroll((d) => {
      d.scrollTopChanged && this._handleVisibleLinesChanged(), d.scrollTopChanged && this._viewportStart.invalidate(), this._eventDispatcher.emitSingleViewEvent(new TY(d)), this._eventDispatcher.emitOutgoingEvent(new Rx(d.oldScrollWidth, d.oldScrollLeft, d.oldScrollHeight, d.oldScrollTop, d.scrollWidth, d.scrollLeft, d.scrollHeight, d.scrollTop));
    })), this._register(this.viewLayout.onDidContentSizeChange((d) => {
      this._eventDispatcher.emitOutgoingEvent(d);
    })), this._decorations = new iQ(this._editorId, this.model, this._configuration, this._lines, this.coordinatesConverter), this._registerModelEvents(), this._register(this._configuration.onDidChangeFast((d) => {
      try {
        const u = this._eventDispatcher.beginEmitViewEvents();
        this._onConfigurationChanged(u, d);
      } finally {
        this._eventDispatcher.endEmitViewEvents();
      }
    })), this._register(z_.getInstance().onDidChange(() => {
      this._eventDispatcher.emitSingleViewEvent(new AY());
    })), this._register(this._themeService.onDidColorThemeChange((d) => {
      this._invalidateDecorationsColorCache(), this._eventDispatcher.emitSingleViewEvent(new MY(d));
    })), this._updateConfigurationViewLineCountNow();
  }
  dispose() {
    super.dispose(), this._decorations.dispose(), this._lines.dispose(), this._viewportStart.dispose(), this._eventDispatcher.dispose();
  }
  createLineBreaksComputer() {
    return this._lines.createLineBreaksComputer();
  }
  addViewEventHandler(e) {
    this._eventDispatcher.addViewEventHandler(e);
  }
  removeViewEventHandler(e) {
    this._eventDispatcher.removeViewEventHandler(e);
  }
  _updateConfigurationViewLineCountNow() {
    this._configuration.setViewLineCount(this._lines.getViewLineCount());
  }
  getModelVisibleRanges() {
    const e = this.viewLayout.getLinesViewportData(), t = new R(e.startLineNumber, this.getLineMinColumn(e.startLineNumber), e.endLineNumber, this.getLineMaxColumn(e.endLineNumber));
    return this._toModelVisibleRanges(t);
  }
  visibleLinesStabilized() {
    const e = this.getModelVisibleRanges();
    this._attachedView.setVisibleLines(e, !0);
  }
  _handleVisibleLinesChanged() {
    const e = this.getModelVisibleRanges();
    this._attachedView.setVisibleLines(e, !1);
  }
  setHasFocus(e) {
    this._hasFocus = e, this._cursor.setHasFocus(e), this._eventDispatcher.emitSingleViewEvent(new IY(e)), this._eventDispatcher.emitOutgoingEvent(new Mx(!e, e));
  }
  onCompositionStart() {
    this._eventDispatcher.emitSingleViewEvent(new kY());
  }
  onCompositionEnd() {
    this._eventDispatcher.emitSingleViewEvent(new xY());
  }
  _captureStableViewport() {
    if (this._viewportStart.isValid && this.viewLayout.getCurrentScrollTop() > 0) {
      const e = new V(this._viewportStart.viewLineNumber, this.getLineMinColumn(this._viewportStart.viewLineNumber)), t = this.coordinatesConverter.convertViewPositionToModelPosition(e);
      return new OT(t, this._viewportStart.startLineDelta);
    }
    return new OT(null, 0);
  }
  _onConfigurationChanged(e, t) {
    const i = this._captureStableViewport(), n = this._configuration.options, o = n.get(
      50
      /* EditorOption.fontInfo */
    ), r = n.get(
      140
      /* EditorOption.wrappingStrategy */
    ), a = n.get(
      147
      /* EditorOption.wrappingInfo */
    ), l = n.get(
      139
      /* EditorOption.wrappingIndent */
    ), c = n.get(
      130
      /* EditorOption.wordBreak */
    );
    this._lines.setWrappingSettings(o, r, a.wrappingColumn, l, c) && (e.emitViewEvent(new Fm()), e.emitViewEvent(new Bm()), e.emitViewEvent(new ul(null)), this._cursor.onLineMappingChanged(e), this._decorations.onLineMappingChanged(), this.viewLayout.onFlushed(this.getLineCount()), this._updateConfigurationViewLineCount.schedule()), t.hasChanged(
      92
      /* EditorOption.readOnly */
    ) && (this._decorations.reset(), e.emitViewEvent(new ul(null))), t.hasChanged(
      99
      /* EditorOption.renderValidationDecorations */
    ) && (this._decorations.reset(), e.emitViewEvent(new ul(null))), e.emitViewEvent(new DY(t)), this.viewLayout.onConfigurationChanged(t), i.recoverViewportStart(this.coordinatesConverter, this.viewLayout), sh.shouldRecreate(t) && (this.cursorConfig = new sh(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService), this._cursor.updateConfiguration(this.cursorConfig));
  }
  _registerModelEvents() {
    this._register(this.model.onDidChangeContentOrInjectedText((e) => {
      try {
        const i = this._eventDispatcher.beginEmitViewEvents();
        let n = !1, o = !1;
        const r = e instanceof ec ? e.rawContentChangedEvent.changes : e.changes, a = e instanceof ec ? e.rawContentChangedEvent.versionId : null, l = this._lines.createLineBreaksComputer();
        for (const d of r)
          switch (d.changeType) {
            case 4: {
              for (let u = 0; u < d.detail.length; u++) {
                const f = d.detail[u];
                let g = d.injectedTexts[u];
                g && (g = g.filter((m) => !m.ownerId || m.ownerId === this._editorId)), l.addRequest(f, g, null);
              }
              break;
            }
            case 2: {
              let u = null;
              d.injectedText && (u = d.injectedText.filter((f) => !f.ownerId || f.ownerId === this._editorId)), l.addRequest(d.detail, u, null);
              break;
            }
          }
        const c = l.finalize(), h = new Gr(c);
        for (const d of r)
          switch (d.changeType) {
            case 1: {
              this._lines.onModelFlushed(), i.emitViewEvent(new Fm()), this._decorations.reset(), this.viewLayout.onFlushed(this.getLineCount()), n = !0;
              break;
            }
            case 3: {
              const u = this._lines.onModelLinesDeleted(a, d.fromLineNumber, d.toLineNumber);
              u !== null && (i.emitViewEvent(u), this.viewLayout.onLinesDeleted(u.fromLineNumber, u.toLineNumber)), n = !0;
              break;
            }
            case 4: {
              const u = h.takeCount(d.detail.length), f = this._lines.onModelLinesInserted(a, d.fromLineNumber, d.toLineNumber, u);
              f !== null && (i.emitViewEvent(f), this.viewLayout.onLinesInserted(f.fromLineNumber, f.toLineNumber)), n = !0;
              break;
            }
            case 2: {
              const u = h.dequeue(), [f, g, m, _] = this._lines.onModelLineChanged(a, d.lineNumber, u);
              o = f, g && i.emitViewEvent(g), m && (i.emitViewEvent(m), this.viewLayout.onLinesInserted(m.fromLineNumber, m.toLineNumber)), _ && (i.emitViewEvent(_), this.viewLayout.onLinesDeleted(_.fromLineNumber, _.toLineNumber));
              break;
            }
            case 5:
              break;
          }
        a !== null && this._lines.acceptVersionId(a), this.viewLayout.onHeightMaybeChanged(), !n && o && (i.emitViewEvent(new Bm()), i.emitViewEvent(new ul(null)), this._cursor.onLineMappingChanged(i), this._decorations.onLineMappingChanged());
      } finally {
        this._eventDispatcher.endEmitViewEvents();
      }
      const t = this._viewportStart.isValid;
      if (this._viewportStart.invalidate(), this._configuration.setModelLineCount(this.model.getLineCount()), this._updateConfigurationViewLineCountNow(), !this._hasFocus && this.model.getAttachedEditorCount() >= 2 && t) {
        const i = this.model._getTrackedRange(this._viewportStart.modelTrackedRange);
        if (i) {
          const n = this.coordinatesConverter.convertModelPositionToViewPosition(i.getStartPosition()), o = this.viewLayout.getVerticalOffsetForLineNumber(n.lineNumber);
          this.viewLayout.setScrollPosition(
            { scrollTop: o + this._viewportStart.startLineDelta },
            1
            /* ScrollType.Immediate */
          );
        }
      }
      try {
        const i = this._eventDispatcher.beginEmitViewEvents();
        e instanceof ec && i.emitOutgoingEvent(new $Y(e.contentChangedEvent)), this._cursor.onModelContentChanged(i, e);
      } finally {
        this._eventDispatcher.endEmitViewEvents();
      }
      this._handleVisibleLinesChanged();
    })), this._register(this.model.onDidChangeTokens((e) => {
      const t = [];
      for (let i = 0, n = e.ranges.length; i < n; i++) {
        const o = e.ranges[i], r = this.coordinatesConverter.convertModelPositionToViewPosition(new V(o.fromLineNumber, 1)).lineNumber, a = this.coordinatesConverter.convertModelPositionToViewPosition(new V(o.toLineNumber, this.model.getLineMaxColumn(o.toLineNumber))).lineNumber;
        t[i] = {
          fromLineNumber: r,
          toLineNumber: a
        };
      }
      this._eventDispatcher.emitSingleViewEvent(new RY(t)), this._eventDispatcher.emitOutgoingEvent(new qY(e));
    })), this._register(this.model.onDidChangeLanguageConfiguration((e) => {
      this._eventDispatcher.emitSingleViewEvent(new NY()), this.cursorConfig = new sh(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService), this._cursor.updateConfiguration(this.cursorConfig), this._eventDispatcher.emitOutgoingEvent(new UY(e));
    })), this._register(this.model.onDidChangeLanguage((e) => {
      this.cursorConfig = new sh(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService), this._cursor.updateConfiguration(this.cursorConfig), this._eventDispatcher.emitOutgoingEvent(new zY(e));
    })), this._register(this.model.onDidChangeOptions((e) => {
      if (this._lines.setTabSize(this.model.getOptions().tabSize)) {
        try {
          const t = this._eventDispatcher.beginEmitViewEvents();
          t.emitViewEvent(new Fm()), t.emitViewEvent(new Bm()), t.emitViewEvent(new ul(null)), this._cursor.onLineMappingChanged(t), this._decorations.onLineMappingChanged(), this.viewLayout.onFlushed(this.getLineCount());
        } finally {
          this._eventDispatcher.endEmitViewEvents();
        }
        this._updateConfigurationViewLineCount.schedule();
      }
      this.cursorConfig = new sh(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService), this._cursor.updateConfiguration(this.cursorConfig), this._eventDispatcher.emitOutgoingEvent(new KY(e));
    })), this._register(this.model.onDidChangeDecorations((e) => {
      this._decorations.onModelDecorationsChanged(), this._eventDispatcher.emitSingleViewEvent(new ul(e)), this._eventDispatcher.emitOutgoingEvent(new HY(e));
    }));
  }
  setHiddenAreas(e, t) {
    var r;
    this.hiddenAreasModel.setHiddenAreas(t, e);
    const i = this.hiddenAreasModel.getMergedRanges();
    if (i === this.previousHiddenAreas)
      return;
    this.previousHiddenAreas = i;
    const n = this._captureStableViewport();
    let o = !1;
    try {
      const a = this._eventDispatcher.beginEmitViewEvents();
      o = this._lines.setHiddenAreas(i), o && (a.emitViewEvent(new Fm()), a.emitViewEvent(new Bm()), a.emitViewEvent(new ul(null)), this._cursor.onLineMappingChanged(a), this._decorations.onLineMappingChanged(), this.viewLayout.onFlushed(this.getLineCount()), this.viewLayout.onHeightMaybeChanged());
      const l = (r = n.viewportStartModelPosition) == null ? void 0 : r.lineNumber;
      l && i.some((h) => h.startLineNumber <= l && l <= h.endLineNumber) || n.recoverViewportStart(this.coordinatesConverter, this.viewLayout);
    } finally {
      this._eventDispatcher.endEmitViewEvents();
    }
    this._updateConfigurationViewLineCount.schedule(), o && this._eventDispatcher.emitOutgoingEvent(new WY());
  }
  getVisibleRangesPlusViewportAboveBelow() {
    const e = this._configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    ), t = this._configuration.options.get(
      67
      /* EditorOption.lineHeight */
    ), i = Math.max(20, Math.round(e.height / t)), n = this.viewLayout.getLinesViewportData(), o = Math.max(1, n.completelyVisibleStartLineNumber - i), r = Math.min(this.getLineCount(), n.completelyVisibleEndLineNumber + i);
    return this._toModelVisibleRanges(new R(o, this.getLineMinColumn(o), r, this.getLineMaxColumn(r)));
  }
  getVisibleRanges() {
    const e = this.getCompletelyVisibleViewRange();
    return this._toModelVisibleRanges(e);
  }
  getHiddenAreas() {
    return this._lines.getHiddenAreas();
  }
  _toModelVisibleRanges(e) {
    const t = this.coordinatesConverter.convertViewRangeToModelRange(e), i = this._lines.getHiddenAreas();
    if (i.length === 0)
      return [t];
    const n = [];
    let o = 0, r = t.startLineNumber, a = t.startColumn;
    const l = t.endLineNumber, c = t.endColumn;
    for (let h = 0, d = i.length; h < d; h++) {
      const u = i[h].startLineNumber, f = i[h].endLineNumber;
      f < r || u > l || (r < u && (n[o++] = new R(r, a, u - 1, this.model.getLineMaxColumn(u - 1))), r = f + 1, a = 1);
    }
    return (r < l || r === l && a < c) && (n[o++] = new R(r, a, l, c)), n;
  }
  getCompletelyVisibleViewRange() {
    const e = this.viewLayout.getLinesViewportData(), t = e.completelyVisibleStartLineNumber, i = e.completelyVisibleEndLineNumber;
    return new R(t, this.getLineMinColumn(t), i, this.getLineMaxColumn(i));
  }
  getCompletelyVisibleViewRangeAtScrollTop(e) {
    const t = this.viewLayout.getLinesViewportDataAtScrollTop(e), i = t.completelyVisibleStartLineNumber, n = t.completelyVisibleEndLineNumber;
    return new R(i, this.getLineMinColumn(i), n, this.getLineMaxColumn(n));
  }
  saveState() {
    const e = this.viewLayout.saveState(), t = e.scrollTop, i = this.viewLayout.getLineNumberAtVerticalOffset(t), n = this.coordinatesConverter.convertViewPositionToModelPosition(new V(i, this.getLineMinColumn(i))), o = this.viewLayout.getVerticalOffsetForLineNumber(i) - t;
    return {
      scrollLeft: e.scrollLeft,
      firstPosition: n,
      firstPositionDeltaTop: o
    };
  }
  reduceRestoreState(e) {
    if (typeof e.firstPosition > "u")
      return this._reduceRestoreStateCompatibility(e);
    const t = this.model.validatePosition(e.firstPosition), i = this.coordinatesConverter.convertModelPositionToViewPosition(t), n = this.viewLayout.getVerticalOffsetForLineNumber(i.lineNumber) - e.firstPositionDeltaTop;
    return {
      scrollLeft: e.scrollLeft,
      scrollTop: n
    };
  }
  _reduceRestoreStateCompatibility(e) {
    return {
      scrollLeft: e.scrollLeft,
      scrollTop: e.scrollTopWithoutViewZones
    };
  }
  getTabSize() {
    return this.model.getOptions().tabSize;
  }
  getLineCount() {
    return this._lines.getViewLineCount();
  }
  /**
   * Gives a hint that a lot of requests are about to come in for these line numbers.
   */
  setViewport(e, t, i) {
    this._viewportStart.update(this, e);
  }
  getActiveIndentGuide(e, t, i) {
    return this._lines.getActiveIndentGuide(e, t, i);
  }
  getLinesIndentGuides(e, t) {
    return this._lines.getViewLinesIndentGuides(e, t);
  }
  getBracketGuidesInRangeByLine(e, t, i, n) {
    return this._lines.getViewLinesBracketGuides(e, t, i, n);
  }
  getLineContent(e) {
    return this._lines.getViewLineContent(e);
  }
  getLineLength(e) {
    return this._lines.getViewLineLength(e);
  }
  getLineMinColumn(e) {
    return this._lines.getViewLineMinColumn(e);
  }
  getLineMaxColumn(e) {
    return this._lines.getViewLineMaxColumn(e);
  }
  getLineFirstNonWhitespaceColumn(e) {
    const t = On(this.getLineContent(e));
    return t === -1 ? 0 : t + 1;
  }
  getLineLastNonWhitespaceColumn(e) {
    const t = Ec(this.getLineContent(e));
    return t === -1 ? 0 : t + 2;
  }
  getMinimapDecorationsInRange(e) {
    return this._decorations.getMinimapDecorationsInRange(e);
  }
  getDecorationsInViewport(e) {
    return this._decorations.getDecorationsViewportData(e).decorations;
  }
  getInjectedTextAt(e) {
    return this._lines.getInjectedTextAt(e);
  }
  getViewportViewLineRenderingData(e, t) {
    const n = this._decorations.getDecorationsViewportData(e).inlineDecorations[t - e.startLineNumber];
    return this._getViewLineRenderingData(t, n);
  }
  getViewLineRenderingData(e) {
    const t = this._decorations.getInlineDecorationsOnLine(e);
    return this._getViewLineRenderingData(e, t);
  }
  _getViewLineRenderingData(e, t) {
    const i = this.model.mightContainRTL(), n = this.model.mightContainNonBasicASCII(), o = this.getTabSize(), r = this._lines.getViewLineData(e);
    return r.inlineDecorations && (t = [
      ...t,
      ...r.inlineDecorations.map((a) => a.toInlineDecoration(e))
    ]), new ns(r.minColumn, r.maxColumn, r.content, r.continuesWithWrappedLine, i, n, r.tokens, t, o, r.startVisibleColumn);
  }
  getViewLineData(e) {
    return this._lines.getViewLineData(e);
  }
  getMinimapLinesRenderingData(e, t, i) {
    const n = this._lines.getViewLinesData(e, t, i);
    return new Yj(this.getTabSize(), n);
  }
  getAllOverviewRulerDecorations(e) {
    const t = this.model.getOverviewRulerDecorations(this._editorId, wp(this._configuration.options)), i = new mQ();
    for (const n of t) {
      const o = n.options, r = o.overviewRuler;
      if (!r)
        continue;
      const a = r.position;
      if (a === 0)
        continue;
      const l = r.getColor(e.value), c = this.coordinatesConverter.getViewLineNumberOfModelPosition(n.range.startLineNumber, n.range.startColumn), h = this.coordinatesConverter.getViewLineNumberOfModelPosition(n.range.endLineNumber, n.range.endColumn);
      i.accept(l, o.zIndex, c, h, a);
    }
    return i.asArray;
  }
  _invalidateDecorationsColorCache() {
    const e = this.model.getOverviewRulerDecorations();
    for (const t of e) {
      const i = t.options.overviewRuler;
      i == null || i.invalidateCachedColor();
      const n = t.options.minimap;
      n == null || n.invalidateCachedColor();
    }
  }
  getValueInRange(e, t) {
    const i = this.coordinatesConverter.convertViewRangeToModelRange(e);
    return this.model.getValueInRange(i, t);
  }
  getValueLengthInRange(e, t) {
    const i = this.coordinatesConverter.convertViewRangeToModelRange(e);
    return this.model.getValueLengthInRange(i, t);
  }
  modifyPosition(e, t) {
    const i = this.coordinatesConverter.convertViewPositionToModelPosition(e), n = this.model.modifyPosition(i, t);
    return this.coordinatesConverter.convertModelPositionToViewPosition(n);
  }
  deduceModelPositionRelativeToViewPosition(e, t, i) {
    const n = this.coordinatesConverter.convertViewPositionToModelPosition(e);
    this.model.getEOL().length === 2 && (t < 0 ? t -= i : t += i);
    const r = this.model.getOffsetAt(n) + t;
    return this.model.getPositionAt(r);
  }
  getPlainTextToCopy(e, t, i) {
    const n = i ? `\r
` : this.model.getEOL();
    e = e.slice(0), e.sort(R.compareRangesUsingStarts);
    let o = !1, r = !1;
    for (const l of e)
      l.isEmpty() ? o = !0 : r = !0;
    if (!r) {
      if (!t)
        return "";
      const l = e.map((h) => h.startLineNumber);
      let c = "";
      for (let h = 0; h < l.length; h++)
        h > 0 && l[h - 1] === l[h] || (c += this.model.getLineContent(l[h]) + n);
      return c;
    }
    if (o && t) {
      const l = [];
      let c = 0;
      for (const h of e) {
        const d = h.startLineNumber;
        h.isEmpty() ? d !== c && l.push(this.model.getLineContent(d)) : l.push(this.model.getValueInRange(
          h,
          i ? 2 : 0
          /* EndOfLinePreference.TextDefined */
        )), c = d;
      }
      return l.length === 1 ? l[0] : l;
    }
    const a = [];
    for (const l of e)
      l.isEmpty() || a.push(this.model.getValueInRange(
        l,
        i ? 2 : 0
        /* EndOfLinePreference.TextDefined */
      ));
    return a.length === 1 ? a[0] : a;
  }
  getRichTextToCopy(e, t) {
    const i = this.model.getLanguageId();
    if (i === Ms || e.length !== 1)
      return null;
    let n = e[0];
    if (n.isEmpty()) {
      if (!t)
        return null;
      const h = n.startLineNumber;
      n = new R(h, this.model.getLineMinColumn(h), h, this.model.getLineMaxColumn(h));
    }
    const o = this._configuration.options.get(
      50
      /* EditorOption.fontInfo */
    ), r = this._getColorMap(), l = /[:;\\\/<>]/.test(o.fontFamily) || o.fontFamily === es.fontFamily;
    let c;
    return l ? c = es.fontFamily : (c = o.fontFamily, c = c.replace(/"/g, "'"), /[,']/.test(c) || /[+ ]/.test(c) && (c = `'${c}'`), c = `${c}, ${es.fontFamily}`), {
      mode: i,
      html: `<div style="color: ${r[
        1
        /* ColorId.DefaultForeground */
      ]};background-color: ${r[
        2
        /* ColorId.DefaultBackground */
      ]};font-family: ${c};font-weight: ${o.fontWeight};font-size: ${o.fontSize}px;line-height: ${o.lineHeight}px;white-space: pre;">` + this._getHTMLToCopy(n, r) + "</div>"
    };
  }
  _getHTMLToCopy(e, t) {
    const i = e.startLineNumber, n = e.startColumn, o = e.endLineNumber, r = e.endColumn, a = this.getTabSize();
    let l = "";
    for (let c = i; c <= o; c++) {
      const h = this.model.tokenization.getLineTokens(c), d = h.getLineContent(), u = c === i ? n - 1 : 0, f = c === o ? r - 1 : d.length;
      d === "" ? l += "<br>" : l += oV(d, h.inflate(), t, u, f, a, Fn);
    }
    return l;
  }
  _getColorMap() {
    const e = Yt.getColorMap(), t = ["#000000"];
    if (e)
      for (let i = 1, n = e.length; i < n; i++)
        t[i] = Z.Format.CSS.formatHex(e[i]);
    return t;
  }
  //#region cursor operations
  getPrimaryCursorState() {
    return this._cursor.getPrimaryCursorState();
  }
  getLastAddedCursorIndex() {
    return this._cursor.getLastAddedCursorIndex();
  }
  getCursorStates() {
    return this._cursor.getCursorStates();
  }
  setCursorStates(e, t, i) {
    return this._withViewEventsCollector((n) => this._cursor.setStates(n, e, t, i));
  }
  getCursorColumnSelectData() {
    return this._cursor.getCursorColumnSelectData();
  }
  getCursorAutoClosedCharacters() {
    return this._cursor.getAutoClosedCharacters();
  }
  setCursorColumnSelectData(e) {
    this._cursor.setCursorColumnSelectData(e);
  }
  getPrevEditOperationType() {
    return this._cursor.getPrevEditOperationType();
  }
  setPrevEditOperationType(e) {
    this._cursor.setPrevEditOperationType(e);
  }
  getSelection() {
    return this._cursor.getSelection();
  }
  getSelections() {
    return this._cursor.getSelections();
  }
  getPosition() {
    return this._cursor.getPrimaryCursorState().modelState.position;
  }
  setSelections(e, t, i = 0) {
    this._withViewEventsCollector((n) => this._cursor.setSelections(n, e, t, i));
  }
  saveCursorState() {
    return this._cursor.saveState();
  }
  restoreCursorState(e) {
    this._withViewEventsCollector((t) => this._cursor.restoreState(t, e));
  }
  _executeCursorEdit(e) {
    if (this._cursor.context.cursorConfig.readOnly) {
      this._eventDispatcher.emitOutgoingEvent(new VY());
      return;
    }
    this._withViewEventsCollector(e);
  }
  executeEdits(e, t, i) {
    this._executeCursorEdit((n) => this._cursor.executeEdits(n, e, t, i));
  }
  startComposition() {
    this._executeCursorEdit((e) => this._cursor.startComposition(e));
  }
  endComposition(e) {
    this._executeCursorEdit((t) => this._cursor.endComposition(t, e));
  }
  type(e, t) {
    this._executeCursorEdit((i) => this._cursor.type(i, e, t));
  }
  compositionType(e, t, i, n, o) {
    this._executeCursorEdit((r) => this._cursor.compositionType(r, e, t, i, n, o));
  }
  paste(e, t, i, n) {
    this._executeCursorEdit((o) => this._cursor.paste(o, e, t, i, n));
  }
  cut(e) {
    this._executeCursorEdit((t) => this._cursor.cut(t, e));
  }
  executeCommand(e, t) {
    this._executeCursorEdit((i) => this._cursor.executeCommand(i, e, t));
  }
  executeCommands(e, t) {
    this._executeCursorEdit((i) => this._cursor.executeCommands(i, e, t));
  }
  revealAllCursors(e, t, i = !1) {
    this._withViewEventsCollector((n) => this._cursor.revealAll(
      n,
      e,
      i,
      0,
      t,
      0
      /* ScrollType.Smooth */
    ));
  }
  revealPrimaryCursor(e, t, i = !1) {
    this._withViewEventsCollector((n) => this._cursor.revealPrimary(
      n,
      e,
      i,
      0,
      t,
      0
      /* ScrollType.Smooth */
    ));
  }
  revealTopMostCursor(e) {
    const t = this._cursor.getTopMostViewPosition(), i = new R(t.lineNumber, t.column, t.lineNumber, t.column);
    this._withViewEventsCollector((n) => n.emitViewEvent(new uf(
      e,
      !1,
      i,
      null,
      0,
      !0,
      0
      /* ScrollType.Smooth */
    )));
  }
  revealBottomMostCursor(e) {
    const t = this._cursor.getBottomMostViewPosition(), i = new R(t.lineNumber, t.column, t.lineNumber, t.column);
    this._withViewEventsCollector((n) => n.emitViewEvent(new uf(
      e,
      !1,
      i,
      null,
      0,
      !0,
      0
      /* ScrollType.Smooth */
    )));
  }
  revealRange(e, t, i, n, o) {
    this._withViewEventsCollector((r) => r.emitViewEvent(new uf(e, !1, i, null, n, t, o)));
  }
  //#endregion
  //#region viewLayout
  changeWhitespace(e) {
    this.viewLayout.changeWhitespace(e) && (this._eventDispatcher.emitSingleViewEvent(new PY()), this._eventDispatcher.emitOutgoingEvent(new BY()));
  }
  //#endregion
  _withViewEventsCollector(e) {
    return this._transactionalTarget.batchChanges(() => {
      try {
        const t = this._eventDispatcher.beginEmitViewEvents();
        return e(t);
      } finally {
        this._eventDispatcher.endEmitViewEvents();
      }
    });
  }
  batchEvents(e) {
    this._withViewEventsCollector(() => {
      e();
    });
  }
  normalizePosition(e, t) {
    return this._lines.normalizePosition(e, t);
  }
  /**
   * Gets the column at which indentation stops at a given line.
   * @internal
  */
  getLineIndentColumn(e) {
    return this._lines.getLineIndentColumn(e);
  }
};
class Ax {
  static create(e) {
    const t = e._setTrackedRange(
      null,
      new R(1, 1, 1, 1),
      1
      /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
    );
    return new Ax(e, 1, !1, t, 0);
  }
  get viewLineNumber() {
    return this._viewLineNumber;
  }
  get isValid() {
    return this._isValid;
  }
  get modelTrackedRange() {
    return this._modelTrackedRange;
  }
  get startLineDelta() {
    return this._startLineDelta;
  }
  constructor(e, t, i, n, o) {
    this._model = e, this._viewLineNumber = t, this._isValid = i, this._modelTrackedRange = n, this._startLineDelta = o;
  }
  dispose() {
    this._model._setTrackedRange(
      this._modelTrackedRange,
      null,
      1
      /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
    );
  }
  update(e, t) {
    const i = e.coordinatesConverter.convertViewPositionToModelPosition(new V(t, e.getLineMinColumn(t))), n = e.model._setTrackedRange(
      this._modelTrackedRange,
      new R(i.lineNumber, i.column, i.lineNumber, i.column),
      1
      /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
    ), o = e.viewLayout.getVerticalOffsetForLineNumber(t), r = e.viewLayout.getCurrentScrollTop();
    this._viewLineNumber = t, this._isValid = !0, this._modelTrackedRange = n, this._startLineDelta = r - o;
  }
  invalidate() {
    this._isValid = !1;
  }
}
class mQ {
  constructor() {
    this._asMap = /* @__PURE__ */ Object.create(null), this.asArray = [];
  }
  accept(e, t, i, n, o) {
    const r = this._asMap[e];
    if (r) {
      const a = r.data, l = a[a.length - 3], c = a[a.length - 1];
      if (l === o && c + 1 >= i) {
        n > c && (a[a.length - 1] = n);
        return;
      }
      a.push(o, i, n);
    } else {
      const a = new lg(e, t, [o, i, n]);
      this._asMap[e] = a, this.asArray.push(a);
    }
  }
}
class pQ {
  constructor() {
    this.hiddenAreas = /* @__PURE__ */ new Map(), this.shouldRecompute = !1, this.ranges = [];
  }
  setHiddenAreas(e, t) {
    const i = this.hiddenAreas.get(e);
    i && PT(i, t) || (this.hiddenAreas.set(e, t), this.shouldRecompute = !0);
  }
  /**
   * The returned array is immutable.
  */
  getMergedRanges() {
    if (!this.shouldRecompute)
      return this.ranges;
    this.shouldRecompute = !1;
    const e = Array.from(this.hiddenAreas.values()).reduce((t, i) => _Q(t, i), []);
    return PT(this.ranges, e) ? this.ranges : (this.ranges = e, this.ranges);
  }
}
function _Q(s, e) {
  const t = [];
  let i = 0, n = 0;
  for (; i < s.length && n < e.length; ) {
    const o = s[i], r = e[n];
    if (o.endLineNumber < r.startLineNumber - 1)
      t.push(s[i++]);
    else if (r.endLineNumber < o.startLineNumber - 1)
      t.push(e[n++]);
    else {
      const a = Math.min(o.startLineNumber, r.startLineNumber), l = Math.max(o.endLineNumber, r.endLineNumber);
      t.push(new R(a, 1, l, 1)), i++, n++;
    }
  }
  for (; i < s.length; )
    t.push(s[i++]);
  for (; n < e.length; )
    t.push(e[n++]);
  return t;
}
function PT(s, e) {
  if (s.length !== e.length)
    return !1;
  for (let t = 0; t < s.length; t++)
    if (!s[t].equalsRange(e[t]))
      return !1;
  return !0;
}
class OT {
  constructor(e, t) {
    this.viewportStartModelPosition = e, this.startLineDelta = t;
  }
  recoverViewportStart(e, t) {
    if (!this.viewportStartModelPosition)
      return;
    const i = e.convertModelPositionToViewPosition(this.viewportStartModelPosition), n = t.getVerticalOffsetForLineNumber(i.lineNumber);
    t.setScrollPosition(
      { scrollTop: n + this.startLineDelta },
      1
      /* ScrollType.Immediate */
    );
  }
}
var bQ = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, rr = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, wl, cc;
let G_ = (cc = class extends q {
  //#endregion
  get isSimpleWidget() {
    return this._configuration.isSimpleWidget;
  }
  get contextMenuId() {
    return this._configuration.contextMenuId;
  }
  constructor(e, t, i, n, o, r, a, l, c, h, d, u) {
    super(), this.languageConfigurationService = d, this._deliveryQueue = hO(), this._contributions = this._register(new vY()), this._onDidDispose = this._register(new O()), this.onDidDispose = this._onDidDispose.event, this._onDidChangeModelContent = this._register(new O({ deliveryQueue: this._deliveryQueue })), this.onDidChangeModelContent = this._onDidChangeModelContent.event, this._onDidChangeModelLanguage = this._register(new O({ deliveryQueue: this._deliveryQueue })), this.onDidChangeModelLanguage = this._onDidChangeModelLanguage.event, this._onDidChangeModelLanguageConfiguration = this._register(new O({ deliveryQueue: this._deliveryQueue })), this.onDidChangeModelLanguageConfiguration = this._onDidChangeModelLanguageConfiguration.event, this._onDidChangeModelOptions = this._register(new O({ deliveryQueue: this._deliveryQueue })), this.onDidChangeModelOptions = this._onDidChangeModelOptions.event, this._onDidChangeModelDecorations = this._register(new O({ deliveryQueue: this._deliveryQueue })), this.onDidChangeModelDecorations = this._onDidChangeModelDecorations.event, this._onDidChangeModelTokens = this._register(new O({ deliveryQueue: this._deliveryQueue })), this.onDidChangeModelTokens = this._onDidChangeModelTokens.event, this._onDidChangeConfiguration = this._register(new O({ deliveryQueue: this._deliveryQueue })), this.onDidChangeConfiguration = this._onDidChangeConfiguration.event, this._onWillChangeModel = this._register(new O({ deliveryQueue: this._deliveryQueue })), this.onWillChangeModel = this._onWillChangeModel.event, this._onDidChangeModel = this._register(new O({ deliveryQueue: this._deliveryQueue })), this.onDidChangeModel = this._onDidChangeModel.event, this._onDidChangeCursorPosition = this._register(new O({ deliveryQueue: this._deliveryQueue })), this.onDidChangeCursorPosition = this._onDidChangeCursorPosition.event, this._onDidChangeCursorSelection = this._register(new O({ deliveryQueue: this._deliveryQueue })), this.onDidChangeCursorSelection = this._onDidChangeCursorSelection.event, this._onDidAttemptReadOnlyEdit = this._register(new Hi(this._contributions, this._deliveryQueue)), this.onDidAttemptReadOnlyEdit = this._onDidAttemptReadOnlyEdit.event, this._onDidLayoutChange = this._register(new O({ deliveryQueue: this._deliveryQueue })), this.onDidLayoutChange = this._onDidLayoutChange.event, this._editorTextFocus = this._register(new FT({ deliveryQueue: this._deliveryQueue })), this.onDidFocusEditorText = this._editorTextFocus.onDidChangeToTrue, this.onDidBlurEditorText = this._editorTextFocus.onDidChangeToFalse, this._editorWidgetFocus = this._register(new FT({ deliveryQueue: this._deliveryQueue })), this.onDidFocusEditorWidget = this._editorWidgetFocus.onDidChangeToTrue, this.onDidBlurEditorWidget = this._editorWidgetFocus.onDidChangeToFalse, this._onWillType = this._register(new Hi(this._contributions, this._deliveryQueue)), this.onWillType = this._onWillType.event, this._onDidType = this._register(new Hi(this._contributions, this._deliveryQueue)), this.onDidType = this._onDidType.event, this._onDidCompositionStart = this._register(new Hi(this._contributions, this._deliveryQueue)), this.onDidCompositionStart = this._onDidCompositionStart.event, this._onDidCompositionEnd = this._register(new Hi(this._contributions, this._deliveryQueue)), this.onDidCompositionEnd = this._onDidCompositionEnd.event, this._onDidPaste = this._register(new Hi(this._contributions, this._deliveryQueue)), this.onDidPaste = this._onDidPaste.event, this._onMouseUp = this._register(new Hi(this._contributions, this._deliveryQueue)), this.onMouseUp = this._onMouseUp.event, this._onMouseDown = this._register(new Hi(this._contributions, this._deliveryQueue)), this.onMouseDown = this._onMouseDown.event, this._onMouseDrag = this._register(new Hi(this._contributions, this._deliveryQueue)), this.onMouseDrag = this._onMouseDrag.event, this._onMouseDrop = this._register(new Hi(this._contributions, this._deliveryQueue)), this.onMouseDrop = this._onMouseDrop.event, this._onMouseDropCanceled = this._register(new Hi(this._contributions, this._deliveryQueue)), this.onMouseDropCanceled = this._onMouseDropCanceled.event, this._onDropIntoEditor = this._register(new Hi(this._contributions, this._deliveryQueue)), this.onDropIntoEditor = this._onDropIntoEditor.event, this._onContextMenu = this._register(new Hi(this._contributions, this._deliveryQueue)), this.onContextMenu = this._onContextMenu.event, this._onMouseMove = this._register(new Hi(this._contributions, this._deliveryQueue)), this.onMouseMove = this._onMouseMove.event, this._onMouseLeave = this._register(new Hi(this._contributions, this._deliveryQueue)), this.onMouseLeave = this._onMouseLeave.event, this._onMouseWheel = this._register(new Hi(this._contributions, this._deliveryQueue)), this.onMouseWheel = this._onMouseWheel.event, this._onKeyUp = this._register(new Hi(this._contributions, this._deliveryQueue)), this.onKeyUp = this._onKeyUp.event, this._onKeyDown = this._register(new Hi(this._contributions, this._deliveryQueue)), this.onKeyDown = this._onKeyDown.event, this._onDidContentSizeChange = this._register(new O({ deliveryQueue: this._deliveryQueue })), this.onDidContentSizeChange = this._onDidContentSizeChange.event, this._onDidScrollChange = this._register(new O({ deliveryQueue: this._deliveryQueue })), this.onDidScrollChange = this._onDidScrollChange.event, this._onDidChangeViewZones = this._register(new O({ deliveryQueue: this._deliveryQueue })), this.onDidChangeViewZones = this._onDidChangeViewZones.event, this._onDidChangeHiddenAreas = this._register(new O({ deliveryQueue: this._deliveryQueue })), this.onDidChangeHiddenAreas = this._onDidChangeHiddenAreas.event, this._updateCounter = 0, this._onBeginUpdate = this._register(new O()), this.onBeginUpdate = this._onBeginUpdate.event, this._onEndUpdate = this._register(new O()), this.onEndUpdate = this._onEndUpdate.event, this._actions = /* @__PURE__ */ new Map(), this._bannerDomNode = null, this._dropIntoEditorDecorations = this.createDecorationsCollection(), o.willCreateCodeEditor();
    const f = { ...t };
    this._domElement = e, this._overflowWidgetsDomNode = f.overflowWidgetsDomNode, delete f.overflowWidgetsDomNode, this._id = ++CQ, this._decorationTypeKeysToIds = {}, this._decorationTypeSubtypes = {}, this._telemetryData = i.telemetryData, this._configuration = this._register(this._createConfiguration(i.isSimpleWidget || !1, i.contextMenuId ?? (i.isSimpleWidget ? Ti.SimpleEditorContext : Ti.EditorContext), f, h)), this._register(this._configuration.onDidChange((_) => {
      this._onDidChangeConfiguration.fire(_);
      const b = this._configuration.options;
      if (_.hasChanged(
        146
        /* EditorOption.layoutInfo */
      )) {
        const C = b.get(
          146
          /* EditorOption.layoutInfo */
        );
        this._onDidLayoutChange.fire(C);
      }
    })), this._contextKeyService = this._register(a.createScoped(this._domElement)), this._notificationService = c, this._codeEditorService = o, this._commandService = r, this._themeService = l, this._register(new vQ(this, this._contextKeyService)), this._register(new yQ(this, this._contextKeyService, u)), this._instantiationService = this._register(n.createChild(new jd([nt, this._contextKeyService]))), this._modelData = null, this._focusTracker = new SQ(e, this._overflowWidgetsDomNode), this._register(this._focusTracker.onChange(() => {
      this._editorWidgetFocus.setValue(this._focusTracker.hasFocus());
    })), this._contentWidgets = {}, this._overlayWidgets = {}, this._glyphMarginWidgets = {};
    let g;
    Array.isArray(i.contributions) ? g = i.contributions : g = Kh.getEditorContributions(), this._contributions.initialize(this, g, this._instantiationService);
    for (const _ of Kh.getEditorActions()) {
      if (this._actions.has(_.id)) {
        ht(new Error(`Cannot have two actions with the same id ${_.id}`));
        continue;
      }
      const b = new h5(_.id, _.label, _.alias, _.metadata, _.precondition ?? void 0, (C) => this._instantiationService.invokeFunction((v) => Promise.resolve(_.runEditorCommand(v, this, C))), this._contextKeyService);
      this._actions.set(b.id, b);
    }
    const m = () => !this._configuration.options.get(
      92
      /* EditorOption.readOnly */
    ) && this._configuration.options.get(
      36
      /* EditorOption.dropIntoEditor */
    ).enabled;
    this._register(new p7(this._domElement, {
      onDragOver: (_) => {
        if (!m())
          return;
        const b = this.getTargetAtClientPoint(_.clientX, _.clientY);
        b != null && b.position && this.showDropIndicatorAt(b.position);
      },
      onDrop: async (_) => {
        if (!m() || (this.removeDropIndicator(), !_.dataTransfer))
          return;
        const b = this.getTargetAtClientPoint(_.clientX, _.clientY);
        b != null && b.position && this._onDropIntoEditor.fire({ position: b.position, event: _ });
      },
      onDragLeave: () => {
        this.removeDropIndicator();
      },
      onDragEnd: () => {
        this.removeDropIndicator();
      }
    })), this._codeEditorService.addCodeEditor(this);
  }
  writeScreenReaderContent(e) {
    var t;
    (t = this._modelData) == null || t.view.writeScreenReaderContent(e);
  }
  _createConfiguration(e, t, i, n) {
    return new yS(e, t, i, this._domElement, n);
  }
  getId() {
    return this.getEditorType() + ":" + this._id;
  }
  getEditorType() {
    return mx.ICodeEditor;
  }
  dispose() {
    this._codeEditorService.removeCodeEditor(this), this._focusTracker.dispose(), this._actions.clear(), this._contentWidgets = {}, this._overlayWidgets = {}, this._removeDecorationTypes(), this._postDetachModelCleanup(this._detachModel()), this._onDidDispose.fire(), super.dispose();
  }
  invokeWithinContext(e) {
    return this._instantiationService.invokeFunction(e);
  }
  updateOptions(e) {
    this._configuration.updateOptions(e || {});
  }
  getOptions() {
    return this._configuration.options;
  }
  getOption(e) {
    return this._configuration.options.get(e);
  }
  getRawOptions() {
    return this._configuration.getRawOptions();
  }
  getOverflowWidgetsDomNode() {
    return this._overflowWidgetsDomNode;
  }
  getConfiguredWordAtPosition(e) {
    return this._modelData ? Ut.getWordAtPosition(this._modelData.model, this._configuration.options.get(
      132
      /* EditorOption.wordSeparators */
    ), this._configuration.options.get(
      131
      /* EditorOption.wordSegmenterLocales */
    ), e) : null;
  }
  getValue(e = null) {
    if (!this._modelData)
      return "";
    const t = !!(e && e.preserveBOM);
    let i = 0;
    return e && e.lineEnding && e.lineEnding === `
` ? i = 1 : e && e.lineEnding && e.lineEnding === `\r
` && (i = 2), this._modelData.model.getValue(i, t);
  }
  setValue(e) {
    try {
      if (this._beginUpdate(), !this._modelData)
        return;
      this._modelData.model.setValue(e);
    } finally {
      this._endUpdate();
    }
  }
  getModel() {
    return this._modelData ? this._modelData.model : null;
  }
  setModel(e = null) {
    var t;
    try {
      this._beginUpdate();
      const i = e;
      if (this._modelData === null && i === null || this._modelData && this._modelData.model === i)
        return;
      const n = {
        oldModelUrl: ((t = this._modelData) == null ? void 0 : t.model.uri) || null,
        newModelUrl: (i == null ? void 0 : i.uri) || null
      };
      this._onWillChangeModel.fire(n);
      const o = this.hasTextFocus(), r = this._detachModel();
      this._attachModel(i), o && this.hasModel() && this.focus(), this._removeDecorationTypes(), this._onDidChangeModel.fire(n), this._postDetachModelCleanup(r), this._contributionsDisposable = this._contributions.onAfterModelAttached();
    } finally {
      this._endUpdate();
    }
  }
  _removeDecorationTypes() {
    if (this._decorationTypeKeysToIds = {}, this._decorationTypeSubtypes) {
      for (const e in this._decorationTypeSubtypes) {
        const t = this._decorationTypeSubtypes[e];
        for (const i in t)
          this._removeDecorationType(e + "-" + i);
      }
      this._decorationTypeSubtypes = {};
    }
  }
  getVisibleRanges() {
    return this._modelData ? this._modelData.viewModel.getVisibleRanges() : [];
  }
  getVisibleRangesPlusViewportAboveBelow() {
    return this._modelData ? this._modelData.viewModel.getVisibleRangesPlusViewportAboveBelow() : [];
  }
  getWhitespaces() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getWhitespaces() : [];
  }
  static _getVerticalOffsetAfterPosition(e, t, i, n) {
    const o = e.model.validatePosition({
      lineNumber: t,
      column: i
    }), r = e.viewModel.coordinatesConverter.convertModelPositionToViewPosition(o);
    return e.viewModel.viewLayout.getVerticalOffsetAfterLineNumber(r.lineNumber, n);
  }
  getTopForLineNumber(e, t = !1) {
    return this._modelData ? wl._getVerticalOffsetForPosition(this._modelData, e, 1, t) : -1;
  }
  getTopForPosition(e, t) {
    return this._modelData ? wl._getVerticalOffsetForPosition(this._modelData, e, t, !1) : -1;
  }
  static _getVerticalOffsetForPosition(e, t, i, n = !1) {
    const o = e.model.validatePosition({
      lineNumber: t,
      column: i
    }), r = e.viewModel.coordinatesConverter.convertModelPositionToViewPosition(o);
    return e.viewModel.viewLayout.getVerticalOffsetForLineNumber(r.lineNumber, n);
  }
  getBottomForLineNumber(e, t = !1) {
    if (!this._modelData)
      return -1;
    const i = this._modelData.model.getLineMaxColumn(e);
    return wl._getVerticalOffsetAfterPosition(this._modelData, e, i, t);
  }
  setHiddenAreas(e, t) {
    var i;
    (i = this._modelData) == null || i.viewModel.setHiddenAreas(e.map((n) => R.lift(n)), t);
  }
  getVisibleColumnFromPosition(e) {
    if (!this._modelData)
      return e.column;
    const t = this._modelData.model.validatePosition(e), i = this._modelData.model.getOptions().tabSize;
    return ii.visibleColumnFromColumn(this._modelData.model.getLineContent(t.lineNumber), t.column, i) + 1;
  }
  getPosition() {
    return this._modelData ? this._modelData.viewModel.getPosition() : null;
  }
  setPosition(e, t = "api") {
    if (this._modelData) {
      if (!V.isIPosition(e))
        throw new Error("Invalid arguments");
      this._modelData.viewModel.setSelections(t, [{
        selectionStartLineNumber: e.lineNumber,
        selectionStartColumn: e.column,
        positionLineNumber: e.lineNumber,
        positionColumn: e.column
      }]);
    }
  }
  _sendRevealRange(e, t, i, n) {
    if (!this._modelData)
      return;
    if (!R.isIRange(e))
      throw new Error("Invalid arguments");
    const o = this._modelData.model.validateRange(e), r = this._modelData.viewModel.coordinatesConverter.convertModelRangeToViewRange(o);
    this._modelData.viewModel.revealRange("api", i, r, t, n);
  }
  revealLine(e, t = 0) {
    this._revealLine(e, 0, t);
  }
  revealLineInCenter(e, t = 0) {
    this._revealLine(e, 1, t);
  }
  revealLineInCenterIfOutsideViewport(e, t = 0) {
    this._revealLine(e, 2, t);
  }
  revealLineNearTop(e, t = 0) {
    this._revealLine(e, 5, t);
  }
  _revealLine(e, t, i) {
    if (typeof e != "number")
      throw new Error("Invalid arguments");
    this._sendRevealRange(new R(e, 1, e, 1), t, !1, i);
  }
  revealPosition(e, t = 0) {
    this._revealPosition(e, 0, !0, t);
  }
  revealPositionInCenter(e, t = 0) {
    this._revealPosition(e, 1, !0, t);
  }
  revealPositionInCenterIfOutsideViewport(e, t = 0) {
    this._revealPosition(e, 2, !0, t);
  }
  revealPositionNearTop(e, t = 0) {
    this._revealPosition(e, 5, !0, t);
  }
  _revealPosition(e, t, i, n) {
    if (!V.isIPosition(e))
      throw new Error("Invalid arguments");
    this._sendRevealRange(new R(e.lineNumber, e.column, e.lineNumber, e.column), t, i, n);
  }
  getSelection() {
    return this._modelData ? this._modelData.viewModel.getSelection() : null;
  }
  getSelections() {
    return this._modelData ? this._modelData.viewModel.getSelections() : null;
  }
  setSelection(e, t = "api") {
    const i = ft.isISelection(e), n = R.isIRange(e);
    if (!i && !n)
      throw new Error("Invalid arguments");
    if (i)
      this._setSelectionImpl(e, t);
    else if (n) {
      const o = {
        selectionStartLineNumber: e.startLineNumber,
        selectionStartColumn: e.startColumn,
        positionLineNumber: e.endLineNumber,
        positionColumn: e.endColumn
      };
      this._setSelectionImpl(o, t);
    }
  }
  _setSelectionImpl(e, t) {
    if (!this._modelData)
      return;
    const i = new ft(e.selectionStartLineNumber, e.selectionStartColumn, e.positionLineNumber, e.positionColumn);
    this._modelData.viewModel.setSelections(t, [i]);
  }
  revealLines(e, t, i = 0) {
    this._revealLines(e, t, 0, i);
  }
  revealLinesInCenter(e, t, i = 0) {
    this._revealLines(e, t, 1, i);
  }
  revealLinesInCenterIfOutsideViewport(e, t, i = 0) {
    this._revealLines(e, t, 2, i);
  }
  revealLinesNearTop(e, t, i = 0) {
    this._revealLines(e, t, 5, i);
  }
  _revealLines(e, t, i, n) {
    if (typeof e != "number" || typeof t != "number")
      throw new Error("Invalid arguments");
    this._sendRevealRange(new R(e, 1, t, 1), i, !1, n);
  }
  revealRange(e, t = 0, i = !1, n = !0) {
    this._revealRange(e, i ? 1 : 0, n, t);
  }
  revealRangeInCenter(e, t = 0) {
    this._revealRange(e, 1, !0, t);
  }
  revealRangeInCenterIfOutsideViewport(e, t = 0) {
    this._revealRange(e, 2, !0, t);
  }
  revealRangeNearTop(e, t = 0) {
    this._revealRange(e, 5, !0, t);
  }
  revealRangeNearTopIfOutsideViewport(e, t = 0) {
    this._revealRange(e, 6, !0, t);
  }
  revealRangeAtTop(e, t = 0) {
    this._revealRange(e, 3, !0, t);
  }
  _revealRange(e, t, i, n) {
    if (!R.isIRange(e))
      throw new Error("Invalid arguments");
    this._sendRevealRange(R.lift(e), t, i, n);
  }
  setSelections(e, t = "api", i = 0) {
    if (this._modelData) {
      if (!e || e.length === 0)
        throw new Error("Invalid arguments");
      for (let n = 0, o = e.length; n < o; n++)
        if (!ft.isISelection(e[n]))
          throw new Error("Invalid arguments");
      this._modelData.viewModel.setSelections(t, e, i);
    }
  }
  getContentWidth() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getContentWidth() : -1;
  }
  getScrollWidth() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getScrollWidth() : -1;
  }
  getScrollLeft() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getCurrentScrollLeft() : -1;
  }
  getContentHeight() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getContentHeight() : -1;
  }
  getScrollHeight() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getScrollHeight() : -1;
  }
  getScrollTop() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getCurrentScrollTop() : -1;
  }
  setScrollLeft(e, t = 1) {
    if (this._modelData) {
      if (typeof e != "number")
        throw new Error("Invalid arguments");
      this._modelData.viewModel.viewLayout.setScrollPosition({
        scrollLeft: e
      }, t);
    }
  }
  setScrollTop(e, t = 1) {
    if (this._modelData) {
      if (typeof e != "number")
        throw new Error("Invalid arguments");
      this._modelData.viewModel.viewLayout.setScrollPosition({
        scrollTop: e
      }, t);
    }
  }
  setScrollPosition(e, t = 1) {
    this._modelData && this._modelData.viewModel.viewLayout.setScrollPosition(e, t);
  }
  hasPendingScrollAnimation() {
    return this._modelData ? this._modelData.viewModel.viewLayout.hasPendingScrollAnimation() : !1;
  }
  saveViewState() {
    if (!this._modelData)
      return null;
    const e = this._contributions.saveViewState(), t = this._modelData.viewModel.saveCursorState(), i = this._modelData.viewModel.saveState();
    return {
      cursorState: t,
      viewState: i,
      contributionsState: e
    };
  }
  restoreViewState(e) {
    if (!this._modelData || !this._modelData.hasRealView)
      return;
    const t = e;
    if (t && t.cursorState && t.viewState) {
      const i = t.cursorState;
      Array.isArray(i) ? i.length > 0 && this._modelData.viewModel.restoreCursorState(i) : this._modelData.viewModel.restoreCursorState([i]), this._contributions.restoreViewState(t.contributionsState || {});
      const n = this._modelData.viewModel.reduceRestoreState(t.viewState);
      this._modelData.view.restoreState(n);
    }
  }
  handleInitialized() {
    var e;
    (e = this._getViewModel()) == null || e.visibleLinesStabilized();
  }
  getContribution(e) {
    return this._contributions.get(e);
  }
  getActions() {
    return Array.from(this._actions.values());
  }
  getSupportedActions() {
    let e = this.getActions();
    return e = e.filter((t) => t.isSupported()), e;
  }
  getAction(e) {
    return this._actions.get(e) || null;
  }
  trigger(e, t, i) {
    i = i || {};
    try {
      switch (this._beginUpdate(), t) {
        case "compositionStart":
          this._startComposition();
          return;
        case "compositionEnd":
          this._endComposition(e);
          return;
        case "type": {
          const o = i;
          this._type(e, o.text || "");
          return;
        }
        case "replacePreviousChar": {
          const o = i;
          this._compositionType(e, o.text || "", o.replaceCharCnt || 0, 0, 0);
          return;
        }
        case "compositionType": {
          const o = i;
          this._compositionType(e, o.text || "", o.replacePrevCharCnt || 0, o.replaceNextCharCnt || 0, o.positionDelta || 0);
          return;
        }
        case "paste": {
          const o = i;
          this._paste(e, o.text || "", o.pasteOnNewLine || !1, o.multicursorText || null, o.mode || null, o.clipboardEvent);
          return;
        }
        case "cut":
          this._cut(e);
          return;
      }
      const n = this.getAction(t);
      if (n) {
        Promise.resolve(n.run(i)).then(void 0, ht);
        return;
      }
      if (!this._modelData || this._triggerEditorCommand(e, t, i))
        return;
      this._triggerCommand(t, i);
    } finally {
      this._endUpdate();
    }
  }
  _triggerCommand(e, t) {
    this._commandService.executeCommand(e, t);
  }
  _startComposition() {
    this._modelData && (this._modelData.viewModel.startComposition(), this._onDidCompositionStart.fire());
  }
  _endComposition(e) {
    this._modelData && (this._modelData.viewModel.endComposition(e), this._onDidCompositionEnd.fire());
  }
  _type(e, t) {
    !this._modelData || t.length === 0 || (e === "keyboard" && this._onWillType.fire(t), this._modelData.viewModel.type(t, e), e === "keyboard" && this._onDidType.fire(t));
  }
  _compositionType(e, t, i, n, o) {
    this._modelData && this._modelData.viewModel.compositionType(t, i, n, o, e);
  }
  _paste(e, t, i, n, o, r) {
    if (!this._modelData)
      return;
    const a = this._modelData.viewModel, l = a.getSelection().getStartPosition();
    a.paste(t, i, n, e);
    const c = a.getSelection().getStartPosition();
    e === "keyboard" && this._onDidPaste.fire({
      clipboardEvent: r,
      range: new R(l.lineNumber, l.column, c.lineNumber, c.column),
      languageId: o
    });
  }
  _cut(e) {
    this._modelData && this._modelData.viewModel.cut(e);
  }
  _triggerEditorCommand(e, t, i) {
    const n = Kh.getEditorCommand(t);
    return n ? (i = i || {}, i.source = e, this._instantiationService.invokeFunction((o) => {
      Promise.resolve(n.runEditorCommand(o, this, i)).then(void 0, ht);
    }), !0) : !1;
  }
  _getViewModel() {
    return this._modelData ? this._modelData.viewModel : null;
  }
  pushUndoStop() {
    return !this._modelData || this._configuration.options.get(
      92
      /* EditorOption.readOnly */
    ) ? !1 : (this._modelData.model.pushStackElement(), !0);
  }
  popUndoStop() {
    return !this._modelData || this._configuration.options.get(
      92
      /* EditorOption.readOnly */
    ) ? !1 : (this._modelData.model.popStackElement(), !0);
  }
  executeEdits(e, t, i) {
    if (!this._modelData || this._configuration.options.get(
      92
      /* EditorOption.readOnly */
    ))
      return !1;
    let n;
    return i ? Array.isArray(i) ? n = () => i : n = i : n = () => null, this._modelData.viewModel.executeEdits(e, t, n), !0;
  }
  executeCommand(e, t) {
    this._modelData && this._modelData.viewModel.executeCommand(t, e);
  }
  executeCommands(e, t) {
    this._modelData && this._modelData.viewModel.executeCommands(t, e);
  }
  createDecorationsCollection(e) {
    return new LQ(this, e);
  }
  changeDecorations(e) {
    return this._modelData ? this._modelData.model.changeDecorations(e, this._id) : null;
  }
  getLineDecorations(e) {
    return this._modelData ? this._modelData.model.getLineDecorations(e, this._id, wp(this._configuration.options)) : null;
  }
  getDecorationsInRange(e) {
    return this._modelData ? this._modelData.model.getDecorationsInRange(e, this._id, wp(this._configuration.options)) : null;
  }
  /**
   * @deprecated
   */
  deltaDecorations(e, t) {
    return this._modelData ? e.length === 0 && t.length === 0 ? e : this._modelData.model.deltaDecorations(e, t, this._id) : [];
  }
  removeDecorations(e) {
    !this._modelData || e.length === 0 || this._modelData.model.changeDecorations((t) => {
      t.deltaDecorations(e, []);
    });
  }
  removeDecorationsByType(e) {
    const t = this._decorationTypeKeysToIds[e];
    t && this.changeDecorations((i) => i.deltaDecorations(t, [])), this._decorationTypeKeysToIds.hasOwnProperty(e) && delete this._decorationTypeKeysToIds[e], this._decorationTypeSubtypes.hasOwnProperty(e) && delete this._decorationTypeSubtypes[e];
  }
  getLayoutInfo() {
    return this._configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    );
  }
  createOverviewRuler(e) {
    return !this._modelData || !this._modelData.hasRealView ? null : this._modelData.view.createOverviewRuler(e);
  }
  getContainerDomNode() {
    return this._domElement;
  }
  getDomNode() {
    return !this._modelData || !this._modelData.hasRealView ? null : this._modelData.view.domNode.domNode;
  }
  delegateVerticalScrollbarPointerDown(e) {
    !this._modelData || !this._modelData.hasRealView || this._modelData.view.delegateVerticalScrollbarPointerDown(e);
  }
  delegateScrollFromMouseWheelEvent(e) {
    !this._modelData || !this._modelData.hasRealView || this._modelData.view.delegateScrollFromMouseWheelEvent(e);
  }
  layout(e, t = !1) {
    this._configuration.observeContainer(e), t || this.render();
  }
  focus() {
    !this._modelData || !this._modelData.hasRealView || this._modelData.view.focus();
  }
  hasTextFocus() {
    return !this._modelData || !this._modelData.hasRealView ? !1 : this._modelData.view.isFocused();
  }
  hasWidgetFocus() {
    return this._focusTracker && this._focusTracker.hasFocus();
  }
  addContentWidget(e) {
    const t = {
      widget: e,
      position: e.getPosition()
    };
    this._contentWidgets.hasOwnProperty(e.getId()) && console.warn("Overwriting a content widget with the same id:" + e.getId()), this._contentWidgets[e.getId()] = t, this._modelData && this._modelData.hasRealView && this._modelData.view.addContentWidget(t);
  }
  layoutContentWidget(e) {
    const t = e.getId();
    if (this._contentWidgets.hasOwnProperty(t)) {
      const i = this._contentWidgets[t];
      i.position = e.getPosition(), this._modelData && this._modelData.hasRealView && this._modelData.view.layoutContentWidget(i);
    }
  }
  removeContentWidget(e) {
    const t = e.getId();
    if (this._contentWidgets.hasOwnProperty(t)) {
      const i = this._contentWidgets[t];
      delete this._contentWidgets[t], this._modelData && this._modelData.hasRealView && this._modelData.view.removeContentWidget(i);
    }
  }
  addOverlayWidget(e) {
    const t = {
      widget: e,
      position: e.getPosition()
    };
    this._overlayWidgets.hasOwnProperty(e.getId()) && console.warn("Overwriting an overlay widget with the same id."), this._overlayWidgets[e.getId()] = t, this._modelData && this._modelData.hasRealView && this._modelData.view.addOverlayWidget(t);
  }
  layoutOverlayWidget(e) {
    const t = e.getId();
    if (this._overlayWidgets.hasOwnProperty(t)) {
      const i = this._overlayWidgets[t];
      i.position = e.getPosition(), this._modelData && this._modelData.hasRealView && this._modelData.view.layoutOverlayWidget(i);
    }
  }
  removeOverlayWidget(e) {
    const t = e.getId();
    if (this._overlayWidgets.hasOwnProperty(t)) {
      const i = this._overlayWidgets[t];
      delete this._overlayWidgets[t], this._modelData && this._modelData.hasRealView && this._modelData.view.removeOverlayWidget(i);
    }
  }
  addGlyphMarginWidget(e) {
    const t = {
      widget: e,
      position: e.getPosition()
    };
    this._glyphMarginWidgets.hasOwnProperty(e.getId()) && console.warn("Overwriting a glyph margin widget with the same id."), this._glyphMarginWidgets[e.getId()] = t, this._modelData && this._modelData.hasRealView && this._modelData.view.addGlyphMarginWidget(t);
  }
  layoutGlyphMarginWidget(e) {
    const t = e.getId();
    if (this._glyphMarginWidgets.hasOwnProperty(t)) {
      const i = this._glyphMarginWidgets[t];
      i.position = e.getPosition(), this._modelData && this._modelData.hasRealView && this._modelData.view.layoutGlyphMarginWidget(i);
    }
  }
  removeGlyphMarginWidget(e) {
    const t = e.getId();
    if (this._glyphMarginWidgets.hasOwnProperty(t)) {
      const i = this._glyphMarginWidgets[t];
      delete this._glyphMarginWidgets[t], this._modelData && this._modelData.hasRealView && this._modelData.view.removeGlyphMarginWidget(i);
    }
  }
  changeViewZones(e) {
    !this._modelData || !this._modelData.hasRealView || this._modelData.view.change(e);
  }
  getTargetAtClientPoint(e, t) {
    return !this._modelData || !this._modelData.hasRealView ? null : this._modelData.view.getTargetAtClientPoint(e, t);
  }
  getScrolledVisiblePosition(e) {
    if (!this._modelData || !this._modelData.hasRealView)
      return null;
    const t = this._modelData.model.validatePosition(e), i = this._configuration.options, n = i.get(
      146
      /* EditorOption.layoutInfo */
    ), o = wl._getVerticalOffsetForPosition(this._modelData, t.lineNumber, t.column) - this.getScrollTop(), r = this._modelData.view.getOffsetForColumn(t.lineNumber, t.column) + n.glyphMarginWidth + n.lineNumbersWidth + n.decorationsWidth - this.getScrollLeft();
    return {
      top: o,
      left: r,
      height: i.get(
        67
        /* EditorOption.lineHeight */
      )
    };
  }
  getOffsetForColumn(e, t) {
    return !this._modelData || !this._modelData.hasRealView ? -1 : this._modelData.view.getOffsetForColumn(e, t);
  }
  render(e = !1) {
    !this._modelData || !this._modelData.hasRealView || this._modelData.viewModel.batchEvents(() => {
      this._modelData.view.render(!0, e);
    });
  }
  setAriaOptions(e) {
    !this._modelData || !this._modelData.hasRealView || this._modelData.view.setAriaOptions(e);
  }
  applyFontInfo(e) {
    Fi(e, this._configuration.options.get(
      50
      /* EditorOption.fontInfo */
    ));
  }
  setBanner(e, t) {
    this._bannerDomNode && this._domElement.contains(this._bannerDomNode) && this._bannerDomNode.remove(), this._bannerDomNode = e, this._configuration.setReservedHeight(e ? t : 0), this._bannerDomNode && this._domElement.prepend(this._bannerDomNode);
  }
  _attachModel(e) {
    if (!e) {
      this._modelData = null;
      return;
    }
    const t = [];
    this._domElement.setAttribute("data-mode-id", e.getLanguageId()), this._configuration.setIsDominatedByLongLines(e.isDominatedByLongLines()), this._configuration.setModelLineCount(e.getLineCount());
    const i = e.onBeforeAttached(), n = new gQ(this._id, this._configuration, e, Ix.create(ue(this._domElement)), Nx.create(this._configuration.options), (a) => Wn(ue(this._domElement), a), this.languageConfigurationService, this._themeService, i, {
      batchChanges: (a) => {
        try {
          return this._beginUpdate(), a();
        } finally {
          this._endUpdate();
        }
      }
    });
    t.push(e.onWillDispose(() => this.setModel(null))), t.push(n.onEvent((a) => {
      switch (a.kind) {
        case 0:
          this._onDidContentSizeChange.fire(a);
          break;
        case 1:
          this._editorTextFocus.setValue(a.hasFocus);
          break;
        case 2:
          this._onDidScrollChange.fire(a);
          break;
        case 3:
          this._onDidChangeViewZones.fire();
          break;
        case 4:
          this._onDidChangeHiddenAreas.fire();
          break;
        case 5:
          this._onDidAttemptReadOnlyEdit.fire();
          break;
        case 6: {
          if (a.reachedMaxCursorCount) {
            const d = this.getOption(
              80
              /* EditorOption.multiCursorLimit */
            ), u = p("cursors.maximum", "The number of cursors has been limited to {0}. Consider using [find and replace](https://code.visualstudio.com/docs/editor/codebasics#_find-and-replace) for larger changes or increase the editor multi cursor limit setting.", d);
            this._notificationService.prompt(mF.Warning, u, [
              {
                label: "Find and Replace",
                run: () => {
                  this._commandService.executeCommand("editor.action.startFindReplaceAction");
                }
              },
              {
                label: p("goToSetting", "Increase Multi Cursor Limit"),
                run: () => {
                  this._commandService.executeCommand("workbench.action.openSettings2", {
                    query: "editor.multiCursorLimit"
                  });
                }
              }
            ]);
          }
          const l = [];
          for (let d = 0, u = a.selections.length; d < u; d++)
            l[d] = a.selections[d].getPosition();
          const c = {
            position: l[0],
            secondaryPositions: l.slice(1),
            reason: a.reason,
            source: a.source
          };
          this._onDidChangeCursorPosition.fire(c);
          const h = {
            selection: a.selections[0],
            secondarySelections: a.selections.slice(1),
            modelVersionId: a.modelVersionId,
            oldSelections: a.oldSelections,
            oldModelVersionId: a.oldModelVersionId,
            source: a.source,
            reason: a.reason
          };
          this._onDidChangeCursorSelection.fire(h);
          break;
        }
        case 7:
          this._onDidChangeModelDecorations.fire(a.event);
          break;
        case 8:
          this._domElement.setAttribute("data-mode-id", e.getLanguageId()), this._onDidChangeModelLanguage.fire(a.event);
          break;
        case 9:
          this._onDidChangeModelLanguageConfiguration.fire(a.event);
          break;
        case 10:
          this._onDidChangeModelContent.fire(a.event);
          break;
        case 11:
          this._onDidChangeModelOptions.fire(a.event);
          break;
        case 12:
          this._onDidChangeModelTokens.fire(a.event);
          break;
      }
    }));
    const [o, r] = this._createView(n);
    if (r) {
      this._domElement.appendChild(o.domNode.domNode);
      let a = Object.keys(this._contentWidgets);
      for (let l = 0, c = a.length; l < c; l++) {
        const h = a[l];
        o.addContentWidget(this._contentWidgets[h]);
      }
      a = Object.keys(this._overlayWidgets);
      for (let l = 0, c = a.length; l < c; l++) {
        const h = a[l];
        o.addOverlayWidget(this._overlayWidgets[h]);
      }
      a = Object.keys(this._glyphMarginWidgets);
      for (let l = 0, c = a.length; l < c; l++) {
        const h = a[l];
        o.addGlyphMarginWidget(this._glyphMarginWidgets[h]);
      }
      o.render(!1, !0), o.domNode.domNode.setAttribute("data-uri", e.uri.toString());
    }
    this._modelData = new wQ(e, n, o, r, t, i);
  }
  _createView(e) {
    let t;
    this.isSimpleWidget ? t = {
      paste: (o, r, a, l) => {
        this._paste("keyboard", o, r, a, l);
      },
      type: (o) => {
        this._type("keyboard", o);
      },
      compositionType: (o, r, a, l) => {
        this._compositionType("keyboard", o, r, a, l);
      },
      startComposition: () => {
        this._startComposition();
      },
      endComposition: () => {
        this._endComposition("keyboard");
      },
      cut: () => {
        this._cut("keyboard");
      }
    } : t = {
      paste: (o, r, a, l) => {
        const c = { text: o, pasteOnNewLine: r, multicursorText: a, mode: l };
        this._commandService.executeCommand("paste", c);
      },
      type: (o) => {
        const r = { text: o };
        this._commandService.executeCommand("type", r);
      },
      compositionType: (o, r, a, l) => {
        if (a || l) {
          const c = { text: o, replacePrevCharCnt: r, replaceNextCharCnt: a, positionDelta: l };
          this._commandService.executeCommand("compositionType", c);
        } else {
          const c = { text: o, replaceCharCnt: r };
          this._commandService.executeCommand("replacePreviousChar", c);
        }
      },
      startComposition: () => {
        this._commandService.executeCommand("compositionStart", {});
      },
      endComposition: () => {
        this._commandService.executeCommand("compositionEnd", {});
      },
      cut: () => {
        this._commandService.executeCommand("cut", {});
      }
    };
    const i = new e0(e.coordinatesConverter);
    return i.onKeyDown = (o) => this._onKeyDown.fire(o), i.onKeyUp = (o) => this._onKeyUp.fire(o), i.onContextMenu = (o) => this._onContextMenu.fire(o), i.onMouseMove = (o) => this._onMouseMove.fire(o), i.onMouseLeave = (o) => this._onMouseLeave.fire(o), i.onMouseDown = (o) => this._onMouseDown.fire(o), i.onMouseUp = (o) => this._onMouseUp.fire(o), i.onMouseDrag = (o) => this._onMouseDrag.fire(o), i.onMouseDrop = (o) => this._onMouseDrop.fire(o), i.onMouseDropCanceled = (o) => this._onMouseDropCanceled.fire(o), i.onMouseWheel = (o) => this._onMouseWheel.fire(o), [new AS(t, this._configuration, this._themeService.getColorTheme(), e, i, this._overflowWidgetsDomNode, this._instantiationService), !0];
  }
  _postDetachModelCleanup(e) {
    e == null || e.removeAllDecorationsWithOwnerId(this._id);
  }
  _detachModel() {
    var i;
    if ((i = this._contributionsDisposable) == null || i.dispose(), this._contributionsDisposable = void 0, !this._modelData)
      return null;
    const e = this._modelData.model, t = this._modelData.hasRealView ? this._modelData.view.domNode.domNode : null;
    return this._modelData.dispose(), this._modelData = null, this._domElement.removeAttribute("data-mode-id"), t && this._domElement.contains(t) && t.remove(), this._bannerDomNode && this._domElement.contains(this._bannerDomNode) && this._bannerDomNode.remove(), e;
  }
  _removeDecorationType(e) {
    this._codeEditorService.removeDecorationType(e);
  }
  hasModel() {
    return this._modelData !== null;
  }
  showDropIndicatorAt(e) {
    const t = [{
      range: new R(e.lineNumber, e.column, e.lineNumber, e.column),
      options: wl.dropIntoEditorDecorationOptions
    }];
    this._dropIntoEditorDecorations.set(t), this.revealPosition(
      e,
      1
      /* editorCommon.ScrollType.Immediate */
    );
  }
  removeDropIndicator() {
    this._dropIntoEditorDecorations.clear();
  }
  setContextValue(e, t) {
    this._contextKeyService.createKey(e, t);
  }
  _beginUpdate() {
    this._updateCounter++, this._updateCounter === 1 && this._onBeginUpdate.fire();
  }
  _endUpdate() {
    this._updateCounter--, this._updateCounter === 0 && this._onEndUpdate.fire();
  }
}, wl = cc, cc.dropIntoEditorDecorationOptions = si.register({
  description: "workbench-dnd-target",
  className: "dnd-target"
}), cc);
G_ = wl = bQ([
  rr(3, ot),
  rr(4, ri),
  rr(5, ss),
  rr(6, nt),
  rr(7, Ws),
  rr(8, fo),
  rr(9, go),
  rr(10, Zo),
  rr(11, gt)
], G_);
let CQ = 0;
class wQ {
  constructor(e, t, i, n, o, r) {
    this.model = e, this.viewModel = t, this.view = i, this.hasRealView = n, this.listenersToRemove = o, this.attachedView = r;
  }
  dispose() {
    Ri(this.listenersToRemove), this.model.onBeforeDetached(this.attachedView), this.hasRealView && this.view.dispose(), this.viewModel.dispose();
  }
}
class FT extends q {
  constructor(e) {
    super(), this._emitterOptions = e, this._onDidChangeToTrue = this._register(new O(this._emitterOptions)), this.onDidChangeToTrue = this._onDidChangeToTrue.event, this._onDidChangeToFalse = this._register(new O(this._emitterOptions)), this.onDidChangeToFalse = this._onDidChangeToFalse.event, this._value = 0;
  }
  setValue(e) {
    const t = e ? 2 : 1;
    this._value !== t && (this._value = t, this._value === 2 ? this._onDidChangeToTrue.fire() : this._value === 1 && this._onDidChangeToFalse.fire());
  }
}
class Hi extends O {
  constructor(e, t) {
    super({ deliveryQueue: t }), this._contributions = e;
  }
  fire(e) {
    this._contributions.onBeforeInteractionEvent(), super.fire(e);
  }
}
class vQ extends q {
  constructor(e, t) {
    super(), this._editor = e, t.createKey("editorId", e.getId()), this._editorSimpleInput = se.editorSimpleInput.bindTo(t), this._editorFocus = se.focus.bindTo(t), this._textInputFocus = se.textInputFocus.bindTo(t), this._editorTextFocus = se.editorTextFocus.bindTo(t), this._tabMovesFocus = se.tabMovesFocus.bindTo(t), this._editorReadonly = se.readOnly.bindTo(t), this._inDiffEditor = se.inDiffEditor.bindTo(t), this._editorColumnSelection = se.columnSelection.bindTo(t), this._hasMultipleSelections = se.hasMultipleSelections.bindTo(t), this._hasNonEmptySelection = se.hasNonEmptySelection.bindTo(t), this._canUndo = se.canUndo.bindTo(t), this._canRedo = se.canRedo.bindTo(t), this._register(this._editor.onDidChangeConfiguration(() => this._updateFromConfig())), this._register(this._editor.onDidChangeCursorSelection(() => this._updateFromSelection())), this._register(this._editor.onDidFocusEditorWidget(() => this._updateFromFocus())), this._register(this._editor.onDidBlurEditorWidget(() => this._updateFromFocus())), this._register(this._editor.onDidFocusEditorText(() => this._updateFromFocus())), this._register(this._editor.onDidBlurEditorText(() => this._updateFromFocus())), this._register(this._editor.onDidChangeModel(() => this._updateFromModel())), this._register(this._editor.onDidChangeConfiguration(() => this._updateFromModel())), this._register(R_.onDidChangeTabFocus((i) => this._tabMovesFocus.set(i))), this._updateFromConfig(), this._updateFromSelection(), this._updateFromFocus(), this._updateFromModel(), this._editorSimpleInput.set(this._editor.isSimpleWidget);
  }
  _updateFromConfig() {
    const e = this._editor.getOptions();
    this._tabMovesFocus.set(R_.getTabFocusMode()), this._editorReadonly.set(e.get(
      92
      /* EditorOption.readOnly */
    )), this._inDiffEditor.set(e.get(
      61
      /* EditorOption.inDiffEditor */
    )), this._editorColumnSelection.set(e.get(
      22
      /* EditorOption.columnSelection */
    ));
  }
  _updateFromSelection() {
    const e = this._editor.getSelections();
    e ? (this._hasMultipleSelections.set(e.length > 1), this._hasNonEmptySelection.set(e.some((t) => !t.isEmpty()))) : (this._hasMultipleSelections.reset(), this._hasNonEmptySelection.reset());
  }
  _updateFromFocus() {
    this._editorFocus.set(this._editor.hasWidgetFocus() && !this._editor.isSimpleWidget), this._editorTextFocus.set(this._editor.hasTextFocus() && !this._editor.isSimpleWidget), this._textInputFocus.set(this._editor.hasTextFocus());
  }
  _updateFromModel() {
    const e = this._editor.getModel();
    this._canUndo.set(!!(e && e.canUndo())), this._canRedo.set(!!(e && e.canRedo()));
  }
}
class yQ extends q {
  constructor(e, t, i) {
    super(), this._editor = e, this._contextKeyService = t, this._languageFeaturesService = i, this._langId = se.languageId.bindTo(t), this._hasCompletionItemProvider = se.hasCompletionItemProvider.bindTo(t), this._hasCodeActionsProvider = se.hasCodeActionsProvider.bindTo(t), this._hasCodeLensProvider = se.hasCodeLensProvider.bindTo(t), this._hasDefinitionProvider = se.hasDefinitionProvider.bindTo(t), this._hasDeclarationProvider = se.hasDeclarationProvider.bindTo(t), this._hasImplementationProvider = se.hasImplementationProvider.bindTo(t), this._hasTypeDefinitionProvider = se.hasTypeDefinitionProvider.bindTo(t), this._hasHoverProvider = se.hasHoverProvider.bindTo(t), this._hasDocumentHighlightProvider = se.hasDocumentHighlightProvider.bindTo(t), this._hasDocumentSymbolProvider = se.hasDocumentSymbolProvider.bindTo(t), this._hasReferenceProvider = se.hasReferenceProvider.bindTo(t), this._hasRenameProvider = se.hasRenameProvider.bindTo(t), this._hasSignatureHelpProvider = se.hasSignatureHelpProvider.bindTo(t), this._hasInlayHintsProvider = se.hasInlayHintsProvider.bindTo(t), this._hasDocumentFormattingProvider = se.hasDocumentFormattingProvider.bindTo(t), this._hasDocumentSelectionFormattingProvider = se.hasDocumentSelectionFormattingProvider.bindTo(t), this._hasMultipleDocumentFormattingProvider = se.hasMultipleDocumentFormattingProvider.bindTo(t), this._hasMultipleDocumentSelectionFormattingProvider = se.hasMultipleDocumentSelectionFormattingProvider.bindTo(t), this._isInEmbeddedEditor = se.isInEmbeddedEditor.bindTo(t);
    const n = () => this._update();
    this._register(e.onDidChangeModel(n)), this._register(e.onDidChangeModelLanguage(n)), this._register(i.completionProvider.onDidChange(n)), this._register(i.codeActionProvider.onDidChange(n)), this._register(i.codeLensProvider.onDidChange(n)), this._register(i.definitionProvider.onDidChange(n)), this._register(i.declarationProvider.onDidChange(n)), this._register(i.implementationProvider.onDidChange(n)), this._register(i.typeDefinitionProvider.onDidChange(n)), this._register(i.hoverProvider.onDidChange(n)), this._register(i.documentHighlightProvider.onDidChange(n)), this._register(i.documentSymbolProvider.onDidChange(n)), this._register(i.referenceProvider.onDidChange(n)), this._register(i.renameProvider.onDidChange(n)), this._register(i.documentFormattingEditProvider.onDidChange(n)), this._register(i.documentRangeFormattingEditProvider.onDidChange(n)), this._register(i.signatureHelpProvider.onDidChange(n)), this._register(i.inlayHintsProvider.onDidChange(n)), n();
  }
  dispose() {
    super.dispose();
  }
  reset() {
    this._contextKeyService.bufferChangeEvents(() => {
      this._langId.reset(), this._hasCompletionItemProvider.reset(), this._hasCodeActionsProvider.reset(), this._hasCodeLensProvider.reset(), this._hasDefinitionProvider.reset(), this._hasDeclarationProvider.reset(), this._hasImplementationProvider.reset(), this._hasTypeDefinitionProvider.reset(), this._hasHoverProvider.reset(), this._hasDocumentHighlightProvider.reset(), this._hasDocumentSymbolProvider.reset(), this._hasReferenceProvider.reset(), this._hasRenameProvider.reset(), this._hasDocumentFormattingProvider.reset(), this._hasDocumentSelectionFormattingProvider.reset(), this._hasSignatureHelpProvider.reset(), this._isInEmbeddedEditor.reset();
    });
  }
  _update() {
    const e = this._editor.getModel();
    if (!e) {
      this.reset();
      return;
    }
    this._contextKeyService.bufferChangeEvents(() => {
      this._langId.set(e.getLanguageId()), this._hasCompletionItemProvider.set(this._languageFeaturesService.completionProvider.has(e)), this._hasCodeActionsProvider.set(this._languageFeaturesService.codeActionProvider.has(e)), this._hasCodeLensProvider.set(this._languageFeaturesService.codeLensProvider.has(e)), this._hasDefinitionProvider.set(this._languageFeaturesService.definitionProvider.has(e)), this._hasDeclarationProvider.set(this._languageFeaturesService.declarationProvider.has(e)), this._hasImplementationProvider.set(this._languageFeaturesService.implementationProvider.has(e)), this._hasTypeDefinitionProvider.set(this._languageFeaturesService.typeDefinitionProvider.has(e)), this._hasHoverProvider.set(this._languageFeaturesService.hoverProvider.has(e)), this._hasDocumentHighlightProvider.set(this._languageFeaturesService.documentHighlightProvider.has(e)), this._hasDocumentSymbolProvider.set(this._languageFeaturesService.documentSymbolProvider.has(e)), this._hasReferenceProvider.set(this._languageFeaturesService.referenceProvider.has(e)), this._hasRenameProvider.set(this._languageFeaturesService.renameProvider.has(e)), this._hasSignatureHelpProvider.set(this._languageFeaturesService.signatureHelpProvider.has(e)), this._hasInlayHintsProvider.set(this._languageFeaturesService.inlayHintsProvider.has(e)), this._hasDocumentFormattingProvider.set(this._languageFeaturesService.documentFormattingEditProvider.has(e) || this._languageFeaturesService.documentRangeFormattingEditProvider.has(e)), this._hasDocumentSelectionFormattingProvider.set(this._languageFeaturesService.documentRangeFormattingEditProvider.has(e)), this._hasMultipleDocumentFormattingProvider.set(this._languageFeaturesService.documentFormattingEditProvider.all(e).length + this._languageFeaturesService.documentRangeFormattingEditProvider.all(e).length > 1), this._hasMultipleDocumentSelectionFormattingProvider.set(this._languageFeaturesService.documentRangeFormattingEditProvider.all(e).length > 1), this._isInEmbeddedEditor.set(e.uri.scheme === Ne.walkThroughSnippet || e.uri.scheme === Ne.vscodeChatCodeBlock);
    });
  }
}
class SQ extends q {
  constructor(e, t) {
    super(), this._onChange = this._register(new O()), this.onChange = this._onChange.event, this._hadFocus = void 0, this._hasDomElementFocus = !1, this._domFocusTracker = this._register(Ff(e)), this._overflowWidgetsDomNodeHasFocus = !1, this._register(this._domFocusTracker.onDidFocus(() => {
      this._hasDomElementFocus = !0, this._update();
    })), this._register(this._domFocusTracker.onDidBlur(() => {
      this._hasDomElementFocus = !1, this._update();
    })), t && (this._overflowWidgetsDomNode = this._register(Ff(t)), this._register(this._overflowWidgetsDomNode.onDidFocus(() => {
      this._overflowWidgetsDomNodeHasFocus = !0, this._update();
    })), this._register(this._overflowWidgetsDomNode.onDidBlur(() => {
      this._overflowWidgetsDomNodeHasFocus = !1, this._update();
    })));
  }
  _update() {
    const e = this._hasDomElementFocus || this._overflowWidgetsDomNodeHasFocus;
    this._hadFocus !== e && (this._hadFocus = e, this._onChange.fire(void 0));
  }
  hasFocus() {
    return this._hadFocus ?? !1;
  }
}
class LQ {
  get length() {
    return this._decorationIds.length;
  }
  constructor(e, t) {
    this._editor = e, this._decorationIds = [], this._isChangingDecorations = !1, Array.isArray(t) && t.length > 0 && this.set(t);
  }
  onDidChange(e, t, i) {
    return this._editor.onDidChangeModelDecorations((n) => {
      this._isChangingDecorations || e.call(t, n);
    }, i);
  }
  getRange(e) {
    return !this._editor.hasModel() || e >= this._decorationIds.length ? null : this._editor.getModel().getDecorationRange(this._decorationIds[e]);
  }
  getRanges() {
    if (!this._editor.hasModel())
      return [];
    const e = this._editor.getModel(), t = [];
    for (const i of this._decorationIds) {
      const n = e.getDecorationRange(i);
      n && t.push(n);
    }
    return t;
  }
  has(e) {
    return this._decorationIds.includes(e.id);
  }
  clear() {
    this._decorationIds.length !== 0 && this.set([]);
  }
  set(e) {
    try {
      this._isChangingDecorations = !0, this._editor.changeDecorations((t) => {
        this._decorationIds = t.deltaDecorations(this._decorationIds, e);
      });
    } finally {
      this._isChangingDecorations = !1;
    }
    return this._decorationIds;
  }
  append(e) {
    let t = [];
    try {
      this._isChangingDecorations = !0, this._editor.changeDecorations((i) => {
        t = i.deltaDecorations([], e), this._decorationIds = this._decorationIds.concat(t);
      });
    } finally {
      this._isChangingDecorations = !1;
    }
    return t;
  }
}
const kQ = encodeURIComponent("<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 6 3' enable-background='new 0 0 6 3' height='3' width='6'><g fill='"), xQ = encodeURIComponent("'><polygon points='5.5,0 2.5,3 1.1,3 4.1,0'/><polygon points='4,0 6,2 6,0.6 5.4,0'/><polygon points='0,2 1,3 2.4,3 0,0.6'/></g></svg>");
function LC(s) {
  return kQ + encodeURIComponent(s.toString()) + xQ;
}
const DQ = encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" height="3" width="12"><g fill="'), EQ = encodeURIComponent('"><circle cx="1" cy="1" r="1"/><circle cx="5" cy="1" r="1"/><circle cx="9" cy="1" r="1"/></g></svg>');
function IQ(s) {
  return DQ + encodeURIComponent(s.toString()) + EQ;
}
Jr((s, e) => {
  const t = s.getColor(lk);
  t && e.addRule(`.monaco-editor .squiggly-error { background: url("data:image/svg+xml,${LC(t)}") repeat-x bottom left; }`);
  const i = s.getColor(ja);
  i && e.addRule(`.monaco-editor .squiggly-warning { background: url("data:image/svg+xml,${LC(i)}") repeat-x bottom left; }`);
  const n = s.getColor(wc);
  n && e.addRule(`.monaco-editor .squiggly-info { background: url("data:image/svg+xml,${LC(n)}") repeat-x bottom left; }`);
  const o = s.getColor(i8);
  o && e.addRule(`.monaco-editor .squiggly-hint { background: url("data:image/svg+xml,${IQ(o)}") no-repeat bottom left; }`);
  const r = s.getColor(Hz);
  r && e.addRule(`.monaco-editor.showUnused .squiggly-inline-unnecessary { opacity: ${r.rgba.a}; }`);
});
class Z_ {
  static capture(e) {
    if (e.getScrollTop() === 0 || e.hasPendingScrollAnimation())
      return new Z_(e.getScrollTop(), e.getContentHeight(), null, 0, null);
    let t = null, i = 0;
    const n = e.getVisibleRanges();
    if (n.length > 0) {
      t = n[0].getStartPosition();
      const o = e.getTopForPosition(t.lineNumber, t.column);
      i = e.getScrollTop() - o;
    }
    return new Z_(e.getScrollTop(), e.getContentHeight(), t, i, e.getPosition());
  }
  constructor(e, t, i, n, o) {
    this._initialScrollTop = e, this._initialContentHeight = t, this._visiblePosition = i, this._visiblePositionScrollDelta = n, this._cursorPosition = o;
  }
  restore(e) {
    if (!(this._initialContentHeight === e.getContentHeight() && this._initialScrollTop === e.getScrollTop()) && this._visiblePosition) {
      const t = e.getTopForPosition(this._visiblePosition.lineNumber, this._visiblePosition.column);
      e.setScrollTop(t + this._visiblePositionScrollDelta);
    }
  }
  restoreRelativeVerticalPositionOfCursor(e) {
    if (this._initialContentHeight === e.getContentHeight() && this._initialScrollTop === e.getScrollTop())
      return;
    const t = e.getPosition();
    if (!this._cursorPosition || !t)
      return;
    const i = e.getTopForLineNumber(t.lineNumber) - e.getTopForLineNumber(this._cursorPosition.lineNumber);
    e.setScrollTop(
      e.getScrollTop() + i,
      1
      /* ScrollType.Immediate */
    );
  }
}
function NQ(s, e, t, i) {
  if (s.length === 0)
    return e;
  if (e.length === 0)
    return s;
  const n = [];
  let o = 0, r = 0;
  for (; o < s.length && r < e.length; ) {
    const a = s[o], l = e[r], c = t(a), h = t(l);
    c < h ? (n.push(a), o++) : c > h ? (n.push(l), r++) : (n.push(i(a, l)), o++, r++);
  }
  for (; o < s.length; )
    n.push(s[o]), o++;
  for (; r < e.length; )
    n.push(e[r]), r++;
  return n;
}
function Y_(s, e) {
  const t = new he(), i = s.createDecorationsCollection();
  return t.add(Mb({ debugName: () => `Apply decorations from ${e.debugName}` }, (n) => {
    const o = e.read(n);
    i.set(o);
  })), t.add({
    dispose: () => {
      i.clear();
    }
  }), t;
}
function Pu(s, e) {
  return s.appendChild(e), ke(() => {
    e.remove();
  });
}
function TQ(s, e) {
  return s.prepend(e), ke(() => {
    e.remove();
  });
}
class g5 extends q {
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  get automaticLayout() {
    return this._automaticLayout;
  }
  constructor(e, t) {
    super(), this._automaticLayout = !1, this.elementSizeObserver = this._register(new G4(e, t)), this._width = $e(this, this.elementSizeObserver.getWidth()), this._height = $e(this, this.elementSizeObserver.getHeight()), this._register(this.elementSizeObserver.onDidChange((i) => ni((n) => {
      this._width.set(this.elementSizeObserver.getWidth(), n), this._height.set(this.elementSizeObserver.getHeight(), n);
    })));
  }
  observe(e) {
    this.elementSizeObserver.observe(e);
  }
  setAutomaticLayout(e) {
    this._automaticLayout = e, e ? this.elementSizeObserver.startObserving() : this.elementSizeObserver.stopObserving();
  }
}
function BT(s, e, t) {
  let i = e.get(), n = i, o = i;
  const r = $e("animatedValue", i);
  let a = -1;
  const l = 300;
  let c;
  t.add(Rb({
    createEmptyChangeSummary: () => ({ animate: !1 }),
    handleChange: (d, u) => (d.didChange(e) && (u.animate = u.animate || d.change), !0)
  }, (d, u) => {
    c !== void 0 && (s.cancelAnimationFrame(c), c = void 0), n = o, i = e.read(d), a = Date.now() - (u.animate ? 0 : l), h();
  }));
  function h() {
    const d = Date.now() - a;
    o = Math.floor(MQ(d, n, i - n, l)), d < l ? c = s.requestAnimationFrame(h) : o = i, r.set(o, void 0);
  }
  return r;
}
function MQ(s, e, t, i) {
  return s === i ? e + t : t * (-Math.pow(2, -10 * s / i) + 1) + e;
}
class Px extends q {
  constructor(e, t, i) {
    super(), this._register(new zS(e, i)), this._register(Qa(i, {
      height: t.actualHeight,
      top: t.actualTop
    }));
  }
}
class Eh {
  get afterLineNumber() {
    return this._afterLineNumber.get();
  }
  constructor(e, t) {
    this._afterLineNumber = e, this.heightInPx = t, this.domNode = document.createElement("div"), this._actualTop = $e(this, void 0), this._actualHeight = $e(this, void 0), this.actualTop = this._actualTop, this.actualHeight = this._actualHeight, this.showInHiddenAreas = !0, this.onChange = this._afterLineNumber, this.onDomNodeTop = (i) => {
      this._actualTop.set(i, void 0);
    }, this.onComputedHeight = (i) => {
      this._actualHeight.set(i, void 0);
    };
  }
}
const j1 = class j1 {
  constructor(e, t) {
    this._editor = e, this._domElement = t, this._overlayWidgetId = `managedOverlayWidget-${j1._counter++}`, this._overlayWidget = {
      getId: () => this._overlayWidgetId,
      getDomNode: () => this._domElement,
      getPosition: () => null
    }, this._editor.addOverlayWidget(this._overlayWidget);
  }
  dispose() {
    this._editor.removeOverlayWidget(this._overlayWidget);
  }
};
j1._counter = 0;
let zS = j1;
function Qa(s, e) {
  return Qe((t) => {
    for (let [i, n] of Object.entries(e))
      n && typeof n == "object" && "read" in n && (n = n.read(t)), typeof n == "number" && (n = `${n}px`), i = i.replace(/[A-Z]/g, (o) => "-" + o.toLowerCase()), s.style[i] = n;
  });
}
function Q_(s, e, t, i) {
  const n = new he(), o = [];
  return n.add(so((r, a) => {
    const l = e.read(r), c = /* @__PURE__ */ new Map(), h = /* @__PURE__ */ new Map();
    t && t(!0), s.changeViewZones((d) => {
      for (const u of o)
        d.removeZone(u), i == null || i.delete(u);
      o.length = 0;
      for (const u of l) {
        const f = d.addZone(u);
        u.setZoneId && u.setZoneId(f), o.push(f), i == null || i.add(f), c.set(u, f);
      }
    }), t && t(!1), a.add(Rb({
      createEmptyChangeSummary() {
        return { zoneIds: [] };
      },
      handleChange(d, u) {
        const f = h.get(d.changedObservable);
        return f !== void 0 && u.zoneIds.push(f), !0;
      }
    }, (d, u) => {
      for (const f of l)
        f.onChange && (h.set(f.onChange, c.get(f)), f.onChange.read(d));
      t && t(!0), s.changeViewZones((f) => {
        for (const g of u.zoneIds)
          f.layoutZone(g);
      }), t && t(!1);
    }));
  })), n.add({
    dispose() {
      t && t(!0), s.changeViewZones((r) => {
        for (const a of o)
          r.removeZone(a);
      }), i == null || i.clear(), t && t(!1);
    }
  }), n;
}
function WT(s, e) {
  const t = Op(e, (n) => n.original.startLineNumber <= s.lineNumber);
  if (!t)
    return R.fromPositions(s);
  if (t.original.endLineNumberExclusive <= s.lineNumber) {
    const n = s.lineNumber - t.original.endLineNumberExclusive + t.modified.endLineNumberExclusive;
    return R.fromPositions(new V(n, s.column));
  }
  if (!t.innerChanges)
    return R.fromPositions(new V(t.modified.startLineNumber, 1));
  const i = Op(t.innerChanges, (n) => n.originalRange.getStartPosition().isBeforeOrEqual(s));
  if (!i) {
    const n = s.lineNumber - t.original.startLineNumber + t.modified.startLineNumber;
    return R.fromPositions(new V(n, s.column));
  }
  if (i.originalRange.containsPosition(s))
    return i.modifiedRange;
  {
    const n = RQ(i.originalRange.getEndPosition(), s);
    return R.fromPositions(n.addToPosition(i.modifiedRange.getEndPosition()));
  }
}
function RQ(s, e) {
  return s.lineNumber === e.lineNumber ? new qa(0, e.column - s.column) : new qa(e.lineNumber - s.lineNumber, e.column - 1);
}
function AQ(s, e) {
  let t;
  return s.filter((i) => {
    const n = e(i, t);
    return t = i, n;
  });
}
class X_ {
  static create(e, t = void 0) {
    return new VT(e, e, t);
  }
  static createWithDisposable(e, t, i = void 0) {
    const n = new he();
    return n.add(t), n.add(e), new VT(e, n, i);
  }
}
class VT extends X_ {
  constructor(e, t, i) {
    super(), this.object = e, this._disposable = t, this._debugOwner = i, this._refCount = 1, this._isDisposed = !1, this._owners = [], i && this._addOwner(i);
  }
  _addOwner(e) {
    e && this._owners.push(e);
  }
  createNewRef(e) {
    return this._refCount++, e && this._addOwner(e), new PQ(this, e);
  }
  dispose() {
    this._isDisposed || (this._isDisposed = !0, this._decreaseRefCount(this._debugOwner));
  }
  _decreaseRefCount(e) {
    if (this._refCount--, this._refCount === 0 && this._disposable.dispose(), e) {
      const t = this._owners.indexOf(e);
      t !== -1 && this._owners.splice(t, 1);
    }
  }
}
class PQ extends X_ {
  constructor(e, t) {
    super(), this._base = e, this._debugOwner = t, this._isDisposed = !1;
  }
  get object() {
    return this._base.object;
  }
  createNewRef(e) {
    return this._base.createNewRef(e);
  }
  dispose() {
    this._isDisposed || (this._isDisposed = !0, this._base._decreaseRefCount(this._debugOwner));
  }
}
var Ox = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Fx = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const OQ = tl("diff-review-insert", re.add, p("accessibleDiffViewerInsertIcon", "Icon for 'Insert' in accessible diff viewer.")), FQ = tl("diff-review-remove", re.remove, p("accessibleDiffViewerRemoveIcon", "Icon for 'Remove' in accessible diff viewer.")), BQ = tl("diff-review-close", re.close, p("accessibleDiffViewerCloseIcon", "Icon for 'Close' in accessible diff viewer."));
var ud;
let jl = (ud = class extends q {
  constructor(e, t, i, n, o, r, a, l, c) {
    super(), this._parentNode = e, this._visible = t, this._setVisible = i, this._canClose = n, this._width = o, this._height = r, this._diffs = a, this._models = l, this._instantiationService = c, this._state = $d(this, (h, d) => {
      const u = this._visible.read(h);
      if (this._parentNode.style.visibility = u ? "visible" : "hidden", !u)
        return null;
      const f = d.add(this._instantiationService.createInstance(US, this._diffs, this._models, this._setVisible, this._canClose)), g = d.add(this._instantiationService.createInstance($S, this._parentNode, f, this._width, this._height, this._models));
      return { model: f, view: g };
    }).recomputeInitiallyAndOnChange(this._store);
  }
  next() {
    ni((e) => {
      const t = this._visible.get();
      this._setVisible(!0, e), t && this._state.get().model.nextGroup(e);
    });
  }
  prev() {
    ni((e) => {
      this._setVisible(!0, e), this._state.get().model.previousGroup(e);
    });
  }
  close() {
    ni((e) => {
      this._setVisible(!1, e);
    });
  }
}, ud._ttPolicy = Pc("diffReview", { createHTML: (e) => e }), ud);
jl = Ox([
  Fx(8, ot)
], jl);
let US = class extends q {
  constructor(e, t, i, n, o) {
    super(), this._diffs = e, this._models = t, this._setVisible = i, this.canClose = n, this._accessibilitySignalService = o, this._groups = $e(this, []), this._currentGroupIdx = $e(this, 0), this._currentElementIdx = $e(this, 0), this.groups = this._groups, this.currentGroup = this._currentGroupIdx.map((r, a) => this._groups.read(a)[r]), this.currentGroupIndex = this._currentGroupIdx, this.currentElement = this._currentElementIdx.map((r, a) => {
      var l;
      return (l = this.currentGroup.read(a)) == null ? void 0 : l.lines[r];
    }), this._register(Qe((r) => {
      const a = this._diffs.read(r);
      if (!a) {
        this._groups.set([], void 0);
        return;
      }
      const l = WQ(a, this._models.getOriginalModel().getLineCount(), this._models.getModifiedModel().getLineCount());
      ni((c) => {
        const h = this._models.getModifiedPosition();
        if (h) {
          const d = l.findIndex((u) => (h == null ? void 0 : h.lineNumber) < u.range.modified.endLineNumberExclusive);
          d !== -1 && this._currentGroupIdx.set(d, c);
        }
        this._groups.set(l, c);
      });
    })), this._register(Qe((r) => {
      const a = this.currentElement.read(r);
      (a == null ? void 0 : a.type) === tn.Deleted ? this._accessibilitySignalService.playSignal(Ao.diffLineDeleted, { source: "accessibleDiffViewer.currentElementChanged" }) : (a == null ? void 0 : a.type) === tn.Added && this._accessibilitySignalService.playSignal(Ao.diffLineInserted, { source: "accessibleDiffViewer.currentElementChanged" });
    })), this._register(Qe((r) => {
      const a = this.currentElement.read(r);
      if (a && a.type !== tn.Header) {
        const l = a.modifiedLineNumber ?? a.diff.modified.startLineNumber;
        this._models.modifiedSetSelection(R.fromPositions(new V(l, 1)));
      }
    }));
  }
  _goToGroupDelta(e, t) {
    const i = this.groups.get();
    !i || i.length <= 1 || Ik(t, (n) => {
      this._currentGroupIdx.set(xe.ofLength(i.length).clipCyclic(this._currentGroupIdx.get() + e), n), this._currentElementIdx.set(0, n);
    });
  }
  nextGroup(e) {
    this._goToGroupDelta(1, e);
  }
  previousGroup(e) {
    this._goToGroupDelta(-1, e);
  }
  _goToLineDelta(e) {
    const t = this.currentGroup.get();
    !t || t.lines.length <= 1 || ni((i) => {
      this._currentElementIdx.set(xe.ofLength(t.lines.length).clip(this._currentElementIdx.get() + e), i);
    });
  }
  goToNextLine() {
    this._goToLineDelta(1);
  }
  goToPreviousLine() {
    this._goToLineDelta(-1);
  }
  goToLine(e) {
    const t = this.currentGroup.get();
    if (!t)
      return;
    const i = t.lines.indexOf(e);
    i !== -1 && ni((n) => {
      this._currentElementIdx.set(i, n);
    });
  }
  revealCurrentElementInEditor() {
    if (!this.canClose.get())
      return;
    this._setVisible(!1, void 0);
    const e = this.currentElement.get();
    e && (e.type === tn.Deleted ? this._models.originalReveal(R.fromPositions(new V(e.originalLineNumber, 1))) : this._models.modifiedReveal(e.type !== tn.Header ? R.fromPositions(new V(e.modifiedLineNumber, 1)) : void 0));
  }
  close() {
    this.canClose.get() && (this._setVisible(!1, void 0), this._models.modifiedFocus());
  }
};
US = Ox([
  Fx(4, Zb)
], US);
const yu = 3;
function WQ(s, e, t) {
  const i = [];
  for (const n of uL(s, (o, r) => r.modified.startLineNumber - o.modified.endLineNumberExclusive < 2 * yu)) {
    const o = [];
    o.push(new HQ());
    const r = new we(Math.max(1, n[0].original.startLineNumber - yu), Math.min(n[n.length - 1].original.endLineNumberExclusive + yu, e + 1)), a = new we(Math.max(1, n[0].modified.startLineNumber - yu), Math.min(n[n.length - 1].modified.endLineNumberExclusive + yu, t + 1));
    _2(n, (h, d) => {
      const u = new we(h ? h.original.endLineNumberExclusive : r.startLineNumber, d ? d.original.startLineNumber : r.endLineNumberExclusive), f = new we(h ? h.modified.endLineNumberExclusive : a.startLineNumber, d ? d.modified.startLineNumber : a.endLineNumberExclusive);
      u.forEach((g) => {
        o.push(new $Q(g, f.startLineNumber + (g - u.startLineNumber)));
      }), d && (d.original.forEach((g) => {
        o.push(new zQ(d, g));
      }), d.modified.forEach((g) => {
        o.push(new UQ(d, g));
      }));
    });
    const l = n[0].modified.join(n[n.length - 1].modified), c = n[0].original.join(n[n.length - 1].original);
    i.push(new VQ(new ji(l, c), o));
  }
  return i;
}
var tn;
(function(s) {
  s[s.Header = 0] = "Header", s[s.Unchanged = 1] = "Unchanged", s[s.Deleted = 2] = "Deleted", s[s.Added = 3] = "Added";
})(tn || (tn = {}));
class VQ {
  constructor(e, t) {
    this.range = e, this.lines = t;
  }
}
class HQ {
  constructor() {
    this.type = tn.Header;
  }
}
class zQ {
  constructor(e, t) {
    this.diff = e, this.originalLineNumber = t, this.type = tn.Deleted, this.modifiedLineNumber = void 0;
  }
}
class UQ {
  constructor(e, t) {
    this.diff = e, this.modifiedLineNumber = t, this.type = tn.Added, this.originalLineNumber = void 0;
  }
}
class $Q {
  constructor(e, t) {
    this.originalLineNumber = e, this.modifiedLineNumber = t, this.type = tn.Unchanged;
  }
}
let $S = class extends q {
  constructor(e, t, i, n, o, r) {
    super(), this._element = e, this._model = t, this._width = i, this._height = n, this._models = o, this._languageService = r, this.domNode = this._element, this.domNode.className = "monaco-component diff-review monaco-editor-background";
    const a = document.createElement("div");
    a.className = "diff-review-actions", this._actionBar = this._register(new Kr(a)), this._register(Qe((l) => {
      this._actionBar.clear(), this._model.canClose.read(l) && this._actionBar.push(new zr("diffreview.close", p("label.close", "Close"), "close-diff-review " + Ke.asClassName(BQ), !0, async () => t.close()), { label: !1, icon: !0 });
    })), this._content = document.createElement("div"), this._content.className = "diff-review-content", this._content.setAttribute("role", "code"), this._scrollbar = this._register(new fk(this._content, {})), on(this.domNode, this._scrollbar.getDomNode(), a), this._register(Qe((l) => {
      this._height.read(l), this._width.read(l), this._scrollbar.scanDomNode();
    })), this._register(ke(() => {
      on(this.domNode);
    })), this._register(Qa(this.domNode, { width: this._width, height: this._height })), this._register(Qa(this._content, { width: this._width, height: this._height })), this._register(so((l, c) => {
      this._model.currentGroup.read(l), this._render(c);
    })), this._register(fi(this.domNode, "keydown", (l) => {
      (l.equals(
        18
        /* KeyCode.DownArrow */
      ) || l.equals(
        2066
        /* KeyCode.DownArrow */
      ) || l.equals(
        530
        /* KeyCode.DownArrow */
      )) && (l.preventDefault(), this._model.goToNextLine()), (l.equals(
        16
        /* KeyCode.UpArrow */
      ) || l.equals(
        2064
        /* KeyCode.UpArrow */
      ) || l.equals(
        528
        /* KeyCode.UpArrow */
      )) && (l.preventDefault(), this._model.goToPreviousLine()), (l.equals(
        9
        /* KeyCode.Escape */
      ) || l.equals(
        2057
        /* KeyCode.Escape */
      ) || l.equals(
        521
        /* KeyCode.Escape */
      ) || l.equals(
        1033
        /* KeyCode.Escape */
      )) && (l.preventDefault(), this._model.close()), (l.equals(
        10
        /* KeyCode.Space */
      ) || l.equals(
        3
        /* KeyCode.Enter */
      )) && (l.preventDefault(), this._model.revealCurrentElementInEditor());
    }));
  }
  _render(e) {
    const t = this._models.getOriginalOptions(), i = this._models.getModifiedOptions(), n = document.createElement("div");
    n.className = "diff-review-table", n.setAttribute("role", "list"), n.setAttribute("aria-label", p("ariaLabel", "Accessible Diff Viewer. Use arrow up and down to navigate.")), Fi(n, i.get(
      50
      /* EditorOption.fontInfo */
    )), on(this._content, n);
    const o = this._models.getOriginalModel(), r = this._models.getModifiedModel();
    if (!o || !r)
      return;
    const a = o.getOptions(), l = r.getOptions(), c = i.get(
      67
      /* EditorOption.lineHeight */
    ), h = this._model.currentGroup.get();
    for (const d of (h == null ? void 0 : h.lines) || []) {
      if (!h)
        break;
      let u;
      if (d.type === tn.Header) {
        const g = document.createElement("div");
        g.className = "diff-review-row", g.setAttribute("role", "listitem");
        const m = h.range, _ = this._model.currentGroupIndex.get(), b = this._model.groups.get().length, C = (L) => L === 0 ? p("no_lines_changed", "no lines changed") : L === 1 ? p("one_line_changed", "1 line changed") : p("more_lines_changed", "{0} lines changed", L), v = C(m.original.length), w = C(m.modified.length);
        g.setAttribute("aria-label", p({
          key: "header",
          comment: [
            "This is the ARIA label for a git diff header.",
            "A git diff header looks like this: @@ -154,12 +159,39 @@.",
            "That encodes that at original line 154 (which is now line 159), 12 lines were removed/changed with 39 lines.",
            "Variables 0 and 1 refer to the diff index out of total number of diffs.",
            "Variables 2 and 4 will be numbers (a line number).",
            'Variables 3 and 5 will be "no lines changed", "1 line changed" or "X lines changed", localized separately.'
          ]
        }, "Difference {0} of {1}: original line {2}, {3}, modified line {4}, {5}", _ + 1, b, m.original.startLineNumber, v, m.modified.startLineNumber, w));
        const S = document.createElement("div");
        S.className = "diff-review-cell diff-review-summary", S.appendChild(document.createTextNode(`${_ + 1}/${b}: @@ -${m.original.startLineNumber},${m.original.length} +${m.modified.startLineNumber},${m.modified.length} @@`)), g.appendChild(S), u = g;
      } else
        u = this._createRow(d, c, this._width.get(), t, o, a, i, r, l);
      n.appendChild(u);
      const f = Se((g) => (
        /** @description isSelected */
        this._model.currentElement.read(g) === d
      ));
      e.add(Qe((g) => {
        const m = f.read(g);
        u.tabIndex = m ? 0 : -1, m && u.focus();
      })), e.add($(u, "focus", () => {
        this._model.goToLine(d);
      }));
    }
    this._scrollbar.scanDomNode();
  }
  _createRow(e, t, i, n, o, r, a, l, c) {
    const h = n.get(
      146
      /* EditorOption.layoutInfo */
    ), d = h.glyphMarginWidth + h.lineNumbersWidth, u = a.get(
      146
      /* EditorOption.layoutInfo */
    ), f = 10 + u.glyphMarginWidth + u.lineNumbersWidth;
    let g = "diff-review-row", m = "";
    const _ = "diff-review-spacer";
    let b = null;
    switch (e.type) {
      case tn.Added:
        g = "diff-review-row line-insert", m = " char-insert", b = OQ;
        break;
      case tn.Deleted:
        g = "diff-review-row line-delete", m = " char-delete", b = FQ;
        break;
    }
    const C = document.createElement("div");
    C.style.minWidth = i + "px", C.className = g, C.setAttribute("role", "listitem"), C.ariaLevel = "";
    const v = document.createElement("div");
    v.className = "diff-review-cell", v.style.height = `${t}px`, C.appendChild(v);
    const w = document.createElement("span");
    w.style.width = d + "px", w.style.minWidth = d + "px", w.className = "diff-review-line-number" + m, e.originalLineNumber !== void 0 ? w.appendChild(document.createTextNode(String(e.originalLineNumber))) : w.innerText = " ", v.appendChild(w);
    const S = document.createElement("span");
    S.style.width = f + "px", S.style.minWidth = f + "px", S.style.paddingRight = "10px", S.className = "diff-review-line-number" + m, e.modifiedLineNumber !== void 0 ? S.appendChild(document.createTextNode(String(e.modifiedLineNumber))) : S.innerText = " ", v.appendChild(S);
    const L = document.createElement("span");
    if (L.className = _, b) {
      const E = document.createElement("span");
      E.className = Ke.asClassName(b), E.innerText = "  ", L.appendChild(E);
    } else
      L.innerText = "  ";
    v.appendChild(L);
    let k;
    if (e.modifiedLineNumber !== void 0) {
      let E = this._getLineHtml(l, a, c.tabSize, e.modifiedLineNumber, this._languageService.languageIdCodec);
      jl._ttPolicy && (E = jl._ttPolicy.createHTML(E)), v.insertAdjacentHTML("beforeend", E), k = l.getLineContent(e.modifiedLineNumber);
    } else {
      let E = this._getLineHtml(o, n, r.tabSize, e.originalLineNumber, this._languageService.languageIdCodec);
      jl._ttPolicy && (E = jl._ttPolicy.createHTML(E)), v.insertAdjacentHTML("beforeend", E), k = o.getLineContent(e.originalLineNumber);
    }
    k.length === 0 && (k = p("blankLine", "blank"));
    let D = "";
    switch (e.type) {
      case tn.Unchanged:
        e.originalLineNumber === e.modifiedLineNumber ? D = p({ key: "unchangedLine", comment: ["The placeholders are contents of the line and should not be translated."] }, "{0} unchanged line {1}", k, e.originalLineNumber) : D = p("equalLine", "{0} original line {1} modified line {2}", k, e.originalLineNumber, e.modifiedLineNumber);
        break;
      case tn.Added:
        D = p("insertLine", "+ {0} modified line {1}", k, e.modifiedLineNumber);
        break;
      case tn.Deleted:
        D = p("deleteLine", "- {0} original line {1}", k, e.originalLineNumber);
        break;
    }
    return C.setAttribute("aria-label", D), C;
  }
  _getLineHtml(e, t, i, n, o) {
    const r = e.getLineContent(n), a = t.get(
      50
      /* EditorOption.fontInfo */
    ), l = Si.createEmpty(r, o), c = ns.isBasicASCII(r, e.mightContainNonBasicASCII()), h = ns.containsRTL(r, c, e.mightContainRTL());
    return Yb(new Gd(a.isMonospace && !t.get(
      33
      /* EditorOption.disableMonospaceOptimizations */
    ), a.canUseHalfwidthRightwardsArrow, r, !1, c, h, 0, l, [], i, 0, a.spaceWidth, a.middotWidth, a.wsmiddotWidth, t.get(
      118
      /* EditorOption.stopRenderingLineAfter */
    ), t.get(
      100
      /* EditorOption.renderWhitespace */
    ), t.get(
      95
      /* EditorOption.renderControlCharacters */
    ), t.get(
      51
      /* EditorOption.fontLigatures */
    ) !== gc.OFF, null)).html;
  }
};
$S = Ox([
  Fx(5, gi)
], $S);
class KQ {
  constructor(e) {
    this.editors = e;
  }
  getOriginalModel() {
    return this.editors.original.getModel();
  }
  getOriginalOptions() {
    return this.editors.original.getOptions();
  }
  originalReveal(e) {
    this.editors.original.revealRange(e), this.editors.original.setSelection(e), this.editors.original.focus();
  }
  getModifiedModel() {
    return this.editors.modified.getModel();
  }
  getModifiedOptions() {
    return this.editors.modified.getOptions();
  }
  modifiedReveal(e) {
    e && (this.editors.modified.revealRange(e), this.editors.modified.setSelection(e)), this.editors.modified.focus();
  }
  modifiedSetSelection(e) {
    this.editors.modified.setSelection(e);
  }
  modifiedFocus() {
    this.editors.modified.focus();
  }
  getModifiedPosition() {
    return this.editors.modified.getPosition() ?? void 0;
  }
}
N("diffEditor.move.border", "#8b8b8b9c", p("diffEditor.move.border", "The border color for text that got moved in the diff editor."));
N("diffEditor.moveActive.border", "#FFA500", p("diffEditor.moveActive.border", "The active border color for text that got moved in the diff editor."));
N("diffEditor.unchangedRegionShadow", { dark: "#000000", light: "#737373BF", hcDark: "#000000", hcLight: "#737373BF" }, p("diffEditor.unchangedRegionShadow", "The color of the shadow around unchanged region widgets."));
const qQ = tl("diff-insert", re.add, p("diffInsertIcon", "Line decoration for inserts in the diff editor.")), m5 = tl("diff-remove", re.remove, p("diffRemoveIcon", "Line decoration for removals in the diff editor.")), HT = si.register({
  className: "line-insert",
  description: "line-insert",
  isWholeLine: !0,
  linesDecorationsClassName: "insert-sign " + Ke.asClassName(qQ),
  marginClassName: "gutter-insert"
}), zT = si.register({
  className: "line-delete",
  description: "line-delete",
  isWholeLine: !0,
  linesDecorationsClassName: "delete-sign " + Ke.asClassName(m5),
  marginClassName: "gutter-delete"
}), UT = si.register({
  className: "line-insert",
  description: "line-insert",
  isWholeLine: !0,
  marginClassName: "gutter-insert"
}), $T = si.register({
  className: "line-delete",
  description: "line-delete",
  isWholeLine: !0,
  marginClassName: "gutter-delete"
}), KT = si.register({
  className: "char-insert",
  description: "char-insert",
  shouldFillLineOnLineBreak: !0
}), jQ = si.register({
  className: "char-insert",
  description: "char-insert",
  isWholeLine: !0
}), GQ = si.register({
  className: "char-insert diff-range-empty",
  description: "char-insert diff-range-empty"
}), KS = si.register({
  className: "char-delete",
  description: "char-delete",
  shouldFillLineOnLineBreak: !0
}), ZQ = si.register({
  className: "char-delete",
  description: "char-delete",
  isWholeLine: !0
}), YQ = si.register({
  className: "char-delete diff-range-empty",
  description: "char-delete diff-range-empty"
});
var p5 = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, qS = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, vl;
const _5 = Ve("diffProviderFactoryService");
let jS = class {
  constructor(e) {
    this.instantiationService = e;
  }
  createDiffProvider(e) {
    return this.instantiationService.createInstance(GS, e);
  }
};
jS = p5([
  qS(0, ot)
], jS);
Ge(
  _5,
  jS,
  1
  /* InstantiationType.Delayed */
);
var hc;
let GS = (hc = class {
  constructor(e, t, i) {
    this.editorWorkerService = t, this.telemetryService = i, this.onDidChangeEventEmitter = new O(), this.onDidChange = this.onDidChangeEventEmitter.event, this.diffAlgorithm = "advanced", this.diffAlgorithmOnDidChangeSubscription = void 0, this.setOptions(e);
  }
  dispose() {
    var e;
    (e = this.diffAlgorithmOnDidChangeSubscription) == null || e.dispose();
  }
  async computeDiff(e, t, i, n) {
    if (typeof this.diffAlgorithm != "string")
      return this.diffAlgorithm.computeDiff(e, t, i, n);
    if (e.isDisposed() || t.isDisposed())
      return {
        changes: [],
        identical: !0,
        quitEarly: !1,
        moves: []
      };
    if (e.getLineCount() === 1 && e.getLineMaxColumn(1) === 1)
      return t.getLineCount() === 1 && t.getLineMaxColumn(1) === 1 ? {
        changes: [],
        identical: !0,
        quitEarly: !1,
        moves: []
      } : {
        changes: [
          new is(new we(1, 2), new we(1, t.getLineCount() + 1), [
            new Gn(e.getFullModelRange(), t.getFullModelRange())
          ])
        ],
        identical: !1,
        quitEarly: !1,
        moves: []
      };
    const o = JSON.stringify([e.uri.toString(), t.uri.toString()]), r = JSON.stringify([e.id, t.id, e.getAlternativeVersionId(), t.getAlternativeVersionId(), JSON.stringify(i)]), a = vl.diffCache.get(o);
    if (a && a.context === r)
      return a.result;
    const l = Dc.create(), c = await this.editorWorkerService.computeDiff(e.uri, t.uri, i, this.diffAlgorithm), h = l.elapsed();
    if (this.telemetryService.publicLog2("diffEditor.computeDiff", {
      timeMs: h,
      timedOut: (c == null ? void 0 : c.quitEarly) ?? !0,
      detectedMoves: i.computeMoves ? (c == null ? void 0 : c.moves.length) ?? 0 : -1
    }), n.isCancellationRequested)
      return {
        changes: [],
        identical: !1,
        quitEarly: !0,
        moves: []
      };
    if (!c)
      throw new Error("no diff result available");
    return vl.diffCache.size > 10 && vl.diffCache.delete(vl.diffCache.keys().next().value), vl.diffCache.set(o, { result: c, context: r }), c;
  }
  setOptions(e) {
    var i;
    let t = !1;
    e.diffAlgorithm && this.diffAlgorithm !== e.diffAlgorithm && ((i = this.diffAlgorithmOnDidChangeSubscription) == null || i.dispose(), this.diffAlgorithmOnDidChangeSubscription = void 0, this.diffAlgorithm = e.diffAlgorithm, typeof e.diffAlgorithm != "string" && (this.diffAlgorithmOnDidChangeSubscription = e.diffAlgorithm.onDidChange(() => this.onDidChangeEventEmitter.fire())), t = !0), t && this.onDidChangeEventEmitter.fire();
  }
}, vl = hc, hc.diffCache = /* @__PURE__ */ new Map(), hc);
GS = vl = p5([
  qS(1, Hg),
  qS(2, Ac)
], GS);
function Bx() {
  return OC && !!OC.VSCODE_DEV;
}
function b5(s) {
  if (Bx()) {
    const e = QQ();
    return e.add(s), {
      dispose() {
        e.delete(s);
      }
    };
  } else
    return { dispose() {
    } };
}
function QQ() {
  Wm || (Wm = /* @__PURE__ */ new Set());
  const s = globalThis;
  return s.$hotReload_applyNewExports || (s.$hotReload_applyNewExports = (e) => {
    const t = { config: { mode: void 0 }, ...e }, i = [];
    for (const n of Wm) {
      const o = n(t);
      o && i.push(o);
    }
    if (i.length > 0)
      return (n) => {
        let o = !1;
        for (const r of i)
          r(n) && (o = !0);
        return o;
      };
  }), Wm;
}
let Wm;
Bx() && b5(({ oldExports: s, newSrc: e, config: t }) => {
  if (t.mode === "patch-prototype")
    return (i) => {
      var n, o;
      for (const r in i) {
        const a = i[r];
        if (console.log(`[hot-reload] Patching prototype methods of '${r}'`, { exportedItem: a }), typeof a == "function" && a.prototype) {
          const l = s[r];
          if (l) {
            for (const c of Object.getOwnPropertyNames(a.prototype)) {
              const h = Object.getOwnPropertyDescriptor(a.prototype, c), d = Object.getOwnPropertyDescriptor(l.prototype, c);
              ((n = h == null ? void 0 : h.value) == null ? void 0 : n.toString()) !== ((o = d == null ? void 0 : d.value) == null ? void 0 : o.toString()) && console.log(`[hot-reload] Patching prototype method '${r}.${c}'`), Object.defineProperty(l.prototype, c, h);
            }
            i[r] = l;
          }
        }
      }
      return !0;
    };
});
function ks(s, e) {
  return XQ([s], e), s;
}
function XQ(s, e) {
  Bx() && ds("reload", (i) => b5(({ oldExports: n }) => {
    if ([...Object.values(n)].some((o) => s.includes(o)))
      return (o) => (i(void 0), !0);
  })).read(e);
}
var JQ = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, eX = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let ZS = class extends q {
  setActiveMovedText(e) {
    this._activeMovedText.set(e, void 0);
  }
  constructor(e, t, i) {
    super(), this.model = e, this._options = t, this._diffProviderFactoryService = i, this._isDiffUpToDate = $e(this, !1), this.isDiffUpToDate = this._isDiffUpToDate, this._diff = $e(this, void 0), this.diff = this._diff, this._unchangedRegions = $e(this, void 0), this.unchangedRegions = Se(this, (a) => {
      var l;
      return this._options.hideUnchangedRegions.read(a) ? ((l = this._unchangedRegions.read(a)) == null ? void 0 : l.regions) ?? [] : (ni((c) => {
        var h;
        for (const d of ((h = this._unchangedRegions.get()) == null ? void 0 : h.regions) || [])
          d.collapseAll(c);
      }), []);
    }), this.movedTextToCompare = $e(this, void 0), this._activeMovedText = $e(this, void 0), this._hoveredMovedText = $e(this, void 0), this.activeMovedText = Se(this, (a) => this.movedTextToCompare.read(a) ?? this._hoveredMovedText.read(a) ?? this._activeMovedText.read(a)), this._cancellationTokenSource = new Wd(), this._diffProvider = Se(this, (a) => {
      const l = this._diffProviderFactoryService.createDiffProvider({
        diffAlgorithm: this._options.diffAlgorithm.read(a)
      }), c = ds("onDidChange", l.onDidChange);
      return {
        diffProvider: l,
        onChangeSignal: c
      };
    }), this._register(ke(() => this._cancellationTokenSource.cancel()));
    const n = Mk("contentChangedSignal"), o = this._register(new sn(() => n.trigger(void 0), 200));
    this._register(Qe((a) => {
      const l = this._unchangedRegions.read(a);
      if (!l || l.regions.some((g) => g.isDragged.read(a)))
        return;
      const c = l.originalDecorationIds.map((g) => e.original.getDecorationRange(g)).map((g) => g ? we.fromRangeInclusive(g) : void 0), h = l.modifiedDecorationIds.map((g) => e.modified.getDecorationRange(g)).map((g) => g ? we.fromRangeInclusive(g) : void 0), d = l.regions.map((g, m) => !c[m] || !h[m] ? void 0 : new Ma(c[m].startLineNumber, h[m].startLineNumber, c[m].length, g.visibleLineCountTop.read(a), g.visibleLineCountBottom.read(a))).filter(gd), u = [];
      let f = !1;
      for (const g of uL(d, (m, _) => m.getHiddenModifiedRange(a).endLineNumberExclusive === _.getHiddenModifiedRange(a).startLineNumber))
        if (g.length > 1) {
          f = !0;
          const m = g.reduce((b, C) => b + C.lineCount, 0), _ = new Ma(g[0].originalLineNumber, g[0].modifiedLineNumber, m, g[0].visibleLineCountTop.get(), g[g.length - 1].visibleLineCountBottom.get());
          u.push(_);
        } else
          u.push(g[0]);
      if (f) {
        const g = e.original.deltaDecorations(l.originalDecorationIds, u.map((_) => ({ range: _.originalUnchangedRange.toInclusiveRange(), options: { description: "unchanged" } }))), m = e.modified.deltaDecorations(l.modifiedDecorationIds, u.map((_) => ({ range: _.modifiedUnchangedRange.toInclusiveRange(), options: { description: "unchanged" } })));
        ni((_) => {
          this._unchangedRegions.set({
            regions: u,
            originalDecorationIds: g,
            modifiedDecorationIds: m
          }, _);
        });
      }
    }));
    const r = (a, l, c) => {
      const h = Ma.fromDiffs(a.changes, e.original.getLineCount(), e.modified.getLineCount(), this._options.hideUnchangedRegionsMinimumLineCount.read(c), this._options.hideUnchangedRegionsContextLineCount.read(c));
      let d;
      const u = this._unchangedRegions.get();
      if (u) {
        const _ = u.originalDecorationIds.map((w) => e.original.getDecorationRange(w)).map((w) => w ? we.fromRangeInclusive(w) : void 0), b = u.modifiedDecorationIds.map((w) => e.modified.getDecorationRange(w)).map((w) => w ? we.fromRangeInclusive(w) : void 0);
        let v = AQ(u.regions.map((w, S) => {
          if (!_[S] || !b[S])
            return;
          const L = _[S].length;
          return new Ma(
            _[S].startLineNumber,
            b[S].startLineNumber,
            L,
            // The visible area can shrink by edits -> we have to account for this
            Math.min(w.visibleLineCountTop.get(), L),
            Math.min(w.visibleLineCountBottom.get(), L - w.visibleLineCountTop.get())
          );
        }).filter(gd), (w, S) => !S || w.modifiedLineNumber >= S.modifiedLineNumber + S.lineCount && w.originalLineNumber >= S.originalLineNumber + S.lineCount).map((w) => new ji(w.getHiddenOriginalRange(c), w.getHiddenModifiedRange(c)));
        v = ji.clip(v, we.ofLength(1, e.original.getLineCount()), we.ofLength(1, e.modified.getLineCount())), d = ji.inverse(v, e.original.getLineCount(), e.modified.getLineCount());
      }
      const f = [];
      if (d)
        for (const _ of h) {
          const b = d.filter((C) => C.original.intersectsStrict(_.originalUnchangedRange) && C.modified.intersectsStrict(_.modifiedUnchangedRange));
          f.push(..._.setVisibleRanges(b, l));
        }
      else
        f.push(...h);
      const g = e.original.deltaDecorations((u == null ? void 0 : u.originalDecorationIds) || [], f.map((_) => ({ range: _.originalUnchangedRange.toInclusiveRange(), options: { description: "unchanged" } }))), m = e.modified.deltaDecorations((u == null ? void 0 : u.modifiedDecorationIds) || [], f.map((_) => ({ range: _.modifiedUnchangedRange.toInclusiveRange(), options: { description: "unchanged" } })));
      this._unchangedRegions.set({
        regions: f,
        originalDecorationIds: g,
        modifiedDecorationIds: m
      }, l);
    };
    this._register(e.modified.onDidChangeContent((a) => {
      if (this._diff.get()) {
        const c = Ar.fromModelContentChanges(a.changes);
        this._lastDiff, e.original, e.modified;
      }
      this._isDiffUpToDate.set(!1, void 0), o.schedule();
    })), this._register(e.original.onDidChangeContent((a) => {
      if (this._diff.get()) {
        const c = Ar.fromModelContentChanges(a.changes);
        this._lastDiff, e.original, e.modified;
      }
      this._isDiffUpToDate.set(!1, void 0), o.schedule();
    })), this._register(so(async (a, l) => {
      this._options.hideUnchangedRegionsMinimumLineCount.read(a), this._options.hideUnchangedRegionsContextLineCount.read(a), o.cancel(), n.read(a);
      const c = this._diffProvider.read(a);
      c.onChangeSignal.read(a), ks(iR, a), ks(pv, a), this._isDiffUpToDate.set(!1, void 0);
      let h = [];
      l.add(e.original.onDidChangeContent((f) => {
        const g = Ar.fromModelContentChanges(f.changes);
        h = u_(h, g);
      }));
      let d = [];
      l.add(e.modified.onDidChangeContent((f) => {
        const g = Ar.fromModelContentChanges(f.changes);
        d = u_(d, g);
      }));
      let u = await c.diffProvider.computeDiff(e.original, e.modified, {
        ignoreTrimWhitespace: this._options.ignoreTrimWhitespace.read(a),
        maxComputationTimeMs: this._options.maxComputationTimeMs.read(a),
        computeMoves: this._options.showMoves.read(a)
      }, this._cancellationTokenSource.token);
      this._cancellationTokenSource.token.isCancellationRequested || e.original.isDisposed() || e.modified.isDisposed() || (u = tX(u, e.original, e.modified), u = (e.original, e.modified, void 0) ?? u, u = (e.original, e.modified, void 0) ?? u, ni((f) => {
        r(u, f), this._lastDiff = u;
        const g = Wx.fromDiffResult(u);
        this._diff.set(g, f), this._isDiffUpToDate.set(!0, f);
        const m = this.movedTextToCompare.get();
        this.movedTextToCompare.set(m ? this._lastDiff.moves.find((_) => _.lineRangeMapping.modified.intersect(m.lineRangeMapping.modified)) : void 0, f);
      }));
    }));
  }
  ensureModifiedLineIsVisible(e, t, i) {
    var o, r;
    if (((o = this.diff.get()) == null ? void 0 : o.mappings.length) === 0)
      return;
    const n = ((r = this._unchangedRegions.get()) == null ? void 0 : r.regions) || [];
    for (const a of n)
      if (a.getHiddenModifiedRange(void 0).contains(e)) {
        a.showModifiedLine(e, t, i);
        return;
      }
  }
  ensureOriginalLineIsVisible(e, t, i) {
    var o, r;
    if (((o = this.diff.get()) == null ? void 0 : o.mappings.length) === 0)
      return;
    const n = ((r = this._unchangedRegions.get()) == null ? void 0 : r.regions) || [];
    for (const a of n)
      if (a.getHiddenOriginalRange(void 0).contains(e)) {
        a.showOriginalLine(e, t, i);
        return;
      }
  }
  async waitForDiff() {
    await vH(this.isDiffUpToDate, (e) => e);
  }
  serializeState() {
    const e = this._unchangedRegions.get();
    return {
      collapsedRegions: e == null ? void 0 : e.regions.map((t) => ({ range: t.getHiddenModifiedRange(void 0).serialize() }))
    };
  }
  restoreSerializedState(e) {
    var n;
    const t = (n = e.collapsedRegions) == null ? void 0 : n.map((o) => we.deserialize(o.range)), i = this._unchangedRegions.get();
    !i || !t || ni((o) => {
      for (const r of i.regions)
        for (const a of t)
          if (r.modifiedUnchangedRange.intersect(a)) {
            r.setHiddenModifiedRange(a, o);
            break;
          }
    });
  }
};
ZS = JQ([
  eX(2, _5)
], ZS);
function tX(s, e, t) {
  return {
    changes: s.changes.map((i) => new is(i.original, i.modified, i.innerChanges ? i.innerChanges.map((n) => iX(n, e, t)) : void 0)),
    moves: s.moves,
    identical: s.identical,
    quitEarly: s.quitEarly
  };
}
function iX(s, e, t) {
  let i = s.originalRange, n = s.modifiedRange;
  return i.startColumn === 1 && n.startColumn === 1 && (i.endColumn !== 1 || n.endColumn !== 1) && i.endColumn === e.getLineMaxColumn(i.endLineNumber) && n.endColumn === t.getLineMaxColumn(n.endLineNumber) && i.endLineNumber < e.getLineCount() && n.endLineNumber < t.getLineCount() && (i = i.setEndPosition(i.endLineNumber + 1, 1), n = n.setEndPosition(n.endLineNumber + 1, 1)), new Gn(i, n);
}
class Wx {
  static fromDiffResult(e) {
    return new Wx(e.changes.map((t) => new C5(t)), e.moves || [], e.identical, e.quitEarly);
  }
  constructor(e, t, i, n) {
    this.mappings = e, this.movedTexts = t, this.identical = i, this.quitEarly = n;
  }
}
class C5 {
  constructor(e) {
    this.lineRangeMapping = e;
  }
}
class Ma {
  static fromDiffs(e, t, i, n, o) {
    const r = is.inverse(e, t, i), a = [];
    for (const l of r) {
      let c = l.original.startLineNumber, h = l.modified.startLineNumber, d = l.original.length;
      const u = c === 1 && h === 1, f = c + d === t + 1 && h + d === i + 1;
      (u || f) && d >= o + n ? (u && !f && (d -= o), f && !u && (c += o, h += o, d -= o), a.push(new Ma(c, h, d, 0, 0))) : d >= o * 2 + n && (c += o, h += o, d -= o * 2, a.push(new Ma(c, h, d, 0, 0)));
    }
    return a;
  }
  get originalUnchangedRange() {
    return we.ofLength(this.originalLineNumber, this.lineCount);
  }
  get modifiedUnchangedRange() {
    return we.ofLength(this.modifiedLineNumber, this.lineCount);
  }
  constructor(e, t, i, n, o) {
    this.originalLineNumber = e, this.modifiedLineNumber = t, this.lineCount = i, this._visibleLineCountTop = $e(this, 0), this.visibleLineCountTop = this._visibleLineCountTop, this._visibleLineCountBottom = $e(this, 0), this.visibleLineCountBottom = this._visibleLineCountBottom, this._shouldHideControls = Se(this, (l) => (
      /** @description isVisible */
      this.visibleLineCountTop.read(l) + this.visibleLineCountBottom.read(l) === this.lineCount && !this.isDragged.read(l)
    )), this.isDragged = $e(this, void 0);
    const r = Math.max(Math.min(n, this.lineCount), 0), a = Math.max(Math.min(o, this.lineCount - n), 0);
    UD(n === r), UD(o === a), this._visibleLineCountTop.set(r, void 0), this._visibleLineCountBottom.set(a, void 0);
  }
  setVisibleRanges(e, t) {
    const i = [], n = new hs(e.map((l) => l.modified)).subtractFrom(this.modifiedUnchangedRange);
    let o = this.originalLineNumber, r = this.modifiedLineNumber;
    const a = this.modifiedLineNumber + this.lineCount;
    if (n.ranges.length === 0)
      this.showAll(t), i.push(this);
    else {
      let l = 0;
      for (const c of n.ranges) {
        const h = l === n.ranges.length - 1;
        l++;
        const d = (h ? a : c.endLineNumberExclusive) - r, u = new Ma(o, r, d, 0, 0);
        u.setHiddenModifiedRange(c, t), i.push(u), o = u.originalUnchangedRange.endLineNumberExclusive, r = u.modifiedUnchangedRange.endLineNumberExclusive;
      }
    }
    return i;
  }
  shouldHideControls(e) {
    return this._shouldHideControls.read(e);
  }
  getHiddenOriginalRange(e) {
    return we.ofLength(this.originalLineNumber + this._visibleLineCountTop.read(e), this.lineCount - this._visibleLineCountTop.read(e) - this._visibleLineCountBottom.read(e));
  }
  getHiddenModifiedRange(e) {
    return we.ofLength(this.modifiedLineNumber + this._visibleLineCountTop.read(e), this.lineCount - this._visibleLineCountTop.read(e) - this._visibleLineCountBottom.read(e));
  }
  setHiddenModifiedRange(e, t) {
    const i = e.startLineNumber - this.modifiedLineNumber, n = this.modifiedLineNumber + this.lineCount - e.endLineNumberExclusive;
    this.setState(i, n, t);
  }
  getMaxVisibleLineCountTop() {
    return this.lineCount - this._visibleLineCountBottom.get();
  }
  getMaxVisibleLineCountBottom() {
    return this.lineCount - this._visibleLineCountTop.get();
  }
  showMoreAbove(e = 10, t) {
    const i = this.getMaxVisibleLineCountTop();
    this._visibleLineCountTop.set(Math.min(this._visibleLineCountTop.get() + e, i), t);
  }
  showMoreBelow(e = 10, t) {
    const i = this.lineCount - this._visibleLineCountTop.get();
    this._visibleLineCountBottom.set(Math.min(this._visibleLineCountBottom.get() + e, i), t);
  }
  showAll(e) {
    this._visibleLineCountBottom.set(this.lineCount - this._visibleLineCountTop.get(), e);
  }
  showModifiedLine(e, t, i) {
    const n = e + 1 - (this.modifiedLineNumber + this._visibleLineCountTop.get()), o = this.modifiedLineNumber - this._visibleLineCountBottom.get() + this.lineCount - e;
    t === 0 && n < o || t === 1 ? this._visibleLineCountTop.set(this._visibleLineCountTop.get() + n, i) : this._visibleLineCountBottom.set(this._visibleLineCountBottom.get() + o, i);
  }
  showOriginalLine(e, t, i) {
    const n = e - this.originalLineNumber, o = this.originalLineNumber + this.lineCount - e;
    t === 0 && n < o || t === 1 ? this._visibleLineCountTop.set(Math.min(this._visibleLineCountTop.get() + o - n, this.getMaxVisibleLineCountTop()), i) : this._visibleLineCountBottom.set(Math.min(this._visibleLineCountBottom.get() + n - o, this.getMaxVisibleLineCountBottom()), i);
  }
  collapseAll(e) {
    this._visibleLineCountTop.set(0, e), this._visibleLineCountBottom.set(0, e);
  }
  setState(e, t, i) {
    e = Math.max(Math.min(e, this.lineCount), 0), t = Math.max(Math.min(t, this.lineCount - e), 0), this._visibleLineCountTop.set(e, i), this._visibleLineCountBottom.set(t, i);
  }
}
class nX extends q {
  get visibility() {
    return this._visibility;
  }
  set visibility(e) {
    this._visibility !== e && (this._visibility = e, this._diffActions.style.visibility = e ? "visible" : "hidden");
  }
  constructor(e, t, i, n, o, r, a, l, c) {
    super(), this._getViewZoneId = e, this._marginDomNode = t, this._modifiedEditor = i, this._diff = n, this._editor = o, this._viewLineCounts = r, this._originalTextModel = a, this._contextMenuService = l, this._clipboardService = c, this._visibility = !1, this._marginDomNode.style.zIndex = "10", this._diffActions = document.createElement("div"), this._diffActions.className = Ke.asClassName(re.lightBulb) + " lightbulb-glyph", this._diffActions.style.position = "absolute";
    const h = this._modifiedEditor.getOption(
      67
      /* EditorOption.lineHeight */
    );
    this._diffActions.style.right = "0px", this._diffActions.style.visibility = "hidden", this._diffActions.style.height = `${h}px`, this._diffActions.style.lineHeight = `${h}px`, this._marginDomNode.appendChild(this._diffActions);
    let d = 0;
    const u = i.getOption(
      128
      /* EditorOption.useShadowDOM */
    ) && !fc, f = (g, m) => {
      this._contextMenuService.showContextMenu({
        domForShadowRoot: u ? i.getDomNode() ?? void 0 : void 0,
        getAnchor: () => ({ x: g, y: m }),
        getActions: () => {
          const _ = [], b = n.modified.isEmpty;
          return _.push(new zr("diff.clipboard.copyDeletedContent", b ? n.original.length > 1 ? p("diff.clipboard.copyDeletedLinesContent.label", "Copy deleted lines") : p("diff.clipboard.copyDeletedLinesContent.single.label", "Copy deleted line") : n.original.length > 1 ? p("diff.clipboard.copyChangedLinesContent.label", "Copy changed lines") : p("diff.clipboard.copyChangedLinesContent.single.label", "Copy changed line"), void 0, !0, async () => {
            const v = this._originalTextModel.getValueInRange(n.original.toExclusiveRange());
            await this._clipboardService.writeText(v);
          })), n.original.length > 1 && _.push(new zr("diff.clipboard.copyDeletedLineContent", b ? p("diff.clipboard.copyDeletedLineContent.label", "Copy deleted line ({0})", n.original.startLineNumber + d) : p("diff.clipboard.copyChangedLineContent.label", "Copy changed line ({0})", n.original.startLineNumber + d), void 0, !0, async () => {
            let v = this._originalTextModel.getLineContent(n.original.startLineNumber + d);
            v === "" && (v = this._originalTextModel.getEndOfLineSequence() === 0 ? `
` : `\r
`), await this._clipboardService.writeText(v);
          })), i.getOption(
            92
            /* EditorOption.readOnly */
          ) || _.push(new zr("diff.inline.revertChange", p("diff.inline.revertChange.label", "Revert this change"), void 0, !0, async () => {
            this._editor.revert(this._diff);
          })), _;
        },
        autoSelectFirstItem: !0
      });
    };
    this._register(fi(this._diffActions, "mousedown", (g) => {
      if (!g.leftButton)
        return;
      const { top: m, height: _ } = gs(this._diffActions), b = Math.floor(h / 3);
      g.preventDefault(), f(g.posx, m + _ + b);
    })), this._register(i.onMouseMove((g) => {
      (g.target.type === 8 || g.target.type === 5) && g.target.detail.viewZoneId === this._getViewZoneId() ? (d = this._updateLightBulbPosition(this._marginDomNode, g.event.browserEvent.y, h), this.visibility = !0) : this.visibility = !1;
    })), this._register(i.onMouseDown((g) => {
      g.event.leftButton && (g.target.type === 8 || g.target.type === 5) && g.target.detail.viewZoneId === this._getViewZoneId() && (g.event.preventDefault(), d = this._updateLightBulbPosition(this._marginDomNode, g.event.browserEvent.y, h), f(g.event.posx, g.event.posy + h));
    }));
  }
  _updateLightBulbPosition(e, t, i) {
    const { top: n } = gs(e), o = t - n, r = Math.floor(o / i), a = r * i;
    if (this._diffActions.style.top = `${a}px`, this._viewLineCounts) {
      let l = 0;
      for (let c = 0; c < this._viewLineCounts.length; c++)
        if (l += this._viewLineCounts[c], r < l)
          return c;
    }
    return r;
  }
}
const qT = Pc("diffEditorWidget", { createHTML: (s) => s });
function sX(s, e, t, i) {
  Fi(i, e.fontInfo);
  const n = t.length > 0, o = new bb(1e4);
  let r = 0, a = 0;
  const l = [];
  for (let u = 0; u < s.lineTokens.length; u++) {
    const f = u + 1, g = s.lineTokens[u], m = s.lineBreakData[u], _ = Ns.filter(t, f, 1, Number.MAX_SAFE_INTEGER);
    if (m) {
      let b = 0;
      for (const C of m.breakOffsets) {
        const v = g.sliceAndInflate(b, C, 0);
        r = Math.max(r, jT(a, v, Ns.extractWrapped(_, b, C), n, s.mightContainNonBasicASCII, s.mightContainRTL, e, o)), a++, b = C;
      }
      l.push(m.breakOffsets.length);
    } else
      l.push(1), r = Math.max(r, jT(a, g, _, n, s.mightContainNonBasicASCII, s.mightContainRTL, e, o)), a++;
  }
  r += e.scrollBeyondLastColumn;
  const c = o.build(), h = qT ? qT.createHTML(c) : c;
  i.innerHTML = h;
  const d = r * e.typicalHalfwidthCharacterWidth;
  return {
    heightInLines: a,
    minWidthInPx: d,
    viewLineCounts: l
  };
}
class oX {
  constructor(e, t, i, n) {
    this.lineTokens = e, this.lineBreakData = t, this.mightContainNonBasicASCII = i, this.mightContainRTL = n;
  }
}
class Vx {
  static fromEditor(e) {
    var o;
    const t = e.getOptions(), i = t.get(
      50
      /* EditorOption.fontInfo */
    ), n = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    return new Vx(((o = e.getModel()) == null ? void 0 : o.getOptions().tabSize) || 0, i, t.get(
      33
      /* EditorOption.disableMonospaceOptimizations */
    ), i.typicalHalfwidthCharacterWidth, t.get(
      105
      /* EditorOption.scrollBeyondLastColumn */
    ), t.get(
      67
      /* EditorOption.lineHeight */
    ), n.decorationsWidth, t.get(
      118
      /* EditorOption.stopRenderingLineAfter */
    ), t.get(
      100
      /* EditorOption.renderWhitespace */
    ), t.get(
      95
      /* EditorOption.renderControlCharacters */
    ), t.get(
      51
      /* EditorOption.fontLigatures */
    ));
  }
  constructor(e, t, i, n, o, r, a, l, c, h, d) {
    this.tabSize = e, this.fontInfo = t, this.disableMonospaceOptimizations = i, this.typicalHalfwidthCharacterWidth = n, this.scrollBeyondLastColumn = o, this.lineHeight = r, this.lineDecorationsWidth = a, this.stopRenderingLineAfter = l, this.renderWhitespace = c, this.renderControlCharacters = h, this.fontLigatures = d;
  }
}
function jT(s, e, t, i, n, o, r, a) {
  a.appendString('<div class="view-line'), i || a.appendString(" char-delete"), a.appendString('" style="top:'), a.appendString(String(s * r.lineHeight)), a.appendString('px;width:1000000px;">');
  const l = e.getLineContent(), c = ns.isBasicASCII(l, n), h = ns.containsRTL(l, c, o), d = px(new Gd(
    r.fontInfo.isMonospace && !r.disableMonospaceOptimizations,
    r.fontInfo.canUseHalfwidthRightwardsArrow,
    l,
    !1,
    c,
    h,
    0,
    e,
    t,
    r.tabSize,
    0,
    r.fontInfo.spaceWidth,
    r.fontInfo.middotWidth,
    r.fontInfo.wsmiddotWidth,
    r.stopRenderingLineAfter,
    r.renderWhitespace,
    r.renderControlCharacters,
    r.fontLigatures !== gc.OFF,
    null
    // Send no selections, original line cannot be selected
  ), a);
  return a.appendString("</div>"), d.characterMapping.getHorizontalOffset(d.characterMapping.length);
}
var rX = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, GT = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let YS = class extends q {
  constructor(e, t, i, n, o, r, a, l, c, h) {
    super(), this._targetWindow = e, this._editors = t, this._diffModel = i, this._options = n, this._diffEditorWidget = o, this._canIgnoreViewZoneUpdateEvent = r, this._origViewZonesToIgnore = a, this._modViewZonesToIgnore = l, this._clipboardService = c, this._contextMenuService = h, this._originalTopPadding = $e(this, 0), this._originalScrollOffset = $e(this, 0), this._originalScrollOffsetAnimated = BT(this._targetWindow, this._originalScrollOffset, this._store), this._modifiedTopPadding = $e(this, 0), this._modifiedScrollOffset = $e(this, 0), this._modifiedScrollOffsetAnimated = BT(this._targetWindow, this._modifiedScrollOffset, this._store);
    const d = $e("invalidateAlignmentsState", 0), u = this._register(new sn(() => {
      d.set(d.get() + 1, void 0);
    }, 0));
    this._register(this._editors.original.onDidChangeViewZones((v) => {
      this._canIgnoreViewZoneUpdateEvent() || u.schedule();
    })), this._register(this._editors.modified.onDidChangeViewZones((v) => {
      this._canIgnoreViewZoneUpdateEvent() || u.schedule();
    })), this._register(this._editors.original.onDidChangeConfiguration((v) => {
      (v.hasChanged(
        147
        /* EditorOption.wrappingInfo */
      ) || v.hasChanged(
        67
        /* EditorOption.lineHeight */
      )) && u.schedule();
    })), this._register(this._editors.modified.onDidChangeConfiguration((v) => {
      (v.hasChanged(
        147
        /* EditorOption.wrappingInfo */
      ) || v.hasChanged(
        67
        /* EditorOption.lineHeight */
      )) && u.schedule();
    }));
    const f = this._diffModel.map((v) => v ? Wt(
      this,
      v.model.original.onDidChangeTokens,
      () => v.model.original.tokenization.backgroundTokenizationState === 2
      /* BackgroundTokenizationState.Completed */
    ) : void 0).map((v, w) => v == null ? void 0 : v.read(w)), g = Se((v) => {
      const w = this._diffModel.read(v), S = w == null ? void 0 : w.diff.read(v);
      if (!w || !S)
        return null;
      d.read(v);
      const k = this._options.renderSideBySide.read(v);
      return ZT(this._editors.original, this._editors.modified, S.mappings, this._origViewZonesToIgnore, this._modViewZonesToIgnore, k);
    }), m = Se((v) => {
      var L;
      const w = (L = this._diffModel.read(v)) == null ? void 0 : L.movedTextToCompare.read(v);
      if (!w)
        return null;
      d.read(v);
      const S = w.changes.map((k) => new C5(k));
      return ZT(this._editors.original, this._editors.modified, S, this._origViewZonesToIgnore, this._modViewZonesToIgnore, !0);
    });
    function _() {
      const v = document.createElement("div");
      return v.className = "diagonal-fill", v;
    }
    const b = this._register(new he());
    this.viewZones = $d(this, (v, w) => {
      var ie, me, _e, vt;
      b.clear();
      const S = g.read(v) || [], L = [], k = [], D = this._modifiedTopPadding.read(v);
      D > 0 && k.push({
        afterLineNumber: 0,
        domNode: document.createElement("div"),
        heightInPx: D,
        showInHiddenAreas: !0,
        suppressMouseDown: !0
      });
      const E = this._originalTopPadding.read(v);
      E > 0 && L.push({
        afterLineNumber: 0,
        domNode: document.createElement("div"),
        heightInPx: E,
        showInHiddenAreas: !0,
        suppressMouseDown: !0
      });
      const U = this._options.renderSideBySide.read(v), P = U || (ie = this._editors.modified._getViewModel()) == null ? void 0 : ie.createLineBreaksComputer();
      if (P) {
        const be = this._editors.original.getModel();
        for (const Ze of S)
          if (Ze.diff)
            for (let De = Ze.originalRange.startLineNumber; De < Ze.originalRange.endLineNumberExclusive; De++) {
              if (De > be.getLineCount())
                return { orig: L, mod: k };
              P == null || P.addRequest(be.getLineContent(De), null, null);
            }
      }
      const B = (P == null ? void 0 : P.finalize()) ?? [];
      let W = 0;
      const A = this._editors.modified.getOption(
        67
        /* EditorOption.lineHeight */
      ), K = (me = this._diffModel.read(v)) == null ? void 0 : me.movedTextToCompare.read(v), Y = ((_e = this._editors.original.getModel()) == null ? void 0 : _e.mightContainNonBasicASCII()) ?? !1, Q = ((vt = this._editors.original.getModel()) == null ? void 0 : vt.mightContainRTL()) ?? !1, ne = Vx.fromEditor(this._editors.modified);
      for (const be of S)
        if (be.diff && !U && (!this._options.useTrueInlineDiffRendering.read(v) || !Hx(be.diff))) {
          if (!be.originalRange.isEmpty) {
            f.read(v);
            const De = document.createElement("div");
            De.classList.add("view-lines", "line-delete", "monaco-mouse-cursor-text");
            const mt = this._editors.original.getModel();
            if (be.originalRange.endLineNumberExclusive - 1 > mt.getLineCount())
              return { orig: L, mod: k };
            const Je = new oX(be.originalRange.mapToLineArray((Xt) => mt.tokenization.getLineTokens(Xt)), be.originalRange.mapToLineArray((Xt) => B[W++]), Y, Q), xt = [];
            for (const Xt of be.diff.innerChanges || [])
              xt.push(new rf(
                Xt.originalRange.delta(-(be.diff.original.startLineNumber - 1)),
                KS.className,
                0
                /* InlineDecorationType.Regular */
              ));
            const mi = sX(Je, ne, xt, De), pi = document.createElement("div");
            if (pi.className = "inline-deleted-margin-view-zone", Fi(pi, ne.fontInfo), this._options.renderIndicators.read(v))
              for (let Xt = 0; Xt < mi.heightInLines; Xt++) {
                const vs = document.createElement("div");
                vs.className = `delete-sign ${Ke.asClassName(m5)}`, vs.setAttribute("style", `position:absolute;top:${Xt * A}px;width:${ne.lineDecorationsWidth}px;height:${A}px;right:0;`), pi.appendChild(vs);
              }
            let ws;
            b.add(new nX(() => w2(ws), pi, this._editors.modified, be.diff, this._diffEditorWidget, mi.viewLineCounts, this._editors.original.getModel(), this._contextMenuService, this._clipboardService));
            for (let Xt = 0; Xt < mi.viewLineCounts.length; Xt++) {
              const vs = mi.viewLineCounts[Xt];
              vs > 1 && L.push({
                afterLineNumber: be.originalRange.startLineNumber + Xt,
                domNode: _(),
                heightInPx: (vs - 1) * A,
                showInHiddenAreas: !0,
                suppressMouseDown: !0
              });
            }
            k.push({
              afterLineNumber: be.modifiedRange.startLineNumber - 1,
              domNode: De,
              heightInPx: mi.heightInLines * A,
              minWidthInPx: mi.minWidthInPx,
              marginDomNode: pi,
              setZoneId(Xt) {
                ws = Xt;
              },
              showInHiddenAreas: !0,
              suppressMouseDown: !0
            });
          }
          const Ze = document.createElement("div");
          Ze.className = "gutter-delete", L.push({
            afterLineNumber: be.originalRange.endLineNumberExclusive - 1,
            domNode: _(),
            heightInPx: be.modifiedHeightInPx,
            marginDomNode: Ze,
            showInHiddenAreas: !0,
            suppressMouseDown: !0
          });
        } else {
          const Ze = be.modifiedHeightInPx - be.originalHeightInPx;
          if (Ze > 0) {
            if (K != null && K.lineRangeMapping.original.delta(-1).deltaLength(2).contains(be.originalRange.endLineNumberExclusive - 1))
              continue;
            L.push({
              afterLineNumber: be.originalRange.endLineNumberExclusive - 1,
              domNode: _(),
              heightInPx: Ze,
              showInHiddenAreas: !0,
              suppressMouseDown: !0
            });
          } else {
            let De = function() {
              const Je = document.createElement("div");
              return Je.className = "arrow-revert-change " + Ke.asClassName(re.arrowRight), w.add($(Je, "mousedown", (xt) => xt.stopPropagation())), w.add($(Je, "click", (xt) => {
                xt.stopPropagation(), o.revert(be.diff);
              })), pe("div", {}, Je);
            };
            if (K != null && K.lineRangeMapping.modified.delta(-1).deltaLength(2).contains(be.modifiedRange.endLineNumberExclusive - 1))
              continue;
            let mt;
            be.diff && be.diff.modified.isEmpty && this._options.shouldRenderOldRevertArrows.read(v) && (mt = De()), k.push({
              afterLineNumber: be.modifiedRange.endLineNumberExclusive - 1,
              domNode: _(),
              heightInPx: -Ze,
              marginDomNode: mt,
              showInHiddenAreas: !0,
              suppressMouseDown: !0
            });
          }
        }
      for (const be of m.read(v) ?? []) {
        if (!(K != null && K.lineRangeMapping.original.intersect(be.originalRange)) || !(K != null && K.lineRangeMapping.modified.intersect(be.modifiedRange)))
          continue;
        const Ze = be.modifiedHeightInPx - be.originalHeightInPx;
        Ze > 0 ? L.push({
          afterLineNumber: be.originalRange.endLineNumberExclusive - 1,
          domNode: _(),
          heightInPx: Ze,
          showInHiddenAreas: !0,
          suppressMouseDown: !0
        }) : k.push({
          afterLineNumber: be.modifiedRange.endLineNumberExclusive - 1,
          domNode: _(),
          heightInPx: -Ze,
          showInHiddenAreas: !0,
          suppressMouseDown: !0
        });
      }
      return { orig: L, mod: k };
    });
    let C = !1;
    this._register(this._editors.original.onDidScrollChange((v) => {
      v.scrollLeftChanged && !C && (C = !0, this._editors.modified.setScrollLeft(v.scrollLeft), C = !1);
    })), this._register(this._editors.modified.onDidScrollChange((v) => {
      v.scrollLeftChanged && !C && (C = !0, this._editors.original.setScrollLeft(v.scrollLeft), C = !1);
    })), this._originalScrollTop = Wt(this._editors.original.onDidScrollChange, () => (
      /** @description original.getScrollTop */
      this._editors.original.getScrollTop()
    )), this._modifiedScrollTop = Wt(this._editors.modified.onDidScrollChange, () => (
      /** @description modified.getScrollTop */
      this._editors.modified.getScrollTop()
    )), this._register(Qe((v) => {
      const w = this._originalScrollTop.read(v) - (this._originalScrollOffsetAnimated.get() - this._modifiedScrollOffsetAnimated.read(v)) - (this._originalTopPadding.get() - this._modifiedTopPadding.read(v));
      w !== this._editors.modified.getScrollTop() && this._editors.modified.setScrollTop(
        w,
        1
        /* ScrollType.Immediate */
      );
    })), this._register(Qe((v) => {
      const w = this._modifiedScrollTop.read(v) - (this._modifiedScrollOffsetAnimated.get() - this._originalScrollOffsetAnimated.read(v)) - (this._modifiedTopPadding.get() - this._originalTopPadding.read(v));
      w !== this._editors.original.getScrollTop() && this._editors.original.setScrollTop(
        w,
        1
        /* ScrollType.Immediate */
      );
    })), this._register(Qe((v) => {
      var L;
      const w = (L = this._diffModel.read(v)) == null ? void 0 : L.movedTextToCompare.read(v);
      let S = 0;
      if (w) {
        const k = this._editors.original.getTopForLineNumber(w.lineRangeMapping.original.startLineNumber, !0) - this._originalTopPadding.get();
        S = this._editors.modified.getTopForLineNumber(w.lineRangeMapping.modified.startLineNumber, !0) - this._modifiedTopPadding.get() - k;
      }
      S > 0 ? (this._modifiedTopPadding.set(0, void 0), this._originalTopPadding.set(S, void 0)) : S < 0 ? (this._modifiedTopPadding.set(-S, void 0), this._originalTopPadding.set(0, void 0)) : setTimeout(() => {
        this._modifiedTopPadding.set(0, void 0), this._originalTopPadding.set(0, void 0);
      }, 400), this._editors.modified.hasTextFocus() ? this._originalScrollOffset.set(this._modifiedScrollOffset.get() - S, void 0, !0) : this._modifiedScrollOffset.set(this._originalScrollOffset.get() + S, void 0, !0);
    }));
  }
};
YS = rX([
  GT(8, fx),
  GT(9, ea)
], YS);
function ZT(s, e, t, i, n, o) {
  const r = new Gr(YT(s, i)), a = new Gr(YT(e, n)), l = s.getOption(
    67
    /* EditorOption.lineHeight */
  ), c = e.getOption(
    67
    /* EditorOption.lineHeight */
  ), h = [];
  let d = 0, u = 0;
  function f(g, m) {
    for (; ; ) {
      let _ = r.peek(), b = a.peek();
      if (_ && _.lineNumber >= g && (_ = void 0), b && b.lineNumber >= m && (b = void 0), !_ && !b)
        break;
      const C = _ ? _.lineNumber - d : Number.MAX_VALUE, v = b ? b.lineNumber - u : Number.MAX_VALUE;
      C < v ? (r.dequeue(), b = {
        lineNumber: _.lineNumber - d + u,
        heightInPx: 0
      }) : C > v ? (a.dequeue(), _ = {
        lineNumber: b.lineNumber - u + d,
        heightInPx: 0
      }) : (r.dequeue(), a.dequeue()), h.push({
        originalRange: we.ofLength(_.lineNumber, 1),
        modifiedRange: we.ofLength(b.lineNumber, 1),
        originalHeightInPx: l + _.heightInPx,
        modifiedHeightInPx: c + b.heightInPx,
        diff: void 0
      });
    }
  }
  for (const g of t) {
    let v = function(w, S, L = !1) {
      var P, B;
      if (w < C || S < b)
        return;
      if (_)
        _ = !1;
      else if (!L && (w === C || S === b))
        return;
      const k = new we(C, w), D = new we(b, S);
      if (k.isEmpty && D.isEmpty)
        return;
      const E = ((P = r.takeWhile((W) => W.lineNumber < w)) == null ? void 0 : P.reduce((W, A) => W + A.heightInPx, 0)) ?? 0, U = ((B = a.takeWhile((W) => W.lineNumber < S)) == null ? void 0 : B.reduce((W, A) => W + A.heightInPx, 0)) ?? 0;
      h.push({
        originalRange: k,
        modifiedRange: D,
        originalHeightInPx: k.length * l + E,
        modifiedHeightInPx: D.length * c + U,
        diff: g.lineRangeMapping
      }), C = w, b = S;
    };
    const m = g.lineRangeMapping;
    f(m.original.startLineNumber, m.modified.startLineNumber);
    let _ = !0, b = m.modified.startLineNumber, C = m.original.startLineNumber;
    if (o)
      for (const w of m.innerChanges || []) {
        w.originalRange.startColumn > 1 && w.modifiedRange.startColumn > 1 && v(w.originalRange.startLineNumber, w.modifiedRange.startLineNumber);
        const S = s.getModel(), L = w.originalRange.endLineNumber <= S.getLineCount() ? S.getLineMaxColumn(w.originalRange.endLineNumber) : Number.MAX_SAFE_INTEGER;
        w.originalRange.endColumn < L && v(w.originalRange.endLineNumber, w.modifiedRange.endLineNumber);
      }
    v(m.original.endLineNumberExclusive, m.modified.endLineNumberExclusive, !0), d = m.original.endLineNumberExclusive, u = m.modified.endLineNumberExclusive;
  }
  return f(Number.MAX_VALUE, Number.MAX_VALUE), h;
}
function YT(s, e) {
  const t = [], i = [], n = s.getOption(
    147
    /* EditorOption.wrappingInfo */
  ).wrappingColumn !== -1, o = s._getViewModel().coordinatesConverter, r = s.getOption(
    67
    /* EditorOption.lineHeight */
  );
  if (n)
    for (let l = 1; l <= s.getModel().getLineCount(); l++) {
      const c = o.getModelLineViewLineCount(l);
      c > 1 && i.push({ lineNumber: l, heightInPx: r * (c - 1) });
    }
  for (const l of s.getWhitespaces()) {
    if (e.has(l.id))
      continue;
    const c = l.afterLineNumber === 0 ? 0 : o.convertViewPositionToModelPosition(new V(l.afterLineNumber, 1)).lineNumber;
    t.push({ lineNumber: c, heightInPx: l.height });
  }
  return NQ(t, i, (l) => l.lineNumber, (l, c) => ({ lineNumber: l.lineNumber, heightInPx: l.heightInPx + c.heightInPx }));
}
function Hx(s) {
  return s.innerChanges ? s.innerChanges.every((e) => QT(e.modifiedRange) && QT(e.originalRange) || e.originalRange.equalsRange(new R(1, 1, 1, 1))) : !1;
}
function QT(s) {
  return s.startLineNumber === s.endLineNumber;
}
const Df = class Df extends q {
  constructor(e, t, i, n, o) {
    super(), this._rootElement = e, this._diffModel = t, this._originalEditorLayoutInfo = i, this._modifiedEditorLayoutInfo = n, this._editors = o, this._originalScrollTop = Wt(this, this._editors.original.onDidScrollChange, () => this._editors.original.getScrollTop()), this._modifiedScrollTop = Wt(this, this._editors.modified.onDidScrollChange, () => this._editors.modified.getScrollTop()), this._viewZonesChanged = ds("onDidChangeViewZones", this._editors.modified.onDidChangeViewZones), this.width = $e(this, 0), this._modifiedViewZonesChangedSignal = ds("modified.onDidChangeViewZones", this._editors.modified.onDidChangeViewZones), this._originalViewZonesChangedSignal = ds("original.onDidChangeViewZones", this._editors.original.onDidChangeViewZones), this._state = $d(this, (h, d) => {
      var k;
      this._element.replaceChildren();
      const u = this._diffModel.read(h), f = (k = u == null ? void 0 : u.diff.read(h)) == null ? void 0 : k.movedTexts;
      if (!f || f.length === 0) {
        this.width.set(0, void 0);
        return;
      }
      this._viewZonesChanged.read(h);
      const g = this._originalEditorLayoutInfo.read(h), m = this._modifiedEditorLayoutInfo.read(h);
      if (!g || !m) {
        this.width.set(0, void 0);
        return;
      }
      this._modifiedViewZonesChangedSignal.read(h), this._originalViewZonesChangedSignal.read(h);
      const _ = f.map((D) => {
        function E(ne, ie) {
          const me = ie.getTopForLineNumber(ne.startLineNumber, !0), _e = ie.getTopForLineNumber(ne.endLineNumberExclusive, !0);
          return (me + _e) / 2;
        }
        const U = E(D.lineRangeMapping.original, this._editors.original), P = this._originalScrollTop.read(h), B = E(D.lineRangeMapping.modified, this._editors.modified), W = this._modifiedScrollTop.read(h), A = U - P, K = B - W, Y = Math.min(U, B), Q = Math.max(U, B);
        return { range: new xe(Y, Q), from: A, to: K, fromWithoutScroll: U, toWithoutScroll: B, move: D };
      });
      _.sort(V5(Ts((D) => D.fromWithoutScroll > D.toWithoutScroll, H5), Ts((D) => D.fromWithoutScroll > D.toWithoutScroll ? D.fromWithoutScroll : -D.toWithoutScroll, Aa)));
      const b = zx.compute(_.map((D) => D.range)), C = 10, v = g.verticalScrollbarWidth, w = (b.getTrackCount() - 1) * 10 + C * 2, S = v + w + (m.contentLeft - Df.movedCodeBlockPadding);
      let L = 0;
      for (const D of _) {
        const E = b.getTrack(L), U = v + C + E * 10, P = 15, B = 15, W = S, A = m.glyphMarginWidth + m.lineNumbersWidth, K = 18, Y = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        Y.classList.add("arrow-rectangle"), Y.setAttribute("x", `${W - A}`), Y.setAttribute("y", `${D.to - K / 2}`), Y.setAttribute("width", `${A}`), Y.setAttribute("height", `${K}`), this._element.appendChild(Y);
        const Q = document.createElementNS("http://www.w3.org/2000/svg", "g"), ne = document.createElementNS("http://www.w3.org/2000/svg", "path");
        ne.setAttribute("d", `M 0 ${D.from} L ${U} ${D.from} L ${U} ${D.to} L ${W - B} ${D.to}`), ne.setAttribute("fill", "none"), Q.appendChild(ne);
        const ie = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
        ie.classList.add("arrow"), d.add(Qe((me) => {
          ne.classList.toggle("currentMove", D.move === u.activeMovedText.read(me)), ie.classList.toggle("currentMove", D.move === u.activeMovedText.read(me));
        })), ie.setAttribute("points", `${W - B},${D.to - P / 2} ${W},${D.to} ${W - B},${D.to + P / 2}`), Q.appendChild(ie), this._element.appendChild(Q), L++;
      }
      this.width.set(w, void 0);
    }), this._element = document.createElementNS("http://www.w3.org/2000/svg", "svg"), this._element.setAttribute("class", "moved-blocks-lines"), this._rootElement.appendChild(this._element), this._register(ke(() => this._element.remove())), this._register(Qe((h) => {
      const d = this._originalEditorLayoutInfo.read(h), u = this._modifiedEditorLayoutInfo.read(h);
      !d || !u || (this._element.style.left = `${d.width - d.verticalScrollbarWidth}px`, this._element.style.height = `${d.height}px`, this._element.style.width = `${d.verticalScrollbarWidth + d.contentLeft - Df.movedCodeBlockPadding + this.width.read(h)}px`);
    })), this._register(Pb(this._state));
    const r = Se((h) => {
      const d = this._diffModel.read(h), u = d == null ? void 0 : d.diff.read(h);
      return u ? u.movedTexts.map((f) => ({
        move: f,
        original: new Eh(n_(f.lineRangeMapping.original.startLineNumber - 1), 18),
        modified: new Eh(n_(f.lineRangeMapping.modified.startLineNumber - 1), 18)
      })) : [];
    });
    this._register(Q_(this._editors.original, r.map((h) => (
      /** @description movedBlockViewZones.original */
      h.map((d) => d.original)
    )))), this._register(Q_(this._editors.modified, r.map((h) => (
      /** @description movedBlockViewZones.modified */
      h.map((d) => d.modified)
    )))), this._register(so((h, d) => {
      const u = r.read(h);
      for (const f of u)
        d.add(new XT(this._editors.original, f.original, f.move, "original", this._diffModel.get())), d.add(new XT(this._editors.modified, f.modified, f.move, "modified", this._diffModel.get()));
    }));
    const a = ds("original.onDidFocusEditorWidget", (h) => this._editors.original.onDidFocusEditorWidget(() => setTimeout(() => h(void 0), 0))), l = ds("modified.onDidFocusEditorWidget", (h) => this._editors.modified.onDidFocusEditorWidget(() => setTimeout(() => h(void 0), 0)));
    let c = "modified";
    this._register(Rb({
      createEmptyChangeSummary: () => {
      },
      handleChange: (h, d) => (h.didChange(a) && (c = "original"), h.didChange(l) && (c = "modified"), !0)
    }, (h) => {
      a.read(h), l.read(h);
      const d = this._diffModel.read(h);
      if (!d)
        return;
      const u = d.diff.read(h);
      let f;
      if (u && c === "original") {
        const g = this._editors.originalCursor.read(h);
        g && (f = u.movedTexts.find((m) => m.lineRangeMapping.original.contains(g.lineNumber)));
      }
      if (u && c === "modified") {
        const g = this._editors.modifiedCursor.read(h);
        g && (f = u.movedTexts.find((m) => m.lineRangeMapping.modified.contains(g.lineNumber)));
      }
      f !== d.movedTextToCompare.get() && d.movedTextToCompare.set(void 0, void 0), d.setActiveMovedText(f);
    }));
  }
};
Df.movedCodeBlockPadding = 4;
let hd = Df;
class zx {
  static compute(e) {
    const t = [], i = [];
    for (const n of e) {
      let o = t.findIndex((r) => !r.intersectsStrict(n));
      o === -1 && (t.length >= 6 ? o = C9(t, Ts((a) => a.intersectWithRangeLength(n), Aa)) : (o = t.length, t.push(new ek()))), t[o].addRange(n), i.push(o);
    }
    return new zx(t.length, i);
  }
  constructor(e, t) {
    this._trackCount = e, this.trackPerLineIdx = t;
  }
  getTrack(e) {
    return this.trackPerLineIdx[e];
  }
  getTrackCount() {
    return this._trackCount;
  }
}
class XT extends Px {
  constructor(e, t, i, n, o) {
    const r = Ue("div.diff-hidden-lines-widget");
    super(e, t, r.root), this._editor = e, this._move = i, this._kind = n, this._diffModel = o, this._nodes = Ue("div.diff-moved-code-block", { style: { marginRight: "4px" } }, [
      Ue("div.text-content@textContent"),
      Ue("div.action-bar@actionBar")
    ]), r.root.appendChild(this._nodes.root);
    const a = Wt(this._editor.onDidLayoutChange, () => this._editor.getLayoutInfo());
    this._register(Qa(this._nodes.root, {
      paddingRight: a.map((u) => u.verticalScrollbarWidth)
    }));
    let l;
    i.changes.length > 0 ? l = this._kind === "original" ? p("codeMovedToWithChanges", "Code moved with changes to line {0}-{1}", this._move.lineRangeMapping.modified.startLineNumber, this._move.lineRangeMapping.modified.endLineNumberExclusive - 1) : p("codeMovedFromWithChanges", "Code moved with changes from line {0}-{1}", this._move.lineRangeMapping.original.startLineNumber, this._move.lineRangeMapping.original.endLineNumberExclusive - 1) : l = this._kind === "original" ? p("codeMovedTo", "Code moved to line {0}-{1}", this._move.lineRangeMapping.modified.startLineNumber, this._move.lineRangeMapping.modified.endLineNumberExclusive - 1) : p("codeMovedFrom", "Code moved from line {0}-{1}", this._move.lineRangeMapping.original.startLineNumber, this._move.lineRangeMapping.original.endLineNumberExclusive - 1);
    const c = this._register(new Kr(this._nodes.actionBar, {
      highlightToggledItems: !0
    })), h = new zr("", l, "", !1);
    c.push(h, { icon: !1, label: !0 });
    const d = new zr("", "Compare", Ke.asClassName(re.compareChanges), !0, () => {
      this._editor.focus(), this._diffModel.movedTextToCompare.set(this._diffModel.movedTextToCompare.get() === i ? void 0 : this._move, void 0);
    });
    this._register(Qe((u) => {
      const f = this._diffModel.movedTextToCompare.read(u) === i;
      d.checked = f;
    })), c.push(d, { icon: !1, label: !0 });
  }
}
class aX extends q {
  constructor(e, t, i, n) {
    super(), this._editors = e, this._diffModel = t, this._options = i, this._decorations = Se(this, (o) => {
      const r = this._diffModel.read(o), a = r == null ? void 0 : r.diff.read(o);
      if (!a)
        return null;
      const l = this._diffModel.read(o).movedTextToCompare.read(o), c = this._options.renderIndicators.read(o), h = this._options.showEmptyDecorations.read(o), d = [], u = [];
      if (!l)
        for (const g of a.mappings)
          if (g.lineRangeMapping.original.isEmpty || d.push({ range: g.lineRangeMapping.original.toInclusiveRange(), options: c ? zT : $T }), g.lineRangeMapping.modified.isEmpty || u.push({ range: g.lineRangeMapping.modified.toInclusiveRange(), options: c ? HT : UT }), g.lineRangeMapping.modified.isEmpty || g.lineRangeMapping.original.isEmpty)
            g.lineRangeMapping.original.isEmpty || d.push({ range: g.lineRangeMapping.original.toInclusiveRange(), options: ZQ }), g.lineRangeMapping.modified.isEmpty || u.push({ range: g.lineRangeMapping.modified.toInclusiveRange(), options: jQ });
          else {
            const m = this._options.useTrueInlineDiffRendering.read(o) && Hx(g.lineRangeMapping);
            for (const _ of g.lineRangeMapping.innerChanges || [])
              if (g.lineRangeMapping.original.contains(_.originalRange.startLineNumber) && d.push({ range: _.originalRange, options: _.originalRange.isEmpty() && h ? YQ : KS }), g.lineRangeMapping.modified.contains(_.modifiedRange.startLineNumber) && u.push({ range: _.modifiedRange, options: _.modifiedRange.isEmpty() && h && !m ? GQ : KT }), m) {
                const b = r.model.original.getValueInRange(_.originalRange);
                u.push({
                  range: _.modifiedRange,
                  options: {
                    description: "deleted-text",
                    before: {
                      content: b,
                      inlineClassName: "inline-deleted-text"
                    },
                    zIndex: 1e5,
                    showIfCollapsed: !0
                  }
                });
              }
          }
      if (l)
        for (const g of l.changes) {
          const m = g.original.toInclusiveRange();
          m && d.push({ range: m, options: c ? zT : $T });
          const _ = g.modified.toInclusiveRange();
          _ && u.push({ range: _, options: c ? HT : UT });
          for (const b of g.innerChanges || [])
            d.push({ range: b.originalRange, options: KS }), u.push({ range: b.modifiedRange, options: KT });
        }
      const f = this._diffModel.read(o).activeMovedText.read(o);
      for (const g of a.movedTexts)
        d.push({
          range: g.lineRangeMapping.original.toInclusiveRange(),
          options: {
            description: "moved",
            blockClassName: "movedOriginal" + (g === f ? " currentMove" : ""),
            blockPadding: [hd.movedCodeBlockPadding, 0, hd.movedCodeBlockPadding, hd.movedCodeBlockPadding]
          }
        }), u.push({
          range: g.lineRangeMapping.modified.toInclusiveRange(),
          options: {
            description: "moved",
            blockClassName: "movedModified" + (g === f ? " currentMove" : ""),
            blockPadding: [4, 0, 4, 4]
          }
        });
      return { originalDecorations: d, modifiedDecorations: u };
    }), this._register(Y_(this._editors.original, this._decorations.map((o) => (o == null ? void 0 : o.originalDecorations) || []))), this._register(Y_(this._editors.modified, this._decorations.map((o) => (o == null ? void 0 : o.modifiedDecorations) || [])));
  }
}
class lX {
  resetSash() {
    this._sashRatio.set(void 0, void 0);
  }
  constructor(e, t) {
    this._options = e, this.dimensions = t, this.sashLeft = Tk(this, (i) => {
      const n = this._sashRatio.read(i) ?? this._options.splitViewDefaultRatio.read(i);
      return this._computeSashLeft(n, i);
    }, (i, n) => {
      const o = this.dimensions.width.get();
      this._sashRatio.set(i / o, n);
    }), this._sashRatio = $e(this, void 0);
  }
  /** @pure */
  _computeSashLeft(e, t) {
    const i = this.dimensions.width.read(t), n = Math.floor(this._options.splitViewDefaultRatio.read(t) * i), o = this._options.enableSplitViewResizing.read(t) ? Math.floor(e * i) : n, r = 100;
    return i <= r * 2 ? n : o < r ? r : o > i - r ? i - r : o;
  }
}
class w5 extends q {
  constructor(e, t, i, n, o, r) {
    super(), this._domNode = e, this._dimensions = t, this._enabled = i, this._boundarySashes = n, this.sashLeft = o, this._resetSash = r, this._sash = this._register(new cs(this._domNode, {
      getVerticalSashTop: (a) => 0,
      getVerticalSashLeft: (a) => this.sashLeft.get(),
      getVerticalSashHeight: (a) => this._dimensions.height.get()
    }, {
      orientation: 0
      /* Orientation.VERTICAL */
    })), this._startSashPosition = void 0, this._register(this._sash.onDidStart(() => {
      this._startSashPosition = this.sashLeft.get();
    })), this._register(this._sash.onDidChange((a) => {
      this.sashLeft.set(this._startSashPosition + (a.currentX - a.startX), void 0);
    })), this._register(this._sash.onDidEnd(() => this._sash.layout())), this._register(this._sash.onDidReset(() => this._resetSash())), this._register(Qe((a) => {
      const l = this._boundarySashes.read(a);
      l && (this._sash.orthogonalEndSash = l.bottom);
    })), this._register(Qe((a) => {
      const l = this._enabled.read(a);
      this._sash.state = l ? 3 : 0, this.sashLeft.read(a), this._dimensions.height.read(a), this._sash.layout();
    }));
  }
}
class cX extends q {
  constructor(e, t, i) {
    super(), this._editor = e, this._domNode = t, this.itemProvider = i, this.scrollTop = Wt(this, this._editor.onDidScrollChange, (r) => (
      /** @description editor.onDidScrollChange */
      this._editor.getScrollTop()
    )), this.isScrollTopZero = this.scrollTop.map((r) => (
      /** @description isScrollTopZero */
      r === 0
    )), this.modelAttached = Wt(this, this._editor.onDidChangeModel, (r) => (
      /** @description editor.onDidChangeModel */
      this._editor.hasModel()
    )), this.editorOnDidChangeViewZones = ds("onDidChangeViewZones", this._editor.onDidChangeViewZones), this.editorOnDidContentSizeChange = ds("onDidContentSizeChange", this._editor.onDidContentSizeChange), this.domNodeSizeChanged = Mk("domNodeSizeChanged"), this.views = /* @__PURE__ */ new Map(), this._domNode.className = "gutter monaco-editor";
    const n = this._domNode.appendChild(Ue("div.scroll-decoration", { role: "presentation", ariaHidden: "true", style: { width: "100%" } }).root), o = new ResizeObserver(() => {
      ni((r) => {
        this.domNodeSizeChanged.trigger(r);
      });
    });
    o.observe(this._domNode), this._register(ke(() => o.disconnect())), this._register(Qe((r) => {
      n.className = this.isScrollTopZero.read(r) ? "" : "scroll-decoration";
    })), this._register(Qe((r) => (
      /** @description EditorGutter.Render */
      this.render(r)
    )));
  }
  dispose() {
    super.dispose(), on(this._domNode);
  }
  render(e) {
    if (!this.modelAttached.read(e))
      return;
    this.domNodeSizeChanged.read(e), this.editorOnDidChangeViewZones.read(e), this.editorOnDidContentSizeChange.read(e);
    const t = this.scrollTop.read(e), i = this._editor.getVisibleRanges(), n = new Set(this.views.keys()), o = xe.ofStartAndLength(0, this._domNode.clientHeight);
    if (!o.isEmpty)
      for (const r of i) {
        const a = new we(r.startLineNumber, r.endLineNumber + 1), l = this.itemProvider.getIntersectingGutterItems(a, e);
        ni((c) => {
          for (const h of l) {
            if (!h.range.intersect(a))
              continue;
            n.delete(h.id);
            let d = this.views.get(h.id);
            if (d)
              d.item.set(h, c);
            else {
              const m = document.createElement("div");
              this._domNode.appendChild(m);
              const _ = $e("item", h), b = this.itemProvider.createView(_, m);
              d = new hX(_, b, m), this.views.set(h.id, d);
            }
            const u = h.range.startLineNumber <= this._editor.getModel().getLineCount() ? this._editor.getTopForLineNumber(h.range.startLineNumber, !0) - t : this._editor.getBottomForLineNumber(h.range.startLineNumber - 1, !1) - t, g = (h.range.endLineNumberExclusive === 1 ? Math.max(u, this._editor.getTopForLineNumber(h.range.startLineNumber, !1) - t) : Math.max(u, this._editor.getBottomForLineNumber(h.range.endLineNumberExclusive - 1, !0) - t)) - u;
            d.domNode.style.top = `${u}px`, d.domNode.style.height = `${g}px`, d.gutterItemView.layout(xe.ofStartAndLength(u, g), o);
          }
        });
      }
    for (const r of n) {
      const a = this.views.get(r);
      a.gutterItemView.dispose(), a.domNode.remove(), this.views.delete(r);
    }
  }
}
class hX {
  constructor(e, t, i) {
    this.item = e, this.gutterItemView = t, this.domNode = i;
  }
}
class v5 extends _c {
  constructor(e) {
    super(), this._getContext = e;
  }
  runAction(e, t) {
    const i = this._getContext();
    return super.runAction(e, i);
  }
}
class JT extends JM {
  constructor(e) {
    super(), this._textModel = e;
  }
  getValueOfRange(e) {
    return this._textModel.getValueInRange(e);
  }
  get length() {
    const e = this._textModel.getLineCount(), t = this._textModel.getLineLength(e);
    return new qa(e - 1, t);
  }
}
class dX extends q {
  constructor(e, t, i = {
    orientation: 0
    /* ActionsOrientation.HORIZONTAL */
  }) {
    super(), this.submenuActionViewItems = [], this.hasSecondaryActions = !1, this._onDidChangeDropdownVisibility = this._register(new uO()), this.onDidChangeDropdownVisibility = this._onDidChangeDropdownVisibility.event, this.disposables = this._register(new he()), i.hoverDelegate = i.hoverDelegate ?? this._register(Rk()), this.options = i, this.toggleMenuAction = this._register(new mg(() => {
      var n;
      return (n = this.toggleMenuActionViewItem) == null ? void 0 : n.show();
    }, i.toggleMenuTitle)), this.element = document.createElement("div"), this.element.className = "monaco-toolbar", e.appendChild(this.element), this.actionBar = this._register(new Kr(this.element, {
      orientation: i.orientation,
      ariaLabel: i.ariaLabel,
      actionRunner: i.actionRunner,
      allowContextMenu: i.allowContextMenu,
      highlightToggledItems: i.highlightToggledItems,
      hoverDelegate: i.hoverDelegate,
      actionViewItemProvider: (n, o) => {
        if (n.id === mg.ID)
          return this.toggleMenuActionViewItem = new o_(n, n.menuActions, t, {
            actionViewItemProvider: this.options.actionViewItemProvider,
            actionRunner: this.actionRunner,
            keybindingProvider: this.options.getKeyBinding,
            classNames: Ke.asClassNameArray(i.moreIcon ?? re.toolBarMore),
            anchorAlignmentProvider: this.options.anchorAlignmentProvider,
            menuAsChild: !!this.options.renderDropdownAsChildElement,
            skipTelemetry: this.options.skipTelemetry,
            isMenu: !0,
            hoverDelegate: this.options.hoverDelegate
          }), this.toggleMenuActionViewItem.setActionContext(this.actionBar.context), this.disposables.add(this._onDidChangeDropdownVisibility.add(this.toggleMenuActionViewItem.onDidChangeVisibility)), this.toggleMenuActionViewItem;
        if (i.actionViewItemProvider) {
          const r = i.actionViewItemProvider(n, o);
          if (r)
            return r;
        }
        if (n instanceof lb) {
          const r = new o_(n, n.actions, t, {
            actionViewItemProvider: this.options.actionViewItemProvider,
            actionRunner: this.actionRunner,
            keybindingProvider: this.options.getKeyBinding,
            classNames: n.class,
            anchorAlignmentProvider: this.options.anchorAlignmentProvider,
            menuAsChild: !!this.options.renderDropdownAsChildElement,
            skipTelemetry: this.options.skipTelemetry,
            hoverDelegate: this.options.hoverDelegate
          });
          return r.setActionContext(this.actionBar.context), this.submenuActionViewItems.push(r), this.disposables.add(this._onDidChangeDropdownVisibility.add(r.onDidChangeVisibility)), r;
        }
      }
    }));
  }
  set actionRunner(e) {
    this.actionBar.actionRunner = e;
  }
  get actionRunner() {
    return this.actionBar.actionRunner;
  }
  getElement() {
    return this.element;
  }
  getItemAction(e) {
    return this.actionBar.getAction(e);
  }
  setActions(e, t) {
    this.clear();
    const i = e ? e.slice(0) : [];
    this.hasSecondaryActions = !!(t && t.length > 0), this.hasSecondaryActions && t && (this.toggleMenuAction.menuActions = t.slice(0), i.push(this.toggleMenuAction)), i.forEach((n) => {
      this.actionBar.push(n, { icon: this.options.icon ?? !0, label: this.options.label ?? !1, keybinding: this.getKeybindingLabel(n) });
    });
  }
  getKeybindingLabel(e) {
    var i, n;
    const t = (n = (i = this.options).getKeyBinding) == null ? void 0 : n.call(i, e);
    return (t == null ? void 0 : t.getLabel()) ?? void 0;
  }
  clear() {
    this.submenuActionViewItems = [], this.disposables.clear(), this.actionBar.clear();
  }
  dispose() {
    this.clear(), this.disposables.dispose(), super.dispose();
  }
}
const G1 = class G1 extends zr {
  constructor(e, t) {
    t = t || p("moreActions", "More Actions..."), super(G1.ID, t, void 0, !0), this._menuActions = [], this.toggleDropdownMenu = e;
  }
  async run() {
    this.toggleDropdownMenu();
  }
  get menuActions() {
    return this._menuActions;
  }
  set menuActions(e) {
    this._menuActions = e;
  }
};
G1.ID = "toolbar.toggle.more";
let mg = G1;
var y5 = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Ds = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let QS = class extends dX {
  constructor(e, t, i, n, o, r, a, l) {
    super(e, o, {
      // defaults
      getKeyBinding: (h) => r.lookupKeybinding(h.id) ?? void 0,
      // options (override defaults)
      ...t,
      // mandatory (overide options)
      allowContextMenu: !0,
      skipTelemetry: typeof (t == null ? void 0 : t.telemetrySource) == "string"
    }), this._options = t, this._menuService = i, this._contextKeyService = n, this._contextMenuService = o, this._keybindingService = r, this._commandService = a, this._sessionDisposables = this._store.add(new he());
    const c = t == null ? void 0 : t.telemetrySource;
    c && this._store.add(this.actionBar.onDidRun((h) => l.publicLog2("workbenchActionExecuted", { id: h.action.id, from: c })));
  }
  setActions(e, t = [], i) {
    var h, d, u;
    this._sessionDisposables.clear();
    const n = e.slice(), o = t.slice(), r = [];
    let a = 0;
    const l = [];
    let c = !1;
    if (((h = this._options) == null ? void 0 : h.hiddenItemStrategy) !== -1)
      for (let f = 0; f < n.length; f++) {
        const g = n[f];
        !(g instanceof Ur) && !(g instanceof zu) || g.hideActions && (r.push(g.hideActions.toggle), g.hideActions.toggle.checked && a++, g.hideActions.isHidden && (c = !0, n[f] = void 0, ((d = this._options) == null ? void 0 : d.hiddenItemStrategy) !== 0 && (l[f] = g)));
      }
    if (((u = this._options) == null ? void 0 : u.overflowBehavior) !== void 0) {
      const f = rU(new Set(this._options.overflowBehavior.exempted), Ye.map(n, (_) => _ == null ? void 0 : _.id)), g = this._options.overflowBehavior.maxItems - f.size;
      let m = 0;
      for (let _ = 0; _ < n.length; _++) {
        const b = n[_];
        b && (m++, !f.has(b.id) && m >= g && (n[_] = void 0, l[_] = b));
      }
    }
    Yx(n), Yx(l), super.setActions(n, Zi.join(l, o)), (r.length > 0 || n.length > 0) && this._sessionDisposables.add($(this.getElement(), "contextmenu", (f) => {
      var C, v, w, S, L;
      const g = new to(ue(this.getElement()), f), m = this.getItemAction(g.target);
      if (!m)
        return;
      g.preventDefault(), g.stopPropagation();
      const _ = [];
      if (m instanceof Ur && m.menuKeybinding)
        _.push(m.menuKeybinding);
      else if (!(m instanceof zu || m instanceof mg)) {
        const k = !!this._keybindingService.lookupKeybinding(m.id);
        _.push(V4(this._commandService, this._keybindingService, m.id, void 0, k));
      }
      if (r.length > 0) {
        let k = !1;
        if (a === 1 && ((C = this._options) == null ? void 0 : C.hiddenItemStrategy) === 0) {
          k = !0;
          for (let D = 0; D < r.length; D++)
            if (r[D].checked) {
              r[D] = $h({
                id: m.id,
                label: m.label,
                checked: !0,
                enabled: !1,
                run() {
                }
              });
              break;
            }
        }
        if (!k && (m instanceof Ur || m instanceof zu)) {
          if (!m.hideActions)
            return;
          _.push(m.hideActions.hide);
        } else
          _.push($h({
            id: "label",
            label: p("hide", "Hide"),
            enabled: !1,
            run() {
            }
          }));
      }
      const b = Zi.join(_, r);
      (v = this._options) != null && v.resetMenu && !i && (i = [this._options.resetMenu]), c && i && (b.push(new Zi()), b.push($h({
        id: "resetThisMenu",
        label: p("resetThisMenu", "Reset Menu"),
        run: () => this._menuService.resetHiddenStates(i)
      }))), b.length !== 0 && this._contextMenuService.showContextMenu({
        getAnchor: () => g,
        getActions: () => b,
        // add context menu actions (iff appicable)
        menuId: (w = this._options) == null ? void 0 : w.contextMenu,
        menuActionOptions: { renderShortTitle: !0, ...(S = this._options) == null ? void 0 : S.menuOptions },
        skipTelemetry: typeof ((L = this._options) == null ? void 0 : L.telemetrySource) == "string",
        contextKeyService: this._contextKeyService
      });
    }));
  }
};
QS = y5([
  Ds(2, Rc),
  Ds(3, nt),
  Ds(4, ea),
  Ds(5, Ai),
  Ds(6, ss),
  Ds(7, Ac)
], QS);
let J_ = class extends QS {
  constructor(e, t, i, n, o, r, a, l, c) {
    super(e, { resetMenu: t, ...i }, n, o, r, a, l, c), this._onDidChangeMenuItems = this._store.add(new O()), this.onDidChangeMenuItems = this._onDidChangeMenuItems.event;
    const h = this._store.add(n.createMenu(t, o, { emitEventsForSubmenuChanges: !0 })), d = () => {
      var g, m, _;
      const u = [], f = [];
      pz(h, i == null ? void 0 : i.menuOptions, { primary: u, secondary: f }, (g = i == null ? void 0 : i.toolbarOptions) == null ? void 0 : g.primaryGroup, (m = i == null ? void 0 : i.toolbarOptions) == null ? void 0 : m.shouldInlineSubmenu, (_ = i == null ? void 0 : i.toolbarOptions) == null ? void 0 : _.useSeparatorsInPrimaryActions), e.classList.toggle("has-no-actions", u.length === 0 && f.length === 0), super.setActions(u, f);
    };
    this._store.add(h.onDidChange(() => {
      d(), this._onDidChangeMenuItems.fire(this);
    })), d();
  }
  /**
   * @deprecated The WorkbenchToolBar does not support this method because it works with menus.
   */
  setActions() {
    throw new it("This toolbar is populated from a menu.");
  }
};
J_ = y5([
  Ds(3, Rc),
  Ds(4, nt),
  Ds(5, ea),
  Ds(6, Ai),
  Ds(7, ss),
  Ds(8, Ac)
], J_);
var S5 = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, gp = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const kC = [], Vm = 35;
let XS = class extends q {
  constructor(e, t, i, n, o, r, a, l, c) {
    super(), this._diffModel = t, this._editors = i, this._options = n, this._sashLayout = o, this._boundarySashes = r, this._instantiationService = a, this._contextKeyService = l, this._menuService = c, this._menu = this._register(this._menuService.createMenu(Ti.DiffEditorHunkToolbar, this._contextKeyService)), this._actions = Wt(this, this._menu.onDidChange, () => this._menu.getActions()), this._hasActions = this._actions.map((h) => h.length > 0), this._showSash = Se(this, (h) => this._options.renderSideBySide.read(h) && this._hasActions.read(h)), this.width = Se(this, (h) => this._hasActions.read(h) ? Vm : 0), this.elements = Ue("div.gutter@gutter", { style: { position: "absolute", height: "100%", width: Vm + "px" } }, []), this._currentDiff = Se(this, (h) => {
      var g;
      const d = this._diffModel.read(h);
      if (!d)
        return;
      const u = (g = d.diff.read(h)) == null ? void 0 : g.mappings, f = this._editors.modifiedCursor.read(h);
      if (f)
        return u == null ? void 0 : u.find((m) => m.lineRangeMapping.modified.contains(f.lineNumber));
    }), this._selectedDiffs = Se(this, (h) => {
      const d = this._diffModel.read(h), u = d == null ? void 0 : d.diff.read(h);
      if (!u)
        return kC;
      const f = this._editors.modifiedSelections.read(h);
      if (f.every((b) => b.isEmpty()))
        return kC;
      const g = new hs(f.map((b) => we.fromRangeInclusive(b))), _ = u.mappings.filter((b) => b.lineRangeMapping.innerChanges && g.intersects(b.lineRangeMapping.modified)).map((b) => ({
        mapping: b,
        rangeMappings: b.lineRangeMapping.innerChanges.filter((C) => f.some((v) => R.areIntersecting(C.modifiedRange, v)))
      }));
      return _.length === 0 || _.every((b) => b.rangeMappings.length === 0) ? kC : _;
    }), this._register(TQ(e, this.elements.root)), this._register($(this.elements.root, "click", () => {
      this._editors.modified.focus();
    })), this._register(Qa(this.elements.root, { display: this._hasActions.map((h) => h ? "block" : "none") })), ko(this, (h) => this._showSash.read(h) ? new w5(e, this._sashLayout.dimensions, this._options.enableSplitViewResizing, this._boundarySashes, Tk(this, (u) => this._sashLayout.sashLeft.read(u) - Vm, (u, f) => this._sashLayout.sashLeft.set(u + Vm, f)), () => this._sashLayout.resetSash()) : void 0).recomputeInitiallyAndOnChange(this._store), this._register(new cX(this._editors.modified, this.elements.root, {
      getIntersectingGutterItems: (h, d) => {
        const u = this._diffModel.read(d);
        if (!u)
          return [];
        const f = u.diff.read(d);
        if (!f)
          return [];
        const g = this._selectedDiffs.read(d);
        if (g.length > 0) {
          const _ = is.fromRangeMappings(g.flatMap((b) => b.rangeMappings));
          return [
            new e2(_, !0, Ti.DiffEditorSelectionToolbar, void 0, u.model.original.uri, u.model.modified.uri)
          ];
        }
        const m = this._currentDiff.read(d);
        return f.mappings.map((_) => new e2(_.lineRangeMapping.withInnerChangesFromLineRanges(), _.lineRangeMapping === (m == null ? void 0 : m.lineRangeMapping), Ti.DiffEditorHunkToolbar, void 0, u.model.original.uri, u.model.modified.uri));
      },
      createView: (h, d) => this._instantiationService.createInstance(JS, h, d, this)
    })), this._register($(this.elements.gutter, ee.MOUSE_WHEEL, (h) => {
      this._editors.modified.getOption(
        104
        /* EditorOption.scrollbar */
      ).handleMouseWheel && this._editors.modified.delegateScrollFromMouseWheelEvent(h);
    }, { passive: !1 }));
  }
  computeStagedValue(e) {
    const t = e.innerChanges ?? [], i = new JT(this._editors.modifiedModel.get()), n = new JT(this._editors.original.getModel());
    return new v9(t.map((a) => a.toTextEdit(i))).apply(n);
  }
  layout(e) {
    this.elements.gutter.style.left = e + "px";
  }
};
XS = S5([
  gp(6, ot),
  gp(7, nt),
  gp(8, Rc)
], XS);
class e2 {
  constructor(e, t, i, n, o, r) {
    this.mapping = e, this.showAlways = t, this.menuId = i, this.rangeOverride = n, this.originalUri = o, this.modifiedUri = r;
  }
  get id() {
    return this.mapping.modified.toString();
  }
  get range() {
    return this.rangeOverride ?? this.mapping.modified;
  }
}
let JS = class extends q {
  constructor(e, t, i, n) {
    super(), this._item = e, this._elements = Ue("div.gutterItem", { style: { height: "20px", width: "34px" } }, [
      Ue("div.background@background", {}, []),
      Ue("div.buttons@buttons", {}, [])
    ]), this._showAlways = this._item.map(this, (r) => r.showAlways), this._menuId = this._item.map(this, (r) => r.menuId), this._isSmall = $e(this, !1), this._lastItemRange = void 0, this._lastViewRange = void 0;
    const o = this._register(n.createInstance(Kf, "element", !0, { position: {
      hoverPosition: 1
      /* HoverPosition.RIGHT */
    } }));
    this._register(Pu(t, this._elements.root)), this._register(Qe((r) => {
      const a = this._showAlways.read(r);
      this._elements.root.classList.toggle("noTransition", !0), this._elements.root.classList.toggle("showAlways", a), setTimeout(() => {
        this._elements.root.classList.toggle("noTransition", !1);
      }, 0);
    })), this._register(so((r, a) => {
      this._elements.buttons.replaceChildren();
      const l = a.add(n.createInstance(J_, this._elements.buttons, this._menuId.read(r), {
        orientation: 1,
        hoverDelegate: o,
        toolbarOptions: {
          primaryGroup: (c) => c.startsWith("primary")
        },
        overflowBehavior: { maxItems: this._isSmall.read(r) ? 1 : 3 },
        hiddenItemStrategy: 0,
        actionRunner: new v5(() => {
          const c = this._item.get(), h = c.mapping;
          return {
            mapping: h,
            originalWithModifiedChanges: i.computeStagedValue(h),
            originalUri: c.originalUri,
            modifiedUri: c.modifiedUri
          };
        }),
        menuOptions: {
          shouldForwardArgs: !0
        }
      }));
      a.add(l.onDidChangeMenuItems(() => {
        this._lastItemRange && this.layout(this._lastItemRange, this._lastViewRange);
      }));
    }));
  }
  layout(e, t) {
    this._lastItemRange = e, this._lastViewRange = t;
    let i = this._elements.buttons.clientHeight;
    this._isSmall.set(this._item.get().mapping.original.startLineNumber === 1 && e.length < 30, void 0), i = this._elements.buttons.clientHeight;
    const n = e.length / 2 - i / 2, o = i;
    let r = e.start + n;
    const a = xe.tryCreate(o, t.endExclusive - o - i), l = xe.tryCreate(e.start + o, e.endExclusive - i - o);
    l && a && l.start < l.endExclusive && (r = a.clip(r), r = l.clip(r)), this._elements.buttons.style.top = `${r - e.start}px`;
  }
};
JS = S5([
  gp(3, ot)
], JS);
function pg(s) {
  return eL.get(s);
}
const ba = class ba extends q {
  /**
   * Make sure that editor is not disposed yet!
  */
  static get(e) {
    let t = ba._map.get(e);
    if (!t) {
      t = new ba(e), ba._map.set(e, t);
      const i = e.onDidDispose(() => {
        const n = ba._map.get(e);
        n && (ba._map.delete(e), n.dispose(), i.dispose());
      });
    }
    return t;
  }
  _beginUpdate() {
    this._updateCounter++, this._updateCounter === 1 && (this._currentTransaction = new Fg(() => {
    }));
  }
  _endUpdate() {
    if (this._updateCounter--, this._updateCounter === 0) {
      const e = this._currentTransaction;
      this._currentTransaction = void 0, e.finish();
    }
  }
  constructor(e) {
    var t;
    super(), this.editor = e, this._updateCounter = 0, this._currentTransaction = void 0, this._model = $e(this, this.editor.getModel()), this.model = this._model, this.isReadonly = Wt(this, this.editor.onDidChangeConfiguration, () => this.editor.getOption(
      92
      /* EditorOption.readOnly */
    )), this._versionId = ry({ owner: this, lazy: !0 }, ((t = this.editor.getModel()) == null ? void 0 : t.getVersionId()) ?? null), this.versionId = this._versionId, this._selections = ry({ owner: this, equalsFn: PI(sH(ft.selectionsEqual)), lazy: !0 }, this.editor.getSelections() ?? null), this.selections = this._selections, this.isFocused = Wt(this, (i) => {
      const n = this.editor.onDidFocusEditorWidget(i), o = this.editor.onDidBlurEditorWidget(i);
      return {
        dispose() {
          n.dispose(), o.dispose();
        }
      };
    }, () => this.editor.hasWidgetFocus()), this.value = Tk(this, (i) => {
      var n;
      return this.versionId.read(i), ((n = this.model.read(i)) == null ? void 0 : n.getValue()) ?? "";
    }, (i, n) => {
      const o = this.model.get();
      o !== null && i !== o.getValue() && o.setValue(i);
    }), this.valueIsEmpty = Se(this, (i) => {
      var n;
      return this.versionId.read(i), ((n = this.editor.getModel()) == null ? void 0 : n.getValueLength()) === 0;
    }), this.cursorSelection = Tb({ owner: this, equalsFn: PI(ft.selectionsEqual) }, (i) => {
      var n;
      return ((n = this.selections.read(i)) == null ? void 0 : n[0]) ?? null;
    }), this.onDidType = Mk(this), this.scrollTop = Wt(this.editor.onDidScrollChange, () => this.editor.getScrollTop()), this.scrollLeft = Wt(this.editor.onDidScrollChange, () => this.editor.getScrollLeft()), this.layoutInfo = Wt(this.editor.onDidLayoutChange, () => this.editor.getLayoutInfo()), this.layoutInfoContentLeft = this.layoutInfo.map((i) => i.contentLeft), this.layoutInfoDecorationsLeft = this.layoutInfo.map((i) => i.decorationsLeft), this.contentWidth = Wt(this.editor.onDidContentSizeChange, () => this.editor.getContentWidth()), this._overlayWidgetCounter = 0, this._register(this.editor.onBeginUpdate(() => this._beginUpdate())), this._register(this.editor.onEndUpdate(() => this._endUpdate())), this._register(this.editor.onDidChangeModel(() => {
      this._beginUpdate();
      try {
        this._model.set(this.editor.getModel(), this._currentTransaction), this._forceUpdate();
      } finally {
        this._endUpdate();
      }
    })), this._register(this.editor.onDidType((i) => {
      this._beginUpdate();
      try {
        this._forceUpdate(), this.onDidType.trigger(this._currentTransaction, i);
      } finally {
        this._endUpdate();
      }
    })), this._register(this.editor.onDidChangeModelContent((i) => {
      var n;
      this._beginUpdate();
      try {
        this._versionId.set(((n = this.editor.getModel()) == null ? void 0 : n.getVersionId()) ?? null, this._currentTransaction, i), this._forceUpdate();
      } finally {
        this._endUpdate();
      }
    })), this._register(this.editor.onDidChangeCursorSelection((i) => {
      this._beginUpdate();
      try {
        this._selections.set(this.editor.getSelections(), this._currentTransaction, i), this._forceUpdate();
      } finally {
        this._endUpdate();
      }
    }));
  }
  forceUpdate(e) {
    this._beginUpdate();
    try {
      return this._forceUpdate(), e ? e(this._currentTransaction) : void 0;
    } finally {
      this._endUpdate();
    }
  }
  _forceUpdate() {
    var e;
    this._beginUpdate();
    try {
      this._model.set(this.editor.getModel(), this._currentTransaction), this._versionId.set(((e = this.editor.getModel()) == null ? void 0 : e.getVersionId()) ?? null, this._currentTransaction, void 0), this._selections.set(this.editor.getSelections(), this._currentTransaction, void 0);
    } finally {
      this._endUpdate();
    }
  }
  getOption(e) {
    return Wt(this, (t) => this.editor.onDidChangeConfiguration((i) => {
      i.hasChanged(e) && t(void 0);
    }), () => this.editor.getOption(e));
  }
  setDecorations(e) {
    const t = new he(), i = this.editor.createDecorationsCollection();
    return t.add(Mb({ owner: this, debugName: () => `Apply decorations from ${e.debugName}` }, (n) => {
      const o = e.read(n);
      i.set(o);
    })), t.add({
      dispose: () => {
        i.clear();
      }
    }), t;
  }
  createOverlayWidget(e) {
    const t = "observableOverlayWidget" + this._overlayWidgetCounter++, i = {
      getDomNode: () => e.domNode,
      getPosition: () => e.position.get(),
      getId: () => t,
      allowEditorOverflow: e.allowEditorOverflow,
      getMinContentWidthInPx: () => e.minContentWidthInPx.get()
    };
    this.editor.addOverlayWidget(i);
    const n = Qe((o) => {
      e.position.read(o), e.minContentWidthInPx.read(o), this.editor.layoutOverlayWidget(i);
    });
    return ke(() => {
      n.dispose(), this.editor.removeOverlayWidget(i);
    });
  }
};
ba._map = /* @__PURE__ */ new Map();
let eL = ba;
var uX = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, fX = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, mp, dc;
let tL = (dc = class extends q {
  static setBreadcrumbsSourceFactory(e) {
    this._breadcrumbsSourceFactory.set(e, void 0);
  }
  get isUpdatingHiddenAreas() {
    return this._isUpdatingHiddenAreas;
  }
  constructor(e, t, i, n) {
    super(), this._editors = e, this._diffModel = t, this._options = i, this._instantiationService = n, this._modifiedOutlineSource = ko(this, (l) => {
      const c = this._editors.modifiedModel.read(l), h = mp._breadcrumbsSourceFactory.read(l);
      return !c || !h ? void 0 : h(c, this._instantiationService);
    }), this._isUpdatingHiddenAreas = !1, this._register(this._editors.original.onDidChangeCursorPosition((l) => {
      if (l.reason === 1)
        return;
      const c = this._diffModel.get();
      ni((h) => {
        for (const d of this._editors.original.getSelections() || [])
          c == null || c.ensureOriginalLineIsVisible(d.getStartPosition().lineNumber, 0, h), c == null || c.ensureOriginalLineIsVisible(d.getEndPosition().lineNumber, 0, h);
      });
    })), this._register(this._editors.modified.onDidChangeCursorPosition((l) => {
      if (l.reason === 1)
        return;
      const c = this._diffModel.get();
      ni((h) => {
        for (const d of this._editors.modified.getSelections() || [])
          c == null || c.ensureModifiedLineIsVisible(d.getStartPosition().lineNumber, 0, h), c == null || c.ensureModifiedLineIsVisible(d.getEndPosition().lineNumber, 0, h);
      });
    }));
    const o = this._diffModel.map((l, c) => {
      var d;
      const h = (l == null ? void 0 : l.unchangedRegions.read(c)) ?? [];
      return h.length === 1 && h[0].modifiedLineNumber === 1 && h[0].lineCount === ((d = this._editors.modifiedModel.read(c)) == null ? void 0 : d.getLineCount()) ? [] : h;
    });
    this.viewZones = $d(this, (l, c) => {
      const h = this._modifiedOutlineSource.read(l);
      if (!h)
        return { origViewZones: [], modViewZones: [] };
      const d = [], u = [], f = this._options.renderSideBySide.read(l), g = this._options.compactMode.read(l), m = o.read(l);
      for (let _ = 0; _ < m.length; _++) {
        const b = m[_];
        if (!b.shouldHideControls(l) && !(g && (_ === 0 || _ === m.length - 1)))
          if (g) {
            {
              const C = Se(this, (w) => (
                /** @description hiddenOriginalRangeStart */
                b.getHiddenOriginalRange(w).startLineNumber - 1
              )), v = new Eh(C, 12);
              d.push(v), c.add(new t2(this._editors.original, v, b, !f));
            }
            {
              const C = Se(this, (w) => (
                /** @description hiddenModifiedRangeStart */
                b.getHiddenModifiedRange(w).startLineNumber - 1
              )), v = new Eh(C, 12);
              u.push(v), c.add(new t2(this._editors.modified, v, b));
            }
          } else {
            {
              const C = Se(this, (w) => (
                /** @description hiddenOriginalRangeStart */
                b.getHiddenOriginalRange(w).startLineNumber - 1
              )), v = new Eh(C, 24);
              d.push(v), c.add(new i2(this._editors.original, v, b, b.originalUnchangedRange, !f, h, (w) => this._diffModel.get().ensureModifiedLineIsVisible(w, 2, void 0), this._options));
            }
            {
              const C = Se(this, (w) => (
                /** @description hiddenModifiedRangeStart */
                b.getHiddenModifiedRange(w).startLineNumber - 1
              )), v = new Eh(C, 24);
              u.push(v), c.add(new i2(this._editors.modified, v, b, b.modifiedUnchangedRange, !1, h, (w) => this._diffModel.get().ensureModifiedLineIsVisible(w, 2, void 0), this._options));
            }
          }
      }
      return { origViewZones: d, modViewZones: u };
    });
    const r = {
      description: "unchanged lines",
      className: "diff-unchanged-lines",
      isWholeLine: !0
    }, a = {
      description: "Fold Unchanged",
      glyphMarginHoverMessage: new sA(void 0, { isTrusted: !0, supportThemeIcons: !0 }).appendMarkdown(p("foldUnchanged", "Fold Unchanged Region")),
      glyphMarginClassName: "fold-unchanged " + Ke.asClassName(re.fold),
      zIndex: 10001
    };
    this._register(Y_(this._editors.original, Se(this, (l) => {
      const c = o.read(l), h = c.map((d) => ({
        range: d.originalUnchangedRange.toInclusiveRange(),
        options: r
      }));
      for (const d of c)
        d.shouldHideControls(l) && h.push({
          range: R.fromPositions(new V(d.originalLineNumber, 1)),
          options: a
        });
      return h;
    }))), this._register(Y_(this._editors.modified, Se(this, (l) => {
      const c = o.read(l), h = c.map((d) => ({
        range: d.modifiedUnchangedRange.toInclusiveRange(),
        options: r
      }));
      for (const d of c)
        d.shouldHideControls(l) && h.push({
          range: we.ofLength(d.modifiedLineNumber, 1).toInclusiveRange(),
          options: a
        });
      return h;
    }))), this._register(Qe((l) => {
      const c = o.read(l);
      this._isUpdatingHiddenAreas = !0;
      try {
        this._editors.original.setHiddenAreas(c.map((h) => h.getHiddenOriginalRange(l).toInclusiveRange()).filter(gd)), this._editors.modified.setHiddenAreas(c.map((h) => h.getHiddenModifiedRange(l).toInclusiveRange()).filter(gd));
      } finally {
        this._isUpdatingHiddenAreas = !1;
      }
    })), this._register(this._editors.modified.onMouseUp((l) => {
      var c;
      if (!l.event.rightButton && l.target.position && ((c = l.target.element) != null && c.className.includes("fold-unchanged"))) {
        const h = l.target.position.lineNumber, d = this._diffModel.get();
        if (!d)
          return;
        const u = d.unchangedRegions.get().find((f) => f.modifiedUnchangedRange.includes(h));
        if (!u)
          return;
        u.collapseAll(void 0), l.event.stopPropagation(), l.event.preventDefault();
      }
    })), this._register(this._editors.original.onMouseUp((l) => {
      var c;
      if (!l.event.rightButton && l.target.position && ((c = l.target.element) != null && c.className.includes("fold-unchanged"))) {
        const h = l.target.position.lineNumber, d = this._diffModel.get();
        if (!d)
          return;
        const u = d.unchangedRegions.get().find((f) => f.originalUnchangedRange.includes(h));
        if (!u)
          return;
        u.collapseAll(void 0), l.event.stopPropagation(), l.event.preventDefault();
      }
    }));
  }
}, mp = dc, dc._breadcrumbsSourceFactory = $e(mp, () => ({
  dispose() {
  },
  getBreadcrumbItems(e, t) {
    return [];
  }
})), dc);
tL = mp = uX([
  fX(3, ot)
], tL);
class t2 extends Px {
  constructor(e, t, i, n = !1) {
    const o = Ue("div.diff-hidden-lines-widget");
    super(e, t, o.root), this._unchangedRegion = i, this._hide = n, this._nodes = Ue("div.diff-hidden-lines-compact", [
      Ue("div.line-left", []),
      Ue("div.text@text", []),
      Ue("div.line-right", [])
    ]), o.root.appendChild(this._nodes.root), this._hide && this._nodes.root.replaceChildren(), this._register(Qe((r) => {
      if (!this._hide) {
        const a = this._unchangedRegion.getHiddenModifiedRange(r).length, l = p("hiddenLines", "{0} hidden lines", a);
        this._nodes.text.innerText = l;
      }
    }));
  }
}
class i2 extends Px {
  constructor(e, t, i, n, o, r, a, l) {
    const c = Ue("div.diff-hidden-lines-widget");
    super(e, t, c.root), this._editor = e, this._unchangedRegion = i, this._unchangedRegionRange = n, this._hide = o, this._modifiedOutlineSource = r, this._revealModifiedHiddenLine = a, this._options = l, this._nodes = Ue("div.diff-hidden-lines", [
      Ue("div.top@top", { title: p("diff.hiddenLines.top", "Click or drag to show more above") }),
      Ue("div.center@content", { style: { display: "flex" } }, [
        Ue("div@first", { style: { display: "flex", justifyContent: "center", alignItems: "center", flexShrink: "0" } }, [pe("a", { title: p("showUnchangedRegion", "Show Unchanged Region"), role: "button", onclick: () => {
          this._unchangedRegion.showAll(void 0);
        } }, ...Yl("$(unfold)"))]),
        Ue("div@others", { style: { display: "flex", justifyContent: "center", alignItems: "center" } })
      ]),
      Ue("div.bottom@bottom", { title: p("diff.bottom", "Click or drag to show more below"), role: "button" })
    ]), c.root.appendChild(this._nodes.root), this._hide ? on(this._nodes.first) : this._register(Qa(this._nodes.first, { width: pg(this._editor).layoutInfoContentLeft })), this._register(Qe((d) => {
      const u = this._unchangedRegion.visibleLineCountTop.read(d) + this._unchangedRegion.visibleLineCountBottom.read(d) === this._unchangedRegion.lineCount;
      this._nodes.bottom.classList.toggle("canMoveTop", !u), this._nodes.bottom.classList.toggle("canMoveBottom", this._unchangedRegion.visibleLineCountBottom.read(d) > 0), this._nodes.top.classList.toggle("canMoveTop", this._unchangedRegion.visibleLineCountTop.read(d) > 0), this._nodes.top.classList.toggle("canMoveBottom", !u);
      const f = this._unchangedRegion.isDragged.read(d), g = this._editor.getDomNode();
      g && (g.classList.toggle("draggingUnchangedRegion", !!f), f === "top" ? (g.classList.toggle("canMoveTop", this._unchangedRegion.visibleLineCountTop.read(d) > 0), g.classList.toggle("canMoveBottom", !u)) : f === "bottom" ? (g.classList.toggle("canMoveTop", !u), g.classList.toggle("canMoveBottom", this._unchangedRegion.visibleLineCountBottom.read(d) > 0)) : (g.classList.toggle("canMoveTop", !1), g.classList.toggle("canMoveBottom", !1)));
    }));
    const h = this._editor;
    this._register($(this._nodes.top, "mousedown", (d) => {
      if (d.button !== 0)
        return;
      this._nodes.top.classList.toggle("dragging", !0), this._nodes.root.classList.toggle("dragging", !0), d.preventDefault();
      const u = d.clientY;
      let f = !1;
      const g = this._unchangedRegion.visibleLineCountTop.get();
      this._unchangedRegion.isDragged.set("top", void 0);
      const m = ue(this._nodes.top), _ = $(m, "mousemove", (C) => {
        const w = C.clientY - u;
        f = f || Math.abs(w) > 2;
        const S = Math.round(w / h.getOption(
          67
          /* EditorOption.lineHeight */
        )), L = Math.max(0, Math.min(g + S, this._unchangedRegion.getMaxVisibleLineCountTop()));
        this._unchangedRegion.visibleLineCountTop.set(L, void 0);
      }), b = $(m, "mouseup", (C) => {
        f || this._unchangedRegion.showMoreAbove(this._options.hideUnchangedRegionsRevealLineCount.get(), void 0), this._nodes.top.classList.toggle("dragging", !1), this._nodes.root.classList.toggle("dragging", !1), this._unchangedRegion.isDragged.set(void 0, void 0), _.dispose(), b.dispose();
      });
    })), this._register($(this._nodes.bottom, "mousedown", (d) => {
      if (d.button !== 0)
        return;
      this._nodes.bottom.classList.toggle("dragging", !0), this._nodes.root.classList.toggle("dragging", !0), d.preventDefault();
      const u = d.clientY;
      let f = !1;
      const g = this._unchangedRegion.visibleLineCountBottom.get();
      this._unchangedRegion.isDragged.set("bottom", void 0);
      const m = ue(this._nodes.bottom), _ = $(m, "mousemove", (C) => {
        const w = C.clientY - u;
        f = f || Math.abs(w) > 2;
        const S = Math.round(w / h.getOption(
          67
          /* EditorOption.lineHeight */
        )), L = Math.max(0, Math.min(g - S, this._unchangedRegion.getMaxVisibleLineCountBottom())), k = this._unchangedRegionRange.endLineNumberExclusive > h.getModel().getLineCount() ? h.getContentHeight() : h.getTopForLineNumber(this._unchangedRegionRange.endLineNumberExclusive);
        this._unchangedRegion.visibleLineCountBottom.set(L, void 0);
        const D = this._unchangedRegionRange.endLineNumberExclusive > h.getModel().getLineCount() ? h.getContentHeight() : h.getTopForLineNumber(this._unchangedRegionRange.endLineNumberExclusive);
        h.setScrollTop(h.getScrollTop() + (D - k));
      }), b = $(m, "mouseup", (C) => {
        if (this._unchangedRegion.isDragged.set(void 0, void 0), !f) {
          const v = h.getTopForLineNumber(this._unchangedRegionRange.endLineNumberExclusive);
          this._unchangedRegion.showMoreBelow(this._options.hideUnchangedRegionsRevealLineCount.get(), void 0);
          const w = h.getTopForLineNumber(this._unchangedRegionRange.endLineNumberExclusive);
          h.setScrollTop(h.getScrollTop() + (w - v));
        }
        this._nodes.bottom.classList.toggle("dragging", !1), this._nodes.root.classList.toggle("dragging", !1), _.dispose(), b.dispose();
      });
    })), this._register(Qe((d) => {
      const u = [];
      if (!this._hide) {
        const f = i.getHiddenModifiedRange(d).length, g = p("hiddenLines", "{0} hidden lines", f), m = pe("span", { title: p("diff.hiddenLines.expandAll", "Double click to unfold") }, g);
        m.addEventListener("dblclick", (C) => {
          C.button === 0 && (C.preventDefault(), this._unchangedRegion.showAll(void 0));
        }), u.push(m);
        const _ = this._unchangedRegion.getHiddenModifiedRange(d), b = this._modifiedOutlineSource.getBreadcrumbItems(_, d);
        if (b.length > 0) {
          u.push(pe("span", void 0, "  |  "));
          for (let C = 0; C < b.length; C++) {
            const v = b[C], w = VC.toIcon(v.kind), S = Ue("div.breadcrumb-item", {
              style: { display: "flex", alignItems: "center" }
            }, [
              Gp(w),
              " ",
              v.name,
              ...C === b.length - 1 ? [] : [Gp(re.chevronRight)]
            ]).root;
            u.push(S), S.onclick = () => {
              this._revealModifiedHiddenLine(v.startLineNumber);
            };
          }
        }
      }
      on(this._nodes.others, ...u);
    }));
  }
}
var gX = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, mX = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, js, Wr;
let _g = (Wr = class extends q {
  constructor(e, t, i, n, o, r, a) {
    super(), this._editors = e, this._rootElement = t, this._diffModel = i, this._rootWidth = n, this._rootHeight = o, this._modifiedEditorLayoutInfo = r, this._themeService = a, this.width = js.ENTIRE_DIFF_OVERVIEW_WIDTH;
    const l = Wt(this._themeService.onDidColorThemeChange, () => this._themeService.getColorTheme()), c = Se((u) => {
      const f = l.read(u), g = f.getColor(l8) || (f.getColor(r8) || Tv).transparent(2), m = f.getColor(c8) || (f.getColor(a8) || Mv).transparent(2);
      return { insertColor: g, removeColor: m };
    }), h = je(document.createElement("div"));
    h.setClassName("diffViewport"), h.setPosition("absolute");
    const d = Ue("div.diffOverview", {
      style: { position: "absolute", top: "0px", width: js.ENTIRE_DIFF_OVERVIEW_WIDTH + "px" }
    }).root;
    this._register(Pu(d, h.domNode)), this._register(fi(d, ee.POINTER_DOWN, (u) => {
      this._editors.modified.delegateVerticalScrollbarPointerDown(u);
    })), this._register($(d, ee.MOUSE_WHEEL, (u) => {
      this._editors.modified.delegateScrollFromMouseWheelEvent(u);
    }, { passive: !1 })), this._register(Pu(this._rootElement, d)), this._register(so((u, f) => {
      const g = this._diffModel.read(u), m = this._editors.original.createOverviewRuler("original diffOverviewRuler");
      m && (f.add(m), f.add(Pu(d, m.getDomNode())));
      const _ = this._editors.modified.createOverviewRuler("modified diffOverviewRuler");
      if (_ && (f.add(_), f.add(Pu(d, _.getDomNode()))), !m || !_)
        return;
      const b = ds("viewZoneChanged", this._editors.original.onDidChangeViewZones), C = ds("viewZoneChanged", this._editors.modified.onDidChangeViewZones), v = ds("hiddenRangesChanged", this._editors.original.onDidChangeHiddenAreas), w = ds("hiddenRangesChanged", this._editors.modified.onDidChangeHiddenAreas);
      f.add(Qe((S) => {
        var P;
        b.read(S), C.read(S), v.read(S), w.read(S);
        const L = c.read(S), k = (P = g == null ? void 0 : g.diff.read(S)) == null ? void 0 : P.mappings;
        function D(B, W, A) {
          const K = A._getViewModel();
          return K ? B.filter((Y) => Y.length > 0).map((Y) => {
            const Q = K.coordinatesConverter.convertModelPositionToViewPosition(new V(Y.startLineNumber, 1)), ne = K.coordinatesConverter.convertModelPositionToViewPosition(new V(Y.endLineNumberExclusive, 1)), ie = ne.lineNumber - Q.lineNumber;
            return new c5(Q.lineNumber, ne.lineNumber, ie, W.toString());
          }) : [];
        }
        const E = D((k || []).map((B) => B.lineRangeMapping.original), L.removeColor, this._editors.original), U = D((k || []).map((B) => B.lineRangeMapping.modified), L.insertColor, this._editors.modified);
        m == null || m.setZones(E), _ == null || _.setZones(U);
      })), f.add(Qe((S) => {
        const L = this._rootHeight.read(S), k = this._rootWidth.read(S), D = this._modifiedEditorLayoutInfo.read(S);
        if (D) {
          const E = js.ENTIRE_DIFF_OVERVIEW_WIDTH - 2 * js.ONE_OVERVIEW_WIDTH;
          m.setLayout({
            top: 0,
            height: L,
            right: E + js.ONE_OVERVIEW_WIDTH,
            width: js.ONE_OVERVIEW_WIDTH
          }), _.setLayout({
            top: 0,
            height: L,
            right: 0,
            width: js.ONE_OVERVIEW_WIDTH
          });
          const U = this._editors.modifiedScrollTop.read(S), P = this._editors.modifiedScrollHeight.read(S), B = this._editors.modified.getOption(
            104
            /* EditorOption.scrollbar */
          ), W = new Ed(B.verticalHasArrows ? B.arrowSize : 0, B.verticalScrollbarSize, 0, D.height, P, U);
          h.setTop(W.getSliderPosition()), h.setHeight(W.getSliderSize());
        } else
          h.setTop(0), h.setHeight(0);
        d.style.height = L + "px", d.style.left = k - js.ENTIRE_DIFF_OVERVIEW_WIDTH + "px", h.setWidth(js.ENTIRE_DIFF_OVERVIEW_WIDTH);
      }));
    }));
  }
}, js = Wr, Wr.ONE_OVERVIEW_WIDTH = 15, Wr.ENTIRE_DIFF_OVERVIEW_WIDTH = Wr.ONE_OVERVIEW_WIDTH * 2, Wr);
_g = js = gX([
  mX(6, Ws)
], _g);
const xC = [];
class pX extends q {
  constructor(e, t, i, n) {
    super(), this._editors = e, this._diffModel = t, this._options = i, this._widget = n, this._selectedDiffs = Se(this, (o) => {
      const r = this._diffModel.read(o), a = r == null ? void 0 : r.diff.read(o);
      if (!a)
        return xC;
      const l = this._editors.modifiedSelections.read(o);
      if (l.every((u) => u.isEmpty()))
        return xC;
      const c = new hs(l.map((u) => we.fromRangeInclusive(u))), d = a.mappings.filter((u) => u.lineRangeMapping.innerChanges && c.intersects(u.lineRangeMapping.modified)).map((u) => ({
        mapping: u,
        rangeMappings: u.lineRangeMapping.innerChanges.filter((f) => l.some((g) => R.areIntersecting(f.modifiedRange, g)))
      }));
      return d.length === 0 || d.every((u) => u.rangeMappings.length === 0) ? xC : d;
    }), this._register(so((o, r) => {
      if (!this._options.shouldRenderOldRevertArrows.read(o))
        return;
      const a = this._diffModel.read(o), l = a == null ? void 0 : a.diff.read(o);
      if (!a || !l || a.movedTextToCompare.read(o))
        return;
      const c = [], h = this._selectedDiffs.read(o), d = new Set(h.map((u) => u.mapping));
      if (h.length > 0) {
        const u = this._editors.modifiedSelections.read(o), f = r.add(new e1(u[u.length - 1].positionLineNumber, this._widget, h.flatMap((g) => g.rangeMappings), !0));
        this._editors.modified.addGlyphMarginWidget(f), c.push(f);
      }
      for (const u of l.mappings)
        if (!d.has(u) && !u.lineRangeMapping.modified.isEmpty && u.lineRangeMapping.innerChanges) {
          const f = r.add(new e1(u.lineRangeMapping.modified.startLineNumber, this._widget, u.lineRangeMapping, !1));
          this._editors.modified.addGlyphMarginWidget(f), c.push(f);
        }
      r.add(ke(() => {
        for (const u of c)
          this._editors.modified.removeGlyphMarginWidget(u);
      }));
    }));
  }
}
const Z1 = class Z1 extends q {
  getId() {
    return this._id;
  }
  constructor(e, t, i, n) {
    super(), this._lineNumber = e, this._widget = t, this._diffs = i, this._revertSelection = n, this._id = `revertButton${Z1.counter++}`, this._domNode = Ue("div.revertButton", {
      title: this._revertSelection ? p("revertSelectedChanges", "Revert Selected Changes") : p("revertChange", "Revert Change")
    }, [Gp(re.arrowRight)]).root, this._register($(this._domNode, ee.MOUSE_DOWN, (o) => {
      o.button !== 2 && (o.stopPropagation(), o.preventDefault());
    })), this._register($(this._domNode, ee.MOUSE_UP, (o) => {
      o.stopPropagation(), o.preventDefault();
    })), this._register($(this._domNode, ee.CLICK, (o) => {
      this._diffs instanceof ji ? this._widget.revert(this._diffs) : this._widget.revertRangeMappings(this._diffs), o.stopPropagation(), o.preventDefault();
    }));
  }
  /**
   * Get the dom node of the glyph widget.
   */
  getDomNode() {
    return this._domNode;
  }
  /**
   * Get the placement of the glyph widget.
   */
  getPosition() {
    return {
      lane: Ka.Right,
      range: {
        startColumn: 1,
        startLineNumber: this._lineNumber,
        endColumn: 1,
        endLineNumber: this._lineNumber
      },
      zIndex: 10001
    };
  }
};
Z1.counter = 0;
let e1 = Z1;
function ar(s, e, t) {
  const i = s.bindTo(e);
  return Mb({ debugName: () => `Set Context Key "${s.key}"` }, (n) => {
    i.set(t(n));
  });
}
var _X = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, n2 = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let iL = class extends q {
  get onDidContentSizeChange() {
    return this._onDidContentSizeChange.event;
  }
  constructor(e, t, i, n, o, r, a) {
    super(), this.originalEditorElement = e, this.modifiedEditorElement = t, this._options = i, this._argCodeEditorWidgetOptions = n, this._createInnerEditor = o, this._instantiationService = r, this._keybindingService = a, this.original = this._register(this._createLeftHandSideEditor(this._options.editorOptions.get(), this._argCodeEditorWidgetOptions.originalEditor || {})), this.modified = this._register(this._createRightHandSideEditor(this._options.editorOptions.get(), this._argCodeEditorWidgetOptions.modifiedEditor || {})), this._onDidContentSizeChange = this._register(new O()), this.modifiedScrollTop = Wt(this, this.modified.onDidScrollChange, () => (
      /** @description modified.getScrollTop */
      this.modified.getScrollTop()
    )), this.modifiedScrollHeight = Wt(this, this.modified.onDidScrollChange, () => (
      /** @description modified.getScrollHeight */
      this.modified.getScrollHeight()
    )), this.modifiedObs = pg(this.modified), this.originalObs = pg(this.original), this.modifiedModel = this.modifiedObs.model, this.modifiedSelections = Wt(this, this.modified.onDidChangeCursorSelection, () => this.modified.getSelections() ?? []), this.modifiedCursor = Tb({ owner: this, equalsFn: V.equals }, (l) => {
      var c;
      return ((c = this.modifiedSelections.read(l)[0]) == null ? void 0 : c.getPosition()) ?? new V(1, 1);
    }), this.originalCursor = Wt(this, this.original.onDidChangeCursorPosition, () => this.original.getPosition() ?? new V(1, 1)), this._argCodeEditorWidgetOptions = null, this._register(Rb({
      createEmptyChangeSummary: () => ({}),
      handleChange: (l, c) => (l.didChange(i.editorOptions) && Object.assign(c, l.change.changedOptions), !0)
    }, (l, c) => {
      i.editorOptions.read(l), this._options.renderSideBySide.read(l), this.modified.updateOptions(this._adjustOptionsForRightHandSide(l, c)), this.original.updateOptions(this._adjustOptionsForLeftHandSide(l, c));
    }));
  }
  _createLeftHandSideEditor(e, t) {
    const i = this._adjustOptionsForLeftHandSide(void 0, e), n = this._constructInnerEditor(this._instantiationService, this.originalEditorElement, i, t);
    return n.setContextValue("isInDiffLeftEditor", !0), n;
  }
  _createRightHandSideEditor(e, t) {
    const i = this._adjustOptionsForRightHandSide(void 0, e), n = this._constructInnerEditor(this._instantiationService, this.modifiedEditorElement, i, t);
    return n.setContextValue("isInDiffRightEditor", !0), n;
  }
  _constructInnerEditor(e, t, i, n) {
    const o = this._createInnerEditor(e, t, i, n);
    return this._register(o.onDidContentSizeChange((r) => {
      const a = this.original.getContentWidth() + this.modified.getContentWidth() + _g.ENTIRE_DIFF_OVERVIEW_WIDTH, l = Math.max(this.modified.getContentHeight(), this.original.getContentHeight());
      this._onDidContentSizeChange.fire({
        contentHeight: l,
        contentWidth: a,
        contentHeightChanged: r.contentHeightChanged,
        contentWidthChanged: r.contentWidthChanged
      });
    })), o;
  }
  _adjustOptionsForLeftHandSide(e, t) {
    const i = this._adjustOptionsForSubEditor(t);
    return this._options.renderSideBySide.get() ? (i.unicodeHighlight = this._options.editorOptions.get().unicodeHighlight || {}, i.wordWrapOverride1 = this._options.diffWordWrap.get()) : (i.wordWrapOverride1 = "off", i.wordWrapOverride2 = "off", i.stickyScroll = { enabled: !1 }, i.unicodeHighlight = { nonBasicASCII: !1, ambiguousCharacters: !1, invisibleCharacters: !1 }), i.glyphMargin = this._options.renderSideBySide.get(), t.originalAriaLabel && (i.ariaLabel = t.originalAriaLabel), i.ariaLabel = this._updateAriaLabel(i.ariaLabel), i.readOnly = !this._options.originalEditable.get(), i.dropIntoEditor = { enabled: !i.readOnly }, i.extraEditorClassName = "original-in-monaco-diff-editor", i;
  }
  _adjustOptionsForRightHandSide(e, t) {
    const i = this._adjustOptionsForSubEditor(t);
    return t.modifiedAriaLabel && (i.ariaLabel = t.modifiedAriaLabel), i.ariaLabel = this._updateAriaLabel(i.ariaLabel), i.wordWrapOverride1 = this._options.diffWordWrap.get(), i.revealHorizontalRightPadding = xc.revealHorizontalRightPadding.defaultValue + _g.ENTIRE_DIFF_OVERVIEW_WIDTH, i.scrollbar.verticalHasArrows = !1, i.extraEditorClassName = "modified-in-monaco-diff-editor", i;
  }
  _adjustOptionsForSubEditor(e) {
    const t = {
      ...e,
      dimension: {
        height: 0,
        width: 0
      }
    };
    return t.inDiffEditor = !0, t.automaticLayout = !1, t.scrollbar = { ...t.scrollbar || {} }, t.folding = !1, t.codeLens = this._options.diffCodeLens.get(), t.fixedOverflowWidgets = !0, t.minimap = { ...t.minimap || {} }, t.minimap.enabled = !1, this._options.hideUnchangedRegions.get() ? t.stickyScroll = { enabled: !1 } : t.stickyScroll = this._options.editorOptions.get().stickyScroll, t;
  }
  _updateAriaLabel(e) {
    var i;
    e || (e = "");
    const t = p("diff-aria-navigation-tip", " use {0} to open the accessibility help.", (i = this._keybindingService.lookupKeybinding("editor.action.accessibilityHelp")) == null ? void 0 : i.getAriaLabel());
    return this._options.accessibilityVerbose.get() ? e + t : e ? e.replaceAll(t, "") : "";
  }
};
iL = _X([
  n2(5, ot),
  n2(6, Ai)
], iL);
const Y1 = class Y1 extends q {
  constructor() {
    super(...arguments), this._id = ++Y1.idCounter, this._onDidDispose = this._register(new O()), this.onDidDispose = this._onDidDispose.event;
  }
  getId() {
    return this.getEditorType() + ":v2:" + this._id;
  }
  // #region editorBrowser.IDiffEditor: Delegating to modified Editor
  getVisibleColumnFromPosition(e) {
    return this._targetEditor.getVisibleColumnFromPosition(e);
  }
  getPosition() {
    return this._targetEditor.getPosition();
  }
  setPosition(e, t = "api") {
    this._targetEditor.setPosition(e, t);
  }
  revealLine(e, t = 0) {
    this._targetEditor.revealLine(e, t);
  }
  revealLineInCenter(e, t = 0) {
    this._targetEditor.revealLineInCenter(e, t);
  }
  revealLineInCenterIfOutsideViewport(e, t = 0) {
    this._targetEditor.revealLineInCenterIfOutsideViewport(e, t);
  }
  revealLineNearTop(e, t = 0) {
    this._targetEditor.revealLineNearTop(e, t);
  }
  revealPosition(e, t = 0) {
    this._targetEditor.revealPosition(e, t);
  }
  revealPositionInCenter(e, t = 0) {
    this._targetEditor.revealPositionInCenter(e, t);
  }
  revealPositionInCenterIfOutsideViewport(e, t = 0) {
    this._targetEditor.revealPositionInCenterIfOutsideViewport(e, t);
  }
  revealPositionNearTop(e, t = 0) {
    this._targetEditor.revealPositionNearTop(e, t);
  }
  getSelection() {
    return this._targetEditor.getSelection();
  }
  getSelections() {
    return this._targetEditor.getSelections();
  }
  setSelection(e, t = "api") {
    this._targetEditor.setSelection(e, t);
  }
  setSelections(e, t = "api") {
    this._targetEditor.setSelections(e, t);
  }
  revealLines(e, t, i = 0) {
    this._targetEditor.revealLines(e, t, i);
  }
  revealLinesInCenter(e, t, i = 0) {
    this._targetEditor.revealLinesInCenter(e, t, i);
  }
  revealLinesInCenterIfOutsideViewport(e, t, i = 0) {
    this._targetEditor.revealLinesInCenterIfOutsideViewport(e, t, i);
  }
  revealLinesNearTop(e, t, i = 0) {
    this._targetEditor.revealLinesNearTop(e, t, i);
  }
  revealRange(e, t = 0, i = !1, n = !0) {
    this._targetEditor.revealRange(e, t, i, n);
  }
  revealRangeInCenter(e, t = 0) {
    this._targetEditor.revealRangeInCenter(e, t);
  }
  revealRangeInCenterIfOutsideViewport(e, t = 0) {
    this._targetEditor.revealRangeInCenterIfOutsideViewport(e, t);
  }
  revealRangeNearTop(e, t = 0) {
    this._targetEditor.revealRangeNearTop(e, t);
  }
  revealRangeNearTopIfOutsideViewport(e, t = 0) {
    this._targetEditor.revealRangeNearTopIfOutsideViewport(e, t);
  }
  revealRangeAtTop(e, t = 0) {
    this._targetEditor.revealRangeAtTop(e, t);
  }
  getSupportedActions() {
    return this._targetEditor.getSupportedActions();
  }
  focus() {
    this._targetEditor.focus();
  }
  trigger(e, t, i) {
    this._targetEditor.trigger(e, t, i);
  }
  createDecorationsCollection(e) {
    return this._targetEditor.createDecorationsCollection(e);
  }
  changeDecorations(e) {
    return this._targetEditor.changeDecorations(e);
  }
};
Y1.idCounter = 0;
let nL = Y1;
var bX = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, CX = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let sL = class {
  get editorOptions() {
    return this._options;
  }
  constructor(e, t) {
    this._accessibilityService = t, this._diffEditorWidth = $e(this, 0), this._screenReaderMode = Wt(this, this._accessibilityService.onDidChangeScreenReaderOptimized, () => this._accessibilityService.isScreenReaderOptimized()), this.couldShowInlineViewBecauseOfSize = Se(this, (n) => this._options.read(n).renderSideBySide && this._diffEditorWidth.read(n) <= this._options.read(n).renderSideBySideInlineBreakpoint), this.renderOverviewRuler = Se(this, (n) => this._options.read(n).renderOverviewRuler), this.renderSideBySide = Se(this, (n) => this.compactMode.read(n) && this.shouldRenderInlineViewInSmartMode.read(n) ? !1 : this._options.read(n).renderSideBySide && !(this._options.read(n).useInlineViewWhenSpaceIsLimited && this.couldShowInlineViewBecauseOfSize.read(n) && !this._screenReaderMode.read(n))), this.readOnly = Se(this, (n) => this._options.read(n).readOnly), this.shouldRenderOldRevertArrows = Se(this, (n) => !(!this._options.read(n).renderMarginRevertIcon || !this.renderSideBySide.read(n) || this.readOnly.read(n) || this.shouldRenderGutterMenu.read(n))), this.shouldRenderGutterMenu = Se(this, (n) => this._options.read(n).renderGutterMenu), this.renderIndicators = Se(this, (n) => this._options.read(n).renderIndicators), this.enableSplitViewResizing = Se(this, (n) => this._options.read(n).enableSplitViewResizing), this.splitViewDefaultRatio = Se(this, (n) => this._options.read(n).splitViewDefaultRatio), this.ignoreTrimWhitespace = Se(this, (n) => this._options.read(n).ignoreTrimWhitespace), this.maxComputationTimeMs = Se(this, (n) => this._options.read(n).maxComputationTime), this.showMoves = Se(this, (n) => this._options.read(n).experimental.showMoves && this.renderSideBySide.read(n)), this.isInEmbeddedEditor = Se(this, (n) => this._options.read(n).isInEmbeddedEditor), this.diffWordWrap = Se(this, (n) => this._options.read(n).diffWordWrap), this.originalEditable = Se(this, (n) => this._options.read(n).originalEditable), this.diffCodeLens = Se(this, (n) => this._options.read(n).diffCodeLens), this.accessibilityVerbose = Se(this, (n) => this._options.read(n).accessibilityVerbose), this.diffAlgorithm = Se(this, (n) => this._options.read(n).diffAlgorithm), this.showEmptyDecorations = Se(this, (n) => this._options.read(n).experimental.showEmptyDecorations), this.onlyShowAccessibleDiffViewer = Se(this, (n) => this._options.read(n).onlyShowAccessibleDiffViewer), this.compactMode = Se(this, (n) => this._options.read(n).compactMode), this.trueInlineDiffRenderingEnabled = Se(this, (n) => this._options.read(n).experimental.useTrueInlineView), this.useTrueInlineDiffRendering = Se(this, (n) => !this.renderSideBySide.read(n) && this.trueInlineDiffRenderingEnabled.read(n)), this.hideUnchangedRegions = Se(this, (n) => this._options.read(n).hideUnchangedRegions.enabled), this.hideUnchangedRegionsRevealLineCount = Se(this, (n) => this._options.read(n).hideUnchangedRegions.revealLineCount), this.hideUnchangedRegionsContextLineCount = Se(this, (n) => this._options.read(n).hideUnchangedRegions.contextLineCount), this.hideUnchangedRegionsMinimumLineCount = Se(this, (n) => this._options.read(n).hideUnchangedRegions.minimumLineCount), this._model = $e(this, void 0), this.shouldRenderInlineViewInSmartMode = this._model.map(this, (n) => wH(this, (o) => {
      const r = n == null ? void 0 : n.diff.read(o);
      return r ? wX(r, this.trueInlineDiffRenderingEnabled.read(o)) : void 0;
    })).flatten().map(this, (n) => !!n), this.inlineViewHideOriginalLineNumbers = this.compactMode;
    const i = { ...e, ...s2(e, xi) };
    this._options = $e(this, i);
  }
  updateOptions(e) {
    const t = s2(e, this._options.get()), i = { ...this._options.get(), ...e, ...t };
    this._options.set(i, void 0, { changedOptions: e });
  }
  setWidth(e) {
    this._diffEditorWidth.set(e, void 0);
  }
  setModel(e) {
    this._model.set(e, void 0);
  }
};
sL = bX([
  CX(1, go)
], sL);
function wX(s, e) {
  return s.mappings.every((t) => vX(t.lineRangeMapping) || yX(t.lineRangeMapping) || e && Hx(t.lineRangeMapping));
}
function vX(s) {
  return s.original.length === 0;
}
function yX(s) {
  return s.modified.length === 0;
}
function s2(s, e) {
  var t, i, n, o, r, a, l, c;
  return {
    enableSplitViewResizing: oe(s.enableSplitViewResizing, e.enableSplitViewResizing),
    splitViewDefaultRatio: hP(s.splitViewDefaultRatio, 0.5, 0.1, 0.9),
    renderSideBySide: oe(s.renderSideBySide, e.renderSideBySide),
    renderMarginRevertIcon: oe(s.renderMarginRevertIcon, e.renderMarginRevertIcon),
    maxComputationTime: gl(
      s.maxComputationTime,
      e.maxComputationTime,
      0,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    ),
    maxFileSize: gl(
      s.maxFileSize,
      e.maxFileSize,
      0,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    ),
    ignoreTrimWhitespace: oe(s.ignoreTrimWhitespace, e.ignoreTrimWhitespace),
    renderIndicators: oe(s.renderIndicators, e.renderIndicators),
    originalEditable: oe(s.originalEditable, e.originalEditable),
    diffCodeLens: oe(s.diffCodeLens, e.diffCodeLens),
    renderOverviewRuler: oe(s.renderOverviewRuler, e.renderOverviewRuler),
    diffWordWrap: Mt(s.diffWordWrap, e.diffWordWrap, ["off", "on", "inherit"]),
    diffAlgorithm: Mt(s.diffAlgorithm, e.diffAlgorithm, ["legacy", "advanced"], { smart: "legacy", experimental: "advanced" }),
    accessibilityVerbose: oe(s.accessibilityVerbose, e.accessibilityVerbose),
    experimental: {
      showMoves: oe((t = s.experimental) == null ? void 0 : t.showMoves, e.experimental.showMoves),
      showEmptyDecorations: oe((i = s.experimental) == null ? void 0 : i.showEmptyDecorations, e.experimental.showEmptyDecorations),
      useTrueInlineView: oe((n = s.experimental) == null ? void 0 : n.useTrueInlineView, e.experimental.useTrueInlineView)
    },
    hideUnchangedRegions: {
      enabled: oe(((o = s.hideUnchangedRegions) == null ? void 0 : o.enabled) ?? ((r = s.experimental) == null ? void 0 : r.collapseUnchangedRegions), e.hideUnchangedRegions.enabled),
      contextLineCount: gl(
        (a = s.hideUnchangedRegions) == null ? void 0 : a.contextLineCount,
        e.hideUnchangedRegions.contextLineCount,
        0,
        1073741824
        /* Constants.MAX_SAFE_SMALL_INTEGER */
      ),
      minimumLineCount: gl(
        (l = s.hideUnchangedRegions) == null ? void 0 : l.minimumLineCount,
        e.hideUnchangedRegions.minimumLineCount,
        0,
        1073741824
        /* Constants.MAX_SAFE_SMALL_INTEGER */
      ),
      revealLineCount: gl(
        (c = s.hideUnchangedRegions) == null ? void 0 : c.revealLineCount,
        e.hideUnchangedRegions.revealLineCount,
        0,
        1073741824
        /* Constants.MAX_SAFE_SMALL_INTEGER */
      )
    },
    isInEmbeddedEditor: oe(s.isInEmbeddedEditor, e.isInEmbeddedEditor),
    onlyShowAccessibleDiffViewer: oe(s.onlyShowAccessibleDiffViewer, e.onlyShowAccessibleDiffViewer),
    renderSideBySideInlineBreakpoint: gl(
      s.renderSideBySideInlineBreakpoint,
      e.renderSideBySideInlineBreakpoint,
      0,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    ),
    useInlineViewWhenSpaceIsLimited: oe(s.useInlineViewWhenSpaceIsLimited, e.useInlineViewWhenSpaceIsLimited),
    renderGutterMenu: oe(s.renderGutterMenu, e.renderGutterMenu),
    compactMode: oe(s.compactMode, e.compactMode)
  };
}
var SX = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Su = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let t1 = class extends nL {
  get onDidContentSizeChange() {
    return this._editors.onDidContentSizeChange;
  }
  constructor(e, t, i, n, o, r, a, l) {
    super(), this._domElement = e, this._parentContextKeyService = n, this._parentInstantiationService = o, this._accessibilitySignalService = a, this._editorProgressService = l, this.elements = Ue("div.monaco-diff-editor.side-by-side", { style: { position: "relative", height: "100%" } }, [
      Ue("div.editor.original@original", { style: { position: "absolute", height: "100%" } }),
      Ue("div.editor.modified@modified", { style: { position: "absolute", height: "100%" } }),
      Ue("div.accessibleDiffViewer@accessibleDiffViewer", { style: { position: "absolute", height: "100%" } })
    ]), this._diffModelSrc = this._register(_A(this, void 0)), this._diffModel = Se(this, (w) => {
      var S;
      return (S = this._diffModelSrc.read(w)) == null ? void 0 : S.object;
    }), this.onDidChangeModel = J.fromObservableLight(this._diffModel), this._contextKeyService = this._register(this._parentContextKeyService.createScoped(this._domElement)), this._instantiationService = this._register(this._parentInstantiationService.createChild(new jd([nt, this._contextKeyService]))), this._boundarySashes = $e(this, void 0), this._accessibleDiffViewerShouldBeVisible = $e(this, !1), this._accessibleDiffViewerVisible = Se(this, (w) => this._options.onlyShowAccessibleDiffViewer.read(w) ? !0 : this._accessibleDiffViewerShouldBeVisible.read(w)), this._movedBlocksLinesPart = $e(this, void 0), this._layoutInfo = Se(this, (w) => {
      var Q, ne;
      const S = this._rootSizeObserver.width.read(w), L = this._rootSizeObserver.height.read(w);
      this._rootSizeObserver.automaticLayout ? this.elements.root.style.height = "100%" : this.elements.root.style.height = L + "px";
      const k = this._sash.read(w), D = this._gutter.read(w), E = (D == null ? void 0 : D.width.read(w)) ?? 0, U = ((Q = this._overviewRulerPart.read(w)) == null ? void 0 : Q.width) ?? 0;
      let P, B, W, A, K;
      if (!!k) {
        const ie = k.sashLeft.read(w), me = ((ne = this._movedBlocksLinesPart.read(w)) == null ? void 0 : ne.width.read(w)) ?? 0;
        P = 0, B = ie - E - me, K = ie - E, W = ie, A = S - W - U;
      } else {
        K = 0;
        const ie = this._options.inlineViewHideOriginalLineNumbers.read(w);
        P = E, ie ? B = 0 : B = Math.max(5, this._editors.originalObs.layoutInfoDecorationsLeft.read(w)), W = E + B, A = S - W - U;
      }
      return this.elements.original.style.left = P + "px", this.elements.original.style.width = B + "px", this._editors.original.layout({ width: B, height: L }, !0), D == null || D.layout(K), this.elements.modified.style.left = W + "px", this.elements.modified.style.width = A + "px", this._editors.modified.layout({ width: A, height: L }, !0), {
        modifiedEditor: this._editors.modified.getLayoutInfo(),
        originalEditor: this._editors.original.getLayoutInfo()
      };
    }), this._diffValue = this._diffModel.map((w, S) => w == null ? void 0 : w.diff.read(S)), this.onDidUpdateDiff = J.fromObservableLight(this._diffValue), r.willCreateDiffEditor(), this._contextKeyService.createKey("isInDiffEditor", !0), this._domElement.appendChild(this.elements.root), this._register(ke(() => this.elements.root.remove())), this._rootSizeObserver = this._register(new g5(this.elements.root, t.dimension)), this._rootSizeObserver.setAutomaticLayout(t.automaticLayout ?? !1), this._options = this._instantiationService.createInstance(sL, t), this._register(Qe((w) => {
      this._options.setWidth(this._rootSizeObserver.width.read(w));
    })), this._contextKeyService.createKey(se.isEmbeddedDiffEditor.key, !1), this._register(ar(se.isEmbeddedDiffEditor, this._contextKeyService, (w) => this._options.isInEmbeddedEditor.read(w))), this._register(ar(se.comparingMovedCode, this._contextKeyService, (w) => {
      var S;
      return !!((S = this._diffModel.read(w)) != null && S.movedTextToCompare.read(w));
    })), this._register(ar(se.diffEditorRenderSideBySideInlineBreakpointReached, this._contextKeyService, (w) => this._options.couldShowInlineViewBecauseOfSize.read(w))), this._register(ar(se.diffEditorInlineMode, this._contextKeyService, (w) => !this._options.renderSideBySide.read(w))), this._register(ar(se.hasChanges, this._contextKeyService, (w) => {
      var S, L;
      return (((L = (S = this._diffModel.read(w)) == null ? void 0 : S.diff.read(w)) == null ? void 0 : L.mappings.length) ?? 0) > 0;
    })), this._editors = this._register(this._instantiationService.createInstance(iL, this.elements.original, this.elements.modified, this._options, i, (w, S, L, k) => this._createInnerEditor(w, S, L, k))), this._register(ar(se.diffEditorOriginalWritable, this._contextKeyService, (w) => this._options.originalEditable.read(w))), this._register(ar(se.diffEditorModifiedWritable, this._contextKeyService, (w) => !this._options.readOnly.read(w))), this._register(ar(se.diffEditorOriginalUri, this._contextKeyService, (w) => {
      var S;
      return ((S = this._diffModel.read(w)) == null ? void 0 : S.model.original.uri.toString()) ?? "";
    })), this._register(ar(se.diffEditorModifiedUri, this._contextKeyService, (w) => {
      var S;
      return ((S = this._diffModel.read(w)) == null ? void 0 : S.model.modified.uri.toString()) ?? "";
    })), this._overviewRulerPart = ko(this, (w) => this._options.renderOverviewRuler.read(w) ? this._instantiationService.createInstance(ks(_g, w), this._editors, this.elements.root, this._diffModel, this._rootSizeObserver.width, this._rootSizeObserver.height, this._layoutInfo.map((S) => S.modifiedEditor)) : void 0).recomputeInitiallyAndOnChange(this._store);
    const c = {
      height: this._rootSizeObserver.height,
      width: this._rootSizeObserver.width.map((w, S) => {
        var L;
        return w - (((L = this._overviewRulerPart.read(S)) == null ? void 0 : L.width) ?? 0);
      })
    };
    this._sashLayout = new lX(this._options, c), this._sash = ko(this, (w) => {
      const S = this._options.renderSideBySide.read(w);
      return this.elements.root.classList.toggle("side-by-side", S), S ? new w5(this.elements.root, c, this._options.enableSplitViewResizing, this._boundarySashes, this._sashLayout.sashLeft, () => this._sashLayout.resetSash()) : void 0;
    }).recomputeInitiallyAndOnChange(this._store);
    const h = ko(this, (w) => (
      /** @description UnchangedRangesFeature */
      this._instantiationService.createInstance(ks(tL, w), this._editors, this._diffModel, this._options)
    )).recomputeInitiallyAndOnChange(this._store);
    ko(this, (w) => (
      /** @description DiffEditorDecorations */
      this._instantiationService.createInstance(ks(aX, w), this._editors, this._diffModel, this._options, this)
    )).recomputeInitiallyAndOnChange(this._store);
    const d = /* @__PURE__ */ new Set(), u = /* @__PURE__ */ new Set();
    let f = !1;
    const g = ko(this, (w) => (
      /** @description ViewZoneManager */
      this._instantiationService.createInstance(ks(YS, w), ue(this._domElement), this._editors, this._diffModel, this._options, this, () => f || h.get().isUpdatingHiddenAreas, d, u)
    )).recomputeInitiallyAndOnChange(this._store), m = Se(this, (w) => {
      const S = g.read(w).viewZones.read(w).orig, L = h.read(w).viewZones.read(w).origViewZones;
      return S.concat(L);
    }), _ = Se(this, (w) => {
      const S = g.read(w).viewZones.read(w).mod, L = h.read(w).viewZones.read(w).modViewZones;
      return S.concat(L);
    });
    this._register(Q_(this._editors.original, m, (w) => {
      f = w;
    }, d));
    let b;
    this._register(Q_(this._editors.modified, _, (w) => {
      f = w, f ? b = Z_.capture(this._editors.modified) : (b == null || b.restore(this._editors.modified), b = void 0);
    }, u)), this._accessibleDiffViewer = ko(this, (w) => this._instantiationService.createInstance(ks(jl, w), this.elements.accessibleDiffViewer, this._accessibleDiffViewerVisible, (S, L) => this._accessibleDiffViewerShouldBeVisible.set(S, L), this._options.onlyShowAccessibleDiffViewer.map((S) => !S), this._rootSizeObserver.width, this._rootSizeObserver.height, this._diffModel.map((S, L) => {
      var k;
      return (k = S == null ? void 0 : S.diff.read(L)) == null ? void 0 : k.mappings.map((D) => D.lineRangeMapping);
    }), new KQ(this._editors))).recomputeInitiallyAndOnChange(this._store);
    const C = this._accessibleDiffViewerVisible.map((w) => w ? "hidden" : "visible");
    this._register(Qa(this.elements.modified, { visibility: C })), this._register(Qa(this.elements.original, { visibility: C })), this._createDiffEditorContributions(), r.addDiffEditor(this), this._gutter = ko(this, (w) => this._options.shouldRenderGutterMenu.read(w) ? this._instantiationService.createInstance(ks(XS, w), this.elements.root, this._diffModel, this._editors, this._options, this._sashLayout, this._boundarySashes) : void 0), this._register(Pb(this._layoutInfo)), ko(this, (w) => (
      /** @description MovedBlocksLinesPart */
      new (ks(hd, w))(this.elements.root, this._diffModel, this._layoutInfo.map((S) => S.originalEditor), this._layoutInfo.map((S) => S.modifiedEditor), this._editors)
    )).recomputeInitiallyAndOnChange(this._store, (w) => {
      this._movedBlocksLinesPart.set(w, void 0);
    }), this._register(J.runAndSubscribe(this._editors.modified.onDidChangeCursorPosition, (w) => this._handleCursorPositionChange(w, !0))), this._register(J.runAndSubscribe(this._editors.original.onDidChangeCursorPosition, (w) => this._handleCursorPositionChange(w, !1)));
    const v = this._diffModel.map(this, (w, S) => {
      if (w)
        return w.diff.read(S) === void 0 && !w.isDiffUpToDate.read(S);
    });
    this._register(so((w, S) => {
      if (v.read(w) === !0) {
        const L = this._editorProgressService.show(!0, 1e3);
        S.add(ke(() => L.done()));
      }
    })), this._register(so((w, S) => {
      S.add(new (ks(pX, w))(this._editors, this._diffModel, this._options, this));
    })), this._register(so((w, S) => {
      const L = this._diffModel.read(w);
      if (L)
        for (const k of [L.model.original, L.model.modified])
          S.add(k.onWillDispose((D) => {
            ht(new it("TextModel got disposed before DiffEditorWidget model got reset")), this.setModel(null);
          }));
    })), this._register(Qe((w) => {
      this._options.setModel(this._diffModel.read(w));
    }));
  }
  _createInnerEditor(e, t, i, n) {
    return e.createInstance(G_, t, i, n);
  }
  _createDiffEditorContributions() {
    const e = Kh.getDiffEditorContributions();
    for (const t of e)
      try {
        this._register(this._instantiationService.createInstance(t.ctor, this));
      } catch (i) {
        ht(i);
      }
  }
  get _targetEditor() {
    return this._editors.modified;
  }
  getEditorType() {
    return mx.IDiffEditor;
  }
  layout(e) {
    this._rootSizeObserver.observe(e);
  }
  hasTextFocus() {
    return this._editors.original.hasTextFocus() || this._editors.modified.hasTextFocus();
  }
  saveViewState() {
    var i;
    const e = this._editors.original.saveViewState(), t = this._editors.modified.saveViewState();
    return {
      original: e,
      modified: t,
      modelState: (i = this._diffModel.get()) == null ? void 0 : i.serializeState()
    };
  }
  restoreViewState(e) {
    var t;
    if (e && e.original && e.modified) {
      const i = e;
      this._editors.original.restoreViewState(i.original), this._editors.modified.restoreViewState(i.modified), i.modelState && ((t = this._diffModel.get()) == null || t.restoreSerializedState(i.modelState));
    }
  }
  handleInitialized() {
    this._editors.original.handleInitialized(), this._editors.modified.handleInitialized();
  }
  createViewModel(e) {
    return this._instantiationService.createInstance(ZS, e, this._options);
  }
  getModel() {
    var e;
    return ((e = this._diffModel.get()) == null ? void 0 : e.model) ?? null;
  }
  setModel(e) {
    const t = e ? "model" in e ? X_.create(e).createNewRef(this) : X_.create(this.createViewModel(e), this) : null;
    this.setDiffModel(t);
  }
  setDiffModel(e, t) {
    const i = this._diffModel.get();
    !e && i && this._accessibleDiffViewer.get().close(), this._diffModel.get() !== (e == null ? void 0 : e.object) && Ik(t, (n) => {
      var a;
      const o = e == null ? void 0 : e.object;
      Wt.batchEventsGlobally(n, () => {
        this._editors.original.setModel(o ? o.model.original : null), this._editors.modified.setModel(o ? o.model.modified : null);
      });
      const r = (a = this._diffModelSrc.get()) == null ? void 0 : a.createNewRef(this);
      this._diffModelSrc.set(e == null ? void 0 : e.createNewRef(this), n), setTimeout(() => {
        r == null || r.dispose();
      }, 0);
    });
  }
  /**
   * @param changedOptions Only has values for top-level options that have actually changed.
   */
  updateOptions(e) {
    this._options.updateOptions(e);
  }
  getContainerDomNode() {
    return this._domElement;
  }
  getOriginalEditor() {
    return this._editors.original;
  }
  getModifiedEditor() {
    return this._editors.modified;
  }
  /**
   * @deprecated Use `this.getDiffComputationResult().changes2` instead.
   */
  getLineChanges() {
    var t;
    const e = (t = this._diffModel.get()) == null ? void 0 : t.diff.get();
    return e ? LX(e) : null;
  }
  revert(e) {
    const t = this._diffModel.get();
    !t || !t.isDiffUpToDate.get() || this._editors.modified.executeEdits("diffEditor", [
      {
        range: e.modified.toExclusiveRange(),
        text: t.model.original.getValueInRange(e.original.toExclusiveRange())
      }
    ]);
  }
  revertRangeMappings(e) {
    const t = this._diffModel.get();
    if (!t || !t.isDiffUpToDate.get())
      return;
    const i = e.map((n) => ({
      range: n.modifiedRange,
      text: t.model.original.getValueInRange(n.originalRange)
    }));
    this._editors.modified.executeEdits("diffEditor", i);
  }
  _goTo(e) {
    this._editors.modified.setPosition(new V(e.lineRangeMapping.modified.startLineNumber, 1)), this._editors.modified.revealRangeInCenter(e.lineRangeMapping.modified.toExclusiveRange());
  }
  goToDiff(e) {
    var o, r;
    const t = (r = (o = this._diffModel.get()) == null ? void 0 : o.diff.get()) == null ? void 0 : r.mappings;
    if (!t || t.length === 0)
      return;
    const i = this._editors.modified.getPosition().lineNumber;
    let n;
    e === "next" ? n = t.find((a) => a.lineRangeMapping.modified.startLineNumber > i) ?? t[0] : n = Op(t, (a) => a.lineRangeMapping.modified.startLineNumber < i) ?? t[t.length - 1], this._goTo(n), n.lineRangeMapping.modified.isEmpty ? this._accessibilitySignalService.playSignal(Ao.diffLineDeleted, { source: "diffEditor.goToDiff" }) : n.lineRangeMapping.original.isEmpty ? this._accessibilitySignalService.playSignal(Ao.diffLineInserted, { source: "diffEditor.goToDiff" }) : n && this._accessibilitySignalService.playSignal(Ao.diffLineModified, { source: "diffEditor.goToDiff" });
  }
  revealFirstDiff() {
    const e = this._diffModel.get();
    e && this.waitForDiff().then(() => {
      var i;
      const t = (i = e.diff.get()) == null ? void 0 : i.mappings;
      !t || t.length === 0 || this._goTo(t[0]);
    });
  }
  accessibleDiffViewerNext() {
    this._accessibleDiffViewer.get().next();
  }
  accessibleDiffViewerPrev() {
    this._accessibleDiffViewer.get().prev();
  }
  async waitForDiff() {
    const e = this._diffModel.get();
    e && await e.waitForDiff();
  }
  mapToOtherSide() {
    var r, a;
    const e = this._editors.modified.hasWidgetFocus(), t = e ? this._editors.modified : this._editors.original, i = e ? this._editors.original : this._editors.modified;
    let n;
    const o = t.getSelection();
    if (o) {
      const l = (a = (r = this._diffModel.get()) == null ? void 0 : r.diff.get()) == null ? void 0 : a.mappings.map((c) => e ? c.lineRangeMapping.flip() : c.lineRangeMapping);
      if (l) {
        const c = WT(o.getStartPosition(), l), h = WT(o.getEndPosition(), l);
        n = R.plusRange(c, h);
      }
    }
    return { destination: i, destinationSelection: n };
  }
  switchSide() {
    const { destination: e, destinationSelection: t } = this.mapToOtherSide();
    e.focus(), t && e.setSelection(t);
  }
  exitCompareMove() {
    const e = this._diffModel.get();
    e && e.movedTextToCompare.set(void 0, void 0);
  }
  collapseAllUnchangedRegions() {
    var t;
    const e = (t = this._diffModel.get()) == null ? void 0 : t.unchangedRegions.get();
    e && ni((i) => {
      for (const n of e)
        n.collapseAll(i);
    });
  }
  showAllUnchangedRegions() {
    var t;
    const e = (t = this._diffModel.get()) == null ? void 0 : t.unchangedRegions.get();
    e && ni((i) => {
      for (const n of e)
        n.showAll(i);
    });
  }
  _handleCursorPositionChange(e, t) {
    var i, n;
    if ((e == null ? void 0 : e.reason) === 3) {
      const o = (n = (i = this._diffModel.get()) == null ? void 0 : i.diff.get()) == null ? void 0 : n.mappings.find((r) => t ? r.lineRangeMapping.modified.contains(e.position.lineNumber) : r.lineRangeMapping.original.contains(e.position.lineNumber));
      o != null && o.lineRangeMapping.modified.isEmpty ? this._accessibilitySignalService.playSignal(Ao.diffLineDeleted, { source: "diffEditor.cursorPositionChanged" }) : o != null && o.lineRangeMapping.original.isEmpty ? this._accessibilitySignalService.playSignal(Ao.diffLineInserted, { source: "diffEditor.cursorPositionChanged" }) : o && this._accessibilitySignalService.playSignal(Ao.diffLineModified, { source: "diffEditor.cursorPositionChanged" });
    }
  }
};
t1 = SX([
  Su(3, nt),
  Su(4, ot),
  Su(5, ri),
  Su(6, Zb),
  Su(7, xk)
], t1);
function LX(s) {
  return s.mappings.map((e) => {
    const t = e.lineRangeMapping;
    let i, n, o, r, a = t.innerChanges;
    return t.original.isEmpty ? (i = t.original.startLineNumber - 1, n = 0, a = void 0) : (i = t.original.startLineNumber, n = t.original.endLineNumberExclusive - 1), t.modified.isEmpty ? (o = t.modified.startLineNumber - 1, r = 0, a = void 0) : (o = t.modified.startLineNumber, r = t.modified.endLineNumberExclusive - 1), {
      originalStartLineNumber: i,
      originalEndLineNumber: n,
      modifiedStartLineNumber: o,
      modifiedEndLineNumber: r,
      charChanges: a == null ? void 0 : a.map((l) => ({
        originalStartLineNumber: l.originalRange.startLineNumber,
        originalStartColumn: l.originalRange.startColumn,
        originalEndLineNumber: l.originalRange.endLineNumber,
        originalEndColumn: l.originalRange.endColumn,
        modifiedStartLineNumber: l.modifiedRange.startLineNumber,
        modifiedStartColumn: l.modifiedRange.startColumn,
        modifiedEndLineNumber: l.modifiedRange.endLineNumber,
        modifiedEndColumn: l.modifiedRange.endColumn
      }))
    };
  });
}
var Ux = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, pt = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let kX = 0, o2 = !1;
function xX(s) {
  if (!s) {
    if (o2)
      return;
    o2 = !0;
  }
  cV(s || ut.document.body);
}
let i1 = class extends G_ {
  constructor(e, t, i, n, o, r, a, l, c, h, d, u, f) {
    const g = { ...t };
    g.ariaLabel = g.ariaLabel || ty.editorViewAccessibleLabel, super(e, g, {}, i, n, o, r, c, h, d, u, f), l instanceof Ad ? this._standaloneKeybindingService = l : this._standaloneKeybindingService = null, xX(g.ariaContainerElement), xH((m, _) => i.createInstance(Kf, m, _, {})), DH(a);
  }
  addCommand(e, t, i) {
    if (!this._standaloneKeybindingService)
      return console.warn("Cannot add command because the editor is configured with an unrecognized KeybindingService"), null;
    const n = "DYNAMIC_" + ++kX, o = et.deserialize(i);
    return this._standaloneKeybindingService.addDynamicKeybinding(n, e, t, o), n;
  }
  createContextKey(e, t) {
    return this._contextKeyService.createKey(e, t);
  }
  addAction(e) {
    if (typeof e.id != "string" || typeof e.label != "string" || typeof e.run != "function")
      throw new Error("Invalid action descriptor, `id`, `label` and `run` are required properties!");
    if (!this._standaloneKeybindingService)
      return console.warn("Cannot add keybinding because the editor is configured with an unrecognized KeybindingService"), q.None;
    const t = e.id, i = e.label, n = et.and(et.equals("editorId", this.getId()), et.deserialize(e.precondition)), o = e.keybindings, r = et.and(n, et.deserialize(e.keybindingContext)), a = e.contextMenuGroupId || null, l = e.contextMenuOrder || 0, c = (f, ...g) => Promise.resolve(e.run(this, ...g)), h = new he(), d = this.getId() + ":" + t;
    if (h.add(Sn.registerCommand(d, c)), a) {
      const f = {
        command: {
          id: d,
          title: i
        },
        when: n,
        group: a,
        order: l
      };
      h.add(Cd.appendMenuItem(Ti.EditorContext, f));
    }
    if (Array.isArray(o))
      for (const f of o)
        h.add(this._standaloneKeybindingService.addDynamicKeybinding(d, f, c, r));
    const u = new h5(d, i, i, void 0, n, (...f) => Promise.resolve(e.run(this, ...f)), this._contextKeyService);
    return this._actions.set(t, u), h.add(ke(() => {
      this._actions.delete(t);
    })), h;
  }
  _triggerCommand(e, t) {
    if (this._codeEditorService instanceof Hp)
      try {
        this._codeEditorService.setActiveCodeEditor(this), super._triggerCommand(e, t);
      } finally {
        this._codeEditorService.setActiveCodeEditor(null);
      }
    else
      super._triggerCommand(e, t);
  }
};
i1 = Ux([
  pt(2, ot),
  pt(3, ri),
  pt(4, ss),
  pt(5, nt),
  pt(6, Ag),
  pt(7, Ai),
  pt(8, Ws),
  pt(9, fo),
  pt(10, go),
  pt(11, Zo),
  pt(12, gt)
], i1);
let oL = class extends i1 {
  constructor(e, t, i, n, o, r, a, l, c, h, d, u, f, g, m, _) {
    const b = { ...t };
    I_(d, b, !1);
    const C = c.registerEditorContainer(e);
    typeof b.theme == "string" && c.setTheme(b.theme), typeof b.autoDetectHighContrast < "u" && c.setAutoDetectHighContrast(!!b.autoDetectHighContrast);
    const v = b.model;
    delete b.model, super(e, b, i, n, o, r, a, l, c, h, u, m, _), this._configurationService = d, this._standaloneThemeService = c, this._register(C);
    let w;
    if (typeof v > "u") {
      const S = g.getLanguageIdByMimeType(b.language) || b.language || Ms;
      w = L5(f, g, b.value || "", S, void 0), this._ownsModel = !0;
    } else
      w = v, this._ownsModel = !1;
    if (this._attachModel(w), w) {
      const S = {
        oldModelUrl: null,
        newModelUrl: w.uri
      };
      this._onDidChangeModel.fire(S);
    }
  }
  dispose() {
    super.dispose();
  }
  updateOptions(e) {
    I_(this._configurationService, e, !1), typeof e.theme == "string" && this._standaloneThemeService.setTheme(e.theme), typeof e.autoDetectHighContrast < "u" && this._standaloneThemeService.setAutoDetectHighContrast(!!e.autoDetectHighContrast), super.updateOptions(e);
  }
  _postDetachModelCleanup(e) {
    super._postDetachModelCleanup(e), e && this._ownsModel && (e.dispose(), this._ownsModel = !1);
  }
};
oL = Ux([
  pt(2, ot),
  pt(3, ri),
  pt(4, ss),
  pt(5, nt),
  pt(6, Ag),
  pt(7, Ai),
  pt(8, Vs),
  pt(9, fo),
  pt(10, Vt),
  pt(11, go),
  pt(12, cn),
  pt(13, gi),
  pt(14, Zo),
  pt(15, gt)
], oL);
let rL = class extends t1 {
  constructor(e, t, i, n, o, r, a, l, c, h, d, u) {
    const f = { ...t };
    I_(l, f, !0);
    const g = r.registerEditorContainer(e);
    typeof f.theme == "string" && r.setTheme(f.theme), typeof f.autoDetectHighContrast < "u" && r.setAutoDetectHighContrast(!!f.autoDetectHighContrast), super(e, f, {}, n, i, o, u, h), this._configurationService = l, this._standaloneThemeService = r, this._register(g);
  }
  dispose() {
    super.dispose();
  }
  updateOptions(e) {
    I_(this._configurationService, e, !0), typeof e.theme == "string" && this._standaloneThemeService.setTheme(e.theme), typeof e.autoDetectHighContrast < "u" && this._standaloneThemeService.setAutoDetectHighContrast(!!e.autoDetectHighContrast), super.updateOptions(e);
  }
  _createInnerEditor(e, t, i) {
    return e.createInstance(i1, t, i);
  }
  getOriginalEditor() {
    return super.getOriginalEditor();
  }
  getModifiedEditor() {
    return super.getModifiedEditor();
  }
  addCommand(e, t, i) {
    return this.getModifiedEditor().addCommand(e, t, i);
  }
  createContextKey(e, t) {
    return this.getModifiedEditor().createContextKey(e, t);
  }
  addAction(e) {
    return this.getModifiedEditor().addAction(e);
  }
};
rL = Ux([
  pt(2, ot),
  pt(3, nt),
  pt(4, ri),
  pt(5, Vs),
  pt(6, fo),
  pt(7, Vt),
  pt(8, ea),
  pt(9, xk),
  pt(10, fx),
  pt(11, Zb)
], rL);
function L5(s, e, t, i, n) {
  if (t = t || "", !i) {
    const o = t.indexOf(`
`);
    let r = t;
    return o !== -1 && (r = t.substring(0, o)), r2(s, t, e.createByFilepathOrFirstLine(n || null, r), n);
  }
  return r2(s, t, e.createById(i), n);
}
function r2(s, e, t, i) {
  return s.createModel(e, t, i);
}
var DX = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, a2 = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
class EX {
  constructor(e, t) {
    this.viewModel = e, this.deltaScrollVertical = t;
  }
  getId() {
    return this.viewModel;
  }
}
let n1 = class extends q {
  constructor(e, t, i, n, o) {
    super(), this._container = e, this._overflowWidgetsDomNode = t, this._workbenchUIElementFactory = i, this._instantiationService = n, this._viewModel = $e(this, void 0), this._collapsed = Se(this, (l) => {
      var c;
      return (c = this._viewModel.read(l)) == null ? void 0 : c.collapsed.read(l);
    }), this._editorContentHeight = $e(this, 500), this.contentHeight = Se(this, (l) => (this._collapsed.read(l) ? 0 : this._editorContentHeight.read(l)) + this._outerEditorHeight), this._modifiedContentWidth = $e(this, 0), this._modifiedWidth = $e(this, 0), this._originalContentWidth = $e(this, 0), this._originalWidth = $e(this, 0), this.maxScroll = Se(this, (l) => {
      const c = this._modifiedContentWidth.read(l) - this._modifiedWidth.read(l), h = this._originalContentWidth.read(l) - this._originalWidth.read(l);
      return c > h ? { maxScroll: c, width: this._modifiedWidth.read(l) } : { maxScroll: h, width: this._originalWidth.read(l) };
    }), this._elements = Ue("div.multiDiffEntry", [
      Ue("div.header@header", [
        Ue("div.header-content", [
          Ue("div.collapse-button@collapseButton"),
          Ue("div.file-path", [
            Ue("div.title.modified.show-file-icons@primaryPath", []),
            Ue("div.status.deleted@status", ["R"]),
            Ue("div.title.original.show-file-icons@secondaryPath", [])
          ]),
          Ue("div.actions@actions")
        ])
      ]),
      Ue("div.editorParent", [
        Ue("div.editorContainer@editor")
      ])
    ]), this.editor = this._register(this._instantiationService.createInstance(t1, this._elements.editor, {
      overflowWidgetsDomNode: this._overflowWidgetsDomNode
    }, {})), this.isModifedFocused = pg(this.editor.getModifiedEditor()).isFocused, this.isOriginalFocused = pg(this.editor.getOriginalEditor()).isFocused, this.isFocused = Se(this, (l) => this.isModifedFocused.read(l) || this.isOriginalFocused.read(l)), this._resourceLabel = this._workbenchUIElementFactory.createResourceLabel ? this._register(this._workbenchUIElementFactory.createResourceLabel(this._elements.primaryPath)) : void 0, this._resourceLabel2 = this._workbenchUIElementFactory.createResourceLabel ? this._register(this._workbenchUIElementFactory.createResourceLabel(this._elements.secondaryPath)) : void 0, this._dataStore = this._register(new he()), this._headerHeight = 40, this._lastScrollTop = -1, this._isSettingScrollTop = !1;
    const r = new Fy(this._elements.collapseButton, {});
    this._register(Qe((l) => {
      r.element.className = "", r.icon = this._collapsed.read(l) ? re.chevronRight : re.chevronDown;
    })), this._register(r.onDidClick(() => {
      var l;
      (l = this._viewModel.get()) == null || l.collapsed.set(!this._collapsed.get(), void 0);
    })), this._register(Qe((l) => {
      this._elements.editor.style.display = this._collapsed.read(l) ? "none" : "block";
    })), this._register(this.editor.getModifiedEditor().onDidLayoutChange((l) => {
      const c = this.editor.getModifiedEditor().getLayoutInfo().contentWidth;
      this._modifiedWidth.set(c, void 0);
    })), this._register(this.editor.getOriginalEditor().onDidLayoutChange((l) => {
      const c = this.editor.getOriginalEditor().getLayoutInfo().contentWidth;
      this._originalWidth.set(c, void 0);
    })), this._register(this.editor.onDidContentSizeChange((l) => {
      Iu((c) => {
        this._editorContentHeight.set(l.contentHeight, c), this._modifiedContentWidth.set(this.editor.getModifiedEditor().getContentWidth(), c), this._originalContentWidth.set(this.editor.getOriginalEditor().getContentWidth(), c);
      });
    })), this._register(this.editor.getOriginalEditor().onDidScrollChange((l) => {
      if (this._isSettingScrollTop || !l.scrollTopChanged || !this._data)
        return;
      const c = l.scrollTop - this._lastScrollTop;
      this._data.deltaScrollVertical(c);
    })), this._register(Qe((l) => {
      var h;
      const c = (h = this._viewModel.read(l)) == null ? void 0 : h.isActive.read(l);
      this._elements.root.classList.toggle("active", c);
    })), this._container.appendChild(this._elements.root), this._outerEditorHeight = this._headerHeight, this._contextKeyService = this._register(o.createScoped(this._elements.actions));
    const a = this._register(this._instantiationService.createChild(new jd([nt, this._contextKeyService])));
    this._register(a.createInstance(J_, this._elements.actions, Ti.MultiDiffEditorFileToolbar, {
      actionRunner: this._register(new v5(() => {
        var l;
        return (l = this._viewModel.get()) == null ? void 0 : l.modifiedUri;
      })),
      menuOptions: {
        shouldForwardArgs: !0
      },
      toolbarOptions: { primaryGroup: (l) => l.startsWith("navigation") },
      actionViewItemProvider: (l, c) => _z(a, l, c)
    }));
  }
  setScrollLeft(e) {
    this._modifiedContentWidth.get() - this._modifiedWidth.get() > this._originalContentWidth.get() - this._originalWidth.get() ? this.editor.getModifiedEditor().setScrollLeft(e) : this.editor.getOriginalEditor().setScrollLeft(e);
  }
  setData(e) {
    this._data = e;
    function t(n) {
      return {
        ...n,
        scrollBeyondLastLine: !1,
        hideUnchangedRegions: {
          enabled: !0
        },
        scrollbar: {
          vertical: "hidden",
          horizontal: "hidden",
          handleMouseWheel: !1,
          useShadows: !1
        },
        renderOverviewRuler: !1,
        fixedOverflowWidgets: !0,
        overviewRulerBorder: !1
      };
    }
    if (!e) {
      Iu((n) => {
        this._viewModel.set(void 0, n), this.editor.setDiffModel(null, n), this._dataStore.clear();
      });
      return;
    }
    const i = e.viewModel.documentDiffItem;
    if (Iu((n) => {
      var c, h;
      (c = this._resourceLabel) == null || c.setUri(e.viewModel.modifiedUri ?? e.viewModel.originalUri, { strikethrough: e.viewModel.modifiedUri === void 0 });
      let o = !1, r = !1, a = !1, l = "";
      e.viewModel.modifiedUri && e.viewModel.originalUri && e.viewModel.modifiedUri.path !== e.viewModel.originalUri.path ? (l = "R", o = !0) : e.viewModel.modifiedUri ? e.viewModel.originalUri || (l = "A", a = !0) : (l = "D", r = !0), this._elements.status.classList.toggle("renamed", o), this._elements.status.classList.toggle("deleted", r), this._elements.status.classList.toggle("added", a), this._elements.status.innerText = l, (h = this._resourceLabel2) == null || h.setUri(o ? e.viewModel.originalUri : void 0, { strikethrough: !0 }), this._dataStore.clear(), this._viewModel.set(e.viewModel, n), this.editor.setDiffModel(e.viewModel.diffEditorViewModelRef, n), this.editor.updateOptions(t(i.options ?? {}));
    }), i.onOptionsDidChange && this._dataStore.add(i.onOptionsDidChange(() => {
      this.editor.updateOptions(t(i.options ?? {}));
    })), e.viewModel.isAlive.recomputeInitiallyAndOnChange(this._dataStore, (n) => {
      n || this.setData(void 0);
    }), e.viewModel.documentDiffItem.contextKeys)
      for (const [n, o] of Object.entries(e.viewModel.documentDiffItem.contextKeys))
        this._contextKeyService.createKey(n, o);
  }
  render(e, t, i, n) {
    this._elements.root.style.visibility = "visible", this._elements.root.style.top = `${e.start}px`, this._elements.root.style.height = `${e.length}px`, this._elements.root.style.width = `${t}px`, this._elements.root.style.position = "absolute";
    const o = e.length - this._headerHeight, r = Math.max(0, Math.min(n.start - e.start, o));
    this._elements.header.style.transform = `translateY(${r}px)`, Iu((a) => {
      this.editor.layout({
        width: t - 16 - 2,
        height: e.length - this._outerEditorHeight
      });
    });
    try {
      this._isSettingScrollTop = !0, this._lastScrollTop = i, this.editor.getOriginalEditor().setScrollTop(i);
    } finally {
      this._isSettingScrollTop = !1;
    }
    this._elements.header.classList.toggle("shadow", r > 0 || i > 0), this._elements.header.classList.toggle("collapsed", r === o);
  }
  hide() {
    this._elements.root.style.top = "-100000px", this._elements.root.style.visibility = "hidden";
  }
};
n1 = DX([
  a2(3, ot),
  a2(4, nt)
], n1);
class IX {
  constructor(e) {
    this._create = e, this._unused = /* @__PURE__ */ new Set(), this._used = /* @__PURE__ */ new Set(), this._itemData = /* @__PURE__ */ new Map();
  }
  getUnusedObj(e) {
    let t;
    if (this._unused.size === 0)
      t = this._create(e), this._itemData.set(t, e);
    else {
      const i = [...this._unused.values()];
      t = i.find((n) => this._itemData.get(n).getId() === e.getId()) ?? i[0], this._unused.delete(t), this._itemData.set(t, e), t.setData(e);
    }
    return this._used.add(t), {
      object: t,
      dispose: () => {
        this._used.delete(t), this._unused.size > 5 ? t.dispose() : this._unused.add(t);
      }
    };
  }
  dispose() {
    for (const e of this._used)
      e.dispose();
    for (const e of this._unused)
      e.dispose();
    this._used.clear(), this._unused.clear();
  }
}
var NX = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, l2 = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let aL = class extends q {
  constructor(e, t, i, n, o, r) {
    super(), this._element = e, this._dimension = t, this._viewModel = i, this._workbenchUIElementFactory = n, this._parentContextKeyService = o, this._parentInstantiationService = r, this._scrollableElements = Ue("div.scrollContent", [
      Ue("div@content", {
        style: {
          overflow: "hidden"
        }
      }),
      Ue("div.monaco-editor@overflowWidgetsDomNode", {})
    ]), this._scrollable = this._register(new zd({
      forceIntegerValues: !1,
      scheduleAtNextAnimationFrame: (l) => Wn(ue(this._element), l),
      smoothScrollDuration: 100
    })), this._scrollableElement = this._register(new xb(this._scrollableElements.root, {
      vertical: 1,
      horizontal: 1,
      useShadows: !1
    }, this._scrollable)), this._elements = Ue("div.monaco-component.multiDiffEditor", {}, [
      Ue("div", {}, [this._scrollableElement.getDomNode()]),
      Ue("div.placeholder@placeholder", {}, [Ue("div", [p("noChangedFiles", "No Changed Files")])])
    ]), this._sizeObserver = this._register(new g5(this._element, void 0)), this._objectPool = this._register(new IX((l) => {
      const c = this._instantiationService.createInstance(n1, this._scrollableElements.content, this._scrollableElements.overflowWidgetsDomNode, this._workbenchUIElementFactory);
      return c.setData(l), c;
    })), this.scrollTop = Wt(this, this._scrollableElement.onScroll, () => (
      /** @description scrollTop */
      this._scrollableElement.getScrollPosition().scrollTop
    )), this.scrollLeft = Wt(this, this._scrollableElement.onScroll, () => (
      /** @description scrollLeft */
      this._scrollableElement.getScrollPosition().scrollLeft
    )), this._viewItemsInfo = $d(this, (l, c) => {
      const h = this._viewModel.read(l);
      if (!h)
        return { items: [], getItem: (g) => {
          throw new it();
        } };
      const d = h.items.read(l), u = /* @__PURE__ */ new Map();
      return { items: d.map((g) => {
        var b;
        const m = c.add(new TX(g, this._objectPool, this.scrollLeft, (C) => {
          this._scrollableElement.setScrollPosition({ scrollTop: this._scrollableElement.getScrollPosition().scrollTop + C });
        })), _ = (b = this._lastDocStates) == null ? void 0 : b[m.getKey()];
        return _ && ni((C) => {
          m.setViewState(_, C);
        }), u.set(g, m), m;
      }), getItem: (g) => u.get(g) };
    }), this._viewItems = this._viewItemsInfo.map(this, (l) => l.items), this._spaceBetweenPx = 0, this._totalHeight = this._viewItems.map(this, (l, c) => l.reduce((h, d) => h + d.contentHeight.read(c) + this._spaceBetweenPx, 0)), this._contextKeyService = this._register(this._parentContextKeyService.createScoped(this._element)), this._instantiationService = this._register(this._parentInstantiationService.createChild(new jd([nt, this._contextKeyService]))), this._lastDocStates = {}, this._contextKeyService.createKey(se.inMultiDiffEditor.key, !0), this._register(so((l, c) => {
      const h = this._viewModel.read(l);
      if (h && h.contextKeys)
        for (const [d, u] of Object.entries(h.contextKeys)) {
          const f = this._contextKeyService.createKey(d, void 0);
          f.set(u), c.add(ke(() => f.reset()));
        }
    }));
    const a = this._parentContextKeyService.createKey(se.multiDiffEditorAllCollapsed.key, !1);
    this._register(Qe((l) => {
      const c = this._viewModel.read(l);
      if (c) {
        const h = c.items.read(l).every((d) => d.collapsed.read(l));
        a.set(h);
      }
    })), this._register(Qe((l) => {
      const c = this._dimension.read(l);
      this._sizeObserver.observe(c);
    })), this._register(Qe((l) => {
      const c = this._viewItems.read(l);
      this._elements.placeholder.classList.toggle("visible", c.length === 0);
    })), this._scrollableElements.content.style.position = "relative", this._register(Qe((l) => {
      const c = this._sizeObserver.height.read(l);
      this._scrollableElements.root.style.height = `${c}px`;
      const h = this._totalHeight.read(l);
      this._scrollableElements.content.style.height = `${h}px`;
      const d = this._sizeObserver.width.read(l);
      let u = d;
      const f = this._viewItems.read(l), g = XM(f, Ts((m) => m.maxScroll.read(l).maxScroll, Aa));
      if (g) {
        const m = g.maxScroll.read(l);
        u = d + m.maxScroll;
      }
      this._scrollableElement.setScrollDimensions({
        width: d,
        height: c,
        scrollHeight: h,
        scrollWidth: u
      });
    })), e.replaceChildren(this._elements.root), this._register(ke(() => {
      e.replaceChildren();
    })), this._register(this._register(Qe((l) => {
      Iu((c) => {
        this.render(l);
      });
    })));
  }
  render(e) {
    const t = this.scrollTop.read(e);
    let i = 0, n = 0, o = 0;
    const r = this._sizeObserver.height.read(e), a = xe.ofStartAndLength(t, r), l = this._sizeObserver.width.read(e);
    for (const c of this._viewItems.read(e)) {
      const h = c.contentHeight.read(e), d = Math.min(h, r), u = xe.ofStartAndLength(n, d), f = xe.ofStartAndLength(o, h);
      if (f.isBefore(a))
        i -= h - d, c.hide();
      else if (f.isAfter(a))
        c.hide();
      else {
        const g = Math.max(0, Math.min(a.start - f.start, h - d));
        i -= g;
        const m = xe.ofStartAndLength(t + i, r);
        c.render(u, g, l, m);
      }
      n += d + this._spaceBetweenPx, o += h + this._spaceBetweenPx;
    }
    this._scrollableElements.content.style.transform = `translateY(${-(t + i)}px)`;
  }
};
aL = NX([
  l2(4, nt),
  l2(5, ot)
], aL);
class TX extends q {
  constructor(e, t, i, n) {
    super(), this.viewModel = e, this._objectPool = t, this._scrollLeft = i, this._deltaScrollVertical = n, this._templateRef = this._register(_A(this, void 0)), this.contentHeight = Se(this, (o) => {
      var r, a;
      return ((a = (r = this._templateRef.read(o)) == null ? void 0 : r.object.contentHeight) == null ? void 0 : a.read(o)) ?? this.viewModel.lastTemplateData.read(o).contentHeight;
    }), this.maxScroll = Se(this, (o) => {
      var r;
      return ((r = this._templateRef.read(o)) == null ? void 0 : r.object.maxScroll.read(o)) ?? { maxScroll: 0, scrollWidth: 0 };
    }), this.template = Se(this, (o) => {
      var r;
      return (r = this._templateRef.read(o)) == null ? void 0 : r.object;
    }), this._isHidden = $e(this, !1), this._isFocused = Se(this, (o) => {
      var r;
      return ((r = this.template.read(o)) == null ? void 0 : r.isFocused.read(o)) ?? !1;
    }), this.viewModel.setIsFocused(this._isFocused, void 0), this._register(Qe((o) => {
      var a;
      const r = this._scrollLeft.read(o);
      (a = this._templateRef.read(o)) == null || a.object.setScrollLeft(r);
    })), this._register(Qe((o) => {
      const r = this._templateRef.read(o);
      !r || !this._isHidden.read(o) || r.object.isFocused.read(o) || this._clear();
    }));
  }
  dispose() {
    this._clear(), super.dispose();
  }
  toString() {
    var e;
    return `VirtualViewItem(${(e = this.viewModel.documentDiffItem.modified) == null ? void 0 : e.uri.toString()})`;
  }
  getKey() {
    return this.viewModel.getKey();
  }
  setViewState(e, t) {
    var r;
    this.viewModel.collapsed.set(e.collapsed, t), this._updateTemplateData(t);
    const i = this.viewModel.lastTemplateData.get(), n = (r = e.selections) == null ? void 0 : r.map(ft.liftSelection);
    this.viewModel.lastTemplateData.set({
      ...i,
      selections: n
    }, t);
    const o = this._templateRef.get();
    o && n && o.object.editor.setSelections(n);
  }
  _updateTemplateData(e) {
    const t = this._templateRef.get();
    t && this.viewModel.lastTemplateData.set({
      contentHeight: t.object.contentHeight.get(),
      selections: t.object.editor.getSelections() ?? void 0
    }, e);
  }
  _clear() {
    const e = this._templateRef.get();
    e && ni((t) => {
      this._updateTemplateData(t), e.object.hide(), this._templateRef.set(void 0, t);
    });
  }
  hide() {
    this._isHidden.set(!0, void 0);
  }
  render(e, t, i, n) {
    this._isHidden.set(!1, void 0);
    let o = this._templateRef.get();
    if (!o) {
      o = this._objectPool.getUnusedObj(new EX(this.viewModel, this._deltaScrollVertical)), this._templateRef.set(o, void 0);
      const r = this.viewModel.lastTemplateData.get().selections;
      r && o.object.editor.setSelections(r);
    }
    o.object.render(e, i, t, n);
  }
}
N("multiDiffEditor.headerBackground", { dark: "#262626", light: "tab.inactiveBackground", hcDark: "tab.inactiveBackground", hcLight: "tab.inactiveBackground" }, p("multiDiffEditor.headerBackground", "The background color of the diff editor's header"));
N("multiDiffEditor.background", ro, p("multiDiffEditor.background", "The background color of the multi file diff editor"));
N("multiDiffEditor.border", { dark: "sideBarSectionHeader.border", light: "#cccccc", hcDark: "sideBarSectionHeader.border", hcLight: "#cccccc" }, p("multiDiffEditor.border", "The border color of the multi file diff editor"));
var MX = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, RX = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let lL = class extends q {
  constructor(e, t, i) {
    super(), this._element = e, this._workbenchUIElementFactory = t, this._instantiationService = i, this._dimension = $e(this, void 0), this._viewModel = $e(this, void 0), this._widgetImpl = $d(this, (n, o) => (ks(n1, n), o.add(this._instantiationService.createInstance(ks(aL, n), this._element, this._dimension, this._viewModel, this._workbenchUIElementFactory)))), this._register(Pb(this._widgetImpl));
  }
};
lL = MX([
  RX(2, ot)
], lL);
function AX(s, e, t) {
  return fe.initialize(t || {}).createInstance(oL, s, e);
}
function PX(s) {
  return fe.get(ri).onCodeEditorAdd((t) => {
    s(t);
  });
}
function OX(s) {
  return fe.get(ri).onDiffEditorAdd((t) => {
    s(t);
  });
}
function FX() {
  return fe.get(ri).listCodeEditors();
}
function BX() {
  return fe.get(ri).listDiffEditors();
}
function WX(s, e, t) {
  return fe.initialize(t || {}).createInstance(rL, s, e);
}
function VX(s, e) {
  const t = fe.initialize(e || {});
  return new lL(s, {}, t);
}
function HX(s) {
  if (typeof s.id != "string" || typeof s.run != "function")
    throw new Error("Invalid command descriptor, `id` and `run` are required properties!");
  return Sn.registerCommand(s.id, s.run);
}
function zX(s) {
  if (typeof s.id != "string" || typeof s.label != "string" || typeof s.run != "function")
    throw new Error("Invalid action descriptor, `id`, `label` and `run` are required properties!");
  const e = et.deserialize(s.precondition), t = (n, ...o) => Cc.runEditorCommand(n, o, e, (r, a, l) => Promise.resolve(s.run(a, ...l))), i = new he();
  if (i.add(Sn.registerCommand(s.id, t)), s.contextMenuGroupId) {
    const n = {
      command: {
        id: s.id,
        title: s.label
      },
      when: e,
      group: s.contextMenuGroupId,
      order: s.contextMenuOrder || 0
    };
    i.add(Cd.appendMenuItem(Ti.EditorContext, n));
  }
  if (Array.isArray(s.keybindings)) {
    const n = fe.get(Ai);
    if (!(n instanceof Ad))
      console.warn("Cannot add keybinding because the editor is configured with an unrecognized KeybindingService");
    else {
      const o = et.and(e, et.deserialize(s.keybindingContext));
      i.add(n.addDynamicKeybindings(s.keybindings.map((r) => ({
        keybinding: r,
        command: s.id,
        when: o
      }))));
    }
  }
  return i;
}
function UX(s) {
  return k5([s]);
}
function k5(s) {
  const e = fe.get(Ai);
  return e instanceof Ad ? e.addDynamicKeybindings(s.map((t) => ({
    keybinding: t.keybinding,
    command: t.command,
    commandArgs: t.commandArgs,
    when: et.deserialize(t.when)
  }))) : (console.warn("Cannot add keybinding because the editor is configured with an unrecognized KeybindingService"), q.None);
}
function $X(s, e, t) {
  const i = fe.get(gi), n = i.getLanguageIdByMimeType(e) || e;
  return L5(fe.get(cn), i, s, n, t);
}
function KX(s, e) {
  const t = fe.get(gi), i = t.getLanguageIdByMimeType(e) || e || Ms;
  s.setLanguage(t.createById(i));
}
function qX(s, e, t) {
  s && fe.get(Bc).changeOne(e, s.uri, t);
}
function jX(s) {
  fe.get(Bc).changeAll(s, []);
}
function GX(s) {
  return fe.get(Bc).read(s);
}
function ZX(s) {
  return fe.get(Bc).onMarkerChanged(s);
}
function YX(s) {
  return fe.get(cn).getModel(s);
}
function QX() {
  return fe.get(cn).getModels();
}
function XX(s) {
  return fe.get(cn).onModelAdded(s);
}
function JX(s) {
  return fe.get(cn).onModelRemoved(s);
}
function eJ(s) {
  return fe.get(cn).onModelLanguageChanged((t) => {
    s({
      model: t.model,
      oldLanguage: t.oldLanguageId
    });
  });
}
function tJ(s) {
  return Oj(fe.get(cn), s);
}
function iJ(s, e) {
  const t = fe.get(gi), i = fe.get(Vs);
  return bx.colorizeElement(i, t, s, e).then(() => {
    i.registerEditorContainer(s);
  });
}
function nJ(s, e, t) {
  const i = fe.get(gi);
  return fe.get(Vs).registerEditorContainer(ut.document.body), bx.colorize(i, s, e, t);
}
function sJ(s, e, t = 4) {
  return fe.get(Vs).registerEditorContainer(ut.document.body), bx.colorizeModelLine(s, e, t);
}
function oJ(s) {
  const e = Yt.get(s);
  return e || {
    getInitialState: () => jf,
    tokenize: (t, i, n) => cA(s, n)
  };
}
function rJ(s, e) {
  Yt.getOrCreate(e);
  const t = oJ(e), i = Vd(s), n = [];
  let o = t.getInitialState();
  for (let r = 0, a = i.length; r < a; r++) {
    const l = i[r], c = t.tokenize(l, !0, o);
    n[r] = c.tokens, o = c.endState;
  }
  return n;
}
function aJ(s, e) {
  fe.get(Vs).defineTheme(s, e);
}
function lJ(s) {
  fe.get(Vs).setTheme(s);
}
function cJ() {
  ev.clearAllFontInfos();
}
function hJ(s, e) {
  return Sn.registerCommand({ id: s, handler: e });
}
function dJ(s) {
  return fe.get(Og).registerOpener({
    async open(t) {
      return typeof t == "string" && (t = Te.parse(t)), s.open(t);
    }
  });
}
function uJ(s) {
  return fe.get(ri).registerCodeEditorOpenHandler(async (t, i, n) => {
    var a;
    if (!i)
      return null;
    const o = (a = t.options) == null ? void 0 : a.selection;
    let r;
    return o && typeof o.endLineNumber == "number" && typeof o.endColumn == "number" ? r = o : o && (r = { lineNumber: o.startLineNumber, column: o.startColumn }), await s.openCodeEditor(i, t.resource, r) ? i : null;
  });
}
function fJ() {
  return {
    // methods
    create: AX,
    getEditors: FX,
    getDiffEditors: BX,
    onDidCreateEditor: PX,
    onDidCreateDiffEditor: OX,
    createDiffEditor: WX,
    addCommand: HX,
    addEditorAction: zX,
    addKeybindingRule: UX,
    addKeybindingRules: k5,
    createModel: $X,
    setModelLanguage: KX,
    setModelMarkers: qX,
    getModelMarkers: GX,
    removeAllMarkers: jX,
    onDidChangeMarkers: ZX,
    getModels: QX,
    getModel: YX,
    onDidCreateModel: XX,
    onWillDisposeModel: JX,
    onDidChangeModelLanguage: eJ,
    createWebWorker: tJ,
    colorizeElement: iJ,
    colorize: nJ,
    colorizeModelLine: sJ,
    tokenize: rJ,
    defineTheme: aJ,
    setTheme: lJ,
    remeasureFonts: cJ,
    registerCommand: hJ,
    registerLinkOpener: dJ,
    registerEditorOpener: uJ,
    // enums
    AccessibilitySupport: UC,
    ContentWidgetPositionPreference: ZC,
    CursorChangeReason: YC,
    DefaultEndOfLine: QC,
    EditorAutoIndentStrategy: JC,
    EditorOption: ew,
    EndOfLinePreference: tw,
    EndOfLineSequence: iw,
    MinimapPosition: fw,
    MinimapSectionHeaderStyle: gw,
    MouseTargetType: mw,
    OverlayWidgetPositionPreference: bw,
    OverviewRulerLane: Cw,
    GlyphMarginLane: nw,
    RenderLineNumbersType: yw,
    RenderMinimap: Sw,
    ScrollbarVisibility: kw,
    ScrollType: Lw,
    TextEditorCursorBlinkingStyle: Tw,
    TextEditorCursorStyle: Mw,
    TrackedRangeStickiness: Rw,
    WrappingIndent: Aw,
    InjectedTextCursorStops: rw,
    PositionAffinity: vw,
    ShowLightbulbIconMode: Dw,
    // classes
    ConfigurationChangedEvent: T2,
    BareFontInfo: Zl,
    FontInfo: Jw,
    TextModelResolvedOptions: Gm,
    FindMatch: Vf,
    ApplyUpdateResult: Ou,
    EditorZoom: Ca,
    createMultiFileDiffEditor: VX,
    // vars
    EditorType: mx,
    EditorOptions: xc
  };
}
function gJ(s, e) {
  if (!e || !Array.isArray(e))
    return !1;
  for (const t of e)
    if (!s(t))
      return !1;
  return !0;
}
function Hm(s, e) {
  return typeof s == "boolean" ? s : e;
}
function c2(s, e) {
  return typeof s == "string" ? s : e;
}
function mJ(s) {
  const e = {};
  for (const t of s)
    e[t] = !0;
  return e;
}
function h2(s, e = !1) {
  e && (s = s.map(function(i) {
    return i.toLowerCase();
  }));
  const t = mJ(s);
  return e ? function(i) {
    return t[i.toLowerCase()] !== void 0 && t.hasOwnProperty(i.toLowerCase());
  } : function(i) {
    return t[i] !== void 0 && t.hasOwnProperty(i);
  };
}
function cL(s, e, t) {
  e = e.replace(/@@/g, "");
  let i = 0, n;
  do
    n = !1, e = e.replace(/@(\w+)/g, function(r, a) {
      n = !0;
      let l = "";
      if (typeof s[a] == "string")
        l = s[a];
      else if (s[a] && s[a] instanceof RegExp)
        l = s[a].source;
      else
        throw s[a] === void 0 ? St(s, "language definition does not contain attribute '" + a + "', used at: " + e) : St(s, "attribute reference '" + a + "' must be a string, used at: " + e);
      return Ml(l) ? "" : "(?:" + l + ")";
    }), i++;
  while (n && i < 5);
  e = e.replace(/\x01/g, "@");
  const o = (s.ignoreCase ? "i" : "") + (s.unicode ? "u" : "");
  if (t && e.match(/\$[sS](\d\d?)/g)) {
    let a = null, l = null;
    return (c) => (l && a === c || (a = c, l = new RegExp(tG(s, e, c), o)), l);
  }
  return new RegExp(e, o);
}
function pJ(s, e, t, i) {
  if (i < 0)
    return s;
  if (i < e.length)
    return e[i];
  if (i >= 100) {
    i = i - 100;
    const n = t.split(".");
    if (n.unshift(t), i < n.length)
      return n[i];
  }
  return null;
}
function _J(s, e, t, i) {
  let n = -1, o = t, r = t.match(/^\$(([sS]?)(\d\d?)|#)(.*)$/);
  r && (r[3] && (n = parseInt(r[3]), r[2] && (n = n + 100)), o = r[4]);
  let a = "~", l = o;
  !o || o.length === 0 ? (a = "!=", l = "") : /^\w*$/.test(l) ? a = "==" : (r = o.match(/^(@|!@|~|!~|==|!=)(.*)$/), r && (a = r[1], l = r[2]));
  let c;
  if ((a === "~" || a === "!~") && /^(\w|\|)*$/.test(l)) {
    const h = h2(l.split("|"), s.ignoreCase);
    c = function(d) {
      return a === "~" ? h(d) : !h(d);
    };
  } else if (a === "@" || a === "!@") {
    const h = s[l];
    if (!h)
      throw St(s, "the @ match target '" + l + "' is not defined, in rule: " + e);
    if (!gJ(function(u) {
      return typeof u == "string";
    }, h))
      throw St(s, "the @ match target '" + l + "' must be an array of strings, in rule: " + e);
    const d = h2(h, s.ignoreCase);
    c = function(u) {
      return a === "@" ? d(u) : !d(u);
    };
  } else if (a === "~" || a === "!~")
    if (l.indexOf("$") < 0) {
      const h = cL(s, "^" + l + "$", !1);
      c = function(d) {
        return a === "~" ? h.test(d) : !h.test(d);
      };
    } else
      c = function(h, d, u, f) {
        return cL(s, "^" + ya(s, l, d, u, f) + "$", !1).test(h);
      };
  else if (l.indexOf("$") < 0) {
    const h = qr(s, l);
    c = function(d) {
      return a === "==" ? d === h : d !== h;
    };
  } else {
    const h = qr(s, l);
    c = function(d, u, f, g, m) {
      const _ = ya(s, h, u, f, g);
      return a === "==" ? d === _ : d !== _;
    };
  }
  return n === -1 ? {
    name: t,
    value: i,
    test: function(h, d, u, f) {
      return c(h, h, d, u, f);
    }
  } : {
    name: t,
    value: i,
    test: function(h, d, u, f) {
      const g = pJ(h, d, u, n);
      return c(g || "", h, d, u, f);
    }
  };
}
function hL(s, e, t) {
  if (t) {
    if (typeof t == "string")
      return t;
    if (t.token || t.token === "") {
      if (typeof t.token != "string")
        throw St(s, "a 'token' attribute must be of type string, in rule: " + e);
      {
        const i = { token: t.token };
        if (t.token.indexOf("$") >= 0 && (i.tokenSubst = !0), typeof t.bracket == "string")
          if (t.bracket === "@open")
            i.bracket = 1;
          else if (t.bracket === "@close")
            i.bracket = -1;
          else
            throw St(s, "a 'bracket' attribute must be either '@open' or '@close', in rule: " + e);
        if (t.next) {
          if (typeof t.next != "string")
            throw St(s, "the next state must be a string value in rule: " + e);
          {
            let n = t.next;
            if (!/^(@pop|@push|@popall)$/.test(n) && (n[0] === "@" && (n = n.substr(1)), n.indexOf("$") < 0 && !iG(s, ya(s, n, "", [], ""))))
              throw St(s, "the next state '" + t.next + "' is not defined in rule: " + e);
            i.next = n;
          }
        }
        return typeof t.goBack == "number" && (i.goBack = t.goBack), typeof t.switchTo == "string" && (i.switchTo = t.switchTo), typeof t.log == "string" && (i.log = t.log), typeof t.nextEmbedded == "string" && (i.nextEmbedded = t.nextEmbedded, s.usesEmbedded = !0), i;
      }
    } else if (Array.isArray(t)) {
      const i = [];
      for (let n = 0, o = t.length; n < o; n++)
        i[n] = hL(s, e, t[n]);
      return { group: i };
    } else if (t.cases) {
      const i = [];
      for (const o in t.cases)
        if (t.cases.hasOwnProperty(o)) {
          const r = hL(s, e, t.cases[o]);
          o === "@default" || o === "@" || o === "" ? i.push({ test: void 0, value: r, name: o }) : o === "@eos" ? i.push({ test: function(a, l, c, h) {
            return h;
          }, value: r, name: o }) : i.push(_J(s, e, o, r));
        }
      const n = s.defaultToken;
      return {
        test: function(o, r, a, l) {
          for (const c of i)
            if (!c.test || c.test(o, r, a, l))
              return c.value;
          return n;
        }
      };
    } else
      throw St(s, "an action must be a string, an object with a 'token' or 'cases' attribute, or an array of actions; in rule: " + e);
  } else return { token: "" };
}
class bJ {
  constructor(e) {
    this.regex = new RegExp(""), this.action = { token: "" }, this.matchOnlyAtLineStart = !1, this.name = "", this.name = e;
  }
  setRegex(e, t) {
    let i;
    if (typeof t == "string")
      i = t;
    else if (t instanceof RegExp)
      i = t.source;
    else
      throw St(e, "rules must start with a match string or regular expression: " + this.name);
    this.matchOnlyAtLineStart = i.length > 0 && i[0] === "^", this.name = this.name + ": " + i, this.regex = cL(e, "^(?:" + (this.matchOnlyAtLineStart ? i.substr(1) : i) + ")", !0);
  }
  setAction(e, t) {
    this.action = hL(e, this.name, t);
  }
  resolveRegex(e) {
    return this.regex instanceof RegExp ? this.regex : this.regex(e);
  }
}
function x5(s, e) {
  if (!e || typeof e != "object")
    throw new Error("Monarch: expecting a language definition object");
  const t = {
    languageId: s,
    includeLF: Hm(e.includeLF, !1),
    noThrow: !1,
    // raise exceptions during compilation
    maxStack: 100,
    start: typeof e.start == "string" ? e.start : null,
    ignoreCase: Hm(e.ignoreCase, !1),
    unicode: Hm(e.unicode, !1),
    tokenPostfix: c2(e.tokenPostfix, "." + s),
    defaultToken: c2(e.defaultToken, "source"),
    usesEmbedded: !1,
    // becomes true if we find a nextEmbedded action
    stateNames: {},
    tokenizer: {},
    brackets: []
  }, i = e;
  i.languageId = s, i.includeLF = t.includeLF, i.ignoreCase = t.ignoreCase, i.unicode = t.unicode, i.noThrow = t.noThrow, i.usesEmbedded = t.usesEmbedded, i.stateNames = e.tokenizer, i.defaultToken = t.defaultToken;
  function n(r, a, l) {
    for (const c of l) {
      let h = c.include;
      if (h) {
        if (typeof h != "string")
          throw St(t, "an 'include' attribute must be a string at: " + r);
        if (h[0] === "@" && (h = h.substr(1)), !e.tokenizer[h])
          throw St(t, "include target '" + h + "' is not defined at: " + r);
        n(r + "." + h, a, e.tokenizer[h]);
      } else {
        const d = new bJ(r);
        if (Array.isArray(c) && c.length >= 1 && c.length <= 3)
          if (d.setRegex(i, c[0]), c.length >= 3)
            if (typeof c[1] == "string")
              d.setAction(i, { token: c[1], next: c[2] });
            else if (typeof c[1] == "object") {
              const u = c[1];
              u.next = c[2], d.setAction(i, u);
            } else
              throw St(t, "a next state as the last element of a rule can only be given if the action is either an object or a string, at: " + r);
          else
            d.setAction(i, c[1]);
        else {
          if (!c.regex)
            throw St(t, "a rule must either be an array, or an object with a 'regex' or 'include' field at: " + r);
          c.name && typeof c.name == "string" && (d.name = c.name), c.matchOnlyAtStart && (d.matchOnlyAtLineStart = Hm(c.matchOnlyAtLineStart, !1)), d.setRegex(i, c.regex), d.setAction(i, c.action);
        }
        a.push(d);
      }
    }
  }
  if (!e.tokenizer || typeof e.tokenizer != "object")
    throw St(t, "a language definition must define the 'tokenizer' attribute as an object");
  t.tokenizer = [];
  for (const r in e.tokenizer)
    if (e.tokenizer.hasOwnProperty(r)) {
      t.start || (t.start = r);
      const a = e.tokenizer[r];
      t.tokenizer[r] = new Array(), n("tokenizer." + r, t.tokenizer[r], a);
    }
  if (t.usesEmbedded = i.usesEmbedded, e.brackets) {
    if (!Array.isArray(e.brackets))
      throw St(t, "the 'brackets' attribute must be defined as an array");
  } else
    e.brackets = [
      { open: "{", close: "}", token: "delimiter.curly" },
      { open: "[", close: "]", token: "delimiter.square" },
      { open: "(", close: ")", token: "delimiter.parenthesis" },
      { open: "<", close: ">", token: "delimiter.angle" }
    ];
  const o = [];
  for (const r of e.brackets) {
    let a = r;
    if (a && Array.isArray(a) && a.length === 3 && (a = { token: a[2], open: a[0], close: a[1] }), a.open === a.close)
      throw St(t, "open and close brackets in a 'brackets' attribute must be different: " + a.open + `
 hint: use the 'bracket' attribute if matching on equal brackets is required.`);
    if (typeof a.open == "string" && typeof a.token == "string" && typeof a.close == "string")
      o.push({
        token: a.token + t.tokenPostfix,
        open: qr(t, a.open),
        close: qr(t, a.close)
      });
    else
      throw St(t, "every element in the 'brackets' array must be a '{open,close,token}' object or array");
  }
  return t.brackets = o, t.noThrow = !0, t;
}
function CJ(s) {
  wd.registerLanguage(s);
}
function wJ() {
  let s = [];
  return s = s.concat(wd.getLanguages()), s;
}
function vJ(s) {
  return fe.get(gi).languageIdCodec.encodeLanguageId(s);
}
function yJ(s, e) {
  return fe.withServices(() => {
    const i = fe.get(gi).onDidRequestRichLanguageFeatures((n) => {
      n === s && (i.dispose(), e());
    });
    return i;
  });
}
function SJ(s, e) {
  return fe.withServices(() => {
    const i = fe.get(gi).onDidRequestBasicLanguageFeatures((n) => {
      n === s && (i.dispose(), e());
    });
    return i;
  });
}
function LJ(s, e) {
  if (!fe.get(gi).isRegisteredLanguageId(s))
    throw new Error(`Cannot set configuration for unknown language ${s}`);
  return fe.get(Zo).register(s, e, 100);
}
class kJ {
  constructor(e, t) {
    this._languageId = e, this._actual = t;
  }
  dispose() {
  }
  getInitialState() {
    return this._actual.getInitialState();
  }
  tokenize(e, t, i) {
    if (typeof this._actual.tokenize == "function")
      return bg.adaptTokenize(this._languageId, this._actual, e, i);
    throw new Error("Not supported!");
  }
  tokenizeEncoded(e, t, i) {
    const n = this._actual.tokenizeEncoded(e, i);
    return new tb(n.tokens, n.endState);
  }
}
class bg {
  constructor(e, t, i, n) {
    this._languageId = e, this._actual = t, this._languageService = i, this._standaloneThemeService = n;
  }
  dispose() {
  }
  getInitialState() {
    return this._actual.getInitialState();
  }
  static _toClassicTokens(e, t) {
    const i = [];
    let n = 0;
    for (let o = 0, r = e.length; o < r; o++) {
      const a = e[o];
      let l = a.startIndex;
      o === 0 ? l = 0 : l < n && (l = n), i[o] = new Rf(l, a.scopes, t), n = l;
    }
    return i;
  }
  static adaptTokenize(e, t, i, n) {
    const o = t.tokenize(i, n), r = bg._toClassicTokens(o.tokens, e);
    let a;
    return o.endState.equals(n) ? a = n : a = o.endState, new xL(r, a);
  }
  tokenize(e, t, i) {
    return bg.adaptTokenize(this._languageId, this._actual, e, i);
  }
  _toBinaryTokens(e, t) {
    const i = e.encodeLanguageId(this._languageId), n = this._standaloneThemeService.getColorTheme().tokenTheme, o = [];
    let r = 0, a = 0;
    for (let c = 0, h = t.length; c < h; c++) {
      const d = t[c], u = n.match(i, d.scopes) | 1024;
      if (r > 0 && o[r - 1] === u)
        continue;
      let f = d.startIndex;
      c === 0 ? f = 0 : f < a && (f = a), o[r++] = f, o[r++] = u, a = f;
    }
    const l = new Uint32Array(r);
    for (let c = 0; c < r; c++)
      l[c] = o[c];
    return l;
  }
  tokenizeEncoded(e, t, i) {
    const n = this._actual.tokenize(e, i), o = this._toBinaryTokens(this._languageService.languageIdCodec, n.tokens);
    let r;
    return n.endState.equals(i) ? r = i : r = n.endState, new tb(o, r);
  }
}
function xJ(s) {
  return typeof s.getInitialState == "function";
}
function DJ(s) {
  return "tokenizeEncoded" in s;
}
function D5(s) {
  return s && typeof s.then == "function";
}
function EJ(s) {
  const e = fe.get(Vs);
  if (s) {
    const t = [null];
    for (let i = 1, n = s.length; i < n; i++)
      t[i] = Z.fromHex(s[i]);
    e.setColorMapOverride(t);
  } else
    e.setColorMapOverride(null);
}
function E5(s, e) {
  return DJ(e) ? new kJ(s, e) : new bg(s, e, fe.get(gi), fe.get(Vs));
}
function $x(s, e) {
  const t = new zO(async () => {
    const i = await Promise.resolve(e.create());
    return i ? xJ(i) ? E5(s, i) : new hg(fe.get(gi), fe.get(Vs), s, x5(s, i), fe.get(Vt)) : null;
  });
  return Yt.registerFactory(s, t);
}
function IJ(s, e) {
  if (!fe.get(gi).isRegisteredLanguageId(s))
    throw new Error(`Cannot set tokens provider for unknown language ${s}`);
  return D5(e) ? $x(s, { create: () => e }) : Yt.register(s, E5(s, e));
}
function NJ(s, e) {
  const t = (i) => new hg(fe.get(gi), fe.get(Vs), s, x5(s, i), fe.get(Vt));
  return D5(e) ? $x(s, { create: () => e }) : Yt.register(s, t(e));
}
function TJ(s, e) {
  return fe.get(gt).referenceProvider.register(s, e);
}
function MJ(s, e) {
  return fe.get(gt).renameProvider.register(s, e);
}
function RJ(s, e) {
  return fe.get(gt).newSymbolNamesProvider.register(s, e);
}
function AJ(s, e) {
  return fe.get(gt).signatureHelpProvider.register(s, e);
}
function PJ(s, e) {
  return fe.get(gt).hoverProvider.register(s, {
    provideHover: async (i, n, o, r) => {
      const a = i.getWordAtPosition(n);
      return Promise.resolve(e.provideHover(i, n, o, r)).then((l) => {
        if (l)
          return !l.range && a && (l.range = new R(n.lineNumber, a.startColumn, n.lineNumber, a.endColumn)), l.range || (l.range = new R(n.lineNumber, n.column, n.lineNumber, n.column)), l;
      });
    }
  });
}
function OJ(s, e) {
  return fe.get(gt).documentSymbolProvider.register(s, e);
}
function FJ(s, e) {
  return fe.get(gt).documentHighlightProvider.register(s, e);
}
function BJ(s, e) {
  return fe.get(gt).linkedEditingRangeProvider.register(s, e);
}
function WJ(s, e) {
  return fe.get(gt).definitionProvider.register(s, e);
}
function VJ(s, e) {
  return fe.get(gt).implementationProvider.register(s, e);
}
function HJ(s, e) {
  return fe.get(gt).typeDefinitionProvider.register(s, e);
}
function zJ(s, e) {
  return fe.get(gt).codeLensProvider.register(s, e);
}
function UJ(s, e, t) {
  return fe.get(gt).codeActionProvider.register(s, {
    providedCodeActionKinds: t == null ? void 0 : t.providedCodeActionKinds,
    documentation: t == null ? void 0 : t.documentation,
    provideCodeActions: (n, o, r, a) => {
      const c = fe.get(Bc).read({ resource: n.uri }).filter((h) => R.areIntersectingOrTouching(h, o));
      return e.provideCodeActions(n, o, { markers: c, only: r.only, trigger: r.trigger }, a);
    },
    resolveCodeAction: e.resolveCodeAction
  });
}
function $J(s, e) {
  return fe.get(gt).documentFormattingEditProvider.register(s, e);
}
function KJ(s, e) {
  return fe.get(gt).documentRangeFormattingEditProvider.register(s, e);
}
function qJ(s, e) {
  return fe.get(gt).onTypeFormattingEditProvider.register(s, e);
}
function jJ(s, e) {
  return fe.get(gt).linkProvider.register(s, e);
}
function GJ(s, e) {
  return fe.get(gt).completionProvider.register(s, e);
}
function ZJ(s, e) {
  return fe.get(gt).colorProvider.register(s, e);
}
function YJ(s, e) {
  return fe.get(gt).foldingRangeProvider.register(s, e);
}
function QJ(s, e) {
  return fe.get(gt).declarationProvider.register(s, e);
}
function XJ(s, e) {
  return fe.get(gt).selectionRangeProvider.register(s, e);
}
function JJ(s, e) {
  return fe.get(gt).documentSemanticTokensProvider.register(s, e);
}
function eee(s, e) {
  return fe.get(gt).documentRangeSemanticTokensProvider.register(s, e);
}
function tee(s, e) {
  return fe.get(gt).inlineCompletionsProvider.register(s, e);
}
function iee(s, e) {
  return fe.get(gt).inlineEditProvider.register(s, e);
}
function nee(s, e) {
  return fe.get(gt).inlayHintsProvider.register(s, e);
}
function see() {
  return {
    register: CJ,
    getLanguages: wJ,
    onLanguage: yJ,
    onLanguageEncountered: SJ,
    getEncodedLanguageId: vJ,
    // provider methods
    setLanguageConfiguration: LJ,
    setColorMap: EJ,
    registerTokensProviderFactory: $x,
    setTokensProvider: IJ,
    setMonarchTokensProvider: NJ,
    registerReferenceProvider: TJ,
    registerRenameProvider: MJ,
    registerNewSymbolNameProvider: RJ,
    registerCompletionItemProvider: GJ,
    registerSignatureHelpProvider: AJ,
    registerHoverProvider: PJ,
    registerDocumentSymbolProvider: OJ,
    registerDocumentHighlightProvider: FJ,
    registerLinkedEditingRangeProvider: BJ,
    registerDefinitionProvider: WJ,
    registerImplementationProvider: VJ,
    registerTypeDefinitionProvider: HJ,
    registerCodeLensProvider: zJ,
    registerCodeActionProvider: UJ,
    registerDocumentFormattingEditProvider: $J,
    registerDocumentRangeFormattingEditProvider: KJ,
    registerOnTypeFormattingEditProvider: qJ,
    registerLinkProvider: jJ,
    registerColorProvider: ZJ,
    registerFoldingRangeProvider: YJ,
    registerDeclarationProvider: QJ,
    registerSelectionRangeProvider: XJ,
    registerDocumentSemanticTokensProvider: JJ,
    registerDocumentRangeSemanticTokensProvider: eee,
    registerInlineCompletionsProvider: tee,
    registerInlineEditProvider: iee,
    registerInlayHintsProvider: nee,
    // enums
    DocumentHighlightKind: XC,
    CompletionItemKind: qC,
    CompletionItemTag: jC,
    CompletionItemInsertTextRule: KC,
    SymbolKind: Iw,
    SymbolTag: Nw,
    IndentAction: ow,
    CompletionTriggerKind: GC,
    SignatureHelpTriggerKind: Ew,
    InlayHintKind: aw,
    InlineCompletionTriggerKind: lw,
    InlineEditTriggerKind: cw,
    CodeActionTriggerType: $C,
    NewSymbolNameTag: pw,
    NewSymbolNameTriggerKind: _w,
    PartialAcceptTriggerKind: ww,
    HoverVerbosityAction: sw,
    // classes
    FoldingRangeKind: HC,
    SelectedSuggestionInfo: HO
  };
}
const I5 = Ve("IEditorCancelService"), N5 = new de("cancellableOperation", !1, p("cancellableOperation", "Whether the editor runs a cancellable operation, e.g. like 'Peek References'"));
Ge(
  I5,
  class {
    constructor() {
      this._tokens = /* @__PURE__ */ new WeakMap();
    }
    add(s, e) {
      let t = this._tokens.get(s);
      t || (t = s.invokeWithinContext((n) => {
        const o = N5.bindTo(n.get(nt)), r = new An();
        return { key: o, tokens: r };
      }), this._tokens.set(s, t));
      let i;
      return t.key.set(!0), i = t.tokens.push(e), () => {
        i && (i(), t.key.set(!t.tokens.isEmpty()), i = void 0);
      };
    }
    cancel(s) {
      const e = this._tokens.get(s);
      if (!e)
        return;
      const t = e.tokens.pop();
      t && (t.cancel(), e.key.set(!e.tokens.isEmpty()));
    }
  },
  1
  /* InstantiationType.Delayed */
);
ye(new class extends Cc {
  constructor() {
    super({
      id: "editor.cancelOperation",
      kbOpts: {
        weight: 100,
        primary: 9
        /* KeyCode.Escape */
      },
      precondition: N5
    });
  }
  runEditorCommand(s, e) {
    s.get(I5).cancel(e);
  }
}());
class d2 {
  constructor(e) {
    this.value = e, this._lower = e.toLowerCase();
  }
  /**
   * Gives the value by which to index (for equality).
   */
  static toKey(e) {
    return typeof e == "string" ? e.toLowerCase() : e._lower;
  }
}
class oee {
  constructor(e) {
    if (this._set = /* @__PURE__ */ new Set(), e)
      for (const t of e)
        this.add(t);
  }
  add(e) {
    this._set.add(d2.toKey(e));
  }
  has(e) {
    return this._set.has(d2.toKey(e));
  }
}
function ree(s, e, t) {
  const i = [], n = new oee(), o = s.ordered(t);
  for (const a of o)
    i.push(a), a.extensionId && n.add(a.extensionId);
  const r = e.ordered(t);
  for (const a of r) {
    if (a.extensionId) {
      if (n.has(a.extensionId))
        continue;
      n.add(a.extensionId);
    }
    i.push({
      displayName: a.displayName,
      extensionId: a.extensionId,
      provideDocumentFormattingEdits(l, c, h) {
        return a.provideDocumentRangeFormattingEdits(l, l.getFullModelRange(), c, h);
      }
    });
  }
  return i;
}
const Ef = class Ef {
  static setFormatterSelector(e) {
    return { dispose: Ef._selectors.unshift(e) };
  }
  static async select(e, t, i, n) {
    if (e.length === 0)
      return;
    const o = Ye.first(Ef._selectors);
    if (o)
      return await o(e, t, i, n);
  }
};
Ef._selectors = new An();
let dL = Ef;
async function aee(s, e, t, i, n, o) {
  const r = e.documentRangeFormattingEditProvider.ordered(t);
  for (const a of r) {
    const l = await Promise.resolve(a.provideDocumentRangeFormattingEdits(t, i, n, o)).catch(wL);
    if (Q1(l))
      return await s.computeMoreMinimalEdits(t.uri, l);
  }
}
async function lee(s, e, t, i, n) {
  const o = ree(e.documentFormattingEditProvider, e.documentRangeFormattingEditProvider, t);
  for (const r of o) {
    const a = await Promise.resolve(r.provideDocumentFormattingEdits(t, i, n)).catch(wL);
    if (Q1(a))
      return await s.computeMoreMinimalEdits(t.uri, a);
  }
}
function cee(s, e, t, i, n, o, r) {
  const a = e.onTypeFormattingEditProvider.ordered(t);
  return a.length === 0 || a[0].autoFormatTriggerCharacters.indexOf(n) < 0 ? Promise.resolve(void 0) : Promise.resolve(a[0].provideOnTypeFormattingEdits(t, i, n, o, r)).catch(wL).then((l) => s.computeMoreMinimalEdits(t.uri, l));
}
Sn.registerCommand("_executeFormatRangeProvider", async function(s, ...e) {
  const [t, i, n] = e;
  Pa(Te.isUri(t)), Pa(R.isIRange(i));
  const o = s.get(ab), r = s.get(Hg), a = s.get(gt), l = await o.createModelReference(t);
  try {
    return aee(r, a, l.object.textEditorModel, R.lift(i), n, Rs.None);
  } finally {
    l.dispose();
  }
});
Sn.registerCommand("_executeFormatDocumentProvider", async function(s, ...e) {
  const [t, i] = e;
  Pa(Te.isUri(t));
  const n = s.get(ab), o = s.get(Hg), r = s.get(gt), a = await n.createModelReference(t);
  try {
    return lee(o, r, a.object.textEditorModel, i, Rs.None);
  } finally {
    a.dispose();
  }
});
Sn.registerCommand("_executeFormatOnTypeProvider", async function(s, ...e) {
  const [t, i, n, o] = e;
  Pa(Te.isUri(t)), Pa(V.isIPosition(i)), Pa(typeof n == "string");
  const r = s.get(ab), a = s.get(Hg), l = s.get(gt), c = await r.createModelReference(t);
  try {
    return cee(a, l, c.object.textEditorModel, V.lift(i), n, o, Rs.None);
  } finally {
    c.dispose();
  }
});
xc.wrappingIndent.defaultValue = 0;
xc.glyphMargin.defaultValue = !1;
xc.autoIndent.defaultValue = 3;
xc.overviewRulerLanes.defaultValue = 2;
dL.setFormatterSelector((s, e, t) => Promise.resolve(s[0]));
const hn = G2();
hn.editor = fJ();
hn.languages = see();
const hee = hn.CancellationTokenSource, dee = hn.Emitter, uee = hn.KeyCode, fee = hn.KeyMod, gee = hn.Position, mee = hn.Range, pee = hn.Selection, _ee = hn.SelectionDirection, bee = hn.MarkerSeverity, Cee = hn.MarkerTag, wee = hn.Uri, vee = hn.Token, Xi = hn.editor, yee = hn.languages, DC = globalThis.MonacoEnvironment;
(DC != null && DC.globalAPI || typeof define == "function" && define.amd) && (globalThis.monaco = hn);
typeof globalThis.require < "u" && typeof globalThis.require.config == "function" && globalThis.require.config({
  ignoreDuplicateModules: [
    "vscode-languageserver-types",
    "vscode-languageserver-types/main",
    "vscode-languageserver-textdocument",
    "vscode-languageserver-textdocument/main",
    "vscode-nls",
    "vscode-nls/vscode-nls",
    "jsonc-parser",
    "jsonc-parser/main",
    "vscode-uri",
    "vscode-uri/index",
    "vs/basic-languages/typescript/typescript"
  ]
});
const Tr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CancellationTokenSource: hee,
  Emitter: dee,
  KeyCode: uee,
  KeyMod: fee,
  MarkerSeverity: bee,
  MarkerTag: Cee,
  Position: gee,
  Range: mee,
  Selection: pee,
  SelectionDirection: _ee,
  Token: vee,
  Uri: wee,
  editor: Xi,
  languages: yee
}, Symbol.toStringTag, { value: "Module" }));
function s1(s) {
  return /^\d+$/.test(s) ? "".concat(s, "px") : s;
}
function Ra() {
}
var Ol = function() {
  return Ol = Object.assign || function(s) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (s[n] = e[n]);
    }
    return s;
  }, Ol.apply(this, arguments);
};
function See(s, e) {
  var t = s.width, i = t === void 0 ? "100%" : t, n = s.height, o = n === void 0 ? "100%" : n, r = s.value, a = r === void 0 ? null : r, l = s.defaultValue, c = l === void 0 ? "" : l, h = s.language, d = h === void 0 ? "javascript" : h, u = s.theme, f = u === void 0 ? null : u, g = s.options, m = g === void 0 ? {} : g, _ = s.overrideServices, b = _ === void 0 ? {} : _, C = s.editorWillMount, v = C === void 0 ? Ra : C, w = s.editorDidMount, S = w === void 0 ? Ra : w, L = s.editorWillUnmount, k = L === void 0 ? Ra : L, D = s.onChange, E = D === void 0 ? Ra : D, U = s.className, P = U === void 0 ? null : U, B = s.original, W = B === void 0 ? null : B, A = s.originalUri, K = s.modifiedUri, Y = Sr(null), Q = Sr(null), ne = Sr(null), ie = Sr(null), me = s1(i), _e = s1(o), vt = p2(function() {
    return {
      width: me,
      height: _e
    };
  }, [me, _e]);
  fd.useImperativeHandle(e, function() {
    return {
      get editor() {
        return Q.current;
      }
    };
  });
  var be = function() {
    var Je = v(Tr);
    return Je || {};
  }, Ze = function() {
    S(Q.current, Tr);
    var Je = Q.current.getModel().modified;
    ne.current = Je.onDidChangeContent(function(xt) {
      ie.current || E(Je.getValue(), xt);
    });
  }, De = function() {
    k(Q.current, Tr);
  }, mt = function() {
    var Je = a ?? c, xt = A == null ? void 0 : A(Tr), mi = K == null ? void 0 : K(Tr), pi = xt && Xi.getModel(xt), ws = mi && Xi.getModel(mi);
    pi ? (pi.setValue(W), Xi.setModelLanguage(pi, d)) : pi = Xi.createModel(Je, d, xt), ws ? (pi.setValue(Je), Xi.setModelLanguage(ws, d)) : ws = Xi.createModel(Je, d, mi), Q.current.setModel({
      original: pi,
      modified: ws
    });
  };
  return Nn(
    function() {
      Y.current && (be(), Q.current = Xi.createDiffEditor(Y.current, Ol(Ol(Ol({}, P ? { extraEditorClassName: P } : {}), m), f ? { theme: f } : {}), b), mt(), Ze());
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  ), Nn(function() {
    Q.current && Q.current.updateOptions(Ol(Ol({}, P ? { extraEditorClassName: P } : {}), m));
  }, [P, m]), Nn(function() {
    Q.current && Q.current.layout();
  }, [i, o]), Nn(function() {
    if (Q.current) {
      var Je = Q.current.getModel(), xt = Je.original, mi = Je.modified;
      Xi.setModelLanguage(xt, d), Xi.setModelLanguage(mi, d);
    }
  }, [d]), Nn(function() {
    if (Q.current) {
      var Je = Q.current.getModel().modified;
      ie.current = !0, Q.current.getModifiedEditor().pushUndoStop(), Je.pushEditOperations([], [
        {
          range: Je.getFullModelRange(),
          text: a
        }
      ]), Q.current.getModifiedEditor().pushUndoStop(), ie.current = !1;
    }
  }, [a]), Nn(function() {
    Xi.setTheme(f);
  }, [f]), Nn(function() {
    if (Q.current) {
      var Je = Q.current.getModel().original;
      W !== Je.getValue() && Je.setValue(W);
    }
  }, [W]), Nn(
    function() {
      return function() {
        if (Q.current) {
          De(), Q.current.dispose();
          var Je = Q.current.getModel(), xt = Je.original, mi = Je.modified;
          xt && xt.dispose(), mi && mi.dispose();
        }
        ne.current && ne.current.dispose();
      };
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  ), fd.createElement("div", { ref: Y, style: vt, className: "react-monaco-editor-container" });
}
var Lee = fd.forwardRef(See);
Lee.displayName = "MonacoDiffEditor";
var gr = function() {
  return gr = Object.assign || function(s) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (s[n] = e[n]);
    }
    return s;
  }, gr.apply(this, arguments);
}, kee = function(s, e) {
  var t = {};
  for (var i in s) Object.prototype.hasOwnProperty.call(s, i) && e.indexOf(i) < 0 && (t[i] = s[i]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var n = 0, i = Object.getOwnPropertySymbols(s); n < i.length; n++)
      e.indexOf(i[n]) < 0 && Object.prototype.propertyIsEnumerable.call(s, i[n]) && (t[i[n]] = s[i[n]]);
  return t;
};
function xee(s, e) {
  var t = s.width, i = t === void 0 ? "100%" : t, n = s.height, o = n === void 0 ? "100%" : n, r = s.value, a = r === void 0 ? null : r, l = s.defaultValue, c = l === void 0 ? "" : l, h = s.language, d = h === void 0 ? "javascript" : h, u = s.theme, f = u === void 0 ? null : u, g = s.options, m = g === void 0 ? {} : g, _ = s.overrideServices, b = _ === void 0 ? {} : _, C = s.editorWillMount, v = C === void 0 ? Ra : C, w = s.editorDidMount, S = w === void 0 ? Ra : w, L = s.editorWillUnmount, k = L === void 0 ? Ra : L, D = s.onChange, E = D === void 0 ? Ra : D, U = s.className, P = U === void 0 ? null : U, B = s.uri, W = Sr(null), A = Sr(null), K = Sr(null), Y = Sr(null), Q = s1(i), ne = s1(o), ie = Sr(E);
  ie.current = E, fd.useImperativeHandle(e, function() {
    return {
      get editor() {
        return A.current;
      }
    };
  });
  var me = p2(function() {
    return {
      width: Q,
      height: ne
    };
  }, [Q, ne]), _e = function() {
    var De = v(Tr);
    return De || {};
  }, vt = function() {
    S(A.current, Tr), K.current = A.current.onDidChangeModelContent(function(De) {
      var mt;
      Y.current || (mt = ie.current) === null || mt === void 0 || mt.call(ie, A.current.getValue(), De);
    });
  }, be = function() {
    k(A.current, Tr);
  }, Ze = function() {
    var De = a !== null ? a : c;
    if (W.current) {
      var mt = gr(gr({}, m), _e()), Je = B == null ? void 0 : B(Tr), xt = Je && Xi.getModel(Je);
      xt ? (xt.setValue(De), Xi.setModelLanguage(xt, d)) : xt = Xi.createModel(De, d, Je), A.current = Xi.create(W.current, gr(gr(gr({ model: xt }, P ? { extraEditorClassName: P } : {}), mt), f ? { theme: f } : {}), b), vt();
    }
  };
  return Nn(Ze, []), Nn(function() {
    if (A.current && a !== null) {
      if (a === A.current.getValue())
        return;
      var De = A.current.getModel();
      Y.current = !0, A.current.pushUndoStop(), De.pushEditOperations([], [
        {
          range: De.getFullModelRange(),
          text: a
        }
      ], void 0), A.current.pushUndoStop(), Y.current = !1;
    }
  }, [a]), Nn(function() {
    if (A.current) {
      var De = A.current.getModel();
      Xi.setModelLanguage(De, d);
    }
  }, [d]), Nn(function() {
    if (A.current) {
      m.model;
      var De = kee(m, ["model"]);
      A.current.updateOptions(gr(gr({}, P ? { extraEditorClassName: P } : {}), De));
    }
  }, [P, m]), Nn(function() {
    A.current && A.current.layout();
  }, [i, o]), Nn(function() {
    Xi.setTheme(f);
  }, [f]), Nn(
    function() {
      return function() {
        A.current && (be(), A.current.dispose()), K.current && K.current.dispose();
      };
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  ), fd.createElement("div", { ref: W, style: me, className: "react-monaco-editor-container" });
}
var Dee = fd.forwardRef(xee);
Dee.displayName = "MonacoEditor";
export {
  Lee as MonacoDiffEditor,
  Dee as default,
  Tr as monaco
};
